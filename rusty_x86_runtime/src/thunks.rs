#![allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clashing_extern_declarations,
    clippy::all,
    unused_mut,
    unused_variables
)]
#[allow(unused)]
use crate::ExtendedContext;
#[allow(unused)]
use core_abi::stdcall::StdCallHelper;
#[allow(unused)]
use core_mem::ctx::FlatMemoryCtx;
#[allow(unused)]
use core_mem::ptr::PtrRepr;
#[no_mangle]
extern "C" fn thunk_CloseHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseHandle(h_object);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareObjectHandles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_first_object_handle = call.get_arg();
        let h_second_object_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CompareObjectHandles(h_first_object_handle, h_second_object_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DuplicateHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_source_process_handle = call.get_arg();
        let h_source_handle = call.get_arg();
        let h_target_process_handle = call.get_arg();
        let lp_target_handle = call.get_arg();
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let dw_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DuplicateHandle(
            h_source_process_handle,
            h_source_handle,
            h_target_process_handle,
            lp_target_handle,
            dw_desired_access,
            b_inherit_handle,
            dw_options,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetHandleInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object = call.get_arg();
        let lpdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetHandleInformation(h_object, lpdw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLastError(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetLastError();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetHandleInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object = call.get_arg();
        let dw_mask = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetHandleInformation(h_object, dw_mask, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLastError(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_err_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetLastError(dw_err_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_cmp_flags = call.get_arg();
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CompareStringA(
            locale,
            dw_cmp_flags,
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_cmp_flags = call.get_arg();
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_reserved = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CompareStringEx(
            lp_locale_name,
            dw_cmp_flags,
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
            lp_version_information,
            lp_reserved,
            l_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringOrdinal(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let b_ignore_case = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CompareStringOrdinal(
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
            b_ignore_case,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_cmp_flags = call.get_arg();
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CompareStringW(
            locale,
            dw_cmp_flags,
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertDefaultLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ConvertDefaultLocale(locale);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumCalendarInfoA(lp_cal_info_enum_proc, locale, calendar, cal_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumCalendarInfoExA(lp_cal_info_enum_proc_ex, locale, calendar, cal_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_cal_info_enum_proc_ex_ex = call.get_arg();
        let lp_locale_name = call.get_arg();
        let calendar = call.get_arg();
        let lp_reserved = call.get_arg();
        let cal_type = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumCalendarInfoExEx(
            p_cal_info_enum_proc_ex_ex,
            lp_locale_name,
            calendar,
            lp_reserved,
            cal_type,
            l_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumCalendarInfoExW(lp_cal_info_enum_proc_ex, locale, calendar, cal_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumCalendarInfoW(lp_cal_info_enum_proc, locale, calendar, cal_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumDateFormatsA(lp_date_fmt_enum_proc, locale, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumDateFormatsExA(lp_date_fmt_enum_proc_ex, locale, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc_ex_ex = call.get_arg();
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumDateFormatsExEx(
            lp_date_fmt_enum_proc_ex_ex,
            lp_locale_name,
            dw_flags,
            l_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumDateFormatsExW(lp_date_fmt_enum_proc_ex, locale, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumDateFormatsW(lp_date_fmt_enum_proc, locale, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumLanguageGroupLocalesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lang_group_locale_enum_proc = call.get_arg();
        let language_group = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumLanguageGroupLocalesA(
            lp_lang_group_locale_enum_proc,
            language_group,
            dw_flags,
            l_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumLanguageGroupLocalesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lang_group_locale_enum_proc = call.get_arg();
        let language_group = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumLanguageGroupLocalesW(
            lp_lang_group_locale_enum_proc,
            language_group,
            dw_flags,
            l_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemCodePagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_code_page_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemCodePagesA(lp_code_page_enum_proc, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemCodePagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_code_page_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemCodePagesW(lp_code_page_enum_proc, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemGeoID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_class = call.get_arg();
        let parent_geo_id = call.get_arg();
        let lp_geo_enum_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemGeoID(geo_class, parent_geo_id, lp_geo_enum_proc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemGeoNames(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_class = call.get_arg();
        let geo_enum_proc = call.get_arg();
        let data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemGeoNames(geo_class, geo_enum_proc, data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLanguageGroupsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_language_group_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemLanguageGroupsA(lp_language_group_enum_proc, dw_flags, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLanguageGroupsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_language_group_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemLanguageGroupsW(lp_language_group_enum_proc, dw_flags, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemLocalesA(lp_locale_enum_proc, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_enum_proc_ex = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemLocalesEx(lp_locale_enum_proc_ex, dw_flags, l_param, lp_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumSystemLocalesW(lp_locale_enum_proc, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumTimeFormatsA(lp_time_fmt_enum_proc, locale, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_fmt_enum_proc_ex = call.get_arg();
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.EnumTimeFormatsEx(lp_time_fmt_enum_proc_ex, lp_locale_name, dw_flags, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumTimeFormatsW(lp_time_fmt_enum_proc, locale, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumUILanguagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_ui_language_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumUILanguagesA(lp_ui_language_enum_proc, dw_flags, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumUILanguagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_ui_language_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumUILanguagesW(lp_ui_language_enum_proc, dw_flags, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNLSString(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_find_nls_string_flags = call.get_arg();
        let lp_string_source = call.get_arg();
        let cch_source = call.get_arg();
        let lp_string_value = call.get_arg();
        let cch_value = call.get_arg();
        let pcch_found = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNLSString(
            locale,
            dw_find_nls_string_flags,
            lp_string_source,
            cch_source,
            lp_string_value,
            cch_value,
            pcch_found,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNLSStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_find_nls_string_flags = call.get_arg();
        let lp_string_source = call.get_arg();
        let cch_source = call.get_arg();
        let lp_string_value = call.get_arg();
        let cch_value = call.get_arg();
        let pcch_found = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_reserved = call.get_arg();
        let sort_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNLSStringEx(
            lp_locale_name,
            dw_find_nls_string_flags,
            lp_string_source,
            cch_source,
            lp_string_value,
            cch_value,
            pcch_found,
            lp_version_information,
            lp_reserved,
            sort_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindStringOrdinal(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_find_string_ordinal_flags = call.get_arg();
        let lp_string_source = call.get_arg();
        let cch_source = call.get_arg();
        let lp_string_value = call.get_arg();
        let cch_value = call.get_arg();
        let b_ignore_case = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindStringOrdinal(
            dw_find_string_ordinal_flags,
            lp_string_source,
            cch_source,
            lp_string_value,
            cch_value,
            b_ignore_case,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FoldStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FoldStringA(dw_map_flags, lp_src_str, cch_src, lp_dest_str, cch_dest);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FoldStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FoldStringW(dw_map_flags, lp_src_str, cch_src, lp_dest_str, cch_dest);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetACP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetACP();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCPInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let lp_cp_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCPInfo(code_page, lp_cp_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCPInfoExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_cp_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCPInfoExA(code_page, dw_flags, lp_cp_info_ex);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCPInfoExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_cp_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCPInfoExW(code_page, dw_flags, lp_cp_info_ex);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let cch_data = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCalendarInfoA(locale, calendar, cal_type, lp_cal_data, cch_data, lp_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let calendar = call.get_arg();
        let lp_reserved = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let cch_data = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCalendarInfoEx(
            lp_locale_name,
            calendar,
            lp_reserved,
            cal_type,
            lp_cal_data,
            cch_data,
            lp_value,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let cch_data = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCalendarInfoW(locale, calendar, cal_type, lp_cal_data, cch_data, lp_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_currency_str = call.get_arg();
        let cch_currency = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrencyFormatA(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_currency_str,
            cch_currency,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_currency_str = call.get_arg();
        let cch_currency = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrencyFormatEx(
            lp_locale_name,
            dw_flags,
            lp_value,
            lp_format,
            lp_currency_str,
            cch_currency,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_currency_str = call.get_arg();
        let cch_currency = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrencyFormatW(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_currency_str,
            cch_currency,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_date = call.get_arg();
        let lp_format = call.get_arg();
        let lp_date_str = call.get_arg();
        let cch_date = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDateFormatA(locale, dw_flags, lp_date, lp_format, lp_date_str, cch_date);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_date = call.get_arg();
        let lp_format = call.get_arg();
        let lp_date_str = call.get_arg();
        let cch_date = call.get_arg();
        let lp_calendar = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDateFormatEx(
            lp_locale_name,
            dw_flags,
            lp_date,
            lp_format,
            lp_date_str,
            cch_date,
            lp_calendar,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_date = call.get_arg();
        let lp_format = call.get_arg();
        let lp_date_str = call.get_arg();
        let cch_date = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDateFormatW(locale, dw_flags, lp_date, lp_format, lp_date_str, cch_date);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDistanceOfClosestLanguageInList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_language = call.get_arg();
        let psz_languages_list = call.get_arg();
        let wch_list_delimiter = call.get_arg();
        let p_closest_distance = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDistanceOfClosestLanguageInList(
            psz_language,
            psz_languages_list,
            wch_list_delimiter,
            p_closest_distance,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDurationFormat(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_duration = call.get_arg();
        let ull_duration = call.get_arg();
        let lp_format = call.get_arg();
        let lp_duration_str = call.get_arg();
        let cch_duration = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDurationFormat(
            locale,
            dw_flags,
            lp_duration,
            ull_duration,
            lp_format,
            lp_duration_str,
            cch_duration,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDurationFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_duration = call.get_arg();
        let ull_duration = call.get_arg();
        let lp_format = call.get_arg();
        let lp_duration_str = call.get_arg();
        let cch_duration = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDurationFormatEx(
            lp_locale_name,
            dw_flags,
            lp_duration,
            ull_duration,
            lp_format,
            lp_duration_str,
            cch_duration,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileMUIInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pcwsz_file_path = call.get_arg();
        let p_file_mui_info = call.get_arg();
        let pcb_file_mui_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileMUIInfo(
            dw_flags,
            pcwsz_file_path,
            p_file_mui_info,
            pcb_file_mui_info,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileMUIPath(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pcwsz_file_path = call.get_arg();
        let pwsz_language = call.get_arg();
        let pcch_language = call.get_arg();
        let pwsz_file_mui_path = call.get_arg();
        let pcch_file_mui_path = call.get_arg();
        let pulul_enumerator = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileMUIPath(
            dw_flags,
            pcwsz_file_path,
            pwsz_language,
            pcch_language,
            pwsz_file_mui_path,
            pcch_file_mui_path,
            pulul_enumerator,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let location = call.get_arg();
        let geo_type = call.get_arg();
        let lp_geo_data = call.get_arg();
        let cch_data = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetGeoInfoA(location, geo_type, lp_geo_data, cch_data, lang_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let location = call.get_arg();
        let geo_type = call.get_arg();
        let geo_data = call.get_arg();
        let geo_data_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetGeoInfoEx(location, geo_type, geo_data, geo_data_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let location = call.get_arg();
        let geo_type = call.get_arg();
        let lp_geo_data = call.get_arg();
        let cch_data = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetGeoInfoW(location, geo_type, lp_geo_data, cch_data, lang_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let cch_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLocaleInfoA(locale, lc_type, lp_lc_data, cch_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let cch_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLocaleInfoEx(lp_locale_name, lc_type, lp_lc_data, cch_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let cch_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLocaleInfoW(locale, lc_type, lp_lc_data, cch_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNLSVersion(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let locale = call.get_arg();
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNLSVersion(function, locale, lp_version_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNLSVersionEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let lp_locale_name = call.get_arg();
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNLSVersionEx(function, lp_locale_name, lp_version_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_number_str = call.get_arg();
        let cch_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumberFormatA(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_number_str,
            cch_number,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_number_str = call.get_arg();
        let cch_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumberFormatEx(
            lp_locale_name,
            dw_flags,
            lp_value,
            lp_format,
            lp_number_str,
            cch_number,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_number_str = call.get_arg();
        let cch_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumberFormatW(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_number_str,
            cch_number,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOEMCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetOEMCP();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringScripts(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_string = call.get_arg();
        let cch_string = call.get_arg();
        let lp_scripts = call.get_arg();
        let cch_scripts = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStringScripts(dw_flags, lp_string, cch_string, lp_scripts, cch_scripts);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStringTypeA(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStringTypeExA(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStringTypeExW(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStringTypeW(dw_info_type, lp_src_str, cch_src, lp_char_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetSystemDefaultLCID();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLangID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetSystemDefaultLangID();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let cch_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemDefaultLocaleName(lp_locale_name, cch_locale_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetSystemDefaultUILanguage();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetThreadLocale();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetThreadUILanguage();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_time = call.get_arg();
        let lp_format = call.get_arg();
        let lp_time_str = call.get_arg();
        let cch_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTimeFormatA(locale, dw_flags, lp_time, lp_format, lp_time_str, cch_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_time = call.get_arg();
        let lp_format = call.get_arg();
        let lp_time_str = call.get_arg();
        let cch_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTimeFormatEx(
            lp_locale_name,
            dw_flags,
            lp_time,
            lp_format,
            lp_time_str,
            cch_time,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_time = call.get_arg();
        let lp_format = call.get_arg();
        let lp_time_str = call.get_arg();
        let cch_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTimeFormatW(locale, dw_flags, lp_time, lp_format, lp_time_str, cch_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUILanguageInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pwmsz_language = call.get_arg();
        let pwsz_fallback_languages = call.get_arg();
        let pcch_fallback_languages = call.get_arg();
        let p_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUILanguageInfo(
            dw_flags,
            pwmsz_language,
            pwsz_fallback_languages,
            pcch_fallback_languages,
            p_attributes,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultGeoName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_name = call.get_arg();
        let geo_name_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUserDefaultGeoName(geo_name, geo_name_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetUserDefaultLCID();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLangID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetUserDefaultLangID();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let cch_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUserDefaultLocaleName(lp_locale_name, cch_locale_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetUserDefaultUILanguage();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserGeoID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_class = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUserGeoID(geo_class);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUserPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IdnToAscii(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_unicode_char_str = call.get_arg();
        let cch_unicode_char = call.get_arg();
        let lp_ascii_char_str = call.get_arg();
        let cch_ascii_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IdnToAscii(
            dw_flags,
            lp_unicode_char_str,
            cch_unicode_char,
            lp_ascii_char_str,
            cch_ascii_char,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IdnToNameprepUnicode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_unicode_char_str = call.get_arg();
        let cch_unicode_char = call.get_arg();
        let lp_nameprep_char_str = call.get_arg();
        let cch_nameprep_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IdnToNameprepUnicode(
            dw_flags,
            lp_unicode_char_str,
            cch_unicode_char,
            lp_nameprep_char_str,
            cch_nameprep_char,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IdnToUnicode(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_ascii_char_str = call.get_arg();
        let cch_ascii_char = call.get_arg();
        let lp_unicode_char_str = call.get_arg();
        let cch_unicode_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IdnToUnicode(
            dw_flags,
            lp_ascii_char_str,
            cch_ascii_char,
            lp_unicode_char_str,
            cch_unicode_char,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDBCSLeadByte(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let test_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsDBCSLeadByte(test_char);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDBCSLeadByteEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let test_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsDBCSLeadByteEx(code_page, test_char);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNLSDefinedString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_string = call.get_arg();
        let cch_str = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsNLSDefinedString(
            function,
            dw_flags,
            lp_version_information,
            lp_string,
            cch_str,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNormalizedString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let norm_form = call.get_arg();
        let lp_string = call.get_arg();
        let cw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsNormalizedString(norm_form, lp_string, cw_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsTextUnicode(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpv = call.get_arg();
        let i_size = call.get_arg();
        let lpi_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsTextUnicode(lpv, i_size, lpi_result);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidCodePage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsValidCodePage(code_page);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidLanguageGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let language_group = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsValidLanguageGroup(language_group, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidLocale(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsValidLocale(locale, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsValidLocaleName(lp_locale_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidNLSVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let lp_locale_name = call.get_arg();
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsValidNLSVersion(function, lp_locale_name, lp_version_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWellFormedTag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_tag = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsWellFormedTag(psz_tag);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCIDToLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lp_name = call.get_arg();
        let cch_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LCIDToLocaleName(locale, lp_name, cch_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCMapStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LCMapStringA(
            locale,
            dw_map_flags,
            lp_src_str,
            cch_src,
            lp_dest_str,
            cch_dest,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCMapStringEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_reserved = call.get_arg();
        let sort_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LCMapStringEx(
            lp_locale_name,
            dw_map_flags,
            lp_src_str,
            cch_src,
            lp_dest_str,
            cch_dest,
            lp_version_information,
            lp_reserved,
            sort_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCMapStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LCMapStringW(
            locale,
            dw_map_flags,
            lp_src_str,
            cch_src,
            lp_dest_str,
            cch_dest,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocaleNameToLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocaleNameToLCID(lp_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingDoAction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_bag = call.get_arg();
        let dw_range_index = call.get_arg();
        let psz_action_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MappingDoAction(p_bag, dw_range_index, psz_action_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingFreePropertyBag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_bag = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MappingFreePropertyBag(p_bag);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingFreeServices(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_service_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MappingFreeServices(p_service_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingGetServices(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_options = call.get_arg();
        let prg_services = call.get_arg();
        let pdw_services_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MappingGetServices(p_options, prg_services, pdw_services_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingRecognizeText(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_service_info = call.get_arg();
        let psz_text = call.get_arg();
        let dw_length = call.get_arg();
        let dw_index = call.get_arg();
        let p_options = call.get_arg();
        let pbag = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MappingRecognizeText(
            p_service_info,
            psz_text,
            dw_length,
            dw_index,
            p_options,
            pbag,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MultiByteToWideChar(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_multi_byte_str = call.get_arg();
        let cb_multi_byte = call.get_arg();
        let lp_wide_char_str = call.get_arg();
        let cch_wide_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MultiByteToWideChar(
            code_page,
            dw_flags,
            lp_multi_byte_str,
            cb_multi_byte,
            lp_wide_char_str,
            cch_wide_char,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NormalizeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let norm_form = call.get_arg();
        let lp_src_string = call.get_arg();
        let cw_src_length = call.get_arg();
        let lp_dst_string = call.get_arg();
        let cw_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NormalizeString(
            norm_form,
            lp_src_string,
            cw_src_length,
            lp_dst_string,
            cw_dst_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NotifyUILanguageChange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pcwstr_new_language = call.get_arg();
        let pcwstr_previous_language = call.get_arg();
        let dw_reserved = call.get_arg();
        let pdw_status_rtrn = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NotifyUILanguageChange(
            dw_flags,
            pcwstr_new_language,
            pcwstr_previous_language,
            dw_reserved,
            pdw_status_rtrn,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResolveLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name_to_resolve = call.get_arg();
        let lp_locale_name = call.get_arg();
        let cch_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ResolveLocaleName(lp_name_to_resolve, lp_locale_name, cch_locale_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RestoreThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let snapshot = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RestoreThreadPreferredUILanguages(snapshot);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptApplyDigitSubstitution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psds = call.get_arg();
        let psc = call.get_arg();
        let pss = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptApplyDigitSubstitution(psds, psc, pss);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptBreak(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_chars = call.get_arg();
        let c_chars = call.get_arg();
        let psa = call.get_arg();
        let psla = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptBreak(pwc_chars, c_chars, psa, psla);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptCPtoX(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let i_cp = call.get_arg();
        let f_trailing = call.get_arg();
        let c_chars = call.get_arg();
        let c_glyphs = call.get_arg();
        let pw_log_clust = call.get_arg();
        let psva = call.get_arg();
        let pi_advance = call.get_arg();
        let psa = call.get_arg();
        let pi_x = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptCPtoX(
            i_cp,
            f_trailing,
            c_chars,
            c_glyphs,
            pw_log_clust,
            psva,
            pi_advance,
            psa,
            pi_x,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptFreeCache(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptFreeCache(psc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptGetLogicalWidths(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psa = call.get_arg();
        let c_chars = call.get_arg();
        let c_glyphs = call.get_arg();
        let pi_glyph_width = call.get_arg();
        let pw_log_clust = call.get_arg();
        let psva = call.get_arg();
        let pi_dx = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptGetLogicalWidths(
            psa,
            c_chars,
            c_glyphs,
            pi_glyph_width,
            pw_log_clust,
            psva,
            pi_dx,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptGetProperties(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pp_sp = call.get_arg();
        let pi_num_scripts = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptGetProperties(pp_sp, pi_num_scripts);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptIsComplex(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_in_chars = call.get_arg();
        let c_in_chars = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptIsComplex(pwc_in_chars, c_in_chars, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptItemize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_in_chars = call.get_arg();
        let c_in_chars = call.get_arg();
        let c_max_items = call.get_arg();
        let ps_control = call.get_arg();
        let ps_state = call.get_arg();
        let p_items = call.get_arg();
        let pc_items = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptItemize(
            pwc_in_chars,
            c_in_chars,
            c_max_items,
            ps_control,
            ps_state,
            p_items,
            pc_items,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptItemizeOpenType(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_in_chars = call.get_arg();
        let c_in_chars = call.get_arg();
        let c_max_items = call.get_arg();
        let ps_control = call.get_arg();
        let ps_state = call.get_arg();
        let p_items = call.get_arg();
        let p_script_tags = call.get_arg();
        let pc_items = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptItemizeOpenType(
            pwc_in_chars,
            c_in_chars,
            c_max_items,
            ps_control,
            ps_state,
            p_items,
            p_script_tags,
            pc_items,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptJustify(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psva = call.get_arg();
        let pi_advance = call.get_arg();
        let c_glyphs = call.get_arg();
        let i_dx = call.get_arg();
        let i_min_kashida = call.get_arg();
        let pi_justify = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptJustify(psva, pi_advance, c_glyphs, i_dx, i_min_kashida, pi_justify);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptLayout(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let c_runs = call.get_arg();
        let pb_level = call.get_arg();
        let pi_visual_to_logical = call.get_arg();
        let pi_logical_to_visual = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptLayout(c_runs, pb_level, pi_visual_to_logical, pi_logical_to_visual);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptRecordDigitSubstitution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let psds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptRecordDigitSubstitution(locale, psds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringCPtoX(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let icp = call.get_arg();
        let f_trailing = call.get_arg();
        let p_x = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptStringCPtoX(ssa, icp, f_trailing, p_x);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringFree(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptStringFree(pssa);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringGetLogicalWidths(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let pi_dx = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptStringGetLogicalWidths(ssa, pi_dx);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringGetOrder(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let pu_order = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptStringGetOrder(ssa, pu_order);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringValidate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptStringValidate(ssa);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringXtoCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let i_x = call.get_arg();
        let pi_ch = call.get_arg();
        let pi_trailing = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptStringXtoCP(ssa, i_x, pi_ch, pi_trailing);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pLogAttr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptString_pLogAttr(ssa);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptString_pSize(ssa);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pcOutChars(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptString_pcOutChars(ssa);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptXtoCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let i_x = call.get_arg();
        let c_chars = call.get_arg();
        let c_glyphs = call.get_arg();
        let pw_log_clust = call.get_arg();
        let psva = call.get_arg();
        let pi_advance = call.get_arg();
        let psa = call.get_arg();
        let pi_cp = call.get_arg();
        let pi_trailing = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScriptXtoCP(
            i_x,
            c_chars,
            c_glyphs,
            pw_log_clust,
            psva,
            pi_advance,
            psa,
            pi_cp,
            pi_trailing,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCalendarInfoA(locale, calendar, cal_type, lp_cal_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCalendarInfoW(locale, calendar, cal_type, lp_cal_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLocaleInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetLocaleInfoA(locale, lc_type, lp_lc_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLocaleInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetLocaleInfoW(locale, lc_type, lp_lc_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pul_num_languages = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetProcessPreferredUILanguages(dw_flags, pwsz_languages_buffer, pul_num_languages);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadLocale(locale);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pul_num_languages = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetThreadPreferredUILanguages(dw_flags, pwsz_languages_buffer, pul_num_languages);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPreferredUILanguages2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let languages = call.get_arg();
        let num_languages_set = call.get_arg();
        let snapshot = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadPreferredUILanguages2(flags, languages, num_languages_set, snapshot);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadUILanguage(lang_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetUserGeoID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetUserGeoID(geo_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetUserGeoName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetUserGeoName(geo_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateCharsetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_src = call.get_arg();
        let lp_cs = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateCharsetInfo(lp_src, lp_cs, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerifyScripts(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_locale_scripts = call.get_arg();
        let cch_locale_scripts = call.get_arg();
        let lp_test_scripts = call.get_arg();
        let cch_test_scripts = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerifyScripts(
            dw_flags,
            lp_locale_scripts,
            cch_locale_scripts,
            lp_test_scripts,
            cch_test_scripts,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WideCharToMultiByte(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_wide_char_str = call.get_arg();
        let cch_wide_char = call.get_arg();
        let lp_multi_byte_str = call.get_arg();
        let cb_multi_byte = call.get_arg();
        let lp_default_char = call.get_arg();
        let lp_used_default_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WideCharToMultiByte(
            code_page,
            dw_flags,
            lp_wide_char_str,
            cch_wide_char,
            lp_multi_byte_str,
            cb_multi_byte,
            lp_default_char,
            lp_used_default_char,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcatA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcatA(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcatW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcatW(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcmpA(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcmpW(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpiA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcmpiA(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpiW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcmpiW(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpyA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcpyA(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpyW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcpyW(lp_string_1, lp_string_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpynA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let i_max_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcpynA(lp_string_1, lp_string_2, i_max_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpynW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let i_max_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrcpynW(lp_string_1, lp_string_2, i_max_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrlenA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrlenA(lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrlenW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.lstrlenW(lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AreFileApisANSI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.AreFileApisANSI();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AreShortNamesEnabled(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let enabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AreShortNamesEnabled(handle, enabled);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BackupRead(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_number_of_bytes_read = call.get_arg();
        let b_abort = call.get_arg();
        let b_process_security = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BackupRead(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_read,
            lp_number_of_bytes_read,
            b_abort,
            b_process_security,
            lp_context,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BackupSeek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let dw_low_bytes_to_seek = call.get_arg();
        let dw_high_bytes_to_seek = call.get_arg();
        let lpdw_low_byte_seeked = call.get_arg();
        let lpdw_high_byte_seeked = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BackupSeek(
            h_file,
            dw_low_bytes_to_seek,
            dw_high_bytes_to_seek,
            lpdw_low_byte_seeked,
            lpdw_high_byte_seeked,
            lp_context,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BackupWrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_number_of_bytes_written = call.get_arg();
        let b_abort = call.get_arg();
        let b_process_security = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BackupWrite(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_write,
            lp_number_of_bytes_written,
            b_abort,
            b_process_security,
            lp_context,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingCancelRequest(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let file = call.get_arg();
        let op_to_cancel = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BuildIoRingCancelRequest(io_ring, file, op_to_cancel, user_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingReadFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let file_ref = call.get_arg();
        let data_ref = call.get_arg();
        let number_of_bytes_to_read = call.get_arg();
        let file_offset = call.get_arg();
        let user_data = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BuildIoRingReadFile(
            io_ring,
            file_ref,
            data_ref,
            number_of_bytes_to_read,
            file_offset,
            user_data,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingRegisterBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let count = call.get_arg();
        let buffers = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BuildIoRingRegisterBuffers(io_ring, count, buffers, user_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingRegisterFileHandles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let count = call.get_arg();
        let handles = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BuildIoRingRegisterFileHandles(io_ring, count, handles, user_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckNameLegalDOS8Dot3A(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_oem_name = call.get_arg();
        let oem_name_size = call.get_arg();
        let pb_name_contains_spaces = call.get_arg();
        let pb_name_legal = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CheckNameLegalDOS8Dot3A(
            lp_name,
            lp_oem_name,
            oem_name_size,
            pb_name_contains_spaces,
            pb_name_legal,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckNameLegalDOS8Dot3W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_oem_name = call.get_arg();
        let oem_name_size = call.get_arg();
        let pb_name_contains_spaces = call.get_arg();
        let pb_name_legal = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CheckNameLegalDOS8Dot3W(
            lp_name,
            lp_oem_name,
            oem_name_size,
            pb_name_contains_spaces,
            pb_name_legal,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseEncryptedFileRaw(pv_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseIoRing(io_ring);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CommitComplete(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CommitEnlistment(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CommitTransaction(transaction_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitTransactionAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CommitTransactionAsync(transaction_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_time_1 = call.get_arg();
        let lp_file_time_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CompareFileTime(lp_file_time_1, lp_file_time_2);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFile2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwsz_existing_file_name = call.get_arg();
        let pwsz_new_file_name = call.get_arg();
        let p_extended_parameters = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFile2(
            pwsz_existing_file_name,
            pwsz_new_file_name,
            p_extended_parameters,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let b_fail_if_exists = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFileA(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFileExA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFileExW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let b_fail_if_exists = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFileFromAppW(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFileTransactedA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFileTransactedW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let b_fail_if_exists = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyFileW(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyLZFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hf_source = call.get_arg();
        let hf_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyLZFile(hf_source, hf_dest);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ioring_version = call.get_arg();
        let flags = call.get_arg();
        let submission_queue_size = call.get_arg();
        let completion_queue_size = call.get_arg();
        let h = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateIoRing(
            ioring_version,
            flags,
            submission_queue_size,
            completion_queue_size,
            h,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateSymbolicLinkA(lp_symlink_file_name, lp_target_file_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateSymbolicLinkTransactedA(
            lp_symlink_file_name,
            lp_target_file_name,
            dw_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateSymbolicLinkTransactedW(
            lp_symlink_file_name,
            lp_target_file_name,
            dw_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateSymbolicLinkW(lp_symlink_file_name, lp_target_file_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateTapePartition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_partition_method = call.get_arg();
        let dw_count = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateTapePartition(h_device, dw_partition_method, dw_count, dw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DecryptFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DecryptFileA(lp_file_name, dw_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DecryptFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DecryptFileW(lp_file_name, dw_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefineDosDeviceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefineDosDeviceA(dw_flags, lp_device_name, lp_target_path);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefineDosDeviceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefineDosDeviceW(dw_flags, lp_device_name, lp_target_path);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteFileA(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteFileFromAppW(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteFileTransactedA(lp_file_name, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteFileTransactedW(lp_file_name, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteFileW(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteVolumeMountPointA(lpsz_volume_mount_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteVolumeMountPointW(lpsz_volume_mount_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EncryptFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EncryptFileA(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EncryptFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EncryptFileW(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EncryptionDisable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dir_path = call.get_arg();
        let disable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EncryptionDisable(dir_path, disable);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EraseTape(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_erase_type = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EraseTape(h_device, dw_erase_type, b_immediate);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileEncryptionStatusA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_status = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileEncryptionStatusA(lp_file_name, lp_status);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileEncryptionStatusW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_status = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileEncryptionStatusW(lp_file_name, lp_status);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileTimeToLocalFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_time = call.get_arg();
        let lp_local_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileTimeToLocalFileTime(lp_file_time, lp_local_file_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindClose(h_find_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindCloseChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_change_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindCloseChangeNotification(h_change_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstChangeNotificationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstChangeNotificationA(lp_path_name, b_watch_subtree, dw_notify_filter);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstChangeNotificationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstChangeNotificationW(lp_path_name, b_watch_subtree, dw_notify_filter);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileA(lp_file_name, lp_find_file_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileExA(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileExFromAppW(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileExW(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let string_length = call.get_arg();
        let link_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileNameTransactedW(
            lp_file_name,
            dw_flags,
            string_length,
            link_name,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let string_length = call.get_arg();
        let link_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileNameW(lp_file_name, dw_flags, string_length, link_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileTransactedA(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileTransactedW(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstFileW(lp_file_name, lp_find_file_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstStreamTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let info_level = call.get_arg();
        let lp_find_stream_data = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstStreamTransactedW(
            lp_file_name,
            info_level,
            lp_find_stream_data,
            dw_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstStreamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let info_level = call.get_arg();
        let lp_find_stream_data = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstStreamW(lp_file_name, info_level, lp_find_stream_data, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstVolumeA(lpsz_volume_name, cch_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_root_path_name = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstVolumeMountPointA(
            lpsz_root_path_name,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_root_path_name = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstVolumeMountPointW(
            lpsz_root_path_name,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindFirstVolumeW(lpsz_volume_name, cch_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_change_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextChangeNotification(h_change_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_file = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextFileA(h_find_file, lp_find_file_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_stream = call.get_arg();
        let string_length = call.get_arg();
        let link_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextFileNameW(h_find_stream, string_length, link_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_file = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextFileW(h_find_file, lp_find_file_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextStreamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_stream = call.get_arg();
        let lp_find_stream_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextStreamW(h_find_stream, lp_find_stream_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextVolumeA(h_find_volume, lpsz_volume_name, cch_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume_mount_point = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextVolumeMountPointA(
            h_find_volume_mount_point,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume_mount_point = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextVolumeMountPointW(
            h_find_volume_mount_point,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindNextVolumeW(h_find_volume, lpsz_volume_name, cch_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindVolumeClose(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindVolumeClose(h_find_volume);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindVolumeMountPointClose(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume_mount_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindVolumeMountPointClose(h_find_volume_mount_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushFileBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlushFileBuffers(h_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeEncryptedFileMetadata(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pb_metadata = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeEncryptedFileMetadata(pb_metadata);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetBinaryTypeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_application_name = call.get_arg();
        let lp_binary_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetBinaryTypeA(lp_application_name, lp_binary_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetBinaryTypeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_application_name = call.get_arg();
        let lp_binary_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetBinaryTypeW(lp_application_name, lp_binary_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCompressedFileSizeA(lp_file_name, lp_file_size_high);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetCompressedFileSizeTransactedA(lp_file_name, lp_file_size_high, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetCompressedFileSizeTransactedW(lp_file_name, lp_file_size_high, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCompressedFileSizeW(lp_file_name, lp_file_size_high);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentClockTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetCurrentClockTransactionManager(transaction_manager_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_sectors_per_cluster = call.get_arg();
        let lp_bytes_per_sector = call.get_arg();
        let lp_number_of_free_clusters = call.get_arg();
        let lp_total_number_of_clusters = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDiskFreeSpaceA(
            lp_root_path_name,
            lp_sectors_per_cluster,
            lp_bytes_per_sector,
            lp_number_of_free_clusters,
            lp_total_number_of_clusters,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_directory_name = call.get_arg();
        let lp_free_bytes_available_to_caller = call.get_arg();
        let lp_total_number_of_bytes = call.get_arg();
        let lp_total_number_of_free_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDiskFreeSpaceExA(
            lp_directory_name,
            lp_free_bytes_available_to_caller,
            lp_total_number_of_bytes,
            lp_total_number_of_free_bytes,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_directory_name = call.get_arg();
        let lp_free_bytes_available_to_caller = call.get_arg();
        let lp_total_number_of_bytes = call.get_arg();
        let lp_total_number_of_free_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDiskFreeSpaceExW(
            lp_directory_name,
            lp_free_bytes_available_to_caller,
            lp_total_number_of_bytes,
            lp_total_number_of_free_bytes,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_sectors_per_cluster = call.get_arg();
        let lp_bytes_per_sector = call.get_arg();
        let lp_number_of_free_clusters = call.get_arg();
        let lp_total_number_of_clusters = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDiskFreeSpaceW(
            lp_root_path_name,
            lp_sectors_per_cluster,
            lp_bytes_per_sector,
            lp_number_of_free_clusters,
            lp_total_number_of_clusters,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskSpaceInformationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let root_path = call.get_arg();
        let disk_space_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDiskSpaceInformationA(root_path, disk_space_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskSpaceInformationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let root_path = call.get_arg();
        let disk_space_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDiskSpaceInformationW(root_path, disk_space_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDriveTypeA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDriveTypeA(lp_root_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDriveTypeW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDriveTypeW(lp_root_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEncryptedFileMetadata(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let pcb_metadata = call.get_arg();
        let ppb_metadata = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetEncryptedFileMetadata(lp_file_name, pcb_metadata, ppb_metadata);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnlistmentId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let enlistment_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetEnlistmentId(enlistment_handle, enlistment_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnlistmentRecoveryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let buffer_size = call.get_arg();
        let buffer = call.get_arg();
        let buffer_used = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetEnlistmentRecoveryInformation(
            enlistment_handle,
            buffer_size,
            buffer,
            buffer_used,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExpandedNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_source = call.get_arg();
        let lpsz_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetExpandedNameA(lpsz_source, lpsz_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExpandedNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_source = call.get_arg();
        let lpsz_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetExpandedNameW(lpsz_source, lpsz_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileAttributesA(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileAttributesExA(lp_file_name, f_info_level_id, lp_file_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetFileAttributesExFromAppW(lp_file_name, f_info_level_id, lp_file_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileAttributesExW(lp_file_name, f_info_level_id, lp_file_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileAttributesTransactedA(
            lp_file_name,
            f_info_level_id,
            lp_file_information,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileAttributesTransactedW(
            lp_file_name,
            f_info_level_id,
            lp_file_information,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileAttributesW(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileBandwidthReservation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_period_milliseconds = call.get_arg();
        let lp_bytes_per_period = call.get_arg();
        let p_discardable = call.get_arg();
        let lp_transfer_size = call.get_arg();
        let lp_num_outstanding_requests = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileBandwidthReservation(
            h_file,
            lp_period_milliseconds,
            lp_bytes_per_period,
            p_discardable,
            lp_transfer_size,
            lp_num_outstanding_requests,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileInformationByHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileInformationByHandle(h_file, lp_file_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileInformationByHandleEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let file_information_class = call.get_arg();
        let lp_file_information = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileInformationByHandleEx(
            h_file,
            file_information_class,
            lp_file_information,
            dw_buffer_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileSize(h_file, lp_file_size_high);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileSizeEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_file_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileSizeEx(h_file, lp_file_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_last_access_time = call.get_arg();
        let lp_last_write_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileTime(
            h_file,
            lp_creation_time,
            lp_last_access_time,
            lp_last_write_time,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileType(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileType(h_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoA(lptstr_filename, dw_handle, dw_len, lp_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoExA(dw_flags, lpwstr_filename, dw_handle, dw_len, lp_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoExW(dw_flags, lpwstr_filename, dw_handle, dw_len, lp_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoSizeA(lptstr_filename, lpdw_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoSizeExA(dw_flags, lpwstr_filename, lpdw_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoSizeExW(dw_flags, lpwstr_filename, lpdw_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoSizeW(lptstr_filename, lpdw_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFileVersionInfoW(lptstr_filename, dw_handle, dw_len, lp_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFinalPathNameByHandleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lpsz_file_path = call.get_arg();
        let cch_file_path = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFinalPathNameByHandleA(h_file, lpsz_file_path, cch_file_path, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFinalPathNameByHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lpsz_file_path = call.get_arg();
        let cch_file_path = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFinalPathNameByHandleW(h_file, lpsz_file_path, cch_file_path, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFullPathNameA(lp_file_name, n_buffer_length, lp_buffer, lp_file_part);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFullPathNameTransactedA(
            lp_file_name,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFullPathNameTransactedW(
            lp_file_name,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFullPathNameW(lp_file_name, n_buffer_length, lp_buffer, lp_file_part);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetIoRingInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetIoRingInfo(io_ring, info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDriveStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLogicalDriveStringsA(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDriveStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLogicalDriveStringsW(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDrives(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetLogicalDrives();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLongPathNameA(lpsz_short_path, lpsz_long_path, cch_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLongPathNameTransactedA(
            lpsz_short_path,
            lpsz_long_path,
            cch_buffer,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLongPathNameTransactedW(
            lpsz_short_path,
            lpsz_long_path,
            cch_buffer,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLongPathNameW(lpsz_short_path, lpsz_long_path, cch_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNotificationResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let transaction_notification = call.get_arg();
        let notification_length = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNotificationResourceManager(
            resource_manager_handle,
            transaction_notification,
            notification_length,
            dw_milliseconds,
            return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNotificationResourceManagerAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let transaction_notification = call.get_arg();
        let transaction_notification_length = call.get_arg();
        let return_length = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNotificationResourceManagerAsync(
            resource_manager_handle,
            transaction_notification,
            transaction_notification_length,
            return_length,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetShortPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_long_path = call.get_arg();
        let lpsz_short_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetShortPathNameA(lpsz_long_path, lpsz_short_path, cch_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetShortPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_long_path = call.get_arg();
        let lpsz_short_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetShortPathNameW(lpsz_long_path, lpsz_short_path, cch_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTapeParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_operation = call.get_arg();
        let lpdw_size = call.get_arg();
        let lp_tape_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTapeParameters(h_device, dw_operation, lpdw_size, lp_tape_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTapePosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_position_type = call.get_arg();
        let lpdw_partition = call.get_arg();
        let lpdw_offset_low = call.get_arg();
        let lpdw_offset_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTapePosition(
            h_device,
            dw_position_type,
            lpdw_partition,
            lpdw_offset_low,
            lpdw_offset_high,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTapeStatus(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTapeStatus(h_device);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let lp_prefix_string = call.get_arg();
        let u_unique = call.get_arg();
        let lp_temp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTempFileNameA(lp_path_name, lp_prefix_string, u_unique, lp_temp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let lp_prefix_string = call.get_arg();
        let u_unique = call.get_arg();
        let lp_temp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTempFileNameW(lp_path_name, lp_prefix_string, u_unique, lp_temp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPath2A(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer_length = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTempPath2A(buffer_length, buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPath2W(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer_length = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTempPath2W(buffer_length, buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPathA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTempPathA(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPathW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTempPathW(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTransactionId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let transaction_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTransactionId(transaction_handle, transaction_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTransactionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let outcome = call.get_arg();
        let isolation_level = call.get_arg();
        let isolation_flags = call.get_arg();
        let timeout = call.get_arg();
        let buffer_length = call.get_arg();
        let description = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTransactionInformation(
            transaction_handle,
            outcome,
            isolation_level,
            isolation_flags,
            timeout,
            buffer_length,
            description,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTransactionManagerId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let transaction_manager_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTransactionManagerId(transaction_manager_handle, transaction_manager_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name_buffer = call.get_arg();
        let n_volume_name_size = call.get_arg();
        let lp_volume_serial_number = call.get_arg();
        let lp_maximum_component_length = call.get_arg();
        let lp_file_system_flags = call.get_arg();
        let lp_file_system_name_buffer = call.get_arg();
        let n_file_system_name_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumeInformationA(
            lp_root_path_name,
            lp_volume_name_buffer,
            n_volume_name_size,
            lp_volume_serial_number,
            lp_maximum_component_length,
            lp_file_system_flags,
            lp_file_system_name_buffer,
            n_file_system_name_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationByHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_volume_name_buffer = call.get_arg();
        let n_volume_name_size = call.get_arg();
        let lp_volume_serial_number = call.get_arg();
        let lp_maximum_component_length = call.get_arg();
        let lp_file_system_flags = call.get_arg();
        let lp_file_system_name_buffer = call.get_arg();
        let n_file_system_name_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumeInformationByHandleW(
            h_file,
            lp_volume_name_buffer,
            n_volume_name_size,
            lp_volume_serial_number,
            lp_maximum_component_length,
            lp_file_system_flags,
            lp_file_system_name_buffer,
            n_file_system_name_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name_buffer = call.get_arg();
        let n_volume_name_size = call.get_arg();
        let lp_volume_serial_number = call.get_arg();
        let lp_maximum_component_length = call.get_arg();
        let lp_file_system_flags = call.get_arg();
        let lp_file_system_name_buffer = call.get_arg();
        let n_file_system_name_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumeInformationW(
            lp_root_path_name,
            lp_volume_name_buffer,
            n_volume_name_size,
            lp_volume_serial_number,
            lp_maximum_component_length,
            lp_file_system_flags,
            lp_file_system_name_buffer,
            n_file_system_name_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeNameForVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumeNameForVolumeMountPointA(
            lpsz_volume_mount_point,
            lpsz_volume_name,
            cch_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeNameForVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumeNameForVolumeMountPointW(
            lpsz_volume_mount_point,
            lpsz_volume_name,
            cch_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_file_name = call.get_arg();
        let lpsz_volume_path_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumePathNameA(lpsz_file_name, lpsz_volume_path_name, cch_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_file_name = call.get_arg();
        let lpsz_volume_path_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumePathNameW(lpsz_file_name, lpsz_volume_path_name, cch_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNamesForVolumeNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let lpsz_volume_path_names = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let lpcch_return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumePathNamesForVolumeNameA(
            lpsz_volume_name,
            lpsz_volume_path_names,
            cch_buffer_length,
            lpcch_return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNamesForVolumeNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let lpsz_volume_path_names = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let lpcch_return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVolumePathNamesForVolumeNameW(
            lpsz_volume_name,
            lpsz_volume_path_names,
            cch_buffer_length,
            lpcch_return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsIoRingOpSupported(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let op = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsIoRingOpSupported(io_ring, op);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LZClose(h_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZCopy(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hf_source = call.get_arg();
        let hf_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LZCopy(hf_source, hf_dest);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZDone(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.LZDone();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZInit(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hf_source = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LZInit(hf_source);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZOpenFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_re_open_buf = call.get_arg();
        let w_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LZOpenFileA(lp_file_name, lp_re_open_buf, w_style);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZOpenFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_re_open_buf = call.get_arg();
        let w_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LZOpenFileW(lp_file_name, lp_re_open_buf, w_style);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZRead(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let cb_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LZRead(h_file, lp_buffer, cb_read);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZSeek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let l_offset = call.get_arg();
        let i_origin = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LZSeek(h_file, l_offset, i_origin);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZStart(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.LZStart();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileA(lp_existing_file_name, lp_new_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileExA(lp_existing_file_name, lp_new_file_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileExW(lp_existing_file_name, lp_new_file_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileFromAppW(lp_existing_file_name, lp_new_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileTransactedA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileTransactedW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
            h_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileW(lp_existing_file_name, lp_new_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileWithProgressA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileWithProgressA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileWithProgressW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveFileWithProgressW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetConnectionEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let qualifier = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetConnectionEnum(
            servername,
            qualifier,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetFileClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let fileid = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetFileClose(servername, fileid);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetFileEnum(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let basepath = call.get_arg();
        let username = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetFileEnum(
            servername,
            basepath,
            username,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetFileGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let fileid = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetFileGetInfo(servername, fileid, level, bufptr);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasAdd(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetServerAliasAdd(servername, level, buf);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasDel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetServerAliasDel(servername, level, buf);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resumehandle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetServerAliasEnum(
            servername,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resumehandle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetSessionDel(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let unc_client_name = call.get_arg();
        let username = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetSessionDel(servername, unc_client_name, username);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetSessionEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let unc_client_name = call.get_arg();
        let username = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetSessionEnum(
            servername,
            unc_client_name,
            username,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetSessionGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let unc_client_name = call.get_arg();
        let username = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetSessionGetInfo(servername, unc_client_name, username, level, bufptr);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareAdd(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let parm_err = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareAdd(servername, level, buf, parm_err);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareCheck(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let device = call.get_arg();
        let r#type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareCheck(servername, device, r#type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareDel(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareDel(servername, netname, reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareDelEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareDelEx(servername, level, buf);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareDelSticky(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareDelSticky(servername, netname, reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareEnum(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareEnum(
            servername,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareEnumSticky(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareEnumSticky(
            servername,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareGetInfo(servername, netname, level, bufptr);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareSetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let parm_err = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetShareSetInfo(servername, netname, level, buf, parm_err);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetStatisticsGet(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let server_name = call.get_arg();
        let service = call.get_arg();
        let level = call.get_arg();
        let options = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NetStatisticsGet(server_name, service, level, options, buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtCreateFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let desired_access = call.get_arg();
        let object_attributes = call.get_arg();
        let io_status_block = call.get_arg();
        let allocation_size = call.get_arg();
        let file_attributes = call.get_arg();
        let share_access = call.get_arg();
        let create_disposition = call.get_arg();
        let create_options = call.get_arg();
        let ea_buffer = call.get_arg();
        let ea_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtCreateFile(
            file_handle,
            desired_access,
            object_attributes,
            io_status_block,
            allocation_size,
            file_attributes,
            share_access,
            create_disposition,
            create_options,
            ea_buffer,
            ea_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEncryptedFileRawA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let ul_flags = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenEncryptedFileRawA(lp_file_name, ul_flags, pv_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEncryptedFileRawW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let ul_flags = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenEncryptedFileRawW(lp_file_name, ul_flags, pv_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let resource_manager_handle = call.get_arg();
        let enlistment_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenEnlistment(dw_desired_access, resource_manager_handle, enlistment_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_re_open_buff = call.get_arg();
        let u_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenFile(lp_file_name, lp_re_open_buff, u_style);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let tm_handle = call.get_arg();
        let resource_manager_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenResourceManager(dw_desired_access, tm_handle, resource_manager_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let transaction_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenTransaction(dw_desired_access, transaction_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_file_name = call.get_arg();
        let desired_access = call.get_arg();
        let open_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenTransactionManager(log_file_name, desired_access, open_options);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenTransactionManagerById(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_id = call.get_arg();
        let desired_access = call.get_arg();
        let open_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.OpenTransactionManagerById(transaction_manager_id, desired_access, open_options);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PopIoRingCompletion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let cqe = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PopIoRingCompletion(io_ring, cqe);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrePrepareComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrePrepareComplete(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrePrepareEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrePrepareEnlistment(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrepareComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrepareComplete(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrepareEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrepareEnlistment(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrepareTape(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_operation = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrepareTape(h_device, dw_operation, b_immediate);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryDosDeviceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryDosDeviceA(lp_device_name, lp_target_path, ucch_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryDosDeviceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryDosDeviceW(lp_device_name, lp_target_path, ucch_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryIoRingCapabilities(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let capabilities = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryIoRingCapabilities(capabilities);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReOpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_original_file = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_share_mode = call.get_arg();
        let dw_flags_and_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReOpenFile(
            h_original_file,
            dw_desired_access,
            dw_share_mode,
            dw_flags_and_attributes,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadDirectoryChangesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_directory = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_buffer_length = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let lp_bytes_returned = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let read_directory_notify_information_class = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadDirectoryChangesExW(
            h_directory,
            lp_buffer,
            n_buffer_length,
            b_watch_subtree,
            dw_notify_filter,
            lp_bytes_returned,
            lp_overlapped,
            lp_completion_routine,
            read_directory_notify_information_class,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadDirectoryChangesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_directory = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_buffer_length = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let lp_bytes_returned = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadDirectoryChangesW(
            h_directory,
            lp_buffer,
            n_buffer_length,
            b_watch_subtree,
            dw_notify_filter,
            lp_bytes_returned,
            lp_overlapped,
            lp_completion_routine,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pf_export_callback = call.get_arg();
        let pv_callback_context = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadEncryptedFileRaw(pf_export_callback, pv_callback_context, pv_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_number_of_bytes_read = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadFile(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_read,
            lp_number_of_bytes_read,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadFileEx(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_read,
            lp_overlapped,
            lp_completion_routine,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadFileScatter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let a_segment_array = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_reserved = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadFileScatter(
            h_file,
            a_segment_array,
            n_number_of_bytes_to_read,
            lp_reserved,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadOnlyEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadOnlyEnlistment(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecoverEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let enlistment_key = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RecoverEnlistment(enlistment_handle, enlistment_key);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecoverResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RecoverResourceManager(resource_manager_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecoverTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RecoverTransactionManager(transaction_manager_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveDirectoryA(lp_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveDirectoryFromAppW(lp_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveDirectoryTransactedA(lp_path_name, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveDirectoryTransactedW(lp_path_name, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveDirectoryW(lp_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RenameTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_file_name = call.get_arg();
        let existing_transaction_manager_guid = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RenameTransactionManager(log_file_name, existing_transaction_manager_guid);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_replaced_file_name = call.get_arg();
        let lp_replacement_file_name = call.get_arg();
        let lp_backup_file_name = call.get_arg();
        let dw_replace_flags = call.get_arg();
        let lp_exclude = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReplaceFileA(
            lp_replaced_file_name,
            lp_replacement_file_name,
            lp_backup_file_name,
            dw_replace_flags,
            lp_exclude,
            lp_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_replaced_file_name = call.get_arg();
        let lp_replacement_file_name = call.get_arg();
        let lp_backup_file_name = call.get_arg();
        let dw_replace_flags = call.get_arg();
        let lp_exclude = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReplaceFileFromAppW(
            lp_replaced_file_name,
            lp_replacement_file_name,
            lp_backup_file_name,
            dw_replace_flags,
            lp_exclude,
            lp_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_replaced_file_name = call.get_arg();
        let lp_replacement_file_name = call.get_arg();
        let lp_backup_file_name = call.get_arg();
        let dw_replace_flags = call.get_arg();
        let lp_exclude = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReplaceFileW(
            lp_replaced_file_name,
            lp_replacement_file_name,
            lp_backup_file_name,
            dw_replace_flags,
            lp_exclude,
            lp_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RollbackComplete(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RollbackEnlistment(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RollbackTransaction(transaction_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackTransactionAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RollbackTransactionAsync(transaction_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollforwardTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RollforwardTransactionManager(transaction_manager_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SearchPathA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path = call.get_arg();
        let lp_file_name = call.get_arg();
        let lp_extension = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SearchPathA(
            lp_path,
            lp_file_name,
            lp_extension,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SearchPathW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path = call.get_arg();
        let lp_file_name = call.get_arg();
        let lp_extension = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SearchPathW(
            lp_path,
            lp_file_name,
            lp_extension,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEndOfFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEndOfFile(h_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnlistmentRecoveryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let buffer_size = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEnlistmentRecoveryInformation(enlistment_handle, buffer_size, buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileApisToANSI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.SetFileApisToANSI();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileApisToOEM(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.SetFileApisToOEM();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileAttributesA(lp_file_name, dw_file_attributes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileAttributesFromAppW(lp_file_name, dw_file_attributes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileAttributesTransactedA(lp_file_name, dw_file_attributes, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileAttributesTransactedW(lp_file_name, dw_file_attributes, h_transaction);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileAttributesW(lp_file_name, dw_file_attributes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileBandwidthReservation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let n_period_milliseconds = call.get_arg();
        let n_bytes_per_period = call.get_arg();
        let b_discardable = call.get_arg();
        let lp_transfer_size = call.get_arg();
        let lp_num_outstanding_requests = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileBandwidthReservation(
            h_file,
            n_period_milliseconds,
            n_bytes_per_period,
            b_discardable,
            lp_transfer_size,
            lp_num_outstanding_requests,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileCompletionNotificationModes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileCompletionNotificationModes(file_handle, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileInformationByHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let file_information_class = call.get_arg();
        let lp_file_information = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileInformationByHandle(
            h_file,
            file_information_class,
            lp_file_information,
            dw_buffer_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileIoOverlappedRange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let overlapped_range_start = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileIoOverlappedRange(file_handle, overlapped_range_start, length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFilePointer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let l_distance_to_move = call.get_arg();
        let lp_distance_to_move_high = call.get_arg();
        let dw_move_method = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFilePointer(
            h_file,
            l_distance_to_move,
            lp_distance_to_move_high,
            dw_move_method,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFilePointerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let li_distance_to_move = call.get_arg();
        let lp_new_file_pointer = call.get_arg();
        let dw_move_method = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFilePointerEx(
            h_file,
            li_distance_to_move,
            lp_new_file_pointer,
            dw_move_method,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileShortNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_short_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileShortNameA(h_file, lp_short_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileShortNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_short_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileShortNameW(h_file, lp_short_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_last_access_time = call.get_arg();
        let lp_last_write_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileTime(
            h_file,
            lp_creation_time,
            lp_last_access_time,
            lp_last_write_time,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileValidData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let valid_data_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFileValidData(h_file, valid_data_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetIoRingCompletionEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetIoRingCompletionEvent(io_ring, h_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetResourceManagerCompletionPort(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let io_completion_port_handle = call.get_arg();
        let completion_key = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetResourceManagerCompletionPort(
            resource_manager_handle,
            io_completion_port_handle,
            completion_key,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSearchPathMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetSearchPathMode(flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTapeParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_operation = call.get_arg();
        let lp_tape_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetTapeParameters(h_device, dw_operation, lp_tape_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTapePosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_position_method = call.get_arg();
        let dw_partition = call.get_arg();
        let dw_offset_low = call.get_arg();
        let dw_offset_high = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetTapePosition(
            h_device,
            dw_position_method,
            dw_partition,
            dw_offset_low,
            dw_offset_high,
            b_immediate,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTransactionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let isolation_level = call.get_arg();
        let isolation_flags = call.get_arg();
        let timeout = call.get_arg();
        let description = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetTransactionInformation(
            transaction_handle,
            isolation_level,
            isolation_flags,
            timeout,
            description,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeLabelA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetVolumeLabelA(lp_root_path_name, lp_volume_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeLabelW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetVolumeLabelW(lp_root_path_name, lp_volume_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetVolumeMountPointA(lpsz_volume_mount_point, lpsz_volume_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetVolumeMountPointW(lpsz_volume_mount_point, lpsz_volume_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SinglePhaseReject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SinglePhaseReject(enlistment_handle, tm_virtual_clock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SubmitIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let wait_operations = call.get_arg();
        let milliseconds = call.get_arg();
        let submitted_entries = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SubmitIoRing(io_ring, wait_operations, milliseconds, submitted_entries);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfGetThreadMiniVersionForCreate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let mini_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfGetThreadMiniVersionForCreate(mini_version);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogCreateFileReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_path = call.get_arg();
        let beginning_lsn = call.get_arg();
        let ending_lsn = call.get_arg();
        let txf_file_id = call.get_arg();
        let txf_log_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfLogCreateFileReadContext(
            log_path,
            beginning_lsn,
            ending_lsn,
            txf_file_id,
            txf_log_context,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogCreateRangeReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_path = call.get_arg();
        let beginning_lsn = call.get_arg();
        let ending_lsn = call.get_arg();
        let beginning_virtual_clock = call.get_arg();
        let ending_virtual_clock = call.get_arg();
        let record_type_mask = call.get_arg();
        let txf_log_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfLogCreateRangeReadContext(
            log_path,
            beginning_lsn,
            ending_lsn,
            beginning_virtual_clock,
            ending_virtual_clock,
            record_type_mask,
            txf_log_context,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogDestroyReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let txf_log_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfLogDestroyReadContext(txf_log_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogReadRecords(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let txf_log_context = call.get_arg();
        let buffer_length = call.get_arg();
        let buffer = call.get_arg();
        let bytes_used = call.get_arg();
        let record_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfLogReadRecords(
            txf_log_context,
            buffer_length,
            buffer,
            bytes_used,
            record_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogRecordGetFileName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let record_buffer = call.get_arg();
        let record_buffer_length_in_bytes = call.get_arg();
        let name_buffer = call.get_arg();
        let name_buffer_length_in_bytes = call.get_arg();
        let txf_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfLogRecordGetFileName(
            record_buffer,
            record_buffer_length_in_bytes,
            name_buffer,
            name_buffer_length_in_bytes,
            txf_id,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogRecordGetGenericType(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let record_buffer = call.get_arg();
        let record_buffer_length_in_bytes = call.get_arg();
        let generic_type = call.get_arg();
        let virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfLogRecordGetGenericType(
            record_buffer,
            record_buffer_length_in_bytes,
            generic_type,
            virtual_clock,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfReadMetadataInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let txf_file_id = call.get_arg();
        let last_lsn = call.get_arg();
        let transaction_state = call.get_arg();
        let locking_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfReadMetadataInfo(
            file_handle,
            txf_file_id,
            last_lsn,
            transaction_state,
            locking_transaction,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfSetThreadMiniVersionForCreate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let mini_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TxfSetThreadMiniVersionForCreate(mini_version);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnlockFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let n_number_of_bytes_to_unlock_low = call.get_arg();
        let n_number_of_bytes_to_unlock_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnlockFile(
            h_file,
            dw_file_offset_low,
            dw_file_offset_high,
            n_number_of_bytes_to_unlock_low,
            n_number_of_bytes_to_unlock_high,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnlockFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let dw_reserved = call.get_arg();
        let n_number_of_bytes_to_unlock_low = call.get_arg();
        let n_number_of_bytes_to_unlock_high = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnlockFileEx(
            h_file,
            dw_reserved,
            n_number_of_bytes_to_unlock_low,
            n_number_of_bytes_to_unlock_high,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerFindFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_file_name = call.get_arg();
        let sz_win_dir = call.get_arg();
        let sz_app_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let pu_cur_dir_len = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let pu_dest_dir_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerFindFileA(
            u_flags,
            sz_file_name,
            sz_win_dir,
            sz_app_dir,
            sz_cur_dir,
            pu_cur_dir_len,
            sz_dest_dir,
            pu_dest_dir_len,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerFindFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_file_name = call.get_arg();
        let sz_win_dir = call.get_arg();
        let sz_app_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let pu_cur_dir_len = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let pu_dest_dir_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerFindFileW(
            u_flags,
            sz_file_name,
            sz_win_dir,
            sz_app_dir,
            sz_cur_dir,
            pu_cur_dir_len,
            sz_dest_dir,
            pu_dest_dir_len,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerInstallFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_src_file_name = call.get_arg();
        let sz_dest_file_name = call.get_arg();
        let sz_src_dir = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let sz_tmp_file = call.get_arg();
        let pu_tmp_file_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerInstallFileA(
            u_flags,
            sz_src_file_name,
            sz_dest_file_name,
            sz_src_dir,
            sz_dest_dir,
            sz_cur_dir,
            sz_tmp_file,
            pu_tmp_file_len,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerInstallFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_src_file_name = call.get_arg();
        let sz_dest_file_name = call.get_arg();
        let sz_src_dir = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let sz_tmp_file = call.get_arg();
        let pu_tmp_file_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerInstallFileW(
            u_flags,
            sz_src_file_name,
            sz_dest_file_name,
            sz_src_dir,
            sz_dest_dir,
            sz_cur_dir,
            sz_tmp_file,
            pu_tmp_file_len,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerLanguageNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_lang = call.get_arg();
        let sz_lang = call.get_arg();
        let cch_lang = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerLanguageNameA(w_lang, sz_lang, cch_lang);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerLanguageNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_lang = call.get_arg();
        let sz_lang = call.get_arg();
        let cch_lang = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerLanguageNameW(w_lang, sz_lang, cch_lang);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerQueryValueA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_block = call.get_arg();
        let lp_sub_block = call.get_arg();
        let lplp_buffer = call.get_arg();
        let pu_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerQueryValueA(p_block, lp_sub_block, lplp_buffer, pu_len);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerQueryValueW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_block = call.get_arg();
        let lp_sub_block = call.get_arg();
        let lplp_buffer = call.get_arg();
        let pu_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerQueryValueW(p_block, lp_sub_block, lplp_buffer, pu_len);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofEnumEntries(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let provider = call.get_arg();
        let enum_proc = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofEnumEntries(volume_name, provider, enum_proc, user_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofFileEnumFiles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let algorithm = call.get_arg();
        let enum_proc = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofFileEnumFiles(volume_name, algorithm, enum_proc, user_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofGetDriverVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_or_volume_handle = call.get_arg();
        let provider = call.get_arg();
        let wof_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofGetDriverVersion(file_or_volume_handle, provider, wof_version);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofIsExternalFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_path = call.get_arg();
        let is_external_file = call.get_arg();
        let provider = call.get_arg();
        let external_file_info = call.get_arg();
        let buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofIsExternalFile(
            file_path,
            is_external_file,
            provider,
            external_file_info,
            buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofSetFileDataLocation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let provider = call.get_arg();
        let external_file_info = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofSetFileDataLocation(file_handle, provider, external_file_info, length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofShouldCompressBinaries(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume = call.get_arg();
        let algorithm = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofShouldCompressBinaries(volume, algorithm);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimAddEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let wim_path = call.get_arg();
        let wim_type = call.get_arg();
        let wim_index = call.get_arg();
        let data_source_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofWimAddEntry(volume_name, wim_path, wim_type, wim_index, data_source_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimEnumFiles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let enum_proc = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofWimEnumFiles(volume_name, data_source_id, enum_proc, user_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimRemoveEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofWimRemoveEntry(volume_name, data_source_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimSuspendEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofWimSuspendEntry(volume_name, data_source_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimUpdateEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let new_wim_path = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WofWimUpdateEntry(volume_name, data_source_id, new_wim_path);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64DisableWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let old_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.Wow64DisableWow64FsRedirection(old_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64EnableWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let wow_64_fs_enable_redirection = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.Wow64EnableWow64FsRedirection(wow_64_fs_enable_redirection);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64RevertWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ol_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.Wow64RevertWow64FsRedirection(ol_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pf_import_callback = call.get_arg();
        let pv_callback_context = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteEncryptedFileRaw(pf_import_callback, pv_callback_context, pv_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_number_of_bytes_written = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteFile(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_write,
            lp_number_of_bytes_written,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteFileEx(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_write,
            lp_overlapped,
            lp_completion_routine,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteFileGather(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let a_segment_array = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_reserved = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteFileGather(
            h_file,
            a_segment_array,
            n_number_of_bytes_to_write,
            lp_reserved,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteTapemark(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_tapemark_type = call.get_arg();
        let dw_tapemark_count = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteTapemark(h_device, dw_tapemark_type, dw_tapemark_count, b_immediate);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddConsoleAliasA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AddConsoleAliasA(source, target, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddConsoleAliasW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AddConsoleAliasW(source, target, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.AllocConsole();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AttachConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AttachConsole(dw_process_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ClosePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_pc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ClosePseudoConsole(h_pc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreatePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let size = call.get_arg();
        let h_input = call.get_arg();
        let h_output = call.get_arg();
        let dw_flags = call.get_arg();
        let ph_pc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreatePseudoConsole(size, h_input, h_output, dw_flags, ph_pc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpungeConsoleCommandHistoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExpungeConsoleCommandHistoryA(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpungeConsoleCommandHistoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExpungeConsoleCommandHistoryW(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let w_attribute = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_attrs_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FillConsoleOutputAttribute(
            h_console_output,
            w_attribute,
            n_length,
            dw_write_coord,
            lp_number_of_attrs_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let c_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FillConsoleOutputCharacterA(
            h_console_output,
            c_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let c_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FillConsoleOutputCharacterW(
            h_console_output,
            c_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushConsoleInputBuffer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlushConsoleInputBuffer(h_console_input);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.FreeConsole();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GenerateConsoleCtrlEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_ctrl_event = call.get_arg();
        let dw_process_group_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GenerateConsoleCtrlEvent(dw_ctrl_event, dw_process_group_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target_buffer = call.get_arg();
        let target_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasA(source, target_buffer, target_buffer_length, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name_buffer = call.get_arg();
        let exe_name_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasExesA(exe_name_buffer, exe_name_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasExesLengthA();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasExesLengthW();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name_buffer = call.get_arg();
        let exe_name_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasExesW(exe_name_buffer, exe_name_buffer_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target_buffer = call.get_arg();
        let target_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasW(source, target_buffer, target_buffer_length, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let alias_buffer = call.get_arg();
        let alias_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasesA(alias_buffer, alias_buffer_length, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasesLengthA(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasesLengthW(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let alias_buffer = call.get_arg();
        let alias_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleAliasesW(alias_buffer, alias_buffer_length, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleCP();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let commands = call.get_arg();
        let command_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleCommandHistoryA(commands, command_buffer_length, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleCommandHistoryLengthA(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleCommandHistoryLengthW(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let commands = call.get_arg();
        let command_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleCommandHistoryW(commands, command_buffer_length, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCursorInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_cursor_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleCursorInfo(h_console_output, lp_console_cursor_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleDisplayMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_mode_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleDisplayMode(lp_mode_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleHistoryInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_history_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleHistoryInfo(lp_console_history_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_handle = call.get_arg();
        let lp_mode = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleMode(h_console_handle, lp_mode);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOriginalTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleOriginalTitleA(lp_console_title, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOriginalTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleOriginalTitleW(lp_console_title, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOutputCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleOutputCP();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleProcessList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpdw_process_list = call.get_arg();
        let dw_process_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleProcessList(lpdw_process_list, dw_process_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleScreenBufferInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_screen_buffer_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleScreenBufferInfo(h_console_output, lp_console_screen_buffer_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleScreenBufferInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_screen_buffer_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetConsoleScreenBufferInfoEx(h_console_output, lp_console_screen_buffer_info_ex);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleSelectionInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_selection_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleSelectionInfo(lp_console_selection_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleTitleA(lp_console_title, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleTitleW(lp_console_title, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetConsoleWindow();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentConsoleFont(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_maximum_window = call.get_arg();
        let lp_console_current_font = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetCurrentConsoleFont(h_console_output, b_maximum_window, lp_console_current_font);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentConsoleFontEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_maximum_window = call.get_arg();
        let lp_console_current_font_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentConsoleFontEx(
            h_console_output,
            b_maximum_window,
            lp_console_current_font_ex,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberOfConsoleInputEvents(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_number_of_events = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumberOfConsoleInputEvents(h_console_input, lp_number_of_events);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberOfConsoleMouseButtons(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_number_of_mouse_buttons = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumberOfConsoleMouseButtons(lp_number_of_mouse_buttons);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStdHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_std_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStdHandle(n_std_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PeekConsoleInputA(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PeekConsoleInputW(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_read = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let p_input_control = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleA(
            h_console_input,
            lp_buffer,
            n_number_of_chars_to_read,
            lp_number_of_chars_read,
            p_input_control,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleInputA(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleInputW(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_read_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleOutputA(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_read_region,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_attribute = call.get_arg();
        let n_length = call.get_arg();
        let dw_read_coord = call.get_arg();
        let lp_number_of_attrs_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleOutputAttribute(
            h_console_output,
            lp_attribute,
            n_length,
            dw_read_coord,
            lp_number_of_attrs_read,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_read_coord = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleOutputCharacterA(
            h_console_output,
            lp_character,
            n_length,
            dw_read_coord,
            lp_number_of_chars_read,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_read_coord = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleOutputCharacterW(
            h_console_output,
            lp_character,
            n_length,
            dw_read_coord,
            lp_number_of_chars_read,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_read_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleOutputW(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_read_region,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_read = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let p_input_control = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReadConsoleW(
            h_console_input,
            lp_buffer,
            n_number_of_chars_to_read,
            lp_number_of_chars_read,
            p_input_control,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResizePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_pc = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ResizePseudoConsole(h_pc, size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScrollConsoleScreenBufferA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_scroll_rectangle = call.get_arg();
        let lp_clip_rectangle = call.get_arg();
        let dw_destination_origin = call.get_arg();
        let lp_fill = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScrollConsoleScreenBufferA(
            h_console_output,
            lp_scroll_rectangle,
            lp_clip_rectangle,
            dw_destination_origin,
            lp_fill,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScrollConsoleScreenBufferW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_scroll_rectangle = call.get_arg();
        let lp_clip_rectangle = call.get_arg();
        let dw_destination_origin = call.get_arg();
        let lp_fill = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScrollConsoleScreenBufferW(
            h_console_output,
            lp_scroll_rectangle,
            lp_clip_rectangle,
            dw_destination_origin,
            lp_fill,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleActiveScreenBuffer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleActiveScreenBuffer(h_console_output);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_code_page_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleCP(w_code_page_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCtrlHandler(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handler_routine = call.get_arg();
        let add = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleCtrlHandler(handler_routine, add);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCursorInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_cursor_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleCursorInfo(h_console_output, lp_console_cursor_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCursorPosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let dw_cursor_position = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleCursorPosition(h_console_output, dw_cursor_position);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleDisplayMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_new_screen_buffer_dimensions = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetConsoleDisplayMode(h_console_output, dw_flags, lp_new_screen_buffer_dimensions);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleHistoryInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_history_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleHistoryInfo(lp_console_history_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_handle = call.get_arg();
        let dw_mode = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleMode(h_console_handle, dw_mode);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleNumberOfCommandsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let number = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleNumberOfCommandsA(number, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleNumberOfCommandsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let number = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleNumberOfCommandsW(number, exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleOutputCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_code_page_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleOutputCP(w_code_page_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleScreenBufferInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_screen_buffer_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetConsoleScreenBufferInfoEx(h_console_output, lp_console_screen_buffer_info_ex);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleScreenBufferSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleScreenBufferSize(h_console_output, dw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTextAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let w_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleTextAttribute(h_console_output, w_attributes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleTitleA(lp_console_title);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleTitleW(lp_console_title);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleWindowInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_absolute = call.get_arg();
        let lp_console_window = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetConsoleWindowInfo(h_console_output, b_absolute, lp_console_window);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCurrentConsoleFontEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_maximum_window = call.get_arg();
        let lp_console_current_font_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCurrentConsoleFontEx(
            h_console_output,
            b_maximum_window,
            lp_console_current_font_ex,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetStdHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_std_handle = call.get_arg();
        let h_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetStdHandle(n_std_handle, h_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetStdHandleEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_std_handle = call.get_arg();
        let h_handle = call.get_arg();
        let ph_prev_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetStdHandleEx(n_std_handle, h_handle, ph_prev_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_write = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleA(
            h_console_output,
            lp_buffer,
            n_number_of_chars_to_write,
            lp_number_of_chars_written,
            lp_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleInputA(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleInputW(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_write_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleOutputA(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_write_region,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_attribute = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_attrs_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleOutputAttribute(
            h_console_output,
            lp_attribute,
            n_length,
            dw_write_coord,
            lp_number_of_attrs_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleOutputCharacterA(
            h_console_output,
            lp_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleOutputCharacterW(
            h_console_output,
            lp_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_write_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleOutputW(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_write_region,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_write = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteConsoleW(
            h_console_output,
            lp_buffer,
            n_number_of_chars_to_write,
            lp_number_of_chars_written,
            lp_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnwind(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Diagnostics::Debug::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let target_frame = call.get_arg();
        let target_ip = call.get_arg();
        let exception_record = call.get_arg();
        let return_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlUnwind(target_frame, target_ip, exception_record, return_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnhandledExceptionFilter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Diagnostics::Debug::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exception_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnhandledExceptionFilter(exception_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_routine = call.get_arg();
        let lp_parameter = call.get_arg();
        let f_wait_for_thread = call.get_arg();
        let lp_return_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CallEnclave(lp_routine, lp_parameter, f_wait_for_thread, lp_return_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let dw_initial_commitment = call.get_arg();
        let fl_enclave_type = call.get_arg();
        let lp_enclave_information = call.get_arg();
        let dw_info_length = call.get_arg();
        let lp_enclave_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateEnclave(
            h_process,
            lp_address,
            dw_size,
            dw_initial_commitment,
            fl_enclave_type,
            lp_enclave_information,
            dw_info_length,
            lp_enclave_error,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateEnvironmentBlock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_environment = call.get_arg();
        let h_token = call.get_arg();
        let b_inherit = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateEnvironmentBlock(lp_environment, h_token, b_inherit);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteEnclave(lp_address);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyEnvironmentBlock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_environment = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DestroyEnvironmentBlock(lp_environment);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveGetAttestationReport(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enclave_data = call.get_arg();
        let report = call.get_arg();
        let buffer_size = call.get_arg();
        let output_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnclaveGetAttestationReport(enclave_data, report, buffer_size, output_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveGetEnclaveInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let information_size = call.get_arg();
        let enclave_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnclaveGetEnclaveInformation(information_size, enclave_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveSealData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let data_to_encrypt = call.get_arg();
        let data_to_encrypt_size = call.get_arg();
        let identity_policy = call.get_arg();
        let runtime_policy = call.get_arg();
        let protected_blob = call.get_arg();
        let buffer_size = call.get_arg();
        let protected_blob_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnclaveSealData(
            data_to_encrypt,
            data_to_encrypt_size,
            identity_policy,
            runtime_policy,
            protected_blob,
            buffer_size,
            protected_blob_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveUnsealData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let protected_blob = call.get_arg();
        let protected_blob_size = call.get_arg();
        let decrypted_data = call.get_arg();
        let buffer_size = call.get_arg();
        let decrypted_data_size = call.get_arg();
        let sealing_identity = call.get_arg();
        let unsealing_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnclaveUnsealData(
            protected_blob,
            protected_blob_size,
            decrypted_data,
            buffer_size,
            decrypted_data_size,
            sealing_identity,
            unsealing_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveVerifyAttestationReport(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enclave_type = call.get_arg();
        let report = call.get_arg();
        let report_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnclaveVerifyAttestationReport(enclave_type, report, report_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_src = call.get_arg();
        let lp_dst = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExpandEnvironmentStringsA(lp_src, lp_dst, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsForUserA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_token = call.get_arg();
        let lp_src = call.get_arg();
        let lp_dest = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExpandEnvironmentStringsForUserA(h_token, lp_src, lp_dest, dw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsForUserW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_token = call.get_arg();
        let lp_src = call.get_arg();
        let lp_dest = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExpandEnvironmentStringsForUserW(h_token, lp_src, lp_dest, dw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_src = call.get_arg();
        let lp_dst = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExpandEnvironmentStringsW(lp_src, lp_dst, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let penv = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeEnvironmentStringsA(penv);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let penv = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeEnvironmentStringsW(penv);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCommandLineA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCommandLineA();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCommandLineW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCommandLineW();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentDirectoryA(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentDirectoryW(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentStrings(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetEnvironmentStrings();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetEnvironmentStringsW();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetEnvironmentVariableA(lp_name, lp_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetEnvironmentVariableW(lp_name, lp_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeEnclave(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let lp_enclave_information = call.get_arg();
        let dw_info_length = call.get_arg();
        let lp_enclave_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeEnclave(
            h_process,
            lp_address,
            lp_enclave_information,
            dw_info_length,
            lp_enclave_error,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsEnclaveTypeSupported(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let fl_enclave_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsEnclaveTypeSupported(fl_enclave_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let fl_protect = call.get_arg();
        let lp_page_information = call.get_arg();
        let dw_info_length = call.get_arg();
        let lp_number_of_bytes_written = call.get_arg();
        let lp_enclave_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadEnclaveData(
            h_process,
            lp_address,
            lp_buffer,
            n_size,
            fl_protect,
            lp_page_information,
            dw_info_length,
            lp_number_of_bytes_written,
            lp_enclave_error,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveImageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_enclave_address = call.get_arg();
        let lp_image_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadEnclaveImageA(lp_enclave_address, lp_image_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveImageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_enclave_address = call.get_arg();
        let lp_image_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadEnclaveImageW(lp_enclave_address, lp_image_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedCurrentDirectoryForExePathA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NeedCurrentDirectoryForExePathA(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedCurrentDirectoryForExePathW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NeedCurrentDirectoryForExePathW(exe_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCurrentDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCurrentDirectoryA(lp_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCurrentDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCurrentDirectoryW(lp_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let new_environment = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEnvironmentStringsW(new_environment);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEnvironmentVariableA(lp_name, lp_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEnvironmentVariableW(lp_name, lp_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TerminateEnclave(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let f_wait = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TerminateEnclave(lp_address, f_wait);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BindIoCompletionCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let function = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BindIoCompletionCallback(file_handle, function, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelIo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CancelIo(h_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelIoEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CancelIoEx(h_file, lp_overlapped);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelSynchronousIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CancelSynchronousIo(h_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIoCompletionPort(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let existing_completion_port = call.get_arg();
        let completion_key = call.get_arg();
        let number_of_concurrent_threads = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateIoCompletionPort(
            file_handle,
            existing_completion_port,
            completion_key,
            number_of_concurrent_threads,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeviceIoControl(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_io_control_code = call.get_arg();
        let lp_in_buffer = call.get_arg();
        let n_in_buffer_size = call.get_arg();
        let lp_out_buffer = call.get_arg();
        let n_out_buffer_size = call.get_arg();
        let lp_bytes_returned = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeviceIoControl(
            h_device,
            dw_io_control_code,
            lp_in_buffer,
            n_in_buffer_size,
            lp_out_buffer,
            n_out_buffer_size,
            lp_bytes_returned,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOverlappedResult(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_number_of_bytes_transferred = call.get_arg();
        let b_wait = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetOverlappedResult(
            h_file,
            lp_overlapped,
            lp_number_of_bytes_transferred,
            b_wait,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOverlappedResultEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_number_of_bytes_transferred = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetOverlappedResultEx(
            h_file,
            lp_overlapped,
            lp_number_of_bytes_transferred,
            dw_milliseconds,
            b_alertable,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetQueuedCompletionStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let completion_port = call.get_arg();
        let lp_number_of_bytes_transferred = call.get_arg();
        let lp_completion_key = call.get_arg();
        let lp_overlapped = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetQueuedCompletionStatus(
            completion_port,
            lp_number_of_bytes_transferred,
            lp_completion_key,
            lp_overlapped,
            dw_milliseconds,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetQueuedCompletionStatusEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let completion_port = call.get_arg();
        let lp_completion_port_entries = call.get_arg();
        let ul_count = call.get_arg();
        let ul_num_entries_removed = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let f_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetQueuedCompletionStatusEx(
            completion_port,
            lp_completion_port_entries,
            ul_count,
            ul_num_entries_removed,
            dw_milliseconds,
            f_alertable,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostQueuedCompletionStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let completion_port = call.get_arg();
        let dw_number_of_bytes_transferred = call.get_arg();
        let dw_completion_key = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PostQueuedCompletionStatus(
            completion_port,
            dw_number_of_bytes_transferred,
            dw_completion_key,
            lp_overlapped,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFirstEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlFirstEntrySList(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitializeSListHead(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInitializeSListHead(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedFlushSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInterlockedFlushSList(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPopEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInterlockedPopEntrySList(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPushEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list_entry = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInterlockedPushEntrySList(list_head, list_entry);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPushListSListEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list = call.get_arg();
        let list_end = call.get_arg();
        let count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInterlockedPushListSListEx(list_head, list, list_end, count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlQueryDepthSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlQueryDepthSList(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddDllDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let new_directory = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AddDllDirectory(new_directory);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BeginUpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_file_name = call.get_arg();
        let b_delete_existing_resources = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BeginUpdateResourceA(p_file_name, b_delete_existing_resources);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BeginUpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_file_name = call.get_arg();
        let b_delete_existing_resources = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BeginUpdateResourceW(p_file_name, b_delete_existing_resources);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DisableThreadLibraryCalls(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_lib_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DisableThreadLibraryCalls(h_lib_module);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndUpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let f_discard = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EndUpdateResourceA(h_update, f_discard);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndUpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let f_discard = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EndUpdateResourceW(h_update, f_discard);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceLanguagesA(h_module, lp_type, lp_name, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceLanguagesExA(
            h_module,
            lp_type,
            lp_name,
            lp_enum_func,
            l_param,
            dw_flags,
            lang_id,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceLanguagesExW(
            h_module,
            lp_type,
            lp_name,
            lp_enum_func,
            l_param,
            dw_flags,
            lang_id,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceLanguagesW(h_module, lp_type, lp_name, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceNamesA(h_module, lp_type, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.EnumResourceNamesExA(h_module, lp_type, lp_enum_func, l_param, dw_flags, lang_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.EnumResourceNamesExW(h_module, lp_type, lp_enum_func, l_param, dw_flags, lang_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceNamesW(h_module, lp_type, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceTypesA(h_module, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceTypesExA(h_module, lp_enum_func, l_param, dw_flags, lang_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceTypesExW(h_module, lp_enum_func, l_param, dw_flags, lang_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumResourceTypesW(h_module, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_name = call.get_arg();
        let lp_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindResourceA(h_module, lp_name, lp_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindResourceExA(h_module, lp_type, lp_name, w_language);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindResourceExW(h_module, lp_type, lp_name, w_language);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_name = call.get_arg();
        let lp_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindResourceW(h_module, lp_name, lp_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeLibrary(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_lib_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeLibrary(h_lib_module);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeLibraryAndExitThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_lib_module = call.get_arg();
        let dw_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeLibraryAndExitThread(h_lib_module, dw_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_res_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeResource(h_res_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDllDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDllDirectoryA(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDllDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDllDirectoryW(n_buffer_length, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_filename = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetModuleFileNameA(h_module, lp_filename, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_filename = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetModuleFileNameW(h_module, lp_filename, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_module_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetModuleHandleA(lp_module_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_module_name = call.get_arg();
        let ph_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetModuleHandleExA(dw_flags, lp_module_name, ph_module);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_module_name = call.get_arg();
        let ph_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetModuleHandleExW(dw_flags, lp_module_name, ph_module);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_module_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetModuleHandleW(lp_module_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcAddress(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_proc_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcAddress(h_module, lp_proc_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadLibraryA(lp_lib_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let h_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadLibraryExA(lp_lib_file_name, h_file, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let h_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadLibraryExW(lp_lib_file_name, h_file, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadLibraryW(lp_lib_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadModule(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_module_name = call.get_arg();
        let lp_parameter_block = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadModule(lp_module_name, lp_parameter_block);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadPackagedLibrary(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpw_lib_file_name = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadPackagedLibrary(lpw_lib_file_name, reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let h_res_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadResource(h_module, h_res_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LockResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_res_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LockResource(h_res_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDllDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let cookie = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveDllDirectory(cookie);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDefaultDllDirectories(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let directory_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetDefaultDllDirectories(directory_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDllDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetDllDirectoryA(lp_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDllDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetDllDirectoryW(lp_path_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SizeofResource(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let h_res_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SizeofResource(h_module, h_res_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let lp_data = call.get_arg();
        let cb = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UpdateResourceA(h_update, lp_type, lp_name, w_language, lp_data, cb);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let lp_data = call.get_arg();
        let cb = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UpdateResourceW(h_update, lp_type, lp_name, w_language, lp_data, cb);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddSecureMemoryCacheCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfn_call_back = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AddSecureMemoryCacheCallback(pfn_call_back);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AllocateUserPhysicalPages(h_process, number_of_pages, page_array);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPages2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let object_handle = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let extended_parameters = call.get_arg();
        let extended_parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AllocateUserPhysicalPages2(
            object_handle,
            number_of_pages,
            page_array,
            extended_parameters,
            extended_parameter_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPagesNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let nnd_preferred = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AllocateUserPhysicalPagesNuma(
            h_process,
            number_of_pages,
            page_array,
            nnd_preferred,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMemoryResourceNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let notification_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateMemoryResourceNotification(notification_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DiscardVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DiscardVirtualMemory(virtual_address, size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushViewOfFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_base_address = call.get_arg();
        let dw_number_of_bytes_to_flush = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlushViewOfFile(lp_base_address, dw_number_of_bytes_to_flush);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeUserPhysicalPages(h_process, number_of_pages, page_array);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLargePageMinimum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetLargePageMinimum();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMemoryErrorHandlingCapabilities(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let capabilities = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMemoryErrorHandlingCapabilities(capabilities);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessHeap(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetProcessHeap();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessHeaps(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let number_of_heaps = call.get_arg();
        let process_heaps = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessHeaps(number_of_heaps, process_heaps);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessWorkingSetSizeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_minimum_working_set_size = call.get_arg();
        let lp_maximum_working_set_size = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessWorkingSetSizeEx(
            h_process,
            lp_minimum_working_set_size,
            lp_maximum_working_set_size,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemFileCacheSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_minimum_file_cache_size = call.get_arg();
        let lp_maximum_file_cache_size = call.get_arg();
        let lp_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemFileCacheSize(
            lp_minimum_file_cache_size,
            lp_maximum_file_cache_size,
            lp_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWriteWatch(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_base_address = call.get_arg();
        let dw_region_size = call.get_arg();
        let lp_addresses = call.get_arg();
        let lpdw_count = call.get_arg();
        let lpdw_granularity = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWriteWatch(
            dw_flags,
            lp_base_address,
            dw_region_size,
            lp_addresses,
            lpdw_count,
            lpdw_granularity,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let dw_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalAlloc(u_flags, dw_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalFlags(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalFlags(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalFree(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalHandle(p_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalLock(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let dw_bytes = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalReAlloc(h_mem, dw_bytes, u_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalSize(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalUnlock(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let dw_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapAlloc(h_heap, dw_flags, dw_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapCompact(h_heap, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapCreate(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let fl_options = call.get_arg();
        let dw_initial_size = call.get_arg();
        let dw_maximum_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapCreate(fl_options, dw_initial_size, dw_maximum_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapDestroy(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapDestroy(h_heap);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapFree(h_heap, dw_flags, lp_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapLock(h_heap);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapQueryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let heap_handle = call.get_arg();
        let heap_information_class = call.get_arg();
        let heap_information = call.get_arg();
        let heap_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapQueryInformation(
            heap_handle,
            heap_information_class,
            heap_information,
            heap_information_length,
            return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let dw_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapReAlloc(h_heap, dw_flags, lp_mem, dw_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapSetInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let heap_handle = call.get_arg();
        let heap_information_class = call.get_arg();
        let heap_information = call.get_arg();
        let heap_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapSetInformation(
            heap_handle,
            heap_information_class,
            heap_information,
            heap_information_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapSize(h_heap, dw_flags, lp_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapSummary(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_summary = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapSummary(h_heap, dw_flags, lp_summary);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapUnlock(h_heap);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapValidate(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapValidate(h_heap, dw_flags, lp_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapWalk(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let lp_entry = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HeapWalk(h_heap, lp_entry);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadCodePtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpfn = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsBadCodePtr(lpfn);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadReadPtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsBadReadPtr(lp, ucb);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadStringPtrA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsBadStringPtrA(lpsz, ucch_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadStringPtrW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsBadStringPtrW(lpsz, ucch_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadWritePtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsBadWritePtr(lp, ucb);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let u_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalAlloc(u_flags, u_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalFlags(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalFlags(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalFree(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalHandle(p_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalLock(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let u_bytes = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalReAlloc(h_mem, u_bytes, u_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalSize(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalUnlock(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapUserPhysicalPages(virtual_address, number_of_pages, page_array);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapUserPhysicalPagesScatter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_addresses = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapUserPhysicalPagesScatter(virtual_addresses, number_of_pages, page_array);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_number_of_bytes_to_map = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapViewOfFile(
            h_file_mapping_object,
            dw_desired_access,
            dw_file_offset_high,
            dw_file_offset_low,
            dw_number_of_bytes_to_map,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile3(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_mapping = call.get_arg();
        let process = call.get_arg();
        let base_address = call.get_arg();
        let offset = call.get_arg();
        let view_size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapViewOfFile3(
            file_mapping,
            process,
            base_address,
            offset,
            view_size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile3FromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_mapping = call.get_arg();
        let process = call.get_arg();
        let base_address = call.get_arg();
        let offset = call.get_arg();
        let view_size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapViewOfFile3FromApp(
            file_mapping,
            process,
            base_address,
            offset,
            view_size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_number_of_bytes_to_map = call.get_arg();
        let lp_base_address = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapViewOfFileEx(
            h_file_mapping_object,
            dw_desired_access,
            dw_file_offset_high,
            dw_file_offset_low,
            dw_number_of_bytes_to_map,
            lp_base_address,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileExNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_number_of_bytes_to_map = call.get_arg();
        let lp_base_address = call.get_arg();
        let nnd_preferred = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapViewOfFileExNuma(
            h_file_mapping_object,
            dw_desired_access,
            dw_file_offset_high,
            dw_file_offset_low,
            dw_number_of_bytes_to_map,
            lp_base_address,
            nnd_preferred,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let desired_access = call.get_arg();
        let file_offset = call.get_arg();
        let number_of_bytes_to_map = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapViewOfFileFromApp(
            h_file_mapping_object,
            desired_access,
            file_offset,
            number_of_bytes_to_map,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileNuma2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_mapping_handle = call.get_arg();
        let process_handle = call.get_arg();
        let offset = call.get_arg();
        let base_address = call.get_arg();
        let view_size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let preferred_node = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapViewOfFileNuma2(
            file_mapping_handle,
            process_handle,
            offset,
            base_address,
            view_size,
            allocation_type,
            page_protection,
            preferred_node,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OfferVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let size = call.get_arg();
        let priority = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OfferVirtualMemory(virtual_address, size, priority);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenDedicatedMemoryPartition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let partition = call.get_arg();
        let dedicated_memory_type_id = call.get_arg();
        let desired_access = call.get_arg();
        let inherit_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenDedicatedMemoryPartition(
            partition,
            dedicated_memory_type_id,
            desired_access,
            inherit_handle,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenFileMappingA(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let desired_access = call.get_arg();
        let inherit_handle = call.get_arg();
        let name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenFileMappingFromApp(desired_access, inherit_handle, name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenFileMappingW(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrefetchVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_entries = call.get_arg();
        let virtual_addresses = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrefetchVirtualMemory(h_process, number_of_entries, virtual_addresses, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryMemoryResourceNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_notification_handle = call.get_arg();
        let resource_state = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryMemoryResourceNotification(resource_notification_handle, resource_state);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryPartitionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let partition = call.get_arg();
        let partition_information_class = call.get_arg();
        let partition_information = call.get_arg();
        let partition_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryPartitionInformation(
            partition,
            partition_information_class,
            partition_information,
            partition_information_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryVirtualMemoryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let virtual_address = call.get_arg();
        let memory_information_class = call.get_arg();
        let memory_information = call.get_arg();
        let memory_information_size = call.get_arg();
        let return_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryVirtualMemoryInformation(
            process,
            virtual_address,
            memory_information_class,
            memory_information,
            memory_information_size,
            return_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReclaimVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReclaimVirtualMemory(virtual_address, size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterBadMemoryNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let callback = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RegisterBadMemoryNotification(callback);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveSecureMemoryCacheCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfn_call_back = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveSecureMemoryCacheCallback(pfn_call_back);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResetWriteWatch(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_base_address = call.get_arg();
        let dw_region_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ResetWriteWatch(lp_base_address, dw_region_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCompareMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source_1 = call.get_arg();
        let source_2 = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlCompareMemory(source_1, source_2, length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCrc32(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let size = call.get_arg();
        let initial_crc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlCrc32(buffer, size, initial_crc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCrc64(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let size = call.get_arg();
        let initial_crc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlCrc64(buffer, size, initial_crc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlIsZeroMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlIsZeroMemory(buffer, length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessValidCallTargets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let virtual_address = call.get_arg();
        let region_size = call.get_arg();
        let number_of_offsets = call.get_arg();
        let offset_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessValidCallTargets(
            h_process,
            virtual_address,
            region_size,
            number_of_offsets,
            offset_information,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessValidCallTargetsForMappedView(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let virtual_address = call.get_arg();
        let region_size = call.get_arg();
        let number_of_offsets = call.get_arg();
        let offset_information = call.get_arg();
        let section = call.get_arg();
        let expected_file_offset = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessValidCallTargetsForMappedView(
            process,
            virtual_address,
            region_size,
            number_of_offsets,
            offset_information,
            section,
            expected_file_offset,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessWorkingSetSizeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_minimum_working_set_size = call.get_arg();
        let dw_maximum_working_set_size = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessWorkingSetSizeEx(
            h_process,
            dw_minimum_working_set_size,
            dw_maximum_working_set_size,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemFileCacheSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let minimum_file_cache_size = call.get_arg();
        let maximum_file_cache_size = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetSystemFileCacheSize(minimum_file_cache_size, maximum_file_cache_size, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_base_address = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnmapViewOfFile(lp_base_address);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFile2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let base_address = call.get_arg();
        let unmap_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnmapViewOfFile2(process, base_address, unmap_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFileEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let base_address = call.get_arg();
        let unmap_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnmapViewOfFileEx(base_address, unmap_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterBadMemoryNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let registration_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnregisterBadMemoryNotification(registration_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_allocation_type = call.get_arg();
        let fl_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualAlloc(lp_address, dw_size, fl_allocation_type, fl_protect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let base_address = call.get_arg();
        let size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualAlloc2(
            process,
            base_address,
            size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc2FromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let base_address = call.get_arg();
        let size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualAlloc2FromApp(
            process,
            base_address,
            size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_allocation_type = call.get_arg();
        let fl_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualAllocEx(
            h_process,
            lp_address,
            dw_size,
            fl_allocation_type,
            fl_protect,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocExNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_allocation_type = call.get_arg();
        let fl_protect = call.get_arg();
        let nnd_preferred = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualAllocExNuma(
            h_process,
            lp_address,
            dw_size,
            fl_allocation_type,
            fl_protect,
            nnd_preferred,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let base_address = call.get_arg();
        let size = call.get_arg();
        let allocation_type = call.get_arg();
        let protection = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualAllocFromApp(base_address, size, allocation_type, protection);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let dw_free_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualFree(lp_address, dw_size, dw_free_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualFreeEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let dw_free_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualFreeEx(h_process, lp_address, dw_size, dw_free_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualLock(lp_address, dw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualProtect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_new_protect = call.get_arg();
        let lpfl_old_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualProtect(lp_address, dw_size, fl_new_protect, lpfl_old_protect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualProtectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_new_protect = call.get_arg();
        let lpfl_old_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualProtectEx(
            h_process,
            lp_address,
            dw_size,
            fl_new_protect,
            lpfl_old_protect,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualProtectFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let size = call.get_arg();
        let new_protection = call.get_arg();
        let old_protection = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualProtectFromApp(address, size, new_protection, old_protection);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualQuery(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualQuery(lp_address, lp_buffer, dw_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualQueryEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualQueryEx(h_process, lp_address, lp_buffer, dw_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualUnlock(lp_address, dw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualUnlockEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let address = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VirtualUnlockEx(process, address, size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetComputerNameExA(name_type, lp_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetComputerNameExW(name_type, lp_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocalTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLocalTime(lp_system_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalProcessorInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let returned_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLogicalProcessorInformation(buffer, returned_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalProcessorInformationEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let relationship_type = call.get_arg();
        let buffer = call.get_arg();
        let returned_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLogicalProcessorInformationEx(relationship_type, buffer, returned_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNativeSystemInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNativeSystemInfo(lp_system_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOsManufacturingMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pb_enabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetOsManufacturingMode(pb_enabled);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOsSafeBootMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetOsSafeBootMode(flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPhysicallyInstalledSystemMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let total_memory_in_kilobytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPhysicallyInstalledSystemMemory(total_memory_in_kilobytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessorSystemCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group = call.get_arg();
        let buffer = call.get_arg();
        let returned_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessorSystemCycleTime(group, buffer, returned_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProductInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_os_major_version = call.get_arg();
        let dw_os_minor_version = call.get_arg();
        let dw_sp_major_version = call.get_arg();
        let dw_sp_minor_version = call.get_arg();
        let pdw_returned_product_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProductInfo(
            dw_os_major_version,
            dw_os_minor_version,
            dw_sp_major_version,
            dw_sp_minor_version,
            pdw_returned_product_type,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemCpuSetInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let information = call.get_arg();
        let buffer_length = call.get_arg();
        let returned_length = call.get_arg();
        let process = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemCpuSetInformation(
            information,
            buffer_length,
            returned_length,
            process,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetSystemDEPPolicy();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemDirectoryA(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemDirectoryW(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemFirmwareTable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let firmware_table_provider_signature = call.get_arg();
        let firmware_table_id = call.get_arg();
        let p_firmware_table_buffer = call.get_arg();
        let buffer_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemFirmwareTable(
            firmware_table_provider_signature,
            firmware_table_id,
            p_firmware_table_buffer,
            buffer_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemInfo(lp_system_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemLeapSecondInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enabled = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemLeapSecondInformation(enabled, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemTime(lp_system_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAdjustment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_adjustment = call.get_arg();
        let lp_time_increment = call.get_arg();
        let lp_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemTimeAdjustment(
            lp_time_adjustment,
            lp_time_increment,
            lp_time_adjustment_disabled,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAdjustmentPrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_adjustment = call.get_arg();
        let lp_time_increment = call.get_arg();
        let lp_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemTimeAdjustmentPrecise(
            lp_time_adjustment,
            lp_time_increment,
            lp_time_adjustment_disabled,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAsFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time_as_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemTimeAsFileTime(lp_system_time_as_file_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimePreciseAsFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time_as_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemTimePreciseAsFileTime(lp_system_time_as_file_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWindowsDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemWindowsDirectoryA(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWindowsDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemWindowsDirectoryW(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64Directory2A(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let image_file_machine_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemWow64Directory2A(lp_buffer, u_size, image_file_machine_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64Directory2W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let image_file_machine_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemWow64Directory2W(lp_buffer, u_size, image_file_machine_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64DirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemWow64DirectoryA(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64DirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemWow64DirectoryW(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTickCount(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetTickCount();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTickCount64(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetTickCount64();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersion(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetVersion();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVersionExA(lp_version_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVersionExW(lp_version_information);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowsDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowsDirectoryA(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowsDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowsDirectoryW(lp_buffer, u_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalMemoryStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalMemoryStatus(lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalMemoryStatusEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalMemoryStatusEx(lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlConvertDeviceFamilyInfoToString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pul_device_family_buffer_size = call.get_arg();
        let pul_device_form_buffer_size = call.get_arg();
        let device_family = call.get_arg();
        let device_form = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlConvertDeviceFamilyInfoToString(
            pul_device_family_buffer_size,
            pul_device_form_buffer_size,
            device_family,
            device_form,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetDeviceFamilyInfoEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pull_uap_info = call.get_arg();
        let pul_device_family = call.get_arg();
        let pul_device_form = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlGetDeviceFamilyInfoEnum(pull_uap_info, pul_device_family, pul_device_form);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetProductInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let os_major_version = call.get_arg();
        let os_minor_version = call.get_arg();
        let sp_major_version = call.get_arg();
        let sp_minor_version = call.get_arg();
        let returned_product_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlGetProductInfo(
            os_major_version,
            os_minor_version,
            sp_major_version,
            sp_minor_version,
            returned_product_type,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetSystemGlobalData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let data_id = call.get_arg();
        let buffer = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlGetSystemGlobalData(data_id, buffer, size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlOsDeploymentState(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlOsDeploymentState(flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlSwitchedVVI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let version_info = call.get_arg();
        let type_mask = call.get_arg();
        let condition_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlSwitchedVVI(version_info, type_mask, condition_mask);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_computer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetComputerNameA(lp_computer_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameEx2W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let flags = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetComputerNameEx2W(name_type, flags, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetComputerNameExA(name_type, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetComputerNameExW(name_type, lp_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_computer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetComputerNameW(lp_computer_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLocalTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetLocalTime(lp_system_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetSystemTime(lp_system_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemTimeAdjustment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_time_adjustment = call.get_arg();
        let b_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetSystemTimeAdjustment(dw_time_adjustment, b_time_adjustment_disabled);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemTimeAdjustmentPrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_time_adjustment = call.get_arg();
        let b_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetSystemTimeAdjustmentPrecise(dw_time_adjustment, b_time_adjustment_disabled);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerSetConditionMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_mask = call.get_arg();
        let type_mask = call.get_arg();
        let condition = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerSetConditionMask(condition_mask, type_mask, condition);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerifyVersionInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let dw_type_mask = call.get_arg();
        let dwl_condition_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerifyVersionInfoA(lp_version_information, dw_type_mask, dwl_condition_mask);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerifyVersionInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let dw_type_mask = call.get_arg();
        let dwl_condition_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.VerifyVersionInfoW(lp_version_information, dw_type_mask, dwl_condition_mask);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AcquireSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AcquireSRWLockExclusive(srw_lock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AcquireSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AcquireSRWLockShared(srw_lock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddIntegrityLabelToBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let boundary_descriptor = call.get_arg();
        let integrity_label = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AddIntegrityLabelToBoundaryDescriptor(boundary_descriptor, integrity_label);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddSIDToBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let boundary_descriptor = call.get_arg();
        let required_sid = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AddSIDToBoundaryDescriptor(boundary_descriptor, required_sid);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AttachThreadInput(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_attach = call.get_arg();
        let id_attach_to = call.get_arg();
        let f_attach = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AttachThreadInput(id_attach, id_attach_to, f_attach);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvQuerySystemResponsiveness(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let avrt_handle = call.get_arg();
        let system_responsiveness_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvQuerySystemResponsiveness(avrt_handle, system_responsiveness_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRevertMmThreadCharacteristics(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let avrt_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRevertMmThreadCharacteristics(avrt_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let period = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let timeout = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRtCreateThreadOrderingGroup(context, period, thread_ordering_guid, timeout);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroupExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let period = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let timeout = call.get_arg();
        let task_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRtCreateThreadOrderingGroupExA(
            context,
            period,
            thread_ordering_guid,
            timeout,
            task_name,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroupExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let period = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let timeout = call.get_arg();
        let task_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRtCreateThreadOrderingGroupExW(
            context,
            period,
            thread_ordering_guid,
            timeout,
            task_name,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtDeleteThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRtDeleteThreadOrderingGroup(context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtJoinThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let before = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRtJoinThreadOrderingGroup(context, thread_ordering_guid, before);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtLeaveThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRtLeaveThreadOrderingGroup(context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtWaitOnThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvRtWaitOnThreadOrderingGroup(context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmMaxThreadCharacteristicsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let first_task = call.get_arg();
        let second_task = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvSetMmMaxThreadCharacteristicsA(first_task, second_task, task_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmMaxThreadCharacteristicsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let first_task = call.get_arg();
        let second_task = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvSetMmMaxThreadCharacteristicsW(first_task, second_task, task_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadCharacteristicsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let task_name = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvSetMmThreadCharacteristicsA(task_name, task_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadCharacteristicsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let task_name = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvSetMmThreadCharacteristicsW(task_name, task_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let avrt_handle = call.get_arg();
        let priority = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AvSetMmThreadPriority(avrt_handle, priority);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallbackMayRunLong(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CallbackMayRunLong(pci);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CancelThreadpoolIo(pio);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelWaitableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_timer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CancelWaitableTimer(h_timer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let timer = call.get_arg();
        let due_time = call.get_arg();
        let period = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ChangeTimerQueueTimer(timer_queue, timer, due_time, period);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ClosePrivateNamespace(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ClosePrivateNamespace(handle, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpool(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseThreadpool(ptpp);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolCleanupGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpcg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseThreadpoolCleanupGroup(ptpcg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolCleanupGroupMembers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpcg = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let pv_cleanup_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseThreadpoolCleanupGroupMembers(
            ptpcg,
            f_cancel_pending_callbacks,
            pv_cleanup_context,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseThreadpoolIo(pio);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseThreadpoolTimer(pti);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseThreadpoolWait(pwa);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwk = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseThreadpoolWork(pwk);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertFiberToThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.ConvertFiberToThread();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertThreadToFiber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_parameter = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ConvertThreadToFiber(lp_parameter);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertThreadToFiberEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_parameter = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ConvertThreadToFiberEx(lp_parameter, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateBoundaryDescriptorA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateBoundaryDescriptorA(name, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateBoundaryDescriptorW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateBoundaryDescriptorW(name, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_stack_size = call.get_arg();
        let lp_start_address = call.get_arg();
        let lp_parameter = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateFiber(dw_stack_size, lp_start_address, lp_parameter);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateFiberEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_stack_commit_size = call.get_arg();
        let dw_stack_reserve_size = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_start_address = call.get_arg();
        let lp_parameter = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateFiberEx(
            dw_stack_commit_size,
            dw_stack_reserve_size,
            dw_flags,
            lp_start_address,
            lp_parameter,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateProcessWithLogonW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_username = call.get_arg();
        let lp_domain = call.get_arg();
        let lp_password = call.get_arg();
        let dw_logon_flags = call.get_arg();
        let lp_application_name = call.get_arg();
        let lp_command_line = call.get_arg();
        let dw_creation_flags = call.get_arg();
        let lp_environment = call.get_arg();
        let lp_current_directory = call.get_arg();
        let lp_startup_info = call.get_arg();
        let lp_process_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateProcessWithLogonW(
            lp_username,
            lp_domain,
            lp_password,
            dw_logon_flags,
            lp_application_name,
            lp_command_line,
            dw_creation_flags,
            lp_environment,
            lp_current_directory,
            lp_startup_info,
            lp_process_information,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateProcessWithTokenW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_token = call.get_arg();
        let dw_logon_flags = call.get_arg();
        let lp_application_name = call.get_arg();
        let lp_command_line = call.get_arg();
        let dw_creation_flags = call.get_arg();
        let lp_environment = call.get_arg();
        let lp_current_directory = call.get_arg();
        let lp_startup_info = call.get_arg();
        let lp_process_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateProcessWithTokenW(
            h_token,
            dw_logon_flags,
            lp_application_name,
            lp_command_line,
            dw_creation_flags,
            lp_environment,
            lp_current_directory,
            lp_startup_info,
            lp_process_information,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpool(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateThreadpool(reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolCleanupGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.CreateThreadpoolCleanupGroup();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let fl = call.get_arg();
        let pfnio = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateThreadpoolIo(fl, pfnio, pv, pcbe);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfnti = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateThreadpoolTimer(pfnti, pv, pcbe);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfnwa = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateThreadpoolWait(pfnwa, pv, pcbe);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfnwk = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateThreadpoolWork(pfnwk, pv, pcbe);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateTimerQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.CreateTimerQueue();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ph_new_timer = call.get_arg();
        let timer_queue = call.get_arg();
        let callback = call.get_arg();
        let parameter = call.get_arg();
        let due_time = call.get_arg();
        let period = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateTimerQueueTimer(
            ph_new_timer,
            timer_queue,
            callback,
            parameter,
            due_time,
            period,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateUmsCompletionList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateUmsCompletionList(ums_completion_list);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateUmsThreadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_ums_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateUmsThreadContext(lp_ums_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let boundary_descriptor = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteBoundaryDescriptor(boundary_descriptor);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteCriticalSection(lp_critical_section);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_fiber = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteFiber(lp_fiber);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteProcThreadAttributeList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_attribute_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteProcThreadAttributeList(lp_attribute_list);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_barrier = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteSynchronizationBarrier(lp_barrier);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteTimerQueue(timer_queue);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueueEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteTimerQueueEx(timer_queue, completion_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let timer = call.get_arg();
        let completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteTimerQueueTimer(timer_queue, timer, completion_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteUmsCompletionList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteUmsCompletionList(ums_completion_list);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteUmsThreadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteUmsThreadContext(ums_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DequeueUmsCompletionListItems(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let wait_time_out = call.get_arg();
        let ums_thread_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.DequeueUmsCompletionListItems(ums_completion_list, wait_time_out, ums_thread_list);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DisassociateCurrentThreadFromCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DisassociateCurrentThreadFromCallback(pci);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnterCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnterCriticalSection(lp_critical_section);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnterSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_barrier = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnterSynchronizationBarrier(lp_barrier, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExecuteUmsThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExecuteUmsThread(ums_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExitProcess(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExitProcess(unwind_token, u_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExitThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExitThread(unwind_token, dw_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_callback = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlsAlloc(lp_callback);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_fls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlsFree(dw_fls_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsGetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_fls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlsGetValue(dw_fls_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsSetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_fls_index = call.get_arg();
        let lp_fls_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlsSetValue(dw_fls_index, lp_fls_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushProcessWriteBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.FlushProcessWriteBuffers();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeLibraryWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let r#mod = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FreeLibraryWhenCallbackReturns(pci, r#mod);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetActiveProcessorCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetActiveProcessorCount(group_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetActiveProcessorGroupCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetActiveProcessorGroupCount();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentProcess();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentProcessId();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessorNumber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentProcessorNumber();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessorNumberEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let proc_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentProcessorNumberEx(proc_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentThread();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThreadId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentThreadId();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThreadStackLimits(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let low_limit = call.get_arg();
        let high_limit = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentThreadStackLimits(low_limit, high_limit);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentUmsThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentUmsThread();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExitCodeProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetExitCodeProcess(h_process, lp_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExitCodeThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetExitCodeThread(h_thread, lp_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGuiResources(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let ui_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetGuiResources(h_process, ui_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMachineTypeAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let machine = call.get_arg();
        let machine_type_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMachineTypeAttributes(machine, machine_type_attributes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMaximumProcessorCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMaximumProcessorCount(group_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMaximumProcessorGroupCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetMaximumProcessorGroupCount();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNextUmsListItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNextUmsListItem(ums_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaAvailableMemoryNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let available_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaAvailableMemoryNode(node, available_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaAvailableMemoryNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let available_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaAvailableMemoryNodeEx(node, available_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaHighestNodeNumber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let highest_node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaHighestNodeNumber(highest_node_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeNumberFromHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaNodeNumberFromHandle(h_file, node_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let processor_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaNodeProcessorMask(node, processor_mask);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMask2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node_number = call.get_arg();
        let processor_masks = call.get_arg();
        let processor_mask_count = call.get_arg();
        let required_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaNodeProcessorMask2(
            node_number,
            processor_masks,
            processor_mask_count,
            required_mask_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMaskEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let processor_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaNodeProcessorMaskEx(node, processor_mask);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProcessorNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let processor = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaProcessorNode(processor, node_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProcessorNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let processor = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaProcessorNodeEx(processor, node_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProximityNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let proximity_id = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaProximityNode(proximity_id, node_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProximityNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let proximity_id = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNumaProximityNodeEx(proximity_id, node_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPriorityClass(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPriorityClass(h_process);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_process_affinity_mask = call.get_arg();
        let lp_system_affinity_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessAffinityMask(
            h_process,
            lp_process_affinity_mask,
            lp_system_affinity_mask,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_flags = call.get_arg();
        let lp_permanent = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessDEPPolicy(h_process, lp_flags, lp_permanent);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let required_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessDefaultCpuSetMasks(
            process,
            cpu_set_masks,
            cpu_set_mask_count,
            required_mask_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let required_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetProcessDefaultCpuSets(process, cpu_set_ids, cpu_set_id_count, required_id_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let group_count = call.get_arg();
        let group_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessGroupAffinity(h_process, group_count, group_array);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessHandleCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let pdw_handle_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessHandleCount(h_process, pdw_handle_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessId(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessId(process);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessIdOfThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessIdOfThread(thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let process_information_class = call.get_arg();
        let process_information = call.get_arg();
        let process_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessInformation(
            h_process,
            process_information_class,
            process_information,
            process_information_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessIoCounters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_io_counters = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessIoCounters(h_process, lp_io_counters);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessMitigationPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let mitigation_policy = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetProcessMitigationPolicy(h_process, mitigation_policy, lp_buffer, dw_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let p_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessPriorityBoost(h_process, p_disable_priority_boost);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessShutdownParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpdw_level = call.get_arg();
        let lpdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessShutdownParameters(lpdw_level, lpdw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_exit_time = call.get_arg();
        let lp_kernel_time = call.get_arg();
        let lp_user_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessTimes(
            h_process,
            lp_creation_time,
            lp_exit_time,
            lp_kernel_time,
            lp_user_time,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessVersion(process_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessWorkingSetSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_minimum_working_set_size = call.get_arg();
        let lp_maximum_working_set_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessWorkingSetSize(
            h_process,
            lp_minimum_working_set_size,
            lp_maximum_working_set_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStartupInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_startup_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStartupInfoA(lp_startup_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStartupInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_startup_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetStartupInfoW(lp_startup_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_idle_time = call.get_arg();
        let lp_kernel_time = call.get_arg();
        let lp_user_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemTimes(lp_idle_time, lp_kernel_time, lp_user_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadDescription(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let ppsz_thread_description = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadDescription(h_thread, ppsz_thread_description);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let group_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadGroupAffinity(h_thread, group_affinity);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadIOPendingFlag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_io_is_pending = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadIOPendingFlag(h_thread, lp_io_is_pending);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadId(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadId(thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadIdealProcessorEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_ideal_processor = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadIdealProcessorEx(h_thread, lp_ideal_processor);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadInformation(
            h_thread,
            thread_information_class,
            thread_information,
            thread_information_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadPriority(h_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let p_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadPriorityBoost(h_thread, p_disable_priority_boost);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadSelectedCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let required_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadSelectedCpuSetMasks(
            thread,
            cpu_set_masks,
            cpu_set_mask_count,
            required_mask_count,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadSelectedCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let required_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetThreadSelectedCpuSets(thread, cpu_set_ids, cpu_set_id_count, required_id_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_exit_time = call.get_arg();
        let lp_kernel_time = call.get_arg();
        let lp_user_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetThreadTimes(
            h_thread,
            lp_creation_time,
            lp_exit_time,
            lp_kernel_time,
            lp_user_time,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUmsCompletionListEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let ums_completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUmsCompletionListEvent(ums_completion_list, ums_completion_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUmsSystemThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let system_thread_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUmsSystemThreadInformation(thread_handle, system_thread_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceBeginInitialize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_init_once = call.get_arg();
        let dw_flags = call.get_arg();
        let f_pending = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitOnceBeginInitialize(lp_init_once, dw_flags, f_pending, lp_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_init_once = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitOnceComplete(lp_init_once, dw_flags, lp_context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceExecuteOnce(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let init_once = call.get_arg();
        let init_fn = call.get_arg();
        let parameter = call.get_arg();
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitOnceExecuteOnce(init_once, init_fn, parameter, context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceInitialize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let init_once = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitOnceInitialize(init_once);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeConditionVariable(condition_variable);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeCriticalSection(lp_critical_section);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSectionAndSpinCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let dw_spin_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeCriticalSectionAndSpinCount(lp_critical_section, dw_spin_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSectionEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let dw_spin_count = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeCriticalSectionEx(lp_critical_section, dw_spin_count, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeProcThreadAttributeList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_attribute_list = call.get_arg();
        let dw_attribute_count = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeProcThreadAttributeList(
            lp_attribute_list,
            dw_attribute_count,
            dw_flags,
            lp_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeSListHead(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeSListHead(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeSRWLock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeSRWLock(srw_lock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_barrier = call.get_arg();
        let l_total_threads = call.get_arg();
        let l_spin_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InitializeSynchronizationBarrier(lp_barrier, l_total_threads, l_spin_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedFlushSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InterlockedFlushSList(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedPopEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InterlockedPopEntrySList(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedPushEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list_entry = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InterlockedPushEntrySList(list_head, list_entry);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedPushListSListEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list = call.get_arg();
        let list_end = call.get_arg();
        let count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InterlockedPushListSListEx(list_head, list, list_end, count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsImmersiveProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsImmersiveProcess(h_process);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsProcessCritical(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let critical = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsProcessCritical(h_process, critical);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsProcessorFeaturePresent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let processor_feature = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsProcessorFeaturePresent(processor_feature);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsThreadAFiber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.IsThreadAFiber();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsThreadpoolTimerSet(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsThreadpoolTimerSet(pti);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWow64Process(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let wow_64_process = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsWow64Process(h_process, wow_64_process);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWow64Process2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let p_process_machine = call.get_arg();
        let p_native_machine = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsWow64Process2(h_process, p_process_machine, p_native_machine);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LeaveCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LeaveCriticalSection(lp_critical_section);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LeaveCriticalSectionWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let pcs = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LeaveCriticalSectionWhenCallbackReturns(pci, pcs);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryInformationProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process_handle = call.get_arg();
        let process_information_class = call.get_arg();
        let process_information = call.get_arg();
        let process_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtQueryInformationProcess(
            process_handle,
            process_information_class,
            process_information,
            process_information_length,
            return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryInformationThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtQueryInformationThread(
            thread_handle,
            thread_information_class,
            thread_information,
            thread_information_length,
            return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtSetInformationThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtSetInformationThread(
            thread_handle,
            thread_information_class,
            thread_information,
            thread_information_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEventA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenEventA(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEventW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenEventW(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenMutexW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenMutexW(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenPrivateNamespaceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_boundary_descriptor = call.get_arg();
        let lp_alias_prefix = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenPrivateNamespaceA(lp_boundary_descriptor, lp_alias_prefix);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenPrivateNamespaceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_boundary_descriptor = call.get_arg();
        let lp_alias_prefix = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenPrivateNamespaceW(lp_boundary_descriptor, lp_alias_prefix);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenProcess(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let dw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenProcess(dw_desired_access, b_inherit_handle, dw_process_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenSemaphoreW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenSemaphoreW(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let dw_thread_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenThread(dw_desired_access, b_inherit_handle, dw_thread_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenWaitableTimerW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_timer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenWaitableTimerW(dw_desired_access, b_inherit_handle, lp_timer_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PulseEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PulseEvent(h_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryDepthSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryDepthSList(list_head);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryFullProcessImageNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_exe_name = call.get_arg();
        let lpdw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryFullProcessImageNameA(h_process, dw_flags, lp_exe_name, lpdw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryFullProcessImageNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_exe_name = call.get_arg();
        let lpdw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryFullProcessImageNameW(h_process, dw_flags, lp_exe_name, lpdw_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryProcessAffinityUpdateMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lpdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryProcessAffinityUpdateMode(h_process, lpdw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryProtectedPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let policy_guid = call.get_arg();
        let policy_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryProtectedPolicy(policy_guid, policy_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryThreadpoolStackInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let ptpsi = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryThreadpoolStackInformation(ptpp, ptpsi);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryUmsThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let ums_thread_info_class = call.get_arg();
        let ums_thread_information = call.get_arg();
        let ums_thread_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryUmsThreadInformation(
            ums_thread,
            ums_thread_info_class,
            ums_thread_information,
            ums_thread_information_length,
            return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueueUserAPC(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfn_apc = call.get_arg();
        let h_thread = call.get_arg();
        let dw_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueueUserAPC(pfn_apc, h_thread, dw_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueueUserAPC2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let apc_routine = call.get_arg();
        let thread = call.get_arg();
        let data = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueueUserAPC2(apc_routine, thread, data, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueueUserWorkItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let context = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueueUserWorkItem(function, context, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterWaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ph_new_wait_object = call.get_arg();
        let h_object = call.get_arg();
        let callback = call.get_arg();
        let context = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RegisterWaitForSingleObject(
            ph_new_wait_object,
            h_object,
            callback,
            context,
            dw_milliseconds,
            dw_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseMutex(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mutex = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReleaseMutex(h_mutex);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseMutexWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let r#mut = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReleaseMutexWhenCallbackReturns(pci, r#mut);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReleaseSRWLockExclusive(srw_lock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReleaseSRWLockShared(srw_lock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSemaphore(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_semaphore = call.get_arg();
        let l_release_count = call.get_arg();
        let lp_previous_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReleaseSemaphore(h_semaphore, l_release_count, lp_previous_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSemaphoreWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let sem = call.get_arg();
        let crel = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReleaseSemaphoreWhenCallbackReturns(pci, sem, crel);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResetEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ResetEvent(h_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResumeThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ResumeThread(h_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCriticalSectionSpinCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let dw_spin_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCriticalSectionSpinCount(lp_critical_section, dw_spin_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEvent(h_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEventWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let evt = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEventWhenCallbackReturns(pci, evt);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPriorityClass(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_priority_class = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetPriorityClass(h_process, dw_priority_class);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_process_affinity_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessAffinityMask(h_process, dw_process_affinity_mask);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessAffinityUpdateMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessAffinityUpdateMode(h_process, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessDEPPolicy(dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessDefaultCpuSetMasks(process, cpu_set_masks, cpu_set_mask_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessDefaultCpuSets(process, cpu_set_ids, cpu_set_id_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDynamicEHContinuationTargets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let number_of_targets = call.get_arg();
        let targets = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessDynamicEHContinuationTargets(process, number_of_targets, targets);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDynamicEnforcedCetCompatibleRanges(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let number_of_ranges = call.get_arg();
        let ranges = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetProcessDynamicEnforcedCetCompatibleRanges(process, number_of_ranges, ranges);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let process_information_class = call.get_arg();
        let process_information = call.get_arg();
        let process_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessInformation(
            h_process,
            process_information_class,
            process_information,
            process_information_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessMitigationPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let mitigation_policy = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessMitigationPolicy(mitigation_policy, lp_buffer, dw_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let b_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessPriorityBoost(h_process, b_disable_priority_boost);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessRestrictionExemption(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let f_enable_exemption = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessRestrictionExemption(f_enable_exemption);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessShutdownParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_level = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessShutdownParameters(dw_level, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessWorkingSetSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_minimum_working_set_size = call.get_arg();
        let dw_maximum_working_set_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessWorkingSetSize(
            h_process,
            dw_minimum_working_set_size,
            dw_maximum_working_set_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProtectedPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let policy_guid = call.get_arg();
        let policy_value = call.get_arg();
        let old_policy_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProtectedPolicy(policy_guid, policy_value, old_policy_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let dw_thread_affinity_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadAffinityMask(h_thread, dw_thread_affinity_mask);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadDescription(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_thread_description = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadDescription(h_thread, lp_thread_description);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let group_affinity = call.get_arg();
        let previous_group_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadGroupAffinity(h_thread, group_affinity, previous_group_affinity);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadIdealProcessor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let dw_ideal_processor = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadIdealProcessor(h_thread, dw_ideal_processor);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadIdealProcessorEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_ideal_processor = call.get_arg();
        let lp_previous_ideal_processor = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadIdealProcessorEx(
            h_thread,
            lp_ideal_processor,
            lp_previous_ideal_processor,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadInformation(
            h_thread,
            thread_information_class,
            thread_information,
            thread_information_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let n_priority = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadPriority(h_thread, n_priority);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let b_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadPriorityBoost(h_thread, b_disable_priority_boost);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadSelectedCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadSelectedCpuSetMasks(thread, cpu_set_masks, cpu_set_mask_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadSelectedCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadSelectedCpuSets(thread, cpu_set_ids, cpu_set_id_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadStackGuarantee(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let stack_size_in_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadStackGuarantee(stack_size_in_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadToken(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let token = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadToken(thread, token);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolStackInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let ptpsi = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadpoolStackInformation(ptpp, ptpsi);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolThreadMaximum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let cthrd_most = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadpoolThreadMaximum(ptpp, cthrd_most);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolThreadMinimum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let cthrd_mic = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadpoolThreadMinimum(ptpp, cthrd_mic);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let pft_due_time = call.get_arg();
        let ms_period = call.get_arg();
        let ms_window_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadpoolTimer(pti, pft_due_time, ms_period, ms_window_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolTimerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let pft_due_time = call.get_arg();
        let ms_period = call.get_arg();
        let ms_window_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadpoolTimerEx(pti, pft_due_time, ms_period, ms_window_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let h = call.get_arg();
        let pft_timeout = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadpoolWait(pwa, h, pft_timeout);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolWaitEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let h = call.get_arg();
        let pft_timeout = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetThreadpoolWaitEx(pwa, h, pft_timeout, reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let callback = call.get_arg();
        let parameter = call.get_arg();
        let due_time = call.get_arg();
        let period = call.get_arg();
        let prefer_io = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetTimerQueueTimer(
            timer_queue,
            callback,
            parameter,
            due_time,
            period,
            prefer_io,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetUmsThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let ums_thread_info_class = call.get_arg();
        let ums_thread_information = call.get_arg();
        let ums_thread_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetUmsThreadInformation(
            ums_thread,
            ums_thread_info_class,
            ums_thread_information,
            ums_thread_information_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWaitableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_timer = call.get_arg();
        let lp_due_time = call.get_arg();
        let l_period = call.get_arg();
        let pfn_completion_routine = call.get_arg();
        let lp_arg_to_completion_routine = call.get_arg();
        let f_resume = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWaitableTimer(
            h_timer,
            lp_due_time,
            l_period,
            pfn_completion_routine,
            lp_arg_to_completion_routine,
            f_resume,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWaitableTimerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_timer = call.get_arg();
        let lp_due_time = call.get_arg();
        let l_period = call.get_arg();
        let pfn_completion_routine = call.get_arg();
        let lp_arg_to_completion_routine = call.get_arg();
        let wake_context = call.get_arg();
        let tolerable_delay = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWaitableTimerEx(
            h_timer,
            lp_due_time,
            l_period,
            pfn_completion_routine,
            lp_arg_to_completion_routine,
            wake_context,
            tolerable_delay,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Sleep(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.Sleep(dw_milliseconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SleepConditionVariableCS(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let critical_section = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SleepConditionVariableCS(condition_variable, critical_section, dw_milliseconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SleepConditionVariableSRW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let srw_lock = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SleepConditionVariableSRW(condition_variable, srw_lock, dw_milliseconds, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SleepEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SleepEx(dw_milliseconds, b_alertable);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_StartThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.StartThreadpoolIo(pio);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SubmitThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwk = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SubmitThreadpoolWork(pwk);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SuspendThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SuspendThread(h_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SwitchToFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_fiber = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SwitchToFiber(lp_fiber);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SwitchToThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.SwitchToThread();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TerminateProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let u_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TerminateProcess(h_process, u_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TerminateThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let dw_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TerminateThread(h_thread, dw_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.TlsAlloc();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_tls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TlsFree(dw_tls_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsGetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_tls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TlsGetValue(dw_tls_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsSetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_tls_index = call.get_arg();
        let lp_tls_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TlsSetValue(dw_tls_index, lp_tls_value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TryAcquireSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TryAcquireSRWLockExclusive(srw_lock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TryAcquireSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TryAcquireSRWLockShared(srw_lock);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TryEnterCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TryEnterCriticalSection(lp_critical_section);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TrySubmitThreadpoolCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfns = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TrySubmitThreadpoolCallback(pfns, pv, pcbe);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UmsThreadYield(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let scheduler_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UmsThreadYield(scheduler_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let wait_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnregisterWait(wait_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterWaitEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let wait_handle = call.get_arg();
        let completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnregisterWaitEx(wait_handle, completion_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UpdateProcThreadAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_attribute_list = call.get_arg();
        let dw_flags = call.get_arg();
        let attribute = call.get_arg();
        let lp_value = call.get_arg();
        let cb_size = call.get_arg();
        let lp_previous_value = call.get_arg();
        let lp_return_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UpdateProcThreadAttribute(
            lp_attribute_list,
            dw_flags,
            attribute,
            lp_value,
            cb_size,
            lp_previous_value,
            lp_return_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForInputIdle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForInputIdle(h_process, dw_milliseconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForMultipleObjects(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let lp_handles = call.get_arg();
        let b_wait_all = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForMultipleObjects(n_count, lp_handles, b_wait_all, dw_milliseconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForMultipleObjectsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let lp_handles = call.get_arg();
        let b_wait_all = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForMultipleObjectsEx(
            n_count,
            lp_handles,
            b_wait_all,
            dw_milliseconds,
            b_alertable,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_handle = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForSingleObject(h_handle, dw_milliseconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForSingleObjectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_handle = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForSingleObjectEx(h_handle, dw_milliseconds, b_alertable);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolIoCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForThreadpoolIoCallbacks(pio, f_cancel_pending_callbacks);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolTimerCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForThreadpoolTimerCallbacks(pti, f_cancel_pending_callbacks);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolWaitCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForThreadpoolWaitCallbacks(pwa, f_cancel_pending_callbacks);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolWorkCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwk = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitForThreadpoolWorkCallbacks(pwk, f_cancel_pending_callbacks);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitOnAddress(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let compare_address = call.get_arg();
        let address_size = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WaitOnAddress(address, compare_address, address_size, dw_milliseconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeAllConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WakeAllConditionVariable(condition_variable);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeByAddressAll(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WakeByAddressAll(address);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeByAddressSingle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WakeByAddressSingle(address);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WakeConditionVariable(condition_variable);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WinExec(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cmd_line = call.get_arg();
        let u_cmd_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WinExec(lp_cmd_line, u_cmd_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64SetThreadDefaultGuestMachine(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let machine = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.Wow64SetThreadDefaultGuestMachine(machine);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64SuspendThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.Wow64SuspendThread(h_thread);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddDelBackupEntryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpcsz_file_list = call.get_arg();
        let lpcsz_backup_dir = call.get_arg();
        let lpcsz_base_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.AddDelBackupEntryA(lpcsz_file_list, lpcsz_backup_dir, lpcsz_base_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddDelBackupEntryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpcsz_file_list = call.get_arg();
        let lpcsz_backup_dir = call.get_arg();
        let lpcsz_base_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.AddDelBackupEntryW(lpcsz_file_list, lpcsz_backup_dir, lpcsz_base_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdvInstallFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let lpsz_source_dir = call.get_arg();
        let lpsz_source_file = call.get_arg();
        let lpsz_dest_dir = call.get_arg();
        let lpsz_dest_file = call.get_arg();
        let dw_flags = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AdvInstallFileA(
            hwnd,
            lpsz_source_dir,
            lpsz_source_file,
            lpsz_dest_dir,
            lpsz_dest_file,
            dw_flags,
            dw_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdvInstallFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let lpsz_source_dir = call.get_arg();
        let lpsz_source_file = call.get_arg();
        let lpsz_dest_dir = call.get_arg();
        let lpsz_dest_file = call.get_arg();
        let dw_flags = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AdvInstallFileW(
            hwnd,
            lpsz_source_dir,
            lpsz_source_file,
            lpsz_dest_dir,
            lpsz_dest_file,
            dw_flags,
            dw_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ApphelpCheckShellObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let object_clsid = call.get_arg();
        let b_shim_if_necessary = call.get_arg();
        let pull_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ApphelpCheckShellObject(object_clsid, b_shim_if_necessary, pull_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelDeviceWakeupRequest(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CancelDeviceWakeupRequest(h_device);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let timer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CancelTimerQueueTimer(timer_queue, timer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseINFEngine(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inf = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseINFEngine(h_inf);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertAuxiliaryCounterToPerformanceCounter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ull_auxiliary_counter_value = call.get_arg();
        let lp_performance_counter_value = call.get_arg();
        let lp_conversion_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ConvertAuxiliaryCounterToPerformanceCounter(
            ull_auxiliary_counter_value,
            lp_performance_counter_value,
            lp_conversion_error,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertPerformanceCounterToAuxiliaryCounter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ull_performance_counter_value = call.get_arg();
        let lp_auxiliary_counter_value = call.get_arg();
        let lp_conversion_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ConvertPerformanceCounterToAuxiliaryCounter(
            ull_performance_counter_value,
            lp_auxiliary_counter_value,
            lp_conversion_error,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DelNodeA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_file_or_dir_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DelNodeA(psz_file_or_dir_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DelNodeRunDLL32W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DelNodeRunDLL32W(hwnd, h_instance, psz_parms, n_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DelNodeW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_file_or_dir_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DelNodeW(psz_file_or_dir_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DnsHostnameToComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hostname = call.get_arg();
        let computer_name = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DnsHostnameToComputerNameA(hostname, computer_name, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DnsHostnameToComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hostname = call.get_arg();
        let computer_name = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DnsHostnameToComputerNameW(hostname, computer_name, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DosDateTimeToFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_fat_date = call.get_arg();
        let w_fat_time = call.get_arg();
        let lp_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DosDateTimeToFileTime(w_fat_date, w_fat_time, lp_file_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnableProcessOptionalXStateFeatures(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let features = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnableProcessOptionalXStateFeatures(features);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExecuteCabA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let p_cab = call.get_arg();
        let p_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExecuteCabA(hwnd, p_cab, p_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExecuteCabW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let p_cab = call.get_arg();
        let p_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExecuteCabW(hwnd, p_cab, p_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExtractFilesA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_cab_name = call.get_arg();
        let psz_expand_dir = call.get_arg();
        let dw_flags = call.get_arg();
        let psz_file_list = call.get_arg();
        let lp_reserved = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExtractFilesA(
            psz_cab_name,
            psz_expand_dir,
            dw_flags,
            psz_file_list,
            lp_reserved,
            dw_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExtractFilesW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_cab_name = call.get_arg();
        let psz_expand_dir = call.get_arg();
        let dw_flags = call.get_arg();
        let psz_file_list = call.get_arg();
        let lp_reserved = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ExtractFilesW(
            psz_cab_name,
            psz_expand_dir,
            dw_flags,
            psz_file_list,
            lp_reserved,
            dw_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveMarkNotExistA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_list = call.get_arg();
        let lp_dir = call.get_arg();
        let lp_base_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileSaveMarkNotExistA(lp_file_list, lp_dir, lp_base_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveMarkNotExistW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_list = call.get_arg();
        let lp_dir = call.get_arg();
        let lp_base_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileSaveMarkNotExistW(lp_file_list, lp_dir, lp_base_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreOnINFA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let psz_title = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_section = call.get_arg();
        let psz_backup_dir = call.get_arg();
        let psz_base_backup_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileSaveRestoreOnINFA(
            h_wnd,
            psz_title,
            psz_inf,
            psz_section,
            psz_backup_dir,
            psz_base_backup_file,
            dw_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreOnINFW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let psz_title = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_section = call.get_arg();
        let psz_backup_dir = call.get_arg();
        let psz_base_backup_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileSaveRestoreOnINFW(
            h_wnd,
            psz_title,
            psz_inf,
            psz_section,
            psz_backup_dir,
            psz_base_backup_file,
            dw_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_file_list = call.get_arg();
        let lp_dir = call.get_arg();
        let lp_base_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileSaveRestoreW(h_dlg, lp_file_list, lp_dir, lp_base_name, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileTimeToDosDateTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_time = call.get_arg();
        let lp_fat_date = call.get_arg();
        let lp_fat_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FileTimeToDosDateTime(lp_file_time, lp_fat_date, lp_fat_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GdiEntry13(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GdiEntry13();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetComputerNameA(lp_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetComputerNameW(lp_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentHwProfileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_hw_profile_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentHwProfileA(lp_hw_profile_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentHwProfileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_hw_profile_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCurrentHwProfileW(lp_hw_profile_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFeatureEnabledState(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let change_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFeatureEnabledState(feature_id, change_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFeatureVariant(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let change_time = call.get_arg();
        let payload_id = call.get_arg();
        let has_notification = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFeatureVariant(feature_id, change_time, payload_id, has_notification);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFirmwareEnvironmentVariableA(lp_name, lp_guid, p_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let pdw_attribubutes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFirmwareEnvironmentVariableExA(
            lp_name,
            lp_guid,
            p_buffer,
            n_size,
            pdw_attribubutes,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let pdw_attribubutes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFirmwareEnvironmentVariableExW(
            lp_name,
            lp_guid,
            p_buffer,
            n_size,
            pdw_attribubutes,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetFirmwareEnvironmentVariableW(lp_name, lp_guid, p_buffer, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileIntA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPrivateProfileIntA(lp_app_name, lp_key_name, n_default, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileIntW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPrivateProfileIntW(lp_app_name, lp_key_name, n_default, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetPrivateProfileSectionA(lp_app_name, lp_returned_string, n_size, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionNamesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_return_buffer = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPrivateProfileSectionNamesA(lpsz_return_buffer, n_size, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionNamesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_return_buffer = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPrivateProfileSectionNamesW(lpsz_return_buffer, n_size, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetPrivateProfileSectionW(lp_app_name, lp_returned_string, n_size, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPrivateProfileStringA(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
            lp_file_name,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPrivateProfileStringW(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
            lp_file_name,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStructA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetPrivateProfileStructA(lpsz_section, lpsz_key, lp_struct, u_size_struct, sz_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStructW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.GetPrivateProfileStructW(lpsz_section, lpsz_key, lp_struct, u_size_struct, sz_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileIntA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProfileIntA(lp_app_name, lp_key_name, n_default);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileIntW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProfileIntW(lp_app_name, lp_key_name, n_default);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProfileSectionA(lp_app_name, lp_returned_string, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProfileSectionW(lp_app_name, lp_returned_string, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProfileStringA(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProfileStringW(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemRegistryQuota(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pdw_quota_allowed = call.get_arg();
        let pdw_quota_used = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemRegistryQuota(pdw_quota_allowed, pdw_quota_used);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadEnabledXStateFeatures(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetThreadEnabledXStateFeatures();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserNameA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let pcb_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUserNameA(lp_buffer, pcb_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserNameW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let pcb_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetUserNameW(lp_buffer, pcb_buffer);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVersionFromFileA(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVersionFromFileExA(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVersionFromFileExW(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetVersionFromFileW(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_min_free = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalCompact(dw_min_free);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalFix(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalFix(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalUnWire(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalUnWire(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalUnfix(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalUnfix(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalWire(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GlobalWire(h_mem);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPGetIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IMPGetIMEA(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPGetIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IMPGetIMEW(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPQueryIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IMPQueryIMEA(param_0);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPQueryIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IMPQueryIMEW(param_0);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPSetIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IMPSetIMEA(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPSetIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IMPSetIMEW(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsApiSetImplemented(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let contract = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsApiSetImplemented(contract);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadHugeReadPtr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsBadHugeReadPtr(lp, ucb);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadHugeWritePtr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsBadHugeWritePtr(lp, ucb);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNTAdmin(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_reserved = call.get_arg();
        let lpdw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsNTAdmin(dw_reserved, lpdw_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNativeVhdBoot(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let native_vhd_boot = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsNativeVhdBoot(native_vhd_boot);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsTokenUntrusted(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let token_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsTokenUntrusted(token_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LaunchINFSectionExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LaunchINFSectionExW(hwnd, h_instance, psz_parms, n_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LaunchINFSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_owner = call.get_arg();
        let h_instance = call.get_arg();
        let psz_params = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LaunchINFSectionW(hwnd_owner, h_instance, psz_params, n_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_min_free = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalCompact(u_min_free);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalShrink(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let cb_new_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LocalShrink(h_mem, cb_new_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MulDiv(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_number = call.get_arg();
        let n_numerator = call.get_arg();
        let n_denominator = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MulDiv(n_number, n_numerator, n_denominator);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedReboot(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_reboot_check = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NeedReboot(dw_reboot_check);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedRebootInit(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.NeedRebootInit();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtClose(handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtDeviceIoControlFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let event = call.get_arg();
        let apc_routine = call.get_arg();
        let apc_context = call.get_arg();
        let io_status_block = call.get_arg();
        let io_control_code = call.get_arg();
        let input_buffer = call.get_arg();
        let input_buffer_length = call.get_arg();
        let output_buffer = call.get_arg();
        let output_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtDeviceIoControlFile(
            file_handle,
            event,
            apc_routine,
            apc_context,
            io_status_block,
            io_control_code,
            input_buffer,
            input_buffer_length,
            output_buffer,
            output_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtNotifyChangeMultipleKeys(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let master_key_handle = call.get_arg();
        let count = call.get_arg();
        let subordinate_objects = call.get_arg();
        let event = call.get_arg();
        let apc_routine = call.get_arg();
        let apc_context = call.get_arg();
        let io_status_block = call.get_arg();
        let completion_filter = call.get_arg();
        let watch_tree = call.get_arg();
        let buffer = call.get_arg();
        let buffer_size = call.get_arg();
        let asynchronous = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtNotifyChangeMultipleKeys(
            master_key_handle,
            count,
            subordinate_objects,
            event,
            apc_routine,
            apc_context,
            io_status_block,
            completion_filter,
            watch_tree,
            buffer,
            buffer_size,
            asynchronous,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtOpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let desired_access = call.get_arg();
        let object_attributes = call.get_arg();
        let io_status_block = call.get_arg();
        let share_access = call.get_arg();
        let open_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtOpenFile(
            file_handle,
            desired_access,
            object_attributes,
            io_status_block,
            share_access,
            open_options,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryMultipleValueKey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let key_handle = call.get_arg();
        let value_entries = call.get_arg();
        let entry_count = call.get_arg();
        let value_buffer = call.get_arg();
        let buffer_length = call.get_arg();
        let required_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtQueryMultipleValueKey(
            key_handle,
            value_entries,
            entry_count,
            value_buffer,
            buffer_length,
            required_buffer_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryObject(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let object_information_class = call.get_arg();
        let object_information = call.get_arg();
        let object_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtQueryObject(
            handle,
            object_information_class,
            object_information,
            object_information_length,
            return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQuerySystemInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let system_information_class = call.get_arg();
        let system_information = call.get_arg();
        let system_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtQuerySystemInformation(
            system_information_class,
            system_information,
            system_information_length,
            return_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQuerySystemTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtQuerySystemTime(system_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryTimerResolution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let maximum_time = call.get_arg();
        let minimum_time = call.get_arg();
        let current_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtQueryTimerResolution(maximum_time, minimum_time, current_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtRenameKey(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let key_handle = call.get_arg();
        let new_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtRenameKey(key_handle, new_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtSetInformationKey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let key_handle = call.get_arg();
        let key_set_information_class = call.get_arg();
        let key_set_information = call.get_arg();
        let key_set_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtSetInformationKey(
            key_handle,
            key_set_information_class,
            key_set_information,
            key_set_information_length,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtWaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let alertable = call.get_arg();
        let timeout = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.NtWaitForSingleObject(handle, alertable, timeout);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenINFEngineA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let dw_flags = call.get_arg();
        let ph_inf = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenINFEngineA(
            psz_inf_filename,
            psz_install_section,
            dw_flags,
            ph_inf,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenINFEngineW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let dw_flags = call.get_arg();
        let ph_inf = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenINFEngineW(
            psz_inf_filename,
            psz_install_section,
            dw_flags,
            ph_inf,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenMutexA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenMutexA(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenSemaphoreA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenSemaphoreA(dw_desired_access, b_inherit_handle, lp_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenWaitableTimerA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_timer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenWaitableTimerA(dw_desired_access, b_inherit_handle, lp_timer_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryAuxiliaryCounterFrequency(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_auxiliary_counter_frequency = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryAuxiliaryCounterFrequency(lp_auxiliary_counter_frequency);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryIdleProcessorCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer_length = call.get_arg();
        let processor_idle_cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryIdleProcessorCycleTime(buffer_length, processor_idle_cycle_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryIdleProcessorCycleTimeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group = call.get_arg();
        let buffer_length = call.get_arg();
        let processor_idle_cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.QueryIdleProcessorCycleTimeEx(group, buffer_length, processor_idle_cycle_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryInterruptTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_interrupt_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryInterruptTime(lp_interrupt_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryInterruptTimePrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_interrupt_time_precise = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryInterruptTimePrecise(lp_interrupt_time_precise);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryProcessCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process_handle = call.get_arg();
        let cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryProcessCycleTime(process_handle, cycle_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryThreadCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryThreadCycleTime(thread_handle, cycle_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryUnbiasedInterruptTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unbiased_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryUnbiasedInterruptTime(unbiased_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryUnbiasedInterruptTimePrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_unbiased_interrupt_time_precise = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.QueryUnbiasedInterruptTimePrecise(lp_unbiased_interrupt_time_precise);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RaiseCustomSystemEventTrigger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let custom_system_event_trigger_config = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RaiseCustomSystemEventTrigger(custom_system_event_trigger_config);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RebootCheckOnInstallA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_sec = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RebootCheckOnInstallA(hwnd, psz_inf, psz_sec, dw_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RebootCheckOnInstallW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_sec = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RebootCheckOnInstallW(hwnd, psz_inf, psz_sec, dw_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecordFeatureError(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let error = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RecordFeatureError(feature_id, error);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecordFeatureUsage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let kind = call.get_arg();
        let addend = call.get_arg();
        let origin_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RecordFeatureUsage(feature_id, kind, addend, origin_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegInstallA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hmod = call.get_arg();
        let psz_section = call.get_arg();
        let pst_table = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RegInstallA(hmod, psz_section, pst_table);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegInstallW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hmod = call.get_arg();
        let psz_section = call.get_arg();
        let pst_table = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RegInstallW(hmod, psz_section, pst_table);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplacePartitionUnit(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let target_partition = call.get_arg();
        let spare_partition = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReplacePartitionUnit(target_partition, spare_partition, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RequestDeviceWakeup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RequestDeviceWakeup(h_device);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlAnsiStringToUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let allocate_destination_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlAnsiStringToUnicodeString(
            destination_string,
            source_string,
            allocate_destination_string,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCharToInteger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let string = call.get_arg();
        let base = call.get_arg();
        let value = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlCharToInteger(string, base, value);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFreeAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ansi_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlFreeAnsiString(ansi_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFreeOemString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let oem_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlFreeOemString(oem_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFreeUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unicode_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlFreeUnicodeString(unicode_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetReturnAddressHijackTarget(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.RtlGetReturnAddressHijackTarget();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInitAnsiString(destination_string, source_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitAnsiStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInitAnsiStringEx(destination_string, source_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitString(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInitString(destination_string, source_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInitStringEx(destination_string, source_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlInitUnicodeString(destination_string, source_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlIsNameLegalDOS8Dot3(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name = call.get_arg();
        let oem_name = call.get_arg();
        let name_contains_spaces = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlIsNameLegalDOS8Dot3(name, oem_name, name_contains_spaces);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlLocalTimeToSystemTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let local_time = call.get_arg();
        let system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlLocalTimeToSystemTime(local_time, system_time);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlRaiseCustomSystemEventTrigger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let trigger_config = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlRaiseCustomSystemEventTrigger(trigger_config);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlTimeToSecondsSince1970(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let time = call.get_arg();
        let elapsed_seconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlTimeToSecondsSince1970(time, elapsed_seconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeStringToAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let allocate_destination_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlUnicodeStringToAnsiString(
            destination_string,
            source_string,
            allocate_destination_string,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeStringToOemString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let allocate_destination_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlUnicodeStringToOemString(
            destination_string,
            source_string,
            allocate_destination_string,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeToMultiByteSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let bytes_in_multi_byte_string = call.get_arg();
        let unicode_string = call.get_arg();
        let bytes_in_unicode_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlUnicodeToMultiByteSize(
            bytes_in_multi_byte_string,
            unicode_string,
            bytes_in_unicode_string,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUniform(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let seed = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RtlUniform(seed);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RunSetupCommandA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let sz_cmd_name = call.get_arg();
        let sz_inf_section = call.get_arg();
        let sz_dir = call.get_arg();
        let lpsz_title = call.get_arg();
        let ph_exe = call.get_arg();
        let dw_flags = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RunSetupCommandA(
            h_wnd,
            sz_cmd_name,
            sz_inf_section,
            sz_dir,
            lpsz_title,
            ph_exe,
            dw_flags,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RunSetupCommandW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let sz_cmd_name = call.get_arg();
        let sz_inf_section = call.get_arg();
        let sz_dir = call.get_arg();
        let lpsz_title = call.get_arg();
        let ph_exe = call.get_arg();
        let dw_flags = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RunSetupCommandW(
            h_wnd,
            sz_cmd_name,
            sz_inf_section,
            sz_dir,
            lpsz_title,
            ph_exe,
            dw_flags,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendIMEMessageExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendIMEMessageExA(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendIMEMessageExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendIMEMessageExW(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let new_environment = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetEnvironmentStringsA(new_environment);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFirmwareEnvironmentVariableA(lp_name, lp_guid, p_value, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let dw_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetFirmwareEnvironmentVariableExA(lp_name, lp_guid, p_value, n_size, dw_attributes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let dw_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SetFirmwareEnvironmentVariableExW(lp_name, lp_guid, p_value, n_size, dw_attributes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetFirmwareEnvironmentVariableW(lp_name, lp_guid, p_value, n_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetHandleCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetHandleCount(u_number);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMessageWaitingIndicator(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_msg_indicator = call.get_arg();
        let ul_msg_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetMessageWaitingIndicator(h_msg_indicator, ul_msg_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPerUserSecValuesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_per_user = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetPerUserSecValuesA(p_per_user);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPerUserSecValuesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_per_user = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetPerUserSecValuesW(p_per_user);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SignalObjectAndWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object_to_signal = call.get_arg();
        let h_object_to_wait_on = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SignalObjectAndWait(
            h_object_to_signal,
            h_object_to_wait_on,
            dw_milliseconds,
            b_alertable,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SubscribeFeatureStateChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let subscription = call.get_arg();
        let callback = call.get_arg();
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SubscribeFeatureStateChangeNotification(subscription, callback, context);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let cch_buffer = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateInfStringA(
            psz_inf_filename,
            psz_install_section,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            cch_buffer,
            pdw_required_size,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inf = call.get_arg();
        let psz_inf_filename = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateInfStringExA(
            h_inf,
            psz_inf_filename,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            dw_buffer_size,
            pdw_required_size,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inf = call.get_arg();
        let psz_inf_filename = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateInfStringExW(
            h_inf,
            psz_inf_filename,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            dw_buffer_size,
            pdw_required_size,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let cch_buffer = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateInfStringW(
            psz_inf_filename,
            psz_install_section,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            cch_buffer,
            pdw_required_size,
            pv_reserved,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnsubscribeFeatureStateChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let subscription = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnsubscribeFeatureStateChangeNotification(subscription);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserInstStubWrapperA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UserInstStubWrapperA(hwnd, h_instance, psz_parms, n_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserInstStubWrapperW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UserInstStubWrapperW(hwnd, h_instance, psz_parms, n_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserUnInstStubWrapperA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UserUnInstStubWrapperA(hwnd, h_instance, psz_parms, n_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserUnInstStubWrapperW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UserUnInstStubWrapperW(hwnd, h_instance, psz_parms, n_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WINNLSEnableIME(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WINNLSEnableIME(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WINNLSGetEnableStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WINNLSGetEnableStatus(param_0);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WINNLSGetIMEHotkey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WINNLSGetIMEHotkey(param_0);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpGetLockdownPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let host_information = call.get_arg();
        let lockdown_state = call.get_arg();
        let lockdown_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WldpGetLockdownPolicy(host_information, lockdown_state, lockdown_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpIsClassInApprovedList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let class_id = call.get_arg();
        let host_information = call.get_arg();
        let is_approved = call.get_arg();
        let optional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.WldpIsClassInApprovedList(class_id, host_information, is_approved, optional_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpIsDynamicCodePolicyEnabled(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let is_enabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WldpIsDynamicCodePolicyEnabled(is_enabled);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpQueryDeviceSecurityInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let information = call.get_arg();
        let information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.WldpQueryDeviceSecurityInformation(information, information_length, return_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpQueryDynamicCodeTrust(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let base_image = call.get_arg();
        let image_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WldpQueryDynamicCodeTrust(file_handle, base_image, image_size);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpSetDynamicCodeTrust(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WldpSetDynamicCodeTrust(file_handle);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WritePrivateProfileSectionA(lp_app_name, lp_string, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WritePrivateProfileSectionW(lp_app_name, lp_string, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WritePrivateProfileStringA(lp_app_name, lp_key_name, lp_string, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WritePrivateProfileStringW(lp_app_name, lp_key_name, lp_string, lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStructA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WritePrivateProfileStructA(
            lpsz_section,
            lpsz_key,
            lp_struct,
            u_size_struct,
            sz_file,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStructW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WritePrivateProfileStructW(
            lpsz_section,
            lpsz_key,
            lp_struct,
            u_size_struct,
            sz_file,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteProfileSectionA(lp_app_name, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteProfileSectionW(lp_app_name, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteProfileStringA(lp_app_name, lp_key_name, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WriteProfileStringW(lp_app_name, lp_key_name, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__hread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let l_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._hread(h_file, lp_buffer, l_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__hwrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let l_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._hwrite(h_file, lp_buffer, l_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lclose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._lclose(h_file);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lcreat(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let i_attribute = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._lcreat(lp_path_name, i_attribute);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__llseek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let l_offset = call.get_arg();
        let i_origin = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._llseek(h_file, l_offset, i_origin);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lopen(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let i_read_write = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._lopen(lp_path_name, i_read_write);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let u_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._lread(h_file, lp_buffer, u_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lwrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let u_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api._lwrite(h_file, lp_buffer, u_bytes);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdjustWindowRect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let dw_style = call.get_arg();
        let b_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AdjustWindowRect(lp_rect, dw_style, b_menu);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdjustWindowRectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let dw_style = call.get_arg();
        let b_menu = call.get_arg();
        let dw_ex_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AdjustWindowRectEx(lp_rect, dw_style, b_menu, dw_ex_style);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllowSetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AllowSetForegroundWindow(dw_process_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AnimateWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let dw_time = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AnimateWindow(h_wnd, dw_time, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AnyPopup(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.AnyPopup();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AppendMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AppendMenuA(h_menu, u_flags, u_id_new_item, lp_new_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AppendMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.AppendMenuW(h_menu, u_flags, u_id_new_item, lp_new_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ArrangeIconicWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ArrangeIconicWindows(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BeginDeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_num_windows = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BeginDeferWindowPos(n_num_windows);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BringWindowToTop(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.BringWindowToTop(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CalculatePopupWindowPosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let anchor_point = call.get_arg();
        let window_size = call.get_arg();
        let flags = call.get_arg();
        let exclude_rect = call.get_arg();
        let popup_window_position = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CalculatePopupWindowPosition(
            anchor_point,
            window_size,
            flags,
            exclude_rect,
            popup_window_position,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallMsgFilterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let n_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CallMsgFilterA(lp_msg, n_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallMsgFilterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let n_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CallMsgFilterW(lp_msg, n_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallNextHookEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hhk = call.get_arg();
        let n_code = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CallNextHookEx(hhk, n_code, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallWindowProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_prev_wnd_func = call.get_arg();
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CallWindowProcA(lp_prev_wnd_func, h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallWindowProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_prev_wnd_func = call.get_arg();
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CallWindowProcW(lp_prev_wnd_func, h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelShutdown(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.CancelShutdown();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CascadeWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let w_how = call.get_arg();
        let lp_rect = call.get_arg();
        let c_kids = call.get_arg();
        let lp_kids = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CascadeWindows(hwnd_parent, w_how, lp_rect, c_kids, lp_kids);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let cmd = call.get_arg();
        let lpsz_new_item = call.get_arg();
        let cmd_insert = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ChangeMenuA(h_menu, cmd, lpsz_new_item, cmd_insert, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let cmd = call.get_arg();
        let lpsz_new_item = call.get_arg();
        let cmd_insert = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ChangeMenuW(h_menu, cmd, lpsz_new_item, cmd_insert, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeWindowMessageFilter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let message = call.get_arg();
        let dw_flag = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ChangeWindowMessageFilter(message, dw_flag);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeWindowMessageFilterEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let message = call.get_arg();
        let action = call.get_arg();
        let p_change_filter_struct = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ChangeWindowMessageFilterEx(hwnd, message, action, p_change_filter_struct);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharLowerA(lpsz);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharLowerBuffA(lpsz, cch_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharLowerBuffW(lpsz, cch_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharLowerW(lpsz);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharNextA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharNextA(lpsz);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharNextExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let lp_current_char = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharNextExA(code_page, lp_current_char, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharNextW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharNextW(lpsz);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharPrevA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_start = call.get_arg();
        let lpsz_current = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharPrevA(lpsz_start, lpsz_current);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharPrevExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let lp_start = call.get_arg();
        let lp_current_char = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharPrevExA(code_page, lp_start, lp_current_char, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharPrevW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_start = call.get_arg();
        let lpsz_current = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharPrevW(lpsz_start, lpsz_current);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharToOemA(p_src, p_dst);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharToOemBuffA(lpsz_src, lpsz_dst, cch_dst_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharToOemBuffW(lpsz_src, lpsz_dst, cch_dst_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharToOemW(p_src, p_dst);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharUpperA(lpsz);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharUpperBuffA(lpsz, cch_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharUpperBuffW(lpsz, cch_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CharUpperW(lpsz);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckMenuItem(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_check_item = call.get_arg();
        let u_check = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CheckMenuItem(h_menu, u_id_check_item, u_check);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckMenuRadioItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hmenu = call.get_arg();
        let first = call.get_arg();
        let last = call.get_arg();
        let check = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CheckMenuRadioItem(hmenu, first, last, check, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChildWindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ChildWindowFromPoint(h_wnd_parent, point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChildWindowFromPointEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pt = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ChildWindowFromPointEx(hwnd, pt, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ClipCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ClipCursor(lp_rect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CloseWindow(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyAcceleratorTableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_accel_src = call.get_arg();
        let lp_accel_dst = call.get_arg();
        let c_accel_entries = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyAcceleratorTableA(h_accel_src, lp_accel_dst, c_accel_entries);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyAcceleratorTableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_accel_src = call.get_arg();
        let lp_accel_dst = call.get_arg();
        let c_accel_entries = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyAcceleratorTableW(h_accel_src, lp_accel_dst, c_accel_entries);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_icon = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyIcon(h_icon);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyImage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h = call.get_arg();
        let r#type = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CopyImage(h, r#type, cx, cy, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateAcceleratorTableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let paccel = call.get_arg();
        let c_accel = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateAcceleratorTableA(paccel, c_accel);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateAcceleratorTableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let paccel = call.get_arg();
        let c_accel = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateAcceleratorTableW(paccel, c_accel);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inst = call.get_arg();
        let x_hot_spot = call.get_arg();
        let y_hot_spot = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let pv_and_plane = call.get_arg();
        let pv_xor_plane = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateCursor(
            h_inst,
            x_hot_spot,
            y_hot_spot,
            n_width,
            n_height,
            pv_and_plane,
            pv_xor_plane,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogIndirectParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateDialogIndirectParamA(
            h_instance,
            lp_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogIndirectParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateDialogIndirectParamW(
            h_instance,
            lp_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateDialogParamA(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateDialogParamW(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let c_planes = call.get_arg();
        let c_bits_pixel = call.get_arg();
        let lpb_an_dbits = call.get_arg();
        let lpb_xo_rbits = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateIcon(
            h_instance,
            n_width,
            n_height,
            c_planes,
            c_bits_pixel,
            lpb_an_dbits,
            lpb_xo_rbits,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIconFromResource(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let dw_res_size = call.get_arg();
        let f_icon = call.get_arg();
        let dw_ver = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateIconFromResource(presbits, dw_res_size, f_icon, dw_ver);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIconFromResourceEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let dw_res_size = call.get_arg();
        let f_icon = call.get_arg();
        let dw_ver = call.get_arg();
        let cx_desired = call.get_arg();
        let cy_desired = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateIconFromResourceEx(
            presbits,
            dw_res_size,
            f_icon,
            dw_ver,
            cx_desired,
            cy_desired,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMDIWindowA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_instance = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateMDIWindowA(
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_instance,
            l_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMDIWindowW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_instance = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateMDIWindowW(
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_instance,
            l_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.CreateMenu();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreatePopupMenu(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.CreatePopupMenu();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateWindowExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_ex_style = call.get_arg();
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_menu = call.get_arg();
        let h_instance = call.get_arg();
        let lp_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateWindowExA(
            dw_ex_style,
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_menu,
            h_instance,
            lp_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateWindowExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_ex_style = call.get_arg();
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_menu = call.get_arg();
        let h_instance = call.get_arg();
        let lp_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.CreateWindowExW(
            dw_ex_style,
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_menu,
            h_instance,
            lp_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefDlgProcA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefDlgProcA(h_dlg, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefDlgProcW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefDlgProcW(h_dlg, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefFrameProcA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_wnd_mdi_client = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefFrameProcA(h_wnd, h_wnd_mdi_client, u_msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefFrameProcW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_wnd_mdi_client = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefFrameProcW(h_wnd, h_wnd_mdi_client, u_msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefMDIChildProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefMDIChildProcA(h_wnd, u_msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefMDIChildProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefMDIChildProcW(h_wnd, u_msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefWindowProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefWindowProcA(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefWindowProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DefWindowProcW(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_win_pos_info = call.get_arg();
        let h_wnd = call.get_arg();
        let h_wnd_insert_after = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeferWindowPos(
            h_win_pos_info,
            h_wnd,
            h_wnd_insert_after,
            x,
            y,
            cx,
            cy,
            u_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeleteMenu(h_menu, u_position, u_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeregisterShellHookWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DeregisterShellHookWindow(hwnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyAcceleratorTable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_accel = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DestroyAcceleratorTable(h_accel);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.DestroyCaret();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_cursor = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DestroyCursor(h_cursor);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_icon = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DestroyIcon(h_icon);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DestroyMenu(h_menu);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DestroyWindow(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxIndirectParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let h_dialog_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DialogBoxIndirectParamA(
            h_instance,
            h_dialog_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxIndirectParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let h_dialog_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DialogBoxIndirectParamW(
            h_instance,
            h_dialog_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DialogBoxParamA(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DialogBoxParamW(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DisableProcessWindowsGhosting(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.DisableProcessWindowsGhosting();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DispatchMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DispatchMessageA(lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DispatchMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DispatchMessageW(lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DragObject(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let hwnd_from = call.get_arg();
        let fmt = call.get_arg();
        let data = call.get_arg();
        let hcur = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DragObject(hwnd_parent, hwnd_from, fmt, data, hcur);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DrawMenuBar(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.DrawMenuBar(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnableMenuItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_enable_item = call.get_arg();
        let u_enable = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnableMenuItem(h_menu, u_id_enable_item, u_enable);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndDeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_win_pos_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EndDeferWindowPos(h_win_pos_info);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndDialog(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EndDialog(h_dlg, n_result);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.EndMenu();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumChildWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumChildWindows(h_wnd_parent, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumPropsA(h_wnd, lp_enum_func);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumPropsExA(h_wnd, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumPropsExW(h_wnd, lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumPropsW(h_wnd, lp_enum_func);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumThreadWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_thread_id = call.get_arg();
        let lpfn = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumThreadWindows(dw_thread_id, lpfn, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumWindows(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.EnumWindows(lp_enum_func, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindWindowA(lp_class_name, lp_window_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let h_wnd_child_after = call.get_arg();
        let lpsz_class = call.get_arg();
        let lpsz_window = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindWindowExA(h_wnd_parent, h_wnd_child_after, lpsz_class, lpsz_window);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let h_wnd_child_after = call.get_arg();
        let lpsz_class = call.get_arg();
        let lpsz_window = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindWindowExW(h_wnd_parent, h_wnd_child_after, lpsz_class, lpsz_window);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FindWindowW(lp_class_name, lp_window_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlashWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let b_invert = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlashWindow(h_wnd, b_invert);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlashWindowEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfwi = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.FlashWindowEx(pfwi);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetAltTabInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let i_item = call.get_arg();
        let pati = call.get_arg();
        let psz_item_text = call.get_arg();
        let cch_item_text = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetAltTabInfoA(hwnd, i_item, pati, psz_item_text, cch_item_text);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetAltTabInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let i_item = call.get_arg();
        let pati = call.get_arg();
        let psz_item_text = call.get_arg();
        let cch_item_text = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetAltTabInfoW(hwnd, i_item, pati, psz_item_text, cch_item_text);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetAncestor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let ga_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetAncestor(hwnd, ga_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCaretBlinkTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCaretBlinkTime();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCaretPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCaretPos(lp_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassLongA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetClassLongA(h_wnd, n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassLongW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetClassLongW(h_wnd, n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassNameA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_class_name = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetClassNameA(h_wnd, lp_class_name, n_max_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassNameW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_class_name = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetClassNameW(h_wnd, lp_class_name, n_max_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetClassWord(h_wnd, n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClientRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetClientRect(h_wnd, lp_rect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClipCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetClipCursor(lp_rect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetCursor();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCursorInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCursorInfo(pci);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCursorPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetCursorPos(lp_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDesktopWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetDesktopWindow();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDialogBaseUnits(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetDialogBaseUnits();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgCtrlID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDlgCtrlID(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItem(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDlgItem(h_dlg, n_id_dlg_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemInt(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_translated = call.get_arg();
        let b_signed = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDlgItemInt(h_dlg, n_id_dlg_item, lp_translated, b_signed);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDlgItemTextA(h_dlg, n_id_dlg_item, lp_string, cch_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetDlgItemTextW(h_dlg, n_id_dlg_item, lp_string, cch_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetForegroundWindow();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGUIThreadInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_thread = call.get_arg();
        let pgui = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetGUIThreadInfo(id_thread, pgui);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetInputState(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetInputState();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLastActivePopup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLastActivePopup(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLayeredWindowAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pcr_key = call.get_arg();
        let pb_alpha = call.get_arg();
        let pdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetLayeredWindowAttributes(hwnd, pcr_key, pb_alpha, pdw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenu(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let id_object = call.get_arg();
        let id_item = call.get_arg();
        let pmbi = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuBarInfo(hwnd, id_object, id_item, pmbi);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuCheckMarkDimensions(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetMenuCheckMarkDimensions();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuDefaultItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let f_by_pos = call.get_arg();
        let gmdi_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuDefaultItem(h_menu, f_by_pos, gmdi_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuItemCount(h_menu);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let n_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuItemID(h_menu, n_pos);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemRect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let u_item = call.get_arg();
        let lprc_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuItemRect(h_wnd, h_menu, u_item, lprc_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuState(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuState(h_menu, u_id, u_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuStringA(h_menu, u_id_item, lp_string, cch_max, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMenuStringW(h_menu, u_id_item, lp_string, cch_max, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMessageA(lp_msg, h_wnd, w_msg_filter_min, w_msg_filter_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageExtraInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetMessageExtraInfo();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessagePos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetMessagePos();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetMessageTime();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetMessageW(lp_msg, h_wnd, w_msg_filter_min, w_msg_filter_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNextDlgGroupItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let h_ctl = call.get_arg();
        let b_previous = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNextDlgGroupItem(h_dlg, h_ctl, b_previous);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNextDlgTabItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let h_ctl = call.get_arg();
        let b_previous = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetNextDlgTabItem(h_dlg, h_ctl, b_previous);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetParent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetParent(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPhysicalCursorPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPhysicalCursorPos(lp_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultLayout(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pdw_default_layout = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetProcessDefaultLayout(pdw_default_layout);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPropA(h_wnd, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetPropW(h_wnd, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetQueueStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetQueueStatus(flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let id_object = call.get_arg();
        let psbi = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetScrollBarInfo(hwnd, id_object, psbi);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let n_bar = call.get_arg();
        let lpsi = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetScrollInfo(hwnd, n_bar, lpsi);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_bar = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetScrollPos(h_wnd, n_bar);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollRange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_bar = call.get_arg();
        let lp_min_pos = call.get_arg();
        let lp_max_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetScrollRange(h_wnd, n_bar, lp_min_pos, lp_max_pos);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetShellWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.GetShellWindow();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSubMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let n_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSubMenu(h_menu, n_pos);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSysColor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSysColor(n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let b_revert = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemMenu(h_wnd, b_revert);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemMetrics(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetSystemMetrics(n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTitleBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pti = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTitleBarInfo(hwnd, pti);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTopWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetTopWindow(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_cmd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindow(h_wnd, u_cmd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowDisplayAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let pdw_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowDisplayAffinity(h_wnd, pdw_affinity);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pwi = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowInfo(hwnd, pwi);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowLongA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowLongA(h_wnd, n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowLongW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowLongW(h_wnd, n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowModuleFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_file_name = call.get_arg();
        let cch_file_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowModuleFileNameA(hwnd, psz_file_name, cch_file_name_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowModuleFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_file_name = call.get_arg();
        let cch_file_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowModuleFileNameW(hwnd, psz_file_name, cch_file_name_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowPlacement(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lpwndpl = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowPlacement(h_wnd, lpwndpl);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowRect(h_wnd, lp_rect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowTextA(h_wnd, lp_string, n_max_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowTextLengthA(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowTextLengthW(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowTextW(h_wnd, lp_string, n_max_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowThreadProcessId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lpdw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowThreadProcessId(h_wnd, lpdw_process_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.GetWindowWord(h_wnd, n_index);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HideCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HideCaret(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HiliteMenuItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let u_id_hilite_item = call.get_arg();
        let u_hilite = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.HiliteMenuItem(h_wnd, h_menu, u_id_hilite_item, u_hilite);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InSendMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.InSendMessage();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InSendMessageEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InSendMessageEx(lp_reserved);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InheritWindowMonitor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let hwnd_inherit = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InheritWindowMonitor(hwnd, hwnd_inherit);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InsertMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InsertMenuA(h_menu, u_position, u_flags, u_id_new_item, lp_new_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InsertMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InsertMenuW(h_menu, u_position, u_flags, u_id_new_item, lp_new_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InternalGetWindowText(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let p_string = call.get_arg();
        let cch_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.InternalGetWindowText(h_wnd, p_string, cch_max_count);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsCharAlphaA(ch);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaNumericA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsCharAlphaNumericA(ch);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaNumericW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsCharAlphaNumericW(ch);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsCharAlphaW(ch);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharLowerA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsCharLowerA(ch);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharUpperA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsCharUpperA(ch);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharUpperW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsCharUpperW(ch);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsChild(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsChild(h_wnd_parent, h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDialogMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsDialogMessageA(h_dlg, lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDialogMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsDialogMessageW(h_dlg, lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsGUIThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let b_convert = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsGUIThread(b_convert);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsHungAppWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsHungAppWindow(hwnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsIconic(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsIconic(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsMenu(h_menu);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsProcessDPIAware(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.IsProcessDPIAware();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsWindow(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWindowUnicode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsWindowUnicode(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWindowVisible(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsWindowVisible(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWow64Message(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.IsWow64Message();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsZoomed(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.IsZoomed(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_KillTimer(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_id_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.KillTimer(h_wnd, u_id_event);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadAcceleratorsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_table_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadAcceleratorsA(h_instance, lp_table_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadAcceleratorsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_table_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadAcceleratorsW(h_instance, lp_table_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_cursor_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadCursorA(h_instance, lp_cursor_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorFromFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadCursorFromFileA(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorFromFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadCursorFromFileW(lp_file_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_cursor_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadCursorW(h_instance, lp_cursor_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadIconA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_icon_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadIconA(h_instance, lp_icon_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadIconW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_icon_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadIconW(h_instance, lp_icon_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadImageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inst = call.get_arg();
        let name = call.get_arg();
        let r#type = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let fu_load = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadImageA(h_inst, name, r#type, cx, cy, fu_load);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadImageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inst = call.get_arg();
        let name = call.get_arg();
        let r#type = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let fu_load = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadImageW(h_inst, name, r#type, cx, cy, fu_load);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_menu_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadMenuA(h_instance, lp_menu_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuIndirectA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_menu_template = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadMenuIndirectA(lp_menu_template);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuIndirectW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_menu_template = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadMenuIndirectW(lp_menu_template);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_menu_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadMenuW(h_instance, lp_menu_name);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let u_id = call.get_arg();
        let lp_buffer = call.get_arg();
        let cch_buffer_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadStringA(h_instance, u_id, lp_buffer, cch_buffer_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let u_id = call.get_arg();
        let lp_buffer = call.get_arg();
        let cch_buffer_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LoadStringW(h_instance, u_id, lp_buffer, cch_buffer_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LockSetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_lock_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LockSetForegroundWindow(u_lock_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LogicalToPhysicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LogicalToPhysicalPoint(h_wnd, lp_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LookupIconIdFromDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let f_icon = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LookupIconIdFromDirectory(presbits, f_icon);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LookupIconIdFromDirectoryEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let f_icon = call.get_arg();
        let cx_desired = call.get_arg();
        let cy_desired = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.LookupIconIdFromDirectoryEx(presbits, f_icon, cx_desired, cy_desired, flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapDialogRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MapDialogRect(h_dlg, lp_rect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MenuItemFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let pt_screen = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MenuItemFromPoint(h_wnd, h_menu, pt_screen);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MessageBoxA(h_wnd, lp_text, lp_caption, u_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let w_language_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MessageBoxExA(h_wnd, lp_text, lp_caption, u_type, w_language_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let w_language_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MessageBoxExW(h_wnd, lp_text, lp_caption, u_type, w_language_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MessageBoxW(h_wnd, lp_text, lp_caption, u_type);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ModifyMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mnu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ModifyMenuA(h_mnu, u_position, u_flags, u_id_new_item, lp_new_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ModifyMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mnu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ModifyMenuW(h_mnu, u_position, u_flags, u_id_new_item, lp_new_item);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let b_repaint = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MoveWindow(h_wnd, x, y, n_width, n_height, b_repaint);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MsgWaitForMultipleObjects(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let p_handles = call.get_arg();
        let f_wait_all = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let dw_wake_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MsgWaitForMultipleObjects(
            n_count,
            p_handles,
            f_wait_all,
            dw_milliseconds,
            dw_wake_mask,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MsgWaitForMultipleObjectsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let p_handles = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let dw_wake_mask = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.MsgWaitForMultipleObjectsEx(
            n_count,
            p_handles,
            dw_milliseconds,
            dw_wake_mask,
            dw_flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OemToCharA(p_src, p_dst);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OemToCharBuffA(lpsz_src, lpsz_dst, cch_dst_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OemToCharBuffW(lpsz_src, lpsz_dst, cch_dst_length);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OemToCharW(p_src, p_dst);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.OpenIcon(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let w_remove_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PeekMessageA(
            lp_msg,
            h_wnd,
            w_msg_filter_min,
            w_msg_filter_max,
            w_remove_msg,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let w_remove_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PeekMessageW(
            lp_msg,
            h_wnd,
            w_msg_filter_min,
            w_msg_filter_max,
            w_remove_msg,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PhysicalToLogicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PhysicalToLogicalPoint(h_wnd, lp_point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PostMessageA(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PostMessageW(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostQuitMessage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PostQuitMessage(n_exit_code);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostThreadMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_thread = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PostThreadMessageA(id_thread, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostThreadMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_thread = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PostThreadMessageW(id_thread, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrivateExtractIconsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let sz_file_name = call.get_arg();
        let n_icon_index = call.get_arg();
        let cx_icon = call.get_arg();
        let cy_icon = call.get_arg();
        let phicon = call.get_arg();
        let piconid = call.get_arg();
        let n_icons = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrivateExtractIconsA(
            sz_file_name,
            n_icon_index,
            cx_icon,
            cy_icon,
            phicon,
            piconid,
            n_icons,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrivateExtractIconsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let sz_file_name = call.get_arg();
        let n_icon_index = call.get_arg();
        let cx_icon = call.get_arg();
        let cy_icon = call.get_arg();
        let phicon = call.get_arg();
        let piconid = call.get_arg();
        let n_icons = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.PrivateExtractIconsW(
            sz_file_name,
            n_icon_index,
            cx_icon,
            cy_icon,
            phicon,
            piconid,
            n_icons,
            flags,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RealChildWindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let pt_parent_client_coords = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RealChildWindowFromPoint(hwnd_parent, pt_parent_client_coords);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RealGetWindowClassA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let ptsz_class_name = call.get_arg();
        let cch_class_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RealGetWindowClassA(hwnd, ptsz_class_name, cch_class_name_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RealGetWindowClassW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let ptsz_class_name = call.get_arg();
        let cch_class_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RealGetWindowClassW(hwnd, ptsz_class_name, cch_class_name_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterShellHookWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RegisterShellHookWindow(hwnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterWindowMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RegisterWindowMessageA(lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterWindowMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RegisterWindowMessageW(lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemoveMenu(h_menu, u_position, u_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemovePropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemovePropA(h_wnd, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemovePropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.RemovePropW(h_wnd, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplyMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let l_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ReplyMessage(l_result);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScrollWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let x_amount = call.get_arg();
        let y_amount = call.get_arg();
        let lp_rect = call.get_arg();
        let lp_clip_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ScrollWindow(h_wnd, x_amount, y_amount, lp_rect, lp_clip_rect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendDlgItemMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendDlgItemMessageA(h_dlg, n_id_dlg_item, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendDlgItemMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendDlgItemMessageW(h_dlg, n_id_dlg_item, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendMessageA(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageCallbackA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let lp_result_call_back = call.get_arg();
        let dw_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SendMessageCallbackA(h_wnd, msg, w_param, l_param, lp_result_call_back, dw_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageCallbackW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let lp_result_call_back = call.get_arg();
        let dw_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res =
            api.SendMessageCallbackW(h_wnd, msg, w_param, l_param, lp_result_call_back, dw_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageTimeoutA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let fu_flags = call.get_arg();
        let u_timeout = call.get_arg();
        let lpdw_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendMessageTimeoutA(
            h_wnd,
            msg,
            w_param,
            l_param,
            fu_flags,
            u_timeout,
            lpdw_result,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageTimeoutW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let fu_flags = call.get_arg();
        let u_timeout = call.get_arg();
        let lpdw_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendMessageTimeoutW(
            h_wnd,
            msg,
            w_param,
            l_param,
            fu_flags,
            u_timeout,
            lpdw_result,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendMessageW(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendNotifyMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendNotifyMessageA(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendNotifyMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SendNotifyMessageW(h_wnd, msg, w_param, l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCaretBlinkTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_m_seconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCaretBlinkTime(u_m_seconds);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCaretPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let x = call.get_arg();
        let y = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCaretPos(x, y);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetClassLongA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetClassLongA(h_wnd, n_index, dw_new_long);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetClassLongW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetClassLongW(h_wnd, n_index, dw_new_long);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetClassWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let w_new_word = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetClassWord(h_wnd, n_index, w_new_word);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCoalescableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_id_event = call.get_arg();
        let u_elapse = call.get_arg();
        let lp_timer_func = call.get_arg();
        let u_tolerance_delay = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCoalescableTimer(
            h_wnd,
            n_id_event,
            u_elapse,
            lp_timer_func,
            u_tolerance_delay,
        );
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_cursor = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCursor(h_cursor);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCursorPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let x = call.get_arg();
        let y = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetCursorPos(x, y);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDebugErrorLevel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_level = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetDebugErrorLevel(dw_level);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemInt(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let u_value = call.get_arg();
        let b_signed = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetDlgItemInt(h_dlg, n_id_dlg_item, u_value, b_signed);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetDlgItemTextA(h_dlg, n_id_dlg_item, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetDlgItemTextW(h_dlg, n_id_dlg_item, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetForegroundWindow(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLayeredWindowAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let cr_key = call.get_arg();
        let b_alpha = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetLayeredWindowAttributes(hwnd, cr_key, b_alpha, dw_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetMenu(h_wnd, h_menu);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMenuDefaultItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_item = call.get_arg();
        let f_by_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetMenuDefaultItem(h_menu, u_item, f_by_pos);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMessageExtraInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetMessageExtraInfo(l_param);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMessageQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let c_messages_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetMessageQueue(c_messages_max);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetParent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_child = call.get_arg();
        let h_wnd_new_parent = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetParent(h_wnd_child, h_wnd_new_parent);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPhysicalCursorPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let x = call.get_arg();
        let y = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetPhysicalCursorPos(x, y);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDPIAware(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.SetProcessDPIAware();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultLayout(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_default_layout = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetProcessDefaultLayout(dw_default_layout);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let h_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetPropA(h_wnd, lp_string, h_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let h_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetPropW(h_wnd, lp_string, h_data);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSysColors(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let c_elements = call.get_arg();
        let lpa_elements = call.get_arg();
        let lpa_rgb_values = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetSysColors(c_elements, lpa_elements, lpa_rgb_values);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemCursor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hcur = call.get_arg();
        let id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetSystemCursor(hcur, id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTimer(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_id_event = call.get_arg();
        let u_elapse = call.get_arg();
        let lp_timer_func = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetTimer(h_wnd, n_id_event, u_elapse, lp_timer_func);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowDisplayAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let dw_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowDisplayAffinity(h_wnd, dw_affinity);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowLongA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowLongA(h_wnd, n_index, dw_new_long);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowLongW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowLongW(h_wnd, n_index, dw_new_long);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowPlacement(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lpwndpl = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowPlacement(h_wnd, lpwndpl);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_wnd_insert_after = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowPos(h_wnd, h_wnd_insert_after, x, y, cx, cy, u_flags);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowTextA(h_wnd, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowTextW(h_wnd, lp_string);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let w_new_word = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowWord(h_wnd, n_index, w_new_word);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_filter_type = call.get_arg();
        let pfn_filter_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowsHookA(n_filter_type, pfn_filter_proc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_hook = call.get_arg();
        let lpfn = call.get_arg();
        let hmod = call.get_arg();
        let dw_thread_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowsHookExA(id_hook, lpfn, hmod, dw_thread_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_hook = call.get_arg();
        let lpfn = call.get_arg();
        let hmod = call.get_arg();
        let dw_thread_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowsHookExW(id_hook, lpfn, hmod, dw_thread_id);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_filter_type = call.get_arg();
        let pfn_filter_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SetWindowsHookW(n_filter_type, pfn_filter_proc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ShowCaret(h_wnd);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let b_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ShowCursor(b_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowOwnedPopups(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let f_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ShowOwnedPopups(h_wnd, f_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_cmd_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ShowWindow(h_wnd, n_cmd_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowWindowAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_cmd_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.ShowWindowAsync(h_wnd, n_cmd_show);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SoundSentry(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.SoundSentry();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SwitchToThisWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let f_unknown = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SwitchToThisWindow(hwnd, f_unknown);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SystemParametersInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ui_action = call.get_arg();
        let ui_param = call.get_arg();
        let pv_param = call.get_arg();
        let f_win_ini = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SystemParametersInfoA(ui_action, ui_param, pv_param, f_win_ini);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SystemParametersInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ui_action = call.get_arg();
        let ui_param = call.get_arg();
        let pv_param = call.get_arg();
        let f_win_ini = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.SystemParametersInfoW(ui_action, ui_param, pv_param, f_win_ini);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TileWindows(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let w_how = call.get_arg();
        let lp_rect = call.get_arg();
        let c_kids = call.get_arg();
        let lp_kids = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TileWindows(hwnd_parent, w_how, lp_rect, c_kids, lp_kids);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TrackPopupMenu(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_reserved = call.get_arg();
        let h_wnd = call.get_arg();
        let prc_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TrackPopupMenu(h_menu, u_flags, x, y, n_reserved, h_wnd, prc_rect);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TrackPopupMenuEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let hwnd = call.get_arg();
        let lptpm = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TrackPopupMenuEx(h_menu, u_flags, x, y, hwnd, lptpm);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateAcceleratorA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_acc_table = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateAcceleratorA(h_wnd, h_acc_table, lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateAcceleratorW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_acc_table = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateAcceleratorW(h_wnd, h_acc_table, lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateMDISysAccel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_client = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateMDISysAccel(h_wnd_client, lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateMessage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.TranslateMessage(lp_msg);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnhookWindowsHook(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_code = call.get_arg();
        let pfn_filter_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnhookWindowsHook(n_code, pfn_filter_proc);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnhookWindowsHookEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hhk = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnhookWindowsHookEx(hhk);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterClassA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let h_instance = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnregisterClassA(lp_class_name, h_instance);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterClassW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let h_instance = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.UnregisterClassW(lp_class_name, h_instance);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let res = api.WaitMessage();
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WindowFromPhysicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WindowFromPhysicalPoint(point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let point = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.WindowFromPoint(point);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wsprintfA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.wsprintfA(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wsprintfW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.wsprintfW(param_0, param_1);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wvsprintfA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let arglist = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.wvsprintfA(param_0, param_1, arglist);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wvsprintfW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let arglist = call.get_arg();
        let unwind_token = call.unwind_token();
        let res = api.wvsprintfW(param_0, param_1, arglist);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
