#![allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clashing_extern_declarations,
    clippy::all,
    unused_mut,
    unused_variables
)]
#[allow(unused)]
use crate::ExtendedContext;
#[allow(unused)]
use core_mem::ctx::FlatMemoryCtx;
#[allow(unused)]
use core_mem::ptr::PtrRepr;
#[allow(unused)]
use tracing::Callsite;
#[no_mangle]
extern "C" fn thunk_CloseHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CloseHandle");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Foundation::get_api(win32);
            let h_object = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_object = {:?}}}", h_object)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CloseHandle(h_object);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CompareObjectHandles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CompareObjectHandles",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Foundation::get_api(win32);
            let h_first_object_handle = call.get_arg();
            let h_second_object_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_first_object_handle = {:?}, h_second_object_handle = {:?}}}" , h_first_object_handle , h_second_object_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CompareObjectHandles(h_first_object_handle, h_second_object_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DuplicateHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DuplicateHandle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Foundation::get_api(win32);
            let h_source_process_handle = call.get_arg();
            let h_source_handle = call.get_arg();
            let h_target_process_handle = call.get_arg();
            let lp_target_handle = call.get_arg();
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let dw_options = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_source_process_handle = {:?}, h_source_handle = {:?}, h_target_process_handle = {:?}, lp_target_handle = {:?}, dw_desired_access = {:?}, b_inherit_handle = {:?}, dw_options = {:?}}}" , h_source_process_handle , h_source_handle , h_target_process_handle , lp_target_handle , dw_desired_access , b_inherit_handle , dw_options ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DuplicateHandle(
                h_source_process_handle,
                h_source_handle,
                h_target_process_handle,
                lp_target_handle,
                dw_desired_access,
                b_inherit_handle,
                dw_options,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetHandleInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetHandleInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Foundation::get_api(win32);
            let h_object = call.get_arg();
            let lpdw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_object = {:?}, lpdw_flags = {:?}}}",
                            h_object, lpdw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetHandleInformation(h_object, lpdw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLastError(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLastError",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Foundation::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetLastError();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetHandleInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetHandleInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Foundation::get_api(win32);
            let h_object = call.get_arg();
            let dw_mask = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_object = {:?}, dw_mask = {:?}, dw_flags = {:?}}}",
                            h_object, dw_mask, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetHandleInformation(h_object, dw_mask, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetLastError(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetLastError",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Foundation::get_api(win32);
            let dw_err_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_err_code = {:?}}}", dw_err_code)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetLastError(dw_err_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CompareStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CompareStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_cmp_flags = call.get_arg();
            let lp_string_1 = call.get_arg();
            let cch_count_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            let cch_count_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_cmp_flags = {:?}, lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}}}" , locale , dw_cmp_flags , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CompareStringA(
                locale,
                dw_cmp_flags,
                lp_string_1,
                cch_count_1,
                lp_string_2,
                cch_count_2,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CompareStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CompareStringEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_cmp_flags = call.get_arg();
            let lp_string_1 = call.get_arg();
            let cch_count_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            let cch_count_2 = call.get_arg();
            let lp_version_information = call.get_arg();
            let lp_reserved = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_cmp_flags = {:?}, lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}, lp_version_information = {:?}, lp_reserved = {:?}, l_param = {:?}}}" , lp_locale_name , dw_cmp_flags , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 , lp_version_information , lp_reserved , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CompareStringEx(
                lp_locale_name,
                dw_cmp_flags,
                lp_string_1,
                cch_count_1,
                lp_string_2,
                cch_count_2,
                lp_version_information,
                lp_reserved,
                l_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CompareStringOrdinal(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CompareStringOrdinal",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let cch_count_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            let cch_count_2 = call.get_arg();
            let b_ignore_case = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}, b_ignore_case = {:?}}}" , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 , b_ignore_case ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CompareStringOrdinal(
                lp_string_1,
                cch_count_1,
                lp_string_2,
                cch_count_2,
                b_ignore_case,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CompareStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CompareStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_cmp_flags = call.get_arg();
            let lp_string_1 = call.get_arg();
            let cch_count_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            let cch_count_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_cmp_flags = {:?}, lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}}}" , locale , dw_cmp_flags , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CompareStringW(
                locale,
                dw_cmp_flags,
                lp_string_1,
                cch_count_1,
                lp_string_2,
                cch_count_2,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ConvertDefaultLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ConvertDefaultLocale",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{locale = {:?}}}", locale)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ConvertDefaultLocale(locale);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumCalendarInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_cal_info_enum_proc = call.get_arg();
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_cal_info_enum_proc = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc , locale , calendar , cal_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumCalendarInfoA(lp_cal_info_enum_proc, locale, calendar, cal_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumCalendarInfoExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_cal_info_enum_proc_ex = call.get_arg();
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_cal_info_enum_proc_ex = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc_ex , locale , calendar , cal_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumCalendarInfoExA(lp_cal_info_enum_proc_ex, locale, calendar, cal_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumCalendarInfoExEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let p_cal_info_enum_proc_ex_ex = call.get_arg();
            let lp_locale_name = call.get_arg();
            let calendar = call.get_arg();
            let lp_reserved = call.get_arg();
            let cal_type = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{p_cal_info_enum_proc_ex_ex = {:?}, lp_locale_name = {:?}, calendar = {:?}, lp_reserved = {:?}, cal_type = {:?}, l_param = {:?}}}" , p_cal_info_enum_proc_ex_ex , lp_locale_name , calendar , lp_reserved , cal_type , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumCalendarInfoExEx(
                p_cal_info_enum_proc_ex_ex,
                lp_locale_name,
                calendar,
                lp_reserved,
                cal_type,
                l_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumCalendarInfoExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_cal_info_enum_proc_ex = call.get_arg();
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_cal_info_enum_proc_ex = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc_ex , locale , calendar , cal_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumCalendarInfoExW(lp_cal_info_enum_proc_ex, locale, calendar, cal_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumCalendarInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_cal_info_enum_proc = call.get_arg();
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_cal_info_enum_proc = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc , locale , calendar , cal_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumCalendarInfoW(lp_cal_info_enum_proc, locale, calendar, cal_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumDateFormatsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_date_fmt_enum_proc = call.get_arg();
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_date_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}" , lp_date_fmt_enum_proc , locale , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumDateFormatsA(lp_date_fmt_enum_proc, locale, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumDateFormatsExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_date_fmt_enum_proc_ex = call.get_arg();
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_date_fmt_enum_proc_ex = {:?}, locale = {:?}, dw_flags = {:?}}}" , lp_date_fmt_enum_proc_ex , locale , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumDateFormatsExA(lp_date_fmt_enum_proc_ex, locale, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumDateFormatsExEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_date_fmt_enum_proc_ex_ex = call.get_arg();
            let lp_locale_name = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_date_fmt_enum_proc_ex_ex = {:?}, lp_locale_name = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_date_fmt_enum_proc_ex_ex , lp_locale_name , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumDateFormatsExEx(
                lp_date_fmt_enum_proc_ex_ex,
                lp_locale_name,
                dw_flags,
                l_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumDateFormatsExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_date_fmt_enum_proc_ex = call.get_arg();
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_date_fmt_enum_proc_ex = {:?}, locale = {:?}, dw_flags = {:?}}}" , lp_date_fmt_enum_proc_ex , locale , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumDateFormatsExW(lp_date_fmt_enum_proc_ex, locale, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumDateFormatsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_date_fmt_enum_proc = call.get_arg();
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_date_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}" , lp_date_fmt_enum_proc , locale , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumDateFormatsW(lp_date_fmt_enum_proc, locale, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumLanguageGroupLocalesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumLanguageGroupLocalesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_lang_group_locale_enum_proc = call.get_arg();
            let language_group = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_lang_group_locale_enum_proc = {:?}, language_group = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_lang_group_locale_enum_proc , language_group , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumLanguageGroupLocalesA(
                lp_lang_group_locale_enum_proc,
                language_group,
                dw_flags,
                l_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumLanguageGroupLocalesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumLanguageGroupLocalesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_lang_group_locale_enum_proc = call.get_arg();
            let language_group = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_lang_group_locale_enum_proc = {:?}, language_group = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_lang_group_locale_enum_proc , language_group , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumLanguageGroupLocalesW(
                lp_lang_group_locale_enum_proc,
                language_group,
                dw_flags,
                l_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemCodePagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemCodePagesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_code_page_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_code_page_enum_proc = {:?}, dw_flags = {:?}}}",
                            lp_code_page_enum_proc, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumSystemCodePagesA(lp_code_page_enum_proc, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemCodePagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemCodePagesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_code_page_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_code_page_enum_proc = {:?}, dw_flags = {:?}}}",
                            lp_code_page_enum_proc, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumSystemCodePagesW(lp_code_page_enum_proc, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemGeoID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemGeoID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let geo_class = call.get_arg();
            let parent_geo_id = call.get_arg();
            let lp_geo_enum_proc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{geo_class = {:?}, parent_geo_id = {:?}, lp_geo_enum_proc = {:?}}}" , geo_class , parent_geo_id , lp_geo_enum_proc ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumSystemGeoID(geo_class, parent_geo_id, lp_geo_enum_proc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemGeoNames(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemGeoNames",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let geo_class = call.get_arg();
            let geo_enum_proc = call.get_arg();
            let data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{geo_class = {:?}, geo_enum_proc = {:?}, data = {:?}}}",
                            geo_class, geo_enum_proc, data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumSystemGeoNames(geo_class, geo_enum_proc, data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLanguageGroupsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemLanguageGroupsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_language_group_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_language_group_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_language_group_enum_proc , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumSystemLanguageGroupsA(lp_language_group_enum_proc, dw_flags, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLanguageGroupsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemLanguageGroupsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_language_group_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_language_group_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_language_group_enum_proc , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumSystemLanguageGroupsW(lp_language_group_enum_proc, dw_flags, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemLocalesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_locale_enum_proc = {:?}, dw_flags = {:?}}}",
                            lp_locale_enum_proc, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumSystemLocalesA(lp_locale_enum_proc, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemLocalesEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_enum_proc_ex = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            let lp_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_enum_proc_ex = {:?}, dw_flags = {:?}, l_param = {:?}, lp_reserved = {:?}}}" , lp_locale_enum_proc_ex , dw_flags , l_param , lp_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.EnumSystemLocalesEx(lp_locale_enum_proc_ex, dw_flags, l_param, lp_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumSystemLocalesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_locale_enum_proc = {:?}, dw_flags = {:?}}}",
                            lp_locale_enum_proc, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumSystemLocalesW(lp_locale_enum_proc, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumTimeFormatsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_time_fmt_enum_proc = call.get_arg();
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_time_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}" , lp_time_fmt_enum_proc , locale , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumTimeFormatsA(lp_time_fmt_enum_proc, locale, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumTimeFormatsEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_time_fmt_enum_proc_ex = call.get_arg();
            let lp_locale_name = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_time_fmt_enum_proc_ex = {:?}, lp_locale_name = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_time_fmt_enum_proc_ex , lp_locale_name , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.EnumTimeFormatsEx(lp_time_fmt_enum_proc_ex, lp_locale_name, dw_flags, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumTimeFormatsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_time_fmt_enum_proc = call.get_arg();
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_time_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}" , lp_time_fmt_enum_proc , locale , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumTimeFormatsW(lp_time_fmt_enum_proc, locale, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumUILanguagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumUILanguagesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_ui_language_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_ui_language_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_ui_language_enum_proc , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumUILanguagesA(lp_ui_language_enum_proc, dw_flags, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumUILanguagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumUILanguagesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_ui_language_enum_proc = call.get_arg();
            let dw_flags = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_ui_language_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_ui_language_enum_proc , dw_flags , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumUILanguagesW(lp_ui_language_enum_proc, dw_flags, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNLSString(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNLSString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_find_nls_string_flags = call.get_arg();
            let lp_string_source = call.get_arg();
            let cch_source = call.get_arg();
            let lp_string_value = call.get_arg();
            let cch_value = call.get_arg();
            let pcch_found = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_find_nls_string_flags = {:?}, lp_string_source = {:?}, cch_source = {:?}, lp_string_value = {:?}, cch_value = {:?}, pcch_found = {:?}}}" , locale , dw_find_nls_string_flags , lp_string_source , cch_source , lp_string_value , cch_value , pcch_found ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindNLSString(
                locale,
                dw_find_nls_string_flags,
                lp_string_source,
                cch_source,
                lp_string_value,
                cch_value,
                pcch_found,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNLSStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNLSStringEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_find_nls_string_flags = call.get_arg();
            let lp_string_source = call.get_arg();
            let cch_source = call.get_arg();
            let lp_string_value = call.get_arg();
            let cch_value = call.get_arg();
            let pcch_found = call.get_arg();
            let lp_version_information = call.get_arg();
            let lp_reserved = call.get_arg();
            let sort_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_find_nls_string_flags = {:?}, lp_string_source = {:?}, cch_source = {:?}, lp_string_value = {:?}, cch_value = {:?}, pcch_found = {:?}, lp_version_information = {:?}, lp_reserved = {:?}, sort_handle = {:?}}}" , lp_locale_name , dw_find_nls_string_flags , lp_string_source , cch_source , lp_string_value , cch_value , pcch_found , lp_version_information , lp_reserved , sort_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindNLSStringEx(
                lp_locale_name,
                dw_find_nls_string_flags,
                lp_string_source,
                cch_source,
                lp_string_value,
                cch_value,
                pcch_found,
                lp_version_information,
                lp_reserved,
                sort_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindStringOrdinal(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindStringOrdinal",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_find_string_ordinal_flags = call.get_arg();
            let lp_string_source = call.get_arg();
            let cch_source = call.get_arg();
            let lp_string_value = call.get_arg();
            let cch_value = call.get_arg();
            let b_ignore_case = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_find_string_ordinal_flags = {:?}, lp_string_source = {:?}, cch_source = {:?}, lp_string_value = {:?}, cch_value = {:?}, b_ignore_case = {:?}}}" , dw_find_string_ordinal_flags , lp_string_source , cch_source , lp_string_value , cch_value , b_ignore_case ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindStringOrdinal(
                dw_find_string_ordinal_flags,
                lp_string_source,
                cch_source,
                lp_string_value,
                cch_value,
                b_ignore_case,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FoldStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FoldStringA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_map_flags = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_dest_str = call.get_arg();
            let cch_dest = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FoldStringA(dw_map_flags, lp_src_str, cch_src, lp_dest_str, cch_dest);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FoldStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FoldStringW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_map_flags = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_dest_str = call.get_arg();
            let cch_dest = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FoldStringW(dw_map_flags, lp_src_str, cch_src, lp_dest_str, cch_dest);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetACP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetACP");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetACP();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCPInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetCPInfo");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let code_page = call.get_arg();
            let lp_cp_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{code_page = {:?}, lp_cp_info = {:?}}}",
                            code_page, lp_cp_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCPInfo(code_page, lp_cp_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCPInfoExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCPInfoExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let code_page = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_cp_info_ex = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{code_page = {:?}, dw_flags = {:?}, lp_cp_info_ex = {:?}}}" , code_page , dw_flags , lp_cp_info_ex ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCPInfoExA(code_page, dw_flags, lp_cp_info_ex);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCPInfoExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCPInfoExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let code_page = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_cp_info_ex = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{code_page = {:?}, dw_flags = {:?}, lp_cp_info_ex = {:?}}}" , code_page , dw_flags , lp_cp_info_ex ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCPInfoExW(code_page, dw_flags, lp_cp_info_ex);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCalendarInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            let lp_cal_data = call.get_arg();
            let cch_data = call.get_arg();
            let lp_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}, cch_data = {:?}, lp_value = {:?}}}" , locale , calendar , cal_type , lp_cal_data , cch_data , lp_value ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetCalendarInfoA(locale, calendar, cal_type, lp_cal_data, cch_data, lp_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCalendarInfoEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let calendar = call.get_arg();
            let lp_reserved = call.get_arg();
            let cal_type = call.get_arg();
            let lp_cal_data = call.get_arg();
            let cch_data = call.get_arg();
            let lp_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, calendar = {:?}, lp_reserved = {:?}, cal_type = {:?}, lp_cal_data = {:?}, cch_data = {:?}, lp_value = {:?}}}" , lp_locale_name , calendar , lp_reserved , cal_type , lp_cal_data , cch_data , lp_value ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCalendarInfoEx(
                lp_locale_name,
                calendar,
                lp_reserved,
                cal_type,
                lp_cal_data,
                cch_data,
                lp_value,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCalendarInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            let lp_cal_data = call.get_arg();
            let cch_data = call.get_arg();
            let lp_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}, cch_data = {:?}, lp_value = {:?}}}" , locale , calendar , cal_type , lp_cal_data , cch_data , lp_value ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetCalendarInfoW(locale, calendar, cal_type, lp_cal_data, cch_data, lp_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrencyFormatA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_value = call.get_arg();
            let lp_format = call.get_arg();
            let lp_currency_str = call.get_arg();
            let cch_currency = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_currency_str = {:?}, cch_currency = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_currency_str , cch_currency ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCurrencyFormatA(
                locale,
                dw_flags,
                lp_value,
                lp_format,
                lp_currency_str,
                cch_currency,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrencyFormatEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_value = call.get_arg();
            let lp_format = call.get_arg();
            let lp_currency_str = call.get_arg();
            let cch_currency = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_currency_str = {:?}, cch_currency = {:?}}}" , lp_locale_name , dw_flags , lp_value , lp_format , lp_currency_str , cch_currency ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCurrencyFormatEx(
                lp_locale_name,
                dw_flags,
                lp_value,
                lp_format,
                lp_currency_str,
                cch_currency,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrencyFormatW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_value = call.get_arg();
            let lp_format = call.get_arg();
            let lp_currency_str = call.get_arg();
            let cch_currency = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_currency_str = {:?}, cch_currency = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_currency_str , cch_currency ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCurrencyFormatW(
                locale,
                dw_flags,
                lp_value,
                lp_format,
                lp_currency_str,
                cch_currency,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDateFormatA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_date = call.get_arg();
            let lp_format = call.get_arg();
            let lp_date_str = call.get_arg();
            let cch_date = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_date = {:?}, lp_format = {:?}, lp_date_str = {:?}, cch_date = {:?}}}" , locale , dw_flags , lp_date , lp_format , lp_date_str , cch_date ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetDateFormatA(locale, dw_flags, lp_date, lp_format, lp_date_str, cch_date);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDateFormatEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_date = call.get_arg();
            let lp_format = call.get_arg();
            let lp_date_str = call.get_arg();
            let cch_date = call.get_arg();
            let lp_calendar = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_date = {:?}, lp_format = {:?}, lp_date_str = {:?}, cch_date = {:?}, lp_calendar = {:?}}}" , lp_locale_name , dw_flags , lp_date , lp_format , lp_date_str , cch_date , lp_calendar ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDateFormatEx(
                lp_locale_name,
                dw_flags,
                lp_date,
                lp_format,
                lp_date_str,
                cch_date,
                lp_calendar,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDateFormatW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_date = call.get_arg();
            let lp_format = call.get_arg();
            let lp_date_str = call.get_arg();
            let cch_date = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_date = {:?}, lp_format = {:?}, lp_date_str = {:?}, cch_date = {:?}}}" , locale , dw_flags , lp_date , lp_format , lp_date_str , cch_date ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetDateFormatW(locale, dw_flags, lp_date, lp_format, lp_date_str, cch_date);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDistanceOfClosestLanguageInList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDistanceOfClosestLanguageInList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let psz_language = call.get_arg();
            let psz_languages_list = call.get_arg();
            let wch_list_delimiter = call.get_arg();
            let p_closest_distance = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psz_language = {:?}, psz_languages_list = {:?}, wch_list_delimiter = {:?}, p_closest_distance = {:?}}}" , psz_language , psz_languages_list , wch_list_delimiter , p_closest_distance ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDistanceOfClosestLanguageInList(
                psz_language,
                psz_languages_list,
                wch_list_delimiter,
                p_closest_distance,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDurationFormat(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDurationFormat",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_duration = call.get_arg();
            let ull_duration = call.get_arg();
            let lp_format = call.get_arg();
            let lp_duration_str = call.get_arg();
            let cch_duration = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_duration = {:?}, ull_duration = {:?}, lp_format = {:?}, lp_duration_str = {:?}, cch_duration = {:?}}}" , locale , dw_flags , lp_duration , ull_duration , lp_format , lp_duration_str , cch_duration ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDurationFormat(
                locale,
                dw_flags,
                lp_duration,
                ull_duration,
                lp_format,
                lp_duration_str,
                cch_duration,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDurationFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDurationFormatEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_duration = call.get_arg();
            let ull_duration = call.get_arg();
            let lp_format = call.get_arg();
            let lp_duration_str = call.get_arg();
            let cch_duration = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_duration = {:?}, ull_duration = {:?}, lp_format = {:?}, lp_duration_str = {:?}, cch_duration = {:?}}}" , lp_locale_name , dw_flags , lp_duration , ull_duration , lp_format , lp_duration_str , cch_duration ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDurationFormatEx(
                lp_locale_name,
                dw_flags,
                lp_duration,
                ull_duration,
                lp_format,
                lp_duration_str,
                cch_duration,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileMUIInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileMUIInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pcwsz_file_path = call.get_arg();
            let p_file_mui_info = call.get_arg();
            let pcb_file_mui_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pcwsz_file_path = {:?}, p_file_mui_info = {:?}, pcb_file_mui_info = {:?}}}" , dw_flags , pcwsz_file_path , p_file_mui_info , pcb_file_mui_info ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileMUIInfo(
                dw_flags,
                pcwsz_file_path,
                p_file_mui_info,
                pcb_file_mui_info,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileMUIPath(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileMUIPath",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pcwsz_file_path = call.get_arg();
            let pwsz_language = call.get_arg();
            let pcch_language = call.get_arg();
            let pwsz_file_mui_path = call.get_arg();
            let pcch_file_mui_path = call.get_arg();
            let pulul_enumerator = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pcwsz_file_path = {:?}, pwsz_language = {:?}, pcch_language = {:?}, pwsz_file_mui_path = {:?}, pcch_file_mui_path = {:?}, pulul_enumerator = {:?}}}" , dw_flags , pcwsz_file_path , pwsz_language , pcch_language , pwsz_file_mui_path , pcch_file_mui_path , pulul_enumerator ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileMUIPath(
                dw_flags,
                pcwsz_file_path,
                pwsz_language,
                pcch_language,
                pwsz_file_mui_path,
                pcch_file_mui_path,
                pulul_enumerator,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetGeoInfoA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let location = call.get_arg();
            let geo_type = call.get_arg();
            let lp_geo_data = call.get_arg();
            let cch_data = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{location = {:?}, geo_type = {:?}, lp_geo_data = {:?}, cch_data = {:?}, lang_id = {:?}}}" , location , geo_type , lp_geo_data , cch_data , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetGeoInfoA(location, geo_type, lp_geo_data, cch_data, lang_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetGeoInfoEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let location = call.get_arg();
            let geo_type = call.get_arg();
            let geo_data = call.get_arg();
            let geo_data_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{location = {:?}, geo_type = {:?}, geo_data = {:?}, geo_data_count = {:?}}}" , location , geo_type , geo_data , geo_data_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetGeoInfoEx(location, geo_type, geo_data, geo_data_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetGeoInfoW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let location = call.get_arg();
            let geo_type = call.get_arg();
            let lp_geo_data = call.get_arg();
            let cch_data = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{location = {:?}, geo_type = {:?}, lp_geo_data = {:?}, cch_data = {:?}, lang_id = {:?}}}" , location , geo_type , lp_geo_data , cch_data , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetGeoInfoW(location, geo_type, lp_geo_data, cch_data, lang_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLocaleInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let lc_type = call.get_arg();
            let lp_lc_data = call.get_arg();
            let cch_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}, cch_data = {:?}}}" , locale , lc_type , lp_lc_data , cch_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLocaleInfoA(locale, lc_type, lp_lc_data, cch_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLocaleInfoEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let lc_type = call.get_arg();
            let lp_lc_data = call.get_arg();
            let cch_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, lc_type = {:?}, lp_lc_data = {:?}, cch_data = {:?}}}" , lp_locale_name , lc_type , lp_lc_data , cch_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLocaleInfoEx(lp_locale_name, lc_type, lp_lc_data, cch_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLocaleInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let lc_type = call.get_arg();
            let lp_lc_data = call.get_arg();
            let cch_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}, cch_data = {:?}}}" , locale , lc_type , lp_lc_data , cch_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLocaleInfoW(locale, lc_type, lp_lc_data, cch_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNLSVersion(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNLSVersion",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let function = call.get_arg();
            let locale = call.get_arg();
            let lp_version_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{function = {:?}, locale = {:?}, lp_version_information = {:?}}}" , function , locale , lp_version_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNLSVersion(function, locale, lp_version_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNLSVersionEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNLSVersionEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let function = call.get_arg();
            let lp_locale_name = call.get_arg();
            let lp_version_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{function = {:?}, lp_locale_name = {:?}, lp_version_information = {:?}}}" , function , lp_locale_name , lp_version_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNLSVersionEx(function, lp_locale_name, lp_version_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumberFormatA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_value = call.get_arg();
            let lp_format = call.get_arg();
            let lp_number_str = call.get_arg();
            let cch_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_number_str = {:?}, cch_number = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_number_str , cch_number ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNumberFormatA(
                locale,
                dw_flags,
                lp_value,
                lp_format,
                lp_number_str,
                cch_number,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumberFormatEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_value = call.get_arg();
            let lp_format = call.get_arg();
            let lp_number_str = call.get_arg();
            let cch_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_number_str = {:?}, cch_number = {:?}}}" , lp_locale_name , dw_flags , lp_value , lp_format , lp_number_str , cch_number ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNumberFormatEx(
                lp_locale_name,
                dw_flags,
                lp_value,
                lp_format,
                lp_number_str,
                cch_number,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumberFormatW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_value = call.get_arg();
            let lp_format = call.get_arg();
            let lp_number_str = call.get_arg();
            let cch_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_number_str = {:?}, cch_number = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_number_str , cch_number ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNumberFormatW(
                locale,
                dw_flags,
                lp_value,
                lp_format,
                lp_number_str,
                cch_number,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetOEMCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetOEMCP");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetOEMCP();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessPreferredUILanguages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pul_num_languages = call.get_arg();
            let pwsz_languages_buffer = call.get_arg();
            let pcch_languages_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessPreferredUILanguages(
                dw_flags,
                pul_num_languages,
                pwsz_languages_buffer,
                pcch_languages_buffer,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStringScripts(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStringScripts",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_string = call.get_arg();
            let cch_string = call.get_arg();
            let lp_scripts = call.get_arg();
            let cch_scripts = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_string = {:?}, cch_string = {:?}, lp_scripts = {:?}, cch_scripts = {:?}}}" , dw_flags , lp_string , cch_string , lp_scripts , cch_scripts ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetStringScripts(dw_flags, lp_string, cch_string, lp_scripts, cch_scripts);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStringTypeA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_info_type = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_char_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , locale , dw_info_type , lp_src_str , cch_src , lp_char_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetStringTypeA(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStringTypeExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_info_type = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_char_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , locale , dw_info_type , lp_src_str , cch_src , lp_char_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetStringTypeExA(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStringTypeExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_info_type = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_char_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , locale , dw_info_type , lp_src_str , cch_src , lp_char_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetStringTypeExW(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStringTypeW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_info_type = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_char_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , dw_info_type , lp_src_str , cch_src , lp_char_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetStringTypeW(dw_info_type, lp_src_str, cch_src, lp_char_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemDefaultLCID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemDefaultLCID();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLangID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemDefaultLangID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemDefaultLangID();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemDefaultLocaleName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let cch_locale_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_locale_name = {:?}, cch_locale_name = {:?}}}",
                            lp_locale_name, cch_locale_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemDefaultLocaleName(lp_locale_name, cch_locale_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemDefaultUILanguage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemDefaultUILanguage();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemPreferredUILanguages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pul_num_languages = call.get_arg();
            let pwsz_languages_buffer = call.get_arg();
            let pcch_languages_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemPreferredUILanguages(
                dw_flags,
                pul_num_languages,
                pwsz_languages_buffer,
                pcch_languages_buffer,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadLocale",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadLocale();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadPreferredUILanguages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pul_num_languages = call.get_arg();
            let pwsz_languages_buffer = call.get_arg();
            let pcch_languages_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetThreadPreferredUILanguages(
                dw_flags,
                pul_num_languages,
                pwsz_languages_buffer,
                pcch_languages_buffer,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadUILanguage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadUILanguage();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTimeFormatA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_time = call.get_arg();
            let lp_format = call.get_arg();
            let lp_time_str = call.get_arg();
            let cch_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_time = {:?}, lp_format = {:?}, lp_time_str = {:?}, cch_time = {:?}}}" , locale , dw_flags , lp_time , lp_format , lp_time_str , cch_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetTimeFormatA(locale, dw_flags, lp_time, lp_format, lp_time_str, cch_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTimeFormatEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_time = call.get_arg();
            let lp_format = call.get_arg();
            let lp_time_str = call.get_arg();
            let cch_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_time = {:?}, lp_format = {:?}, lp_time_str = {:?}, cch_time = {:?}}}" , lp_locale_name , dw_flags , lp_time , lp_format , lp_time_str , cch_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetTimeFormatEx(
                lp_locale_name,
                dw_flags,
                lp_time,
                lp_format,
                lp_time_str,
                cch_time,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTimeFormatW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_time = call.get_arg();
            let lp_format = call.get_arg();
            let lp_time_str = call.get_arg();
            let cch_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_flags = {:?}, lp_time = {:?}, lp_format = {:?}, lp_time_str = {:?}, cch_time = {:?}}}" , locale , dw_flags , lp_time , lp_format , lp_time_str , cch_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetTimeFormatW(locale, dw_flags, lp_time, lp_format, lp_time_str, cch_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUILanguageInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUILanguageInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pwmsz_language = call.get_arg();
            let pwsz_fallback_languages = call.get_arg();
            let pcch_fallback_languages = call.get_arg();
            let p_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pwmsz_language = {:?}, pwsz_fallback_languages = {:?}, pcch_fallback_languages = {:?}, p_attributes = {:?}}}" , dw_flags , pwmsz_language , pwsz_fallback_languages , pcch_fallback_languages , p_attributes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetUILanguageInfo(
                dw_flags,
                pwmsz_language,
                pwsz_fallback_languages,
                pcch_fallback_languages,
                p_attributes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultGeoName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserDefaultGeoName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let geo_name = call.get_arg();
            let geo_name_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{geo_name = {:?}, geo_name_count = {:?}}}",
                            geo_name, geo_name_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserDefaultGeoName(geo_name, geo_name_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserDefaultLCID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserDefaultLCID();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLangID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserDefaultLangID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserDefaultLangID();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserDefaultLocaleName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let cch_locale_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_locale_name = {:?}, cch_locale_name = {:?}}}",
                            lp_locale_name, cch_locale_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserDefaultLocaleName(lp_locale_name, cch_locale_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserDefaultUILanguage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserDefaultUILanguage();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserGeoID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserGeoID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let geo_class = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{geo_class = {:?}}}", geo_class)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserGeoID(geo_class);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserPreferredUILanguages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pul_num_languages = call.get_arg();
            let pwsz_languages_buffer = call.get_arg();
            let pcch_languages_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetUserPreferredUILanguages(
                dw_flags,
                pul_num_languages,
                pwsz_languages_buffer,
                pcch_languages_buffer,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IdnToAscii(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IdnToAscii");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_unicode_char_str = call.get_arg();
            let cch_unicode_char = call.get_arg();
            let lp_ascii_char_str = call.get_arg();
            let cch_ascii_char = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_unicode_char_str = {:?}, cch_unicode_char = {:?}, lp_ascii_char_str = {:?}, cch_ascii_char = {:?}}}" , dw_flags , lp_unicode_char_str , cch_unicode_char , lp_ascii_char_str , cch_ascii_char ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.IdnToAscii(
                dw_flags,
                lp_unicode_char_str,
                cch_unicode_char,
                lp_ascii_char_str,
                cch_ascii_char,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IdnToNameprepUnicode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IdnToNameprepUnicode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_unicode_char_str = call.get_arg();
            let cch_unicode_char = call.get_arg();
            let lp_nameprep_char_str = call.get_arg();
            let cch_nameprep_char = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_unicode_char_str = {:?}, cch_unicode_char = {:?}, lp_nameprep_char_str = {:?}, cch_nameprep_char = {:?}}}" , dw_flags , lp_unicode_char_str , cch_unicode_char , lp_nameprep_char_str , cch_nameprep_char ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.IdnToNameprepUnicode(
                dw_flags,
                lp_unicode_char_str,
                cch_unicode_char,
                lp_nameprep_char_str,
                cch_nameprep_char,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IdnToUnicode(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IdnToUnicode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_ascii_char_str = call.get_arg();
            let cch_ascii_char = call.get_arg();
            let lp_unicode_char_str = call.get_arg();
            let cch_unicode_char = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_ascii_char_str = {:?}, cch_ascii_char = {:?}, lp_unicode_char_str = {:?}, cch_unicode_char = {:?}}}" , dw_flags , lp_ascii_char_str , cch_ascii_char , lp_unicode_char_str , cch_unicode_char ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.IdnToUnicode(
                dw_flags,
                lp_ascii_char_str,
                cch_ascii_char,
                lp_unicode_char_str,
                cch_unicode_char,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsDBCSLeadByte(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsDBCSLeadByte",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let test_char = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{test_char = {:?}}}", test_char)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsDBCSLeadByte(test_char);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsDBCSLeadByteEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsDBCSLeadByteEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let code_page = call.get_arg();
            let test_char = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{code_page = {:?}, test_char = {:?}}}",
                            code_page, test_char
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsDBCSLeadByteEx(code_page, test_char);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsNLSDefinedString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsNLSDefinedString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let function = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_version_information = call.get_arg();
            let lp_string = call.get_arg();
            let cch_str = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{function = {:?}, dw_flags = {:?}, lp_version_information = {:?}, lp_string = {:?}, cch_str = {:?}}}" , function , dw_flags , lp_version_information , lp_string , cch_str ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.IsNLSDefinedString(
                function,
                dw_flags,
                lp_version_information,
                lp_string,
                cch_str,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsNormalizedString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsNormalizedString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let norm_form = call.get_arg();
            let lp_string = call.get_arg();
            let cw_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{norm_form = {:?}, lp_string = {:?}, cw_length = {:?}}}",
                            norm_form, lp_string, cw_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsNormalizedString(norm_form, lp_string, cw_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsTextUnicode(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsTextUnicode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lpv = call.get_arg();
            let i_size = call.get_arg();
            let lpi_result = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpv = {:?}, i_size = {:?}, lpi_result = {:?}}}",
                            lpv, i_size, lpi_result
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsTextUnicode(lpv, i_size, lpi_result);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsValidCodePage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsValidCodePage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let code_page = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{code_page = {:?}}}", code_page)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsValidCodePage(code_page);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsValidLanguageGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsValidLanguageGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let language_group = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{language_group = {:?}, dw_flags = {:?}}}",
                            language_group, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsValidLanguageGroup(language_group, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsValidLocale(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsValidLocale",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{locale = {:?}, dw_flags = {:?}}}",
                            locale, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsValidLocale(locale, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsValidLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsValidLocaleName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_locale_name = {:?}}}", lp_locale_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsValidLocaleName(lp_locale_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsValidNLSVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsValidNLSVersion",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let function = call.get_arg();
            let lp_locale_name = call.get_arg();
            let lp_version_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{function = {:?}, lp_locale_name = {:?}, lp_version_information = {:?}}}" , function , lp_locale_name , lp_version_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.IsValidNLSVersion(function, lp_locale_name, lp_version_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsWellFormedTag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsWellFormedTag",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let psz_tag = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{psz_tag = {:?}}}", psz_tag)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsWellFormedTag(psz_tag);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LCIDToLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LCIDToLocaleName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let lp_name = call.get_arg();
            let cch_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, lp_name = {:?}, cch_name = {:?}, dw_flags = {:?}}}" , locale , lp_name , cch_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LCIDToLocaleName(locale, lp_name, cch_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LCMapStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LCMapStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_map_flags = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_dest_str = call.get_arg();
            let cch_dest = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , locale , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LCMapStringA(
                locale,
                dw_map_flags,
                lp_src_str,
                cch_src,
                lp_dest_str,
                cch_dest,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LCMapStringEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LCMapStringEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_locale_name = call.get_arg();
            let dw_map_flags = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_dest_str = call.get_arg();
            let cch_dest = call.get_arg();
            let lp_version_information = call.get_arg();
            let lp_reserved = call.get_arg();
            let sort_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_locale_name = {:?}, dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}, lp_version_information = {:?}, lp_reserved = {:?}, sort_handle = {:?}}}" , lp_locale_name , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest , lp_version_information , lp_reserved , sort_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LCMapStringEx(
                lp_locale_name,
                dw_map_flags,
                lp_src_str,
                cch_src,
                lp_dest_str,
                cch_dest,
                lp_version_information,
                lp_reserved,
                sort_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LCMapStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LCMapStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let dw_map_flags = call.get_arg();
            let lp_src_str = call.get_arg();
            let cch_src = call.get_arg();
            let lp_dest_str = call.get_arg();
            let cch_dest = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , locale , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LCMapStringW(
                locale,
                dw_map_flags,
                lp_src_str,
                cch_src,
                lp_dest_str,
                cch_dest,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocaleNameToLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LocaleNameToLCID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_name = {:?}, dw_flags = {:?}}}",
                            lp_name, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocaleNameToLCID(lp_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MappingDoAction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MappingDoAction",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let p_bag = call.get_arg();
            let dw_range_index = call.get_arg();
            let psz_action_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{p_bag = {:?}, dw_range_index = {:?}, psz_action_id = {:?}}}" , p_bag , dw_range_index , psz_action_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MappingDoAction(p_bag, dw_range_index, psz_action_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MappingFreePropertyBag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MappingFreePropertyBag",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let p_bag = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{p_bag = {:?}}}", p_bag)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.MappingFreePropertyBag(p_bag);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MappingFreeServices(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MappingFreeServices",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let p_service_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{p_service_info = {:?}}}", p_service_info)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.MappingFreeServices(p_service_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MappingGetServices(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MappingGetServices",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let p_options = call.get_arg();
            let prg_services = call.get_arg();
            let pdw_services_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{p_options = {:?}, prg_services = {:?}, pdw_services_count = {:?}}}" , p_options , prg_services , pdw_services_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MappingGetServices(p_options, prg_services, pdw_services_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MappingRecognizeText(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MappingRecognizeText",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let p_service_info = call.get_arg();
            let psz_text = call.get_arg();
            let dw_length = call.get_arg();
            let dw_index = call.get_arg();
            let p_options = call.get_arg();
            let pbag = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{p_service_info = {:?}, psz_text = {:?}, dw_length = {:?}, dw_index = {:?}, p_options = {:?}, pbag = {:?}}}" , p_service_info , psz_text , dw_length , dw_index , p_options , pbag ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MappingRecognizeText(
                p_service_info,
                psz_text,
                dw_length,
                dw_index,
                p_options,
                pbag,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MultiByteToWideChar(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MultiByteToWideChar",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let code_page = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_multi_byte_str = call.get_arg();
            let cb_multi_byte = call.get_arg();
            let lp_wide_char_str = call.get_arg();
            let cch_wide_char = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{code_page = {:?}, dw_flags = {:?}, lp_multi_byte_str = {:?}, cb_multi_byte = {:?}, lp_wide_char_str = {:?}, cch_wide_char = {:?}}}" , code_page , dw_flags , lp_multi_byte_str , cb_multi_byte , lp_wide_char_str , cch_wide_char ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MultiByteToWideChar(
                code_page,
                dw_flags,
                lp_multi_byte_str,
                cb_multi_byte,
                lp_wide_char_str,
                cch_wide_char,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NormalizeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NormalizeString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let norm_form = call.get_arg();
            let lp_src_string = call.get_arg();
            let cw_src_length = call.get_arg();
            let lp_dst_string = call.get_arg();
            let cw_dst_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{norm_form = {:?}, lp_src_string = {:?}, cw_src_length = {:?}, lp_dst_string = {:?}, cw_dst_length = {:?}}}" , norm_form , lp_src_string , cw_src_length , lp_dst_string , cw_dst_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NormalizeString(
                norm_form,
                lp_src_string,
                cw_src_length,
                lp_dst_string,
                cw_dst_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NotifyUILanguageChange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NotifyUILanguageChange",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pcwstr_new_language = call.get_arg();
            let pcwstr_previous_language = call.get_arg();
            let dw_reserved = call.get_arg();
            let pdw_status_rtrn = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pcwstr_new_language = {:?}, pcwstr_previous_language = {:?}, dw_reserved = {:?}, pdw_status_rtrn = {:?}}}" , dw_flags , pcwstr_new_language , pcwstr_previous_language , dw_reserved , pdw_status_rtrn ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NotifyUILanguageChange(
                dw_flags,
                pcwstr_new_language,
                pcwstr_previous_language,
                dw_reserved,
                pdw_status_rtrn,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ResolveLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ResolveLocaleName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_name_to_resolve = call.get_arg();
            let lp_locale_name = call.get_arg();
            let cch_locale_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name_to_resolve = {:?}, lp_locale_name = {:?}, cch_locale_name = {:?}}}" , lp_name_to_resolve , lp_locale_name , cch_locale_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ResolveLocaleName(lp_name_to_resolve, lp_locale_name, cch_locale_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RestoreThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RestoreThreadPreferredUILanguages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let snapshot = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{snapshot = {:?}}}", snapshot)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RestoreThreadPreferredUILanguages(snapshot);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptApplyDigitSubstitution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptApplyDigitSubstitution",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let psds = call.get_arg();
            let psc = call.get_arg();
            let pss = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{psds = {:?}, psc = {:?}, pss = {:?}}}",
                            psds, psc, pss
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ScriptApplyDigitSubstitution(psds, psc, pss);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptBreak(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ScriptBreak");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let pwc_chars = call.get_arg();
            let c_chars = call.get_arg();
            let psa = call.get_arg();
            let psla = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwc_chars = {:?}, c_chars = {:?}, psa = {:?}, psla = {:?}}}" , pwc_chars , c_chars , psa , psla ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptBreak(pwc_chars, c_chars, psa, psla);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptCPtoX(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ScriptCPtoX");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let i_cp = call.get_arg();
            let f_trailing = call.get_arg();
            let c_chars = call.get_arg();
            let c_glyphs = call.get_arg();
            let pw_log_clust = call.get_arg();
            let psva = call.get_arg();
            let pi_advance = call.get_arg();
            let psa = call.get_arg();
            let pi_x = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{i_cp = {:?}, f_trailing = {:?}, c_chars = {:?}, c_glyphs = {:?}, pw_log_clust = {:?}, psva = {:?}, pi_advance = {:?}, psa = {:?}, pi_x = {:?}}}" , i_cp , f_trailing , c_chars , c_glyphs , pw_log_clust , psva , pi_advance , psa , pi_x ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptCPtoX(
                i_cp,
                f_trailing,
                c_chars,
                c_glyphs,
                pw_log_clust,
                psva,
                pi_advance,
                psa,
                pi_x,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptFreeCache(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptFreeCache",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let psc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psc = {:?}}}" , psc ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptFreeCache(psc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptGetLogicalWidths(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptGetLogicalWidths",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let psa = call.get_arg();
            let c_chars = call.get_arg();
            let c_glyphs = call.get_arg();
            let pi_glyph_width = call.get_arg();
            let pw_log_clust = call.get_arg();
            let psva = call.get_arg();
            let pi_dx = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psa = {:?}, c_chars = {:?}, c_glyphs = {:?}, pi_glyph_width = {:?}, pw_log_clust = {:?}, psva = {:?}, pi_dx = {:?}}}" , psa , c_chars , c_glyphs , pi_glyph_width , pw_log_clust , psva , pi_dx ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptGetLogicalWidths(
                psa,
                c_chars,
                c_glyphs,
                pi_glyph_width,
                pw_log_clust,
                psva,
                pi_dx,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptGetProperties(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptGetProperties",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let pp_sp = call.get_arg();
            let pi_num_scripts = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pp_sp = {:?}, pi_num_scripts = {:?}}}",
                            pp_sp, pi_num_scripts
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ScriptGetProperties(pp_sp, pi_num_scripts);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptIsComplex(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptIsComplex",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let pwc_in_chars = call.get_arg();
            let c_in_chars = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwc_in_chars = {:?}, c_in_chars = {:?}, dw_flags = {:?}}}" , pwc_in_chars , c_in_chars , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptIsComplex(pwc_in_chars, c_in_chars, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptItemize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptItemize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let pwc_in_chars = call.get_arg();
            let c_in_chars = call.get_arg();
            let c_max_items = call.get_arg();
            let ps_control = call.get_arg();
            let ps_state = call.get_arg();
            let p_items = call.get_arg();
            let pc_items = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwc_in_chars = {:?}, c_in_chars = {:?}, c_max_items = {:?}, ps_control = {:?}, ps_state = {:?}, p_items = {:?}, pc_items = {:?}}}" , pwc_in_chars , c_in_chars , c_max_items , ps_control , ps_state , p_items , pc_items ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptItemize(
                pwc_in_chars,
                c_in_chars,
                c_max_items,
                ps_control,
                ps_state,
                p_items,
                pc_items,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptItemizeOpenType(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptItemizeOpenType",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let pwc_in_chars = call.get_arg();
            let c_in_chars = call.get_arg();
            let c_max_items = call.get_arg();
            let ps_control = call.get_arg();
            let ps_state = call.get_arg();
            let p_items = call.get_arg();
            let p_script_tags = call.get_arg();
            let pc_items = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwc_in_chars = {:?}, c_in_chars = {:?}, c_max_items = {:?}, ps_control = {:?}, ps_state = {:?}, p_items = {:?}, p_script_tags = {:?}, pc_items = {:?}}}" , pwc_in_chars , c_in_chars , c_max_items , ps_control , ps_state , p_items , p_script_tags , pc_items ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptItemizeOpenType(
                pwc_in_chars,
                c_in_chars,
                c_max_items,
                ps_control,
                ps_state,
                p_items,
                p_script_tags,
                pc_items,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptJustify(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptJustify",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let psva = call.get_arg();
            let pi_advance = call.get_arg();
            let c_glyphs = call.get_arg();
            let i_dx = call.get_arg();
            let i_min_kashida = call.get_arg();
            let pi_justify = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psva = {:?}, pi_advance = {:?}, c_glyphs = {:?}, i_dx = {:?}, i_min_kashida = {:?}, pi_justify = {:?}}}" , psva , pi_advance , c_glyphs , i_dx , i_min_kashida , pi_justify ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.ScriptJustify(psva, pi_advance, c_glyphs, i_dx, i_min_kashida, pi_justify);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptLayout(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptLayout",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let c_runs = call.get_arg();
            let pb_level = call.get_arg();
            let pi_visual_to_logical = call.get_arg();
            let pi_logical_to_visual = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{c_runs = {:?}, pb_level = {:?}, pi_visual_to_logical = {:?}, pi_logical_to_visual = {:?}}}" , c_runs , pb_level , pi_visual_to_logical , pi_logical_to_visual ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.ScriptLayout(c_runs, pb_level, pi_visual_to_logical, pi_logical_to_visual);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptRecordDigitSubstitution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptRecordDigitSubstitution",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let psds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{locale = {:?}, psds = {:?}}}",
                            locale, psds
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ScriptRecordDigitSubstitution(locale, psds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptStringCPtoX(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptStringCPtoX",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            let icp = call.get_arg();
            let f_trailing = call.get_arg();
            let p_x = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{ssa = {:?}, icp = {:?}, f_trailing = {:?}, p_x = {:?}}}",
                            ssa, icp, f_trailing, p_x
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ScriptStringCPtoX(ssa, icp, f_trailing, p_x);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptStringFree(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptStringFree",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let pssa = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{pssa = {:?}}}", pssa)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ScriptStringFree(pssa);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptStringGetLogicalWidths(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptStringGetLogicalWidths",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            let pi_dx = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{ssa = {:?}, pi_dx = {:?}}}", ssa, pi_dx)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.ScriptStringGetLogicalWidths(ssa, pi_dx);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptStringGetOrder(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptStringGetOrder",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            let pu_order = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{ssa = {:?}, pu_order = {:?}}}",
                            ssa, pu_order
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ScriptStringGetOrder(ssa, pu_order);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptStringValidate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptStringValidate",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ssa = {:?}}}" , ssa ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptStringValidate(ssa);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptStringXtoCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptStringXtoCP",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            let i_x = call.get_arg();
            let pi_ch = call.get_arg();
            let pi_trailing = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ssa = {:?}, i_x = {:?}, pi_ch = {:?}, pi_trailing = {:?}}}" , ssa , i_x , pi_ch , pi_trailing ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptStringXtoCP(ssa, i_x, pi_ch, pi_trailing);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pLogAttr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptString_pLogAttr",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ssa = {:?}}}" , ssa ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptString_pLogAttr(ssa);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptString_pSize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ssa = {:?}}}" , ssa ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptString_pSize(ssa);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pcOutChars(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScriptString_pcOutChars",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let ssa = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ssa = {:?}}}" , ssa ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptString_pcOutChars(ssa);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScriptXtoCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ScriptXtoCP");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let i_x = call.get_arg();
            let c_chars = call.get_arg();
            let c_glyphs = call.get_arg();
            let pw_log_clust = call.get_arg();
            let psva = call.get_arg();
            let pi_advance = call.get_arg();
            let psa = call.get_arg();
            let pi_cp = call.get_arg();
            let pi_trailing = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{i_x = {:?}, c_chars = {:?}, c_glyphs = {:?}, pw_log_clust = {:?}, psva = {:?}, pi_advance = {:?}, psa = {:?}, pi_cp = {:?}, pi_trailing = {:?}}}" , i_x , c_chars , c_glyphs , pw_log_clust , psva , pi_advance , psa , pi_cp , pi_trailing ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScriptXtoCP(
                i_x,
                c_chars,
                c_glyphs,
                pw_log_clust,
                psva,
                pi_advance,
                psa,
                pi_cp,
                pi_trailing,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCalendarInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            let lp_cal_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}}}" , locale , calendar , cal_type , lp_cal_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetCalendarInfoA(locale, calendar, cal_type, lp_cal_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCalendarInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let calendar = call.get_arg();
            let cal_type = call.get_arg();
            let lp_cal_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}}}" , locale , calendar , cal_type , lp_cal_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetCalendarInfoW(locale, calendar, cal_type, lp_cal_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetLocaleInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetLocaleInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let lc_type = call.get_arg();
            let lp_lc_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}}}",
                            locale, lc_type, lp_lc_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetLocaleInfoA(locale, lc_type, lp_lc_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetLocaleInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetLocaleInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            let lc_type = call.get_arg();
            let lp_lc_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}}}",
                            locale, lc_type, lp_lc_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetLocaleInfoW(locale, lc_type, lp_lc_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessPreferredUILanguages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pwsz_languages_buffer = call.get_arg();
            let pul_num_languages = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pwsz_languages_buffer = {:?}, pul_num_languages = {:?}}}" , dw_flags , pwsz_languages_buffer , pul_num_languages ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessPreferredUILanguages(
                dw_flags,
                pwsz_languages_buffer,
                pul_num_languages,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadLocale",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let locale = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{locale = {:?}}}", locale)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadLocale(locale);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadPreferredUILanguages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let pwsz_languages_buffer = call.get_arg();
            let pul_num_languages = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, pwsz_languages_buffer = {:?}, pul_num_languages = {:?}}}" , dw_flags , pwsz_languages_buffer , pul_num_languages ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadPreferredUILanguages(
                dw_flags,
                pwsz_languages_buffer,
                pul_num_languages,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadPreferredUILanguages2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadPreferredUILanguages2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let flags = call.get_arg();
            let languages = call.get_arg();
            let num_languages_set = call.get_arg();
            let snapshot = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{flags = {:?}, languages = {:?}, num_languages_set = {:?}, snapshot = {:?}}}" , flags , languages , num_languages_set , snapshot ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SetThreadPreferredUILanguages2(flags, languages, num_languages_set, snapshot);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadUILanguage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lang_id = {:?}}}", lang_id)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadUILanguage(lang_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetUserGeoID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetUserGeoID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let geo_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{geo_id = {:?}}}", geo_id)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetUserGeoID(geo_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetUserGeoName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetUserGeoName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let geo_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{geo_name = {:?}}}", geo_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetUserGeoName(geo_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateCharsetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateCharsetInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_src = call.get_arg();
            let lp_cs = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_src = {:?}, lp_cs = {:?}, dw_flags = {:?}}}",
                            lp_src, lp_cs, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TranslateCharsetInfo(lp_src, lp_cs, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerifyScripts(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerifyScripts",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_locale_scripts = call.get_arg();
            let cch_locale_scripts = call.get_arg();
            let lp_test_scripts = call.get_arg();
            let cch_test_scripts = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_locale_scripts = {:?}, cch_locale_scripts = {:?}, lp_test_scripts = {:?}, cch_test_scripts = {:?}}}" , dw_flags , lp_locale_scripts , cch_locale_scripts , lp_test_scripts , cch_test_scripts ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerifyScripts(
                dw_flags,
                lp_locale_scripts,
                cch_locale_scripts,
                lp_test_scripts,
                cch_test_scripts,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WideCharToMultiByte(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WideCharToMultiByte",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let code_page = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_wide_char_str = call.get_arg();
            let cch_wide_char = call.get_arg();
            let lp_multi_byte_str = call.get_arg();
            let cb_multi_byte = call.get_arg();
            let lp_default_char = call.get_arg();
            let lp_used_default_char = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{code_page = {:?}, dw_flags = {:?}, lp_wide_char_str = {:?}, cch_wide_char = {:?}, lp_multi_byte_str = {:?}, cb_multi_byte = {:?}, lp_default_char = {:?}, lp_used_default_char = {:?}}}" , code_page , dw_flags , lp_wide_char_str , cch_wide_char , lp_multi_byte_str , cb_multi_byte , lp_default_char , lp_used_default_char ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WideCharToMultiByte(
                code_page,
                dw_flags,
                lp_wide_char_str,
                cch_wide_char,
                lp_multi_byte_str,
                cb_multi_byte,
                lp_default_char,
                lp_used_default_char,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcatA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcatA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcatA(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcatW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcatW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcatW(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcmpA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcmpA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcmpA(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcmpW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcmpW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcmpW(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcmpiA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcmpiA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcmpiA(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcmpiW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcmpiW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcmpiW(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcpyA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcpyA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcpyA(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcpyW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcpyW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
                            lp_string_1, lp_string_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrcpyW(lp_string_1, lp_string_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcpynA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcpynA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            let i_max_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}, i_max_length = {:?}}}" , lp_string_1 , lp_string_2 , i_max_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.lstrcpynA(lp_string_1, lp_string_2, i_max_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrcpynW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrcpynW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string_1 = call.get_arg();
            let lp_string_2 = call.get_arg();
            let i_max_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_string_1 = {:?}, lp_string_2 = {:?}, i_max_length = {:?}}}" , lp_string_1 , lp_string_2 , i_max_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.lstrcpynW(lp_string_1, lp_string_2, i_max_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrlenA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrlenA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_string = {:?}}}", lp_string)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrlenA(lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_lstrlenW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "lstrlenW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Globalization::get_api(win32);
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_string = {:?}}}", lp_string)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.lstrlenW(lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AreFileApisANSI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AreFileApisANSI",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AreFileApisANSI();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AreShortNamesEnabled(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AreShortNamesEnabled",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let handle = call.get_arg();
            let enabled = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{handle = {:?}, enabled = {:?}}}",
                            handle, enabled
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AreShortNamesEnabled(handle, enabled);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BackupRead(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "BackupRead");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_bytes_to_read = call.get_arg();
            let lp_number_of_bytes_read = call.get_arg();
            let b_abort = call.get_arg();
            let b_process_security = call.get_arg();
            let lp_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_read = {:?}, lp_number_of_bytes_read = {:?}, b_abort = {:?}, b_process_security = {:?}, lp_context = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_read , lp_number_of_bytes_read , b_abort , b_process_security , lp_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.BackupRead(
                h_file,
                lp_buffer,
                n_number_of_bytes_to_read,
                lp_number_of_bytes_read,
                b_abort,
                b_process_security,
                lp_context,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BackupSeek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "BackupSeek");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let dw_low_bytes_to_seek = call.get_arg();
            let dw_high_bytes_to_seek = call.get_arg();
            let lpdw_low_byte_seeked = call.get_arg();
            let lpdw_high_byte_seeked = call.get_arg();
            let lp_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, dw_low_bytes_to_seek = {:?}, dw_high_bytes_to_seek = {:?}, lpdw_low_byte_seeked = {:?}, lpdw_high_byte_seeked = {:?}, lp_context = {:?}}}" , h_file , dw_low_bytes_to_seek , dw_high_bytes_to_seek , lpdw_low_byte_seeked , lpdw_high_byte_seeked , lp_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.BackupSeek(
                h_file,
                dw_low_bytes_to_seek,
                dw_high_bytes_to_seek,
                lpdw_low_byte_seeked,
                lpdw_high_byte_seeked,
                lp_context,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BackupWrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "BackupWrite");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_bytes_to_write = call.get_arg();
            let lp_number_of_bytes_written = call.get_arg();
            let b_abort = call.get_arg();
            let b_process_security = call.get_arg();
            let lp_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_write = {:?}, lp_number_of_bytes_written = {:?}, b_abort = {:?}, b_process_security = {:?}, lp_context = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_write , lp_number_of_bytes_written , b_abort , b_process_security , lp_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.BackupWrite(
                h_file,
                lp_buffer,
                n_number_of_bytes_to_write,
                lp_number_of_bytes_written,
                b_abort,
                b_process_security,
                lp_context,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingRegisterBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "BuildIoRingRegisterBuffers",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            let count = call.get_arg();
            let buffers = call.get_arg();
            let user_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{io_ring = {:?}, count = {:?}, buffers = {:?}, user_data = {:?}}}" , io_ring , count , buffers , user_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.BuildIoRingRegisterBuffers(io_ring, count, buffers, user_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingRegisterFileHandles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "BuildIoRingRegisterFileHandles",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            let count = call.get_arg();
            let handles = call.get_arg();
            let user_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{io_ring = {:?}, count = {:?}, handles = {:?}, user_data = {:?}}}" , io_ring , count , handles , user_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.BuildIoRingRegisterFileHandles(io_ring, count, handles, user_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CheckNameLegalDOS8Dot3A(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CheckNameLegalDOS8Dot3A",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_name = call.get_arg();
            let lp_oem_name = call.get_arg();
            let oem_name_size = call.get_arg();
            let pb_name_contains_spaces = call.get_arg();
            let pb_name_legal = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_oem_name = {:?}, oem_name_size = {:?}, pb_name_contains_spaces = {:?}, pb_name_legal = {:?}}}" , lp_name , lp_oem_name , oem_name_size , pb_name_contains_spaces , pb_name_legal ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CheckNameLegalDOS8Dot3A(
                lp_name,
                lp_oem_name,
                oem_name_size,
                pb_name_contains_spaces,
                pb_name_legal,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CheckNameLegalDOS8Dot3W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CheckNameLegalDOS8Dot3W",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_name = call.get_arg();
            let lp_oem_name = call.get_arg();
            let oem_name_size = call.get_arg();
            let pb_name_contains_spaces = call.get_arg();
            let pb_name_legal = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_oem_name = {:?}, oem_name_size = {:?}, pb_name_contains_spaces = {:?}, pb_name_legal = {:?}}}" , lp_name , lp_oem_name , oem_name_size , pb_name_contains_spaces , pb_name_legal ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CheckNameLegalDOS8Dot3W(
                lp_name,
                lp_oem_name,
                oem_name_size,
                pb_name_contains_spaces,
                pb_name_legal,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseEncryptedFileRaw",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let pv_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pv_context = {:?}}}", pv_context)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.CloseEncryptedFileRaw(pv_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CloseIoRing");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{io_ring = {:?}}}", io_ring)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CloseIoRing(io_ring);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CommitComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CommitComplete",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CommitComplete(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CommitEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CommitEnlistment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CommitEnlistment(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CommitTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CommitTransaction",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{transaction_handle = {:?}}}",
                            transaction_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CommitTransaction(transaction_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CommitTransactionAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CommitTransactionAsync",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{transaction_handle = {:?}}}",
                            transaction_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CommitTransactionAsync(transaction_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CompareFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CompareFileTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_time_1 = call.get_arg();
            let lp_file_time_2 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_time_1 = {:?}, lp_file_time_2 = {:?}}}",
                            lp_file_time_1, lp_file_time_2
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CompareFileTime(lp_file_time_1, lp_file_time_2);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFile2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyFile2");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let pwsz_existing_file_name = call.get_arg();
            let pwsz_new_file_name = call.get_arg();
            let p_extended_parameters = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwsz_existing_file_name = {:?}, pwsz_new_file_name = {:?}, p_extended_parameters = {:?}}}" , pwsz_existing_file_name , pwsz_new_file_name , p_extended_parameters ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyFile2(
                pwsz_existing_file_name,
                pwsz_new_file_name,
                p_extended_parameters,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyFileA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let b_fail_if_exists = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, b_fail_if_exists = {:?}}}" , lp_existing_file_name , lp_new_file_name , b_fail_if_exists ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyFileA(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFileExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyFileExA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let pb_cancel = call.get_arg();
            let dw_copy_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyFileExA(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                pb_cancel,
                dw_copy_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFileExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyFileExW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let pb_cancel = call.get_arg();
            let dw_copy_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyFileExW(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                pb_cancel,
                dw_copy_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CopyFileFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let b_fail_if_exists = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, b_fail_if_exists = {:?}}}" , lp_existing_file_name , lp_new_file_name , b_fail_if_exists ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.CopyFileFromAppW(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CopyFileTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let pb_cancel = call.get_arg();
            let dw_copy_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyFileTransactedA(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                pb_cancel,
                dw_copy_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CopyFileTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let pb_cancel = call.get_arg();
            let dw_copy_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyFileTransactedW(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                pb_cancel,
                dw_copy_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyFileW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let b_fail_if_exists = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, b_fail_if_exists = {:?}}}" , lp_existing_file_name , lp_new_file_name , b_fail_if_exists ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyFileW(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyLZFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyLZFile");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let hf_source = call.get_arg();
            let hf_dest = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hf_source = {:?}, hf_dest = {:?}}}",
                            hf_source, hf_dest
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CopyLZFile(hf_source, hf_dest);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateIoRing",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let ioring_version = call.get_arg();
            let flags = call.get_arg();
            let submission_queue_size = call.get_arg();
            let completion_queue_size = call.get_arg();
            let h = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ioring_version = {:?}, flags = {:?}, submission_queue_size = {:?}, completion_queue_size = {:?}, h = {:?}}}" , ioring_version , flags , submission_queue_size , completion_queue_size , h ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateIoRing(
                ioring_version,
                flags,
                submission_queue_size,
                completion_queue_size,
                h,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateSymbolicLinkA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_symlink_file_name = call.get_arg();
            let lp_target_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}}}" , lp_symlink_file_name , lp_target_file_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateSymbolicLinkA(lp_symlink_file_name, lp_target_file_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateSymbolicLinkTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_symlink_file_name = call.get_arg();
            let lp_target_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_symlink_file_name , lp_target_file_name , dw_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateSymbolicLinkTransactedA(
                lp_symlink_file_name,
                lp_target_file_name,
                dw_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateSymbolicLinkTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_symlink_file_name = call.get_arg();
            let lp_target_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_symlink_file_name , lp_target_file_name , dw_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateSymbolicLinkTransactedW(
                lp_symlink_file_name,
                lp_target_file_name,
                dw_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateSymbolicLinkW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_symlink_file_name = call.get_arg();
            let lp_target_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}}}" , lp_symlink_file_name , lp_target_file_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateSymbolicLinkW(lp_symlink_file_name, lp_target_file_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateTapePartition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateTapePartition",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_partition_method = call.get_arg();
            let dw_count = call.get_arg();
            let dw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_partition_method = {:?}, dw_count = {:?}, dw_size = {:?}}}" , h_device , dw_partition_method , dw_count , dw_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateTapePartition(h_device, dw_partition_method, dw_count, dw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DecryptFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DecryptFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, dw_reserved = {:?}}}",
                            lp_file_name, dw_reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DecryptFileA(lp_file_name, dw_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DecryptFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DecryptFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, dw_reserved = {:?}}}",
                            lp_file_name, dw_reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DecryptFileW(lp_file_name, dw_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefineDosDeviceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefineDosDeviceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_device_name = call.get_arg();
            let lp_target_path = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_device_name = {:?}, lp_target_path = {:?}}}" , dw_flags , lp_device_name , lp_target_path ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefineDosDeviceA(dw_flags, lp_device_name, lp_target_path);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefineDosDeviceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefineDosDeviceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_device_name = call.get_arg();
            let lp_target_path = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_device_name = {:?}, lp_target_path = {:?}}}" , dw_flags , lp_device_name , lp_target_path ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefineDosDeviceW(dw_flags, lp_device_name, lp_target_path);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DeleteFileA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DeleteFileA(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteFileFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DeleteFileFromAppW(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteFileTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, h_transaction = {:?}}}",
                            lp_file_name, h_transaction
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteFileTransactedA(lp_file_name, h_transaction);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteFileTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, h_transaction = {:?}}}",
                            lp_file_name, h_transaction
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteFileTransactedW(lp_file_name, h_transaction);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DeleteFileW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DeleteFileW(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteVolumeMountPointA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_mount_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_volume_mount_point = {:?}}}",
                            lpsz_volume_mount_point
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteVolumeMountPointA(lpsz_volume_mount_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteVolumeMountPointW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_mount_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_volume_mount_point = {:?}}}",
                            lpsz_volume_mount_point
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteVolumeMountPointW(lpsz_volume_mount_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EncryptFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EncryptFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.EncryptFileA(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EncryptFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EncryptFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.EncryptFileW(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EncryptionDisable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EncryptionDisable",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dir_path = call.get_arg();
            let disable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dir_path = {:?}, disable = {:?}}}",
                            dir_path, disable
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EncryptionDisable(dir_path, disable);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EraseTape(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "EraseTape");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_erase_type = call.get_arg();
            let b_immediate = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_erase_type = {:?}, b_immediate = {:?}}}" , h_device , dw_erase_type , b_immediate ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EraseTape(h_device, dw_erase_type, b_immediate);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileEncryptionStatusA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileEncryptionStatusA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_status = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, lp_status = {:?}}}",
                            lp_file_name, lp_status
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FileEncryptionStatusA(lp_file_name, lp_status);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileEncryptionStatusW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileEncryptionStatusW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_status = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, lp_status = {:?}}}",
                            lp_file_name, lp_status
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FileEncryptionStatusW(lp_file_name, lp_status);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileTimeToLocalFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileTimeToLocalFileTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_time = call.get_arg();
            let lp_local_file_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_time = {:?}, lp_local_file_time = {:?}}}",
                            lp_file_time, lp_local_file_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FileTimeToLocalFileTime(lp_file_time, lp_local_file_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FindClose");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_find_file = {:?}}}", h_find_file)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FindClose(h_find_file);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindCloseChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindCloseChangeNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_change_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_change_handle = {:?}}}", h_change_handle)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FindCloseChangeNotification(h_change_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstChangeNotificationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstChangeNotificationA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            let b_watch_subtree = call.get_arg();
            let dw_notify_filter = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_path_name = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}}}" , lp_path_name , b_watch_subtree , dw_notify_filter ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.FindFirstChangeNotificationA(lp_path_name, b_watch_subtree, dw_notify_filter);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstChangeNotificationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstChangeNotificationW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            let b_watch_subtree = call.get_arg();
            let dw_notify_filter = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_path_name = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}}}" , lp_path_name , b_watch_subtree , dw_notify_filter ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.FindFirstChangeNotificationW(lp_path_name, b_watch_subtree, dw_notify_filter);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_find_file_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, lp_find_file_data = {:?}}}",
                            lp_file_name, lp_find_file_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindFirstFileA(lp_file_name, lp_find_file_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_find_file_data = call.get_arg();
            let f_search_op = call.get_arg();
            let lp_search_filter = call.get_arg();
            let dw_additional_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstFileExA(
                lp_file_name,
                f_info_level_id,
                lp_find_file_data,
                f_search_op,
                lp_search_filter,
                dw_additional_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileExFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_find_file_data = call.get_arg();
            let f_search_op = call.get_arg();
            let lp_search_filter = call.get_arg();
            let dw_additional_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstFileExFromAppW(
                lp_file_name,
                f_info_level_id,
                lp_find_file_data,
                f_search_op,
                lp_search_filter,
                dw_additional_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_find_file_data = call.get_arg();
            let f_search_op = call.get_arg();
            let lp_search_filter = call.get_arg();
            let dw_additional_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstFileExW(
                lp_file_name,
                f_info_level_id,
                lp_find_file_data,
                f_search_op,
                lp_search_filter,
                dw_additional_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileNameTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            let string_length = call.get_arg();
            let link_name = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, dw_flags = {:?}, string_length = {:?}, link_name = {:?}, h_transaction = {:?}}}" , lp_file_name , dw_flags , string_length , link_name , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstFileNameTransactedW(
                lp_file_name,
                dw_flags,
                string_length,
                link_name,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            let string_length = call.get_arg();
            let link_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, dw_flags = {:?}, string_length = {:?}, link_name = {:?}}}" , lp_file_name , dw_flags , string_length , link_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstFileNameW(lp_file_name, dw_flags, string_length, link_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_find_file_data = call.get_arg();
            let f_search_op = call.get_arg();
            let lp_search_filter = call.get_arg();
            let dw_additional_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstFileTransactedA(
                lp_file_name,
                f_info_level_id,
                lp_find_file_data,
                f_search_op,
                lp_search_filter,
                dw_additional_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_find_file_data = call.get_arg();
            let f_search_op = call.get_arg();
            let lp_search_filter = call.get_arg();
            let dw_additional_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstFileTransactedW(
                lp_file_name,
                f_info_level_id,
                lp_find_file_data,
                f_search_op,
                lp_search_filter,
                dw_additional_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_find_file_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, lp_find_file_data = {:?}}}",
                            lp_file_name, lp_find_file_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindFirstFileW(lp_file_name, lp_find_file_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstStreamTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstStreamTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let info_level = call.get_arg();
            let lp_find_stream_data = call.get_arg();
            let dw_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, info_level = {:?}, lp_find_stream_data = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_file_name , info_level , lp_find_stream_data , dw_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstStreamTransactedW(
                lp_file_name,
                info_level,
                lp_find_stream_data,
                dw_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstStreamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstStreamW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let info_level = call.get_arg();
            let lp_find_stream_data = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, info_level = {:?}, lp_find_stream_data = {:?}, dw_flags = {:?}}}" , lp_file_name , info_level , lp_find_stream_data , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstStreamW(lp_file_name, info_level, lp_find_stream_data, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstVolumeA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}",
                            lpsz_volume_name, cch_buffer_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindFirstVolumeA(lpsz_volume_name, cch_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstVolumeMountPointA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_root_path_name = call.get_arg();
            let lpsz_volume_mount_point = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_root_path_name = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , lpsz_root_path_name , lpsz_volume_mount_point , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstVolumeMountPointA(
                lpsz_root_path_name,
                lpsz_volume_mount_point,
                cch_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstVolumeMountPointW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_root_path_name = call.get_arg();
            let lpsz_volume_mount_point = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_root_path_name = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , lpsz_root_path_name , lpsz_volume_mount_point , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindFirstVolumeMountPointW(
                lpsz_root_path_name,
                lpsz_volume_mount_point,
                cch_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindFirstVolumeW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}",
                            lpsz_volume_name, cch_buffer_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindFirstVolumeW(lpsz_volume_name, cch_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextChangeNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_change_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_change_handle = {:?}}}", h_change_handle)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FindNextChangeNotification(h_change_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_file = call.get_arg();
            let lp_find_file_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_find_file = {:?}, lp_find_file_data = {:?}}}",
                            h_find_file, lp_find_file_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindNextFileA(h_find_file, lp_find_file_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextFileNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_stream = call.get_arg();
            let string_length = call.get_arg();
            let link_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_find_stream = {:?}, string_length = {:?}, link_name = {:?}}}" , h_find_stream , string_length , link_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindNextFileNameW(h_find_stream, string_length, link_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_file = call.get_arg();
            let lp_find_file_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_find_file = {:?}, lp_find_file_data = {:?}}}",
                            h_find_file, lp_find_file_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindNextFileW(h_find_file, lp_find_file_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextStreamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextStreamW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_stream = call.get_arg();
            let lp_find_stream_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_find_stream = {:?}, lp_find_stream_data = {:?}}}",
                            h_find_stream, lp_find_stream_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindNextStreamW(h_find_stream, lp_find_stream_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextVolumeA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_volume = call.get_arg();
            let lpsz_volume_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_find_volume = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}" , h_find_volume , lpsz_volume_name , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindNextVolumeA(h_find_volume, lpsz_volume_name, cch_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextVolumeMountPointA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_volume_mount_point = call.get_arg();
            let lpsz_volume_mount_point = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_find_volume_mount_point = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , h_find_volume_mount_point , lpsz_volume_mount_point , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindNextVolumeMountPointA(
                h_find_volume_mount_point,
                lpsz_volume_mount_point,
                cch_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextVolumeMountPointW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_volume_mount_point = call.get_arg();
            let lpsz_volume_mount_point = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_find_volume_mount_point = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , h_find_volume_mount_point , lpsz_volume_mount_point , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindNextVolumeMountPointW(
                h_find_volume_mount_point,
                lpsz_volume_mount_point,
                cch_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindNextVolumeW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_volume = call.get_arg();
            let lpsz_volume_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_find_volume = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}" , h_find_volume , lpsz_volume_name , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindNextVolumeW(h_find_volume, lpsz_volume_name, cch_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindVolumeClose(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindVolumeClose",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_volume = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_find_volume = {:?}}}", h_find_volume)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FindVolumeClose(h_find_volume);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindVolumeMountPointClose(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindVolumeMountPointClose",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_find_volume_mount_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_find_volume_mount_point = {:?}}}",
                            h_find_volume_mount_point
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindVolumeMountPointClose(h_find_volume_mount_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlushFileBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FlushFileBuffers",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_file = {:?}}}", h_file)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FlushFileBuffers(h_file);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeEncryptedFileMetadata(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FreeEncryptedFileMetadata",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let pb_metadata = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pb_metadata = {:?}}}", pb_metadata)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FreeEncryptedFileMetadata(pb_metadata);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetBinaryTypeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetBinaryTypeA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_application_name = call.get_arg();
            let lp_binary_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_application_name = {:?}, lp_binary_type = {:?}}}",
                            lp_application_name, lp_binary_type
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetBinaryTypeA(lp_application_name, lp_binary_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetBinaryTypeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetBinaryTypeW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_application_name = call.get_arg();
            let lp_binary_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_application_name = {:?}, lp_binary_type = {:?}}}",
                            lp_application_name, lp_binary_type
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetBinaryTypeW(lp_application_name, lp_binary_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCompressedFileSizeA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_file_size_high = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, lp_file_size_high = {:?}}}",
                            lp_file_name, lp_file_size_high
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCompressedFileSizeA(lp_file_name, lp_file_size_high);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCompressedFileSizeTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_file_size_high = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, lp_file_size_high = {:?}, h_transaction = {:?}}}" , lp_file_name , lp_file_size_high , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCompressedFileSizeTransactedA(
                lp_file_name,
                lp_file_size_high,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCompressedFileSizeTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_file_size_high = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, lp_file_size_high = {:?}, h_transaction = {:?}}}" , lp_file_name , lp_file_size_high , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCompressedFileSizeTransactedW(
                lp_file_name,
                lp_file_size_high,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCompressedFileSizeW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_file_size_high = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, lp_file_size_high = {:?}}}",
                            lp_file_name, lp_file_size_high
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCompressedFileSizeW(lp_file_name, lp_file_size_high);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentClockTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentClockTransactionManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_manager_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{transaction_manager_handle = {:?}, tm_virtual_clock = {:?}}}" , transaction_manager_handle , tm_virtual_clock ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetCurrentClockTransactionManager(transaction_manager_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDiskFreeSpaceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            let lp_sectors_per_cluster = call.get_arg();
            let lp_bytes_per_sector = call.get_arg();
            let lp_number_of_free_clusters = call.get_arg();
            let lp_total_number_of_clusters = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_root_path_name = {:?}, lp_sectors_per_cluster = {:?}, lp_bytes_per_sector = {:?}, lp_number_of_free_clusters = {:?}, lp_total_number_of_clusters = {:?}}}" , lp_root_path_name , lp_sectors_per_cluster , lp_bytes_per_sector , lp_number_of_free_clusters , lp_total_number_of_clusters ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDiskFreeSpaceA(
                lp_root_path_name,
                lp_sectors_per_cluster,
                lp_bytes_per_sector,
                lp_number_of_free_clusters,
                lp_total_number_of_clusters,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDiskFreeSpaceExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_directory_name = call.get_arg();
            let lp_free_bytes_available_to_caller = call.get_arg();
            let lp_total_number_of_bytes = call.get_arg();
            let lp_total_number_of_free_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_directory_name = {:?}, lp_free_bytes_available_to_caller = {:?}, lp_total_number_of_bytes = {:?}, lp_total_number_of_free_bytes = {:?}}}" , lp_directory_name , lp_free_bytes_available_to_caller , lp_total_number_of_bytes , lp_total_number_of_free_bytes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDiskFreeSpaceExA(
                lp_directory_name,
                lp_free_bytes_available_to_caller,
                lp_total_number_of_bytes,
                lp_total_number_of_free_bytes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDiskFreeSpaceExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_directory_name = call.get_arg();
            let lp_free_bytes_available_to_caller = call.get_arg();
            let lp_total_number_of_bytes = call.get_arg();
            let lp_total_number_of_free_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_directory_name = {:?}, lp_free_bytes_available_to_caller = {:?}, lp_total_number_of_bytes = {:?}, lp_total_number_of_free_bytes = {:?}}}" , lp_directory_name , lp_free_bytes_available_to_caller , lp_total_number_of_bytes , lp_total_number_of_free_bytes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDiskFreeSpaceExW(
                lp_directory_name,
                lp_free_bytes_available_to_caller,
                lp_total_number_of_bytes,
                lp_total_number_of_free_bytes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDiskFreeSpaceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            let lp_sectors_per_cluster = call.get_arg();
            let lp_bytes_per_sector = call.get_arg();
            let lp_number_of_free_clusters = call.get_arg();
            let lp_total_number_of_clusters = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_root_path_name = {:?}, lp_sectors_per_cluster = {:?}, lp_bytes_per_sector = {:?}, lp_number_of_free_clusters = {:?}, lp_total_number_of_clusters = {:?}}}" , lp_root_path_name , lp_sectors_per_cluster , lp_bytes_per_sector , lp_number_of_free_clusters , lp_total_number_of_clusters ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDiskFreeSpaceW(
                lp_root_path_name,
                lp_sectors_per_cluster,
                lp_bytes_per_sector,
                lp_number_of_free_clusters,
                lp_total_number_of_clusters,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDiskSpaceInformationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDiskSpaceInformationA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let root_path = call.get_arg();
            let disk_space_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{root_path = {:?}, disk_space_info = {:?}}}",
                            root_path, disk_space_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDiskSpaceInformationA(root_path, disk_space_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDiskSpaceInformationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDiskSpaceInformationW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let root_path = call.get_arg();
            let disk_space_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{root_path = {:?}, disk_space_info = {:?}}}",
                            root_path, disk_space_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDiskSpaceInformationW(root_path, disk_space_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDriveTypeA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDriveTypeA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_root_path_name = {:?}}}",
                            lp_root_path_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDriveTypeA(lp_root_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDriveTypeW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDriveTypeW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_root_path_name = {:?}}}",
                            lp_root_path_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDriveTypeW(lp_root_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetEncryptedFileMetadata(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetEncryptedFileMetadata",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let pcb_metadata = call.get_arg();
            let ppb_metadata = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, pcb_metadata = {:?}, ppb_metadata = {:?}}}" , lp_file_name , pcb_metadata , ppb_metadata ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetEncryptedFileMetadata(lp_file_name, pcb_metadata, ppb_metadata);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetEnlistmentId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetEnlistmentId",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let enlistment_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, enlistment_id = {:?}}}",
                            enlistment_handle, enlistment_id
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetEnlistmentId(enlistment_handle, enlistment_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetEnlistmentRecoveryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetEnlistmentRecoveryInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let buffer_size = call.get_arg();
            let buffer = call.get_arg();
            let buffer_used = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{enlistment_handle = {:?}, buffer_size = {:?}, buffer = {:?}, buffer_used = {:?}}}" , enlistment_handle , buffer_size , buffer , buffer_used ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetEnlistmentRecoveryInformation(
                enlistment_handle,
                buffer_size,
                buffer,
                buffer_used,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetExpandedNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetExpandedNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_source = call.get_arg();
            let lpsz_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_source = {:?}, lpsz_buffer = {:?}}}",
                            lpsz_source, lpsz_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetExpandedNameA(lpsz_source, lpsz_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetExpandedNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetExpandedNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_source = call.get_arg();
            let lpsz_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_source = {:?}, lpsz_buffer = {:?}}}",
                            lpsz_source, lpsz_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetExpandedNameW(lpsz_source, lpsz_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileAttributesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetFileAttributesA(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileAttributesExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_file_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}}}" , lp_file_name , f_info_level_id , lp_file_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileAttributesExA(lp_file_name, f_info_level_id, lp_file_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileAttributesExFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_file_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}}}" , lp_file_name , f_info_level_id , lp_file_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetFileAttributesExFromAppW(lp_file_name, f_info_level_id, lp_file_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileAttributesExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_file_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}}}" , lp_file_name , f_info_level_id , lp_file_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileAttributesExW(lp_file_name, f_info_level_id, lp_file_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileAttributesTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_file_information = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_file_information , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileAttributesTransactedA(
                lp_file_name,
                f_info_level_id,
                lp_file_information,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileAttributesTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let f_info_level_id = call.get_arg();
            let lp_file_information = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_file_information , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileAttributesTransactedW(
                lp_file_name,
                f_info_level_id,
                lp_file_information,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileAttributesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetFileAttributesW(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileBandwidthReservation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileBandwidthReservation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_period_milliseconds = call.get_arg();
            let lp_bytes_per_period = call.get_arg();
            let p_discardable = call.get_arg();
            let lp_transfer_size = call.get_arg();
            let lp_num_outstanding_requests = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_period_milliseconds = {:?}, lp_bytes_per_period = {:?}, p_discardable = {:?}, lp_transfer_size = {:?}, lp_num_outstanding_requests = {:?}}}" , h_file , lp_period_milliseconds , lp_bytes_per_period , p_discardable , lp_transfer_size , lp_num_outstanding_requests ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileBandwidthReservation(
                h_file,
                lp_period_milliseconds,
                lp_bytes_per_period,
                p_discardable,
                lp_transfer_size,
                lp_num_outstanding_requests,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileInformationByHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileInformationByHandle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_file_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_file_information = {:?}}}",
                            h_file, lp_file_information
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetFileInformationByHandle(h_file, lp_file_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileInformationByHandleEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileInformationByHandleEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let file_information_class = call.get_arg();
            let lp_file_information = call.get_arg();
            let dw_buffer_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, file_information_class = {:?}, lp_file_information = {:?}, dw_buffer_size = {:?}}}" , h_file , file_information_class , lp_file_information , dw_buffer_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileInformationByHandleEx(
                h_file,
                file_information_class,
                lp_file_information,
                dw_buffer_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetFileSize");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_file_size_high = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_file_size_high = {:?}}}",
                            h_file, lp_file_size_high
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetFileSize(h_file, lp_file_size_high);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileSizeEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileSizeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_file_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_file_size = {:?}}}",
                            h_file, lp_file_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetFileSizeEx(h_file, lp_file_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetFileTime");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_creation_time = call.get_arg();
            let lp_last_access_time = call.get_arg();
            let lp_last_write_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_creation_time = {:?}, lp_last_access_time = {:?}, lp_last_write_time = {:?}}}" , h_file , lp_creation_time , lp_last_access_time , lp_last_write_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileTime(
                h_file,
                lp_creation_time,
                lp_last_access_time,
                lp_last_write_time,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileType(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetFileType");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_file = {:?}}}", h_file)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetFileType(h_file);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lptstr_filename = call.get_arg();
            let dw_handle = call.get_arg();
            let dw_len = call.get_arg();
            let lp_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lptstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}" , lptstr_filename , dw_handle , dw_len , lp_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileVersionInfoA(lptstr_filename, dw_handle, dw_len, lp_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_flags = call.get_arg();
            let lpwstr_filename = call.get_arg();
            let dw_handle = call.get_arg();
            let dw_len = call.get_arg();
            let lp_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lpwstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}" , dw_flags , lpwstr_filename , dw_handle , dw_len , lp_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetFileVersionInfoExA(dw_flags, lpwstr_filename, dw_handle, dw_len, lp_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_flags = call.get_arg();
            let lpwstr_filename = call.get_arg();
            let dw_handle = call.get_arg();
            let dw_len = call.get_arg();
            let lp_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lpwstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}" , dw_flags , lpwstr_filename , dw_handle , dw_len , lp_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetFileVersionInfoExW(dw_flags, lpwstr_filename, dw_handle, dw_len, lp_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoSizeA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lptstr_filename = call.get_arg();
            let lpdw_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lptstr_filename = {:?}, lpdw_handle = {:?}}}",
                            lptstr_filename, lpdw_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetFileVersionInfoSizeA(lptstr_filename, lpdw_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoSizeExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_flags = call.get_arg();
            let lpwstr_filename = call.get_arg();
            let lpdw_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lpwstr_filename = {:?}, lpdw_handle = {:?}}}" , dw_flags , lpwstr_filename , lpdw_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileVersionInfoSizeExA(dw_flags, lpwstr_filename, lpdw_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoSizeExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_flags = call.get_arg();
            let lpwstr_filename = call.get_arg();
            let lpdw_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lpwstr_filename = {:?}, lpdw_handle = {:?}}}" , dw_flags , lpwstr_filename , lpdw_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileVersionInfoSizeExW(dw_flags, lpwstr_filename, lpdw_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoSizeW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lptstr_filename = call.get_arg();
            let lpdw_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lptstr_filename = {:?}, lpdw_handle = {:?}}}",
                            lptstr_filename, lpdw_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetFileVersionInfoSizeW(lptstr_filename, lpdw_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFileVersionInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lptstr_filename = call.get_arg();
            let dw_handle = call.get_arg();
            let dw_len = call.get_arg();
            let lp_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lptstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}" , lptstr_filename , dw_handle , dw_len , lp_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFileVersionInfoW(lptstr_filename, dw_handle, dw_len, lp_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFinalPathNameByHandleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFinalPathNameByHandleA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lpsz_file_path = call.get_arg();
            let cch_file_path = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lpsz_file_path = {:?}, cch_file_path = {:?}, dw_flags = {:?}}}" , h_file , lpsz_file_path , cch_file_path , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetFinalPathNameByHandleA(h_file, lpsz_file_path, cch_file_path, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFinalPathNameByHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFinalPathNameByHandleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lpsz_file_path = call.get_arg();
            let cch_file_path = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lpsz_file_path = {:?}, cch_file_path = {:?}, dw_flags = {:?}}}" , h_file , lpsz_file_path , cch_file_path , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetFinalPathNameByHandleW(h_file, lpsz_file_path, cch_file_path, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFullPathNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            let lp_file_part = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFullPathNameA(lp_file_name, n_buffer_length, lp_buffer, lp_file_part);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFullPathNameTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            let lp_file_part = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}, h_transaction = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFullPathNameTransactedA(
                lp_file_name,
                n_buffer_length,
                lp_buffer,
                lp_file_part,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFullPathNameTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            let lp_file_part = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}, h_transaction = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFullPathNameTransactedW(
                lp_file_name,
                n_buffer_length,
                lp_buffer,
                lp_file_part,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFullPathNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            let lp_file_part = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFullPathNameW(lp_file_name, n_buffer_length, lp_buffer, lp_file_part);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetIoRingInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetIoRingInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            let info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{io_ring = {:?}, info = {:?}}}",
                            io_ring, info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetIoRingInfo(io_ring, info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDriveStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLogicalDriveStringsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetLogicalDriveStringsA(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDriveStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLogicalDriveStringsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetLogicalDriveStringsW(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDrives(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLogicalDrives",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetLogicalDrives();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLongPathNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_short_path = call.get_arg();
            let lpsz_long_path = call.get_arg();
            let cch_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}}}" , lpsz_short_path , lpsz_long_path , cch_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLongPathNameA(lpsz_short_path, lpsz_long_path, cch_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLongPathNameTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_short_path = call.get_arg();
            let lpsz_long_path = call.get_arg();
            let cch_buffer = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}, h_transaction = {:?}}}" , lpsz_short_path , lpsz_long_path , cch_buffer , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLongPathNameTransactedA(
                lpsz_short_path,
                lpsz_long_path,
                cch_buffer,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLongPathNameTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_short_path = call.get_arg();
            let lpsz_long_path = call.get_arg();
            let cch_buffer = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}, h_transaction = {:?}}}" , lpsz_short_path , lpsz_long_path , cch_buffer , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLongPathNameTransactedW(
                lpsz_short_path,
                lpsz_long_path,
                cch_buffer,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLongPathNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_short_path = call.get_arg();
            let lpsz_long_path = call.get_arg();
            let cch_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}}}" , lpsz_short_path , lpsz_long_path , cch_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLongPathNameW(lpsz_short_path, lpsz_long_path, cch_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNotificationResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNotificationResourceManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let resource_manager_handle = call.get_arg();
            let transaction_notification = call.get_arg();
            let notification_length = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{resource_manager_handle = {:?}, transaction_notification = {:?}, notification_length = {:?}, dw_milliseconds = {:?}, return_length = {:?}}}" , resource_manager_handle , transaction_notification , notification_length , dw_milliseconds , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNotificationResourceManager(
                resource_manager_handle,
                transaction_notification,
                notification_length,
                dw_milliseconds,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNotificationResourceManagerAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNotificationResourceManagerAsync",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let resource_manager_handle = call.get_arg();
            let transaction_notification = call.get_arg();
            let transaction_notification_length = call.get_arg();
            let return_length = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{resource_manager_handle = {:?}, transaction_notification = {:?}, transaction_notification_length = {:?}, return_length = {:?}, lp_overlapped = {:?}}}" , resource_manager_handle , transaction_notification , transaction_notification_length , return_length , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNotificationResourceManagerAsync(
                resource_manager_handle,
                transaction_notification,
                transaction_notification_length,
                return_length,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetShortPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetShortPathNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_long_path = call.get_arg();
            let lpsz_short_path = call.get_arg();
            let cch_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_long_path = {:?}, lpsz_short_path = {:?}, cch_buffer = {:?}}}" , lpsz_long_path , lpsz_short_path , cch_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetShortPathNameA(lpsz_long_path, lpsz_short_path, cch_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetShortPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetShortPathNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_long_path = call.get_arg();
            let lpsz_short_path = call.get_arg();
            let cch_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_long_path = {:?}, lpsz_short_path = {:?}, cch_buffer = {:?}}}" , lpsz_long_path , lpsz_short_path , cch_buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetShortPathNameW(lpsz_long_path, lpsz_short_path, cch_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTapeParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTapeParameters",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_operation = call.get_arg();
            let lpdw_size = call.get_arg();
            let lp_tape_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_operation = {:?}, lpdw_size = {:?}, lp_tape_information = {:?}}}" , h_device , dw_operation , lpdw_size , lp_tape_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetTapeParameters(h_device, dw_operation, lpdw_size, lp_tape_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTapePosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTapePosition",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_position_type = call.get_arg();
            let lpdw_partition = call.get_arg();
            let lpdw_offset_low = call.get_arg();
            let lpdw_offset_high = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_position_type = {:?}, lpdw_partition = {:?}, lpdw_offset_low = {:?}, lpdw_offset_high = {:?}}}" , h_device , dw_position_type , lpdw_partition , lpdw_offset_low , lpdw_offset_high ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetTapePosition(
                h_device,
                dw_position_type,
                lpdw_partition,
                lpdw_offset_low,
                lpdw_offset_high,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTapeStatus(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTapeStatus",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_device = {:?}}}", h_device)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTapeStatus(h_device);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTempFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTempFileNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            let lp_prefix_string = call.get_arg();
            let u_unique = call.get_arg();
            let lp_temp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_path_name = {:?}, lp_prefix_string = {:?}, u_unique = {:?}, lp_temp_file_name = {:?}}}" , lp_path_name , lp_prefix_string , u_unique , lp_temp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetTempFileNameA(lp_path_name, lp_prefix_string, u_unique, lp_temp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTempFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTempFileNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            let lp_prefix_string = call.get_arg();
            let u_unique = call.get_arg();
            let lp_temp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_path_name = {:?}, lp_prefix_string = {:?}, u_unique = {:?}, lp_temp_file_name = {:?}}}" , lp_path_name , lp_prefix_string , u_unique , lp_temp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetTempFileNameW(lp_path_name, lp_prefix_string, u_unique, lp_temp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTempPath2A(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTempPath2A",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let buffer_length = call.get_arg();
            let buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{buffer_length = {:?}, buffer = {:?}}}",
                            buffer_length, buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTempPath2A(buffer_length, buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTempPath2W(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTempPath2W",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let buffer_length = call.get_arg();
            let buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{buffer_length = {:?}, buffer = {:?}}}",
                            buffer_length, buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTempPath2W(buffer_length, buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTempPathA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTempPathA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTempPathA(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTempPathW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTempPathW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTempPathW(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTransactionId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTransactionId",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_handle = call.get_arg();
            let transaction_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{transaction_handle = {:?}, transaction_id = {:?}}}",
                            transaction_handle, transaction_id
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTransactionId(transaction_handle, transaction_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTransactionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTransactionInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_handle = call.get_arg();
            let outcome = call.get_arg();
            let isolation_level = call.get_arg();
            let isolation_flags = call.get_arg();
            let timeout = call.get_arg();
            let buffer_length = call.get_arg();
            let description = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{transaction_handle = {:?}, outcome = {:?}, isolation_level = {:?}, isolation_flags = {:?}, timeout = {:?}, buffer_length = {:?}, description = {:?}}}" , transaction_handle , outcome , isolation_level , isolation_flags , timeout , buffer_length , description ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetTransactionInformation(
                transaction_handle,
                outcome,
                isolation_level,
                isolation_flags,
                timeout,
                buffer_length,
                description,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTransactionManagerId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTransactionManagerId",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_manager_handle = call.get_arg();
            let transaction_manager_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{transaction_manager_handle = {:?}, transaction_manager_id = {:?}}}" , transaction_manager_handle , transaction_manager_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetTransactionManagerId(transaction_manager_handle, transaction_manager_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumeInformationA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            let lp_volume_name_buffer = call.get_arg();
            let n_volume_name_size = call.get_arg();
            let lp_volume_serial_number = call.get_arg();
            let lp_maximum_component_length = call.get_arg();
            let lp_file_system_flags = call.get_arg();
            let lp_file_system_name_buffer = call.get_arg();
            let n_file_system_name_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_root_path_name = {:?}, lp_volume_name_buffer = {:?}, n_volume_name_size = {:?}, lp_volume_serial_number = {:?}, lp_maximum_component_length = {:?}, lp_file_system_flags = {:?}, lp_file_system_name_buffer = {:?}, n_file_system_name_size = {:?}}}" , lp_root_path_name , lp_volume_name_buffer , n_volume_name_size , lp_volume_serial_number , lp_maximum_component_length , lp_file_system_flags , lp_file_system_name_buffer , n_file_system_name_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVolumeInformationA(
                lp_root_path_name,
                lp_volume_name_buffer,
                n_volume_name_size,
                lp_volume_serial_number,
                lp_maximum_component_length,
                lp_file_system_flags,
                lp_file_system_name_buffer,
                n_file_system_name_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationByHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumeInformationByHandleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_volume_name_buffer = call.get_arg();
            let n_volume_name_size = call.get_arg();
            let lp_volume_serial_number = call.get_arg();
            let lp_maximum_component_length = call.get_arg();
            let lp_file_system_flags = call.get_arg();
            let lp_file_system_name_buffer = call.get_arg();
            let n_file_system_name_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_volume_name_buffer = {:?}, n_volume_name_size = {:?}, lp_volume_serial_number = {:?}, lp_maximum_component_length = {:?}, lp_file_system_flags = {:?}, lp_file_system_name_buffer = {:?}, n_file_system_name_size = {:?}}}" , h_file , lp_volume_name_buffer , n_volume_name_size , lp_volume_serial_number , lp_maximum_component_length , lp_file_system_flags , lp_file_system_name_buffer , n_file_system_name_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVolumeInformationByHandleW(
                h_file,
                lp_volume_name_buffer,
                n_volume_name_size,
                lp_volume_serial_number,
                lp_maximum_component_length,
                lp_file_system_flags,
                lp_file_system_name_buffer,
                n_file_system_name_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumeInformationW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            let lp_volume_name_buffer = call.get_arg();
            let n_volume_name_size = call.get_arg();
            let lp_volume_serial_number = call.get_arg();
            let lp_maximum_component_length = call.get_arg();
            let lp_file_system_flags = call.get_arg();
            let lp_file_system_name_buffer = call.get_arg();
            let n_file_system_name_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_root_path_name = {:?}, lp_volume_name_buffer = {:?}, n_volume_name_size = {:?}, lp_volume_serial_number = {:?}, lp_maximum_component_length = {:?}, lp_file_system_flags = {:?}, lp_file_system_name_buffer = {:?}, n_file_system_name_size = {:?}}}" , lp_root_path_name , lp_volume_name_buffer , n_volume_name_size , lp_volume_serial_number , lp_maximum_component_length , lp_file_system_flags , lp_file_system_name_buffer , n_file_system_name_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVolumeInformationW(
                lp_root_path_name,
                lp_volume_name_buffer,
                n_volume_name_size,
                lp_volume_serial_number,
                lp_maximum_component_length,
                lp_file_system_flags,
                lp_file_system_name_buffer,
                n_file_system_name_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumeNameForVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumeNameForVolumeMountPointA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_mount_point = call.get_arg();
            let lpsz_volume_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_volume_mount_point , lpsz_volume_name , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVolumeNameForVolumeMountPointA(
                lpsz_volume_mount_point,
                lpsz_volume_name,
                cch_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumeNameForVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumeNameForVolumeMountPointW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_mount_point = call.get_arg();
            let lpsz_volume_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_volume_mount_point , lpsz_volume_name , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVolumeNameForVolumeMountPointW(
                lpsz_volume_mount_point,
                lpsz_volume_name,
                cch_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumePathNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_file_name = call.get_arg();
            let lpsz_volume_path_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_file_name = {:?}, lpsz_volume_path_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_file_name , lpsz_volume_path_name , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetVolumePathNameA(lpsz_file_name, lpsz_volume_path_name, cch_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumePathNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_file_name = call.get_arg();
            let lpsz_volume_path_name = call.get_arg();
            let cch_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_file_name = {:?}, lpsz_volume_path_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_file_name , lpsz_volume_path_name , cch_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetVolumePathNameW(lpsz_file_name, lpsz_volume_path_name, cch_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNamesForVolumeNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumePathNamesForVolumeNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_name = call.get_arg();
            let lpsz_volume_path_names = call.get_arg();
            let cch_buffer_length = call.get_arg();
            let lpcch_return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_volume_name = {:?}, lpsz_volume_path_names = {:?}, cch_buffer_length = {:?}, lpcch_return_length = {:?}}}" , lpsz_volume_name , lpsz_volume_path_names , cch_buffer_length , lpcch_return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVolumePathNamesForVolumeNameA(
                lpsz_volume_name,
                lpsz_volume_path_names,
                cch_buffer_length,
                lpcch_return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNamesForVolumeNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVolumePathNamesForVolumeNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_name = call.get_arg();
            let lpsz_volume_path_names = call.get_arg();
            let cch_buffer_length = call.get_arg();
            let lpcch_return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_volume_name = {:?}, lpsz_volume_path_names = {:?}, cch_buffer_length = {:?}, lpcch_return_length = {:?}}}" , lpsz_volume_name , lpsz_volume_path_names , cch_buffer_length , lpcch_return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVolumePathNamesForVolumeNameW(
                lpsz_volume_name,
                lpsz_volume_path_names,
                cch_buffer_length,
                lpcch_return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsIoRingOpSupported(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsIoRingOpSupported",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            let op = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{io_ring = {:?}, op = {:?}}}", io_ring, op)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsIoRingOpSupported(io_ring, op);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZClose");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_file = {:?}}}", h_file)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LZClose(h_file);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZCopy(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZCopy");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let hf_source = call.get_arg();
            let hf_dest = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hf_source = {:?}, hf_dest = {:?}}}",
                            hf_source, hf_dest
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LZCopy(hf_source, hf_dest);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZDone(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZDone");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LZDone();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZInit(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZInit");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let hf_source = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{hf_source = {:?}}}", hf_source)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LZInit(hf_source);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZOpenFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZOpenFileA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_re_open_buf = call.get_arg();
            let w_style = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, lp_re_open_buf = {:?}, w_style = {:?}}}" , lp_file_name , lp_re_open_buf , w_style ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LZOpenFileA(lp_file_name, lp_re_open_buf, w_style);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZOpenFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZOpenFileW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_re_open_buf = call.get_arg();
            let w_style = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, lp_re_open_buf = {:?}, w_style = {:?}}}" , lp_file_name , lp_re_open_buf , w_style ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LZOpenFileW(lp_file_name, lp_re_open_buf, w_style);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZRead(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZRead");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let cb_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_buffer = {:?}, cb_read = {:?}}}",
                            h_file, lp_buffer, cb_read
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LZRead(h_file, lp_buffer, cb_read);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZSeek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZSeek");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let l_offset = call.get_arg();
            let i_origin = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, l_offset = {:?}, i_origin = {:?}}}",
                            h_file, l_offset, i_origin
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LZSeek(h_file, l_offset, i_origin);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LZStart(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LZStart");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LZStart();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MoveFileA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}}}",
                            lp_existing_file_name, lp_new_file_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.MoveFileA(lp_existing_file_name, lp_new_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MoveFileExA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, dw_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MoveFileExA(lp_existing_file_name, lp_new_file_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MoveFileExW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, dw_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MoveFileExW(lp_existing_file_name, lp_new_file_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MoveFileFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}}}",
                            lp_existing_file_name, lp_new_file_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.MoveFileFromAppW(lp_existing_file_name, lp_new_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MoveFileTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let dw_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MoveFileTransactedA(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                dw_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MoveFileTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let dw_flags = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MoveFileTransactedW(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                dw_flags,
                h_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MoveFileW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}}}",
                            lp_existing_file_name, lp_new_file_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.MoveFileW(lp_existing_file_name, lp_new_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileWithProgressA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MoveFileWithProgressA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MoveFileWithProgressA(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveFileWithProgressW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MoveFileWithProgressW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_existing_file_name = call.get_arg();
            let lp_new_file_name = call.get_arg();
            let lp_progress_routine = call.get_arg();
            let lp_data = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MoveFileWithProgressW(
                lp_existing_file_name,
                lp_new_file_name,
                lp_progress_routine,
                lp_data,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetConnectionEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetConnectionEnum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let qualifier = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            let prefmaxlen = call.get_arg();
            let entriesread = call.get_arg();
            let totalentries = call.get_arg();
            let resume_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, qualifier = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , qualifier , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetConnectionEnum(
                servername,
                qualifier,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetFileClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetFileClose",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let fileid = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{servername = {:?}, fileid = {:?}}}",
                            servername, fileid
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NetFileClose(servername, fileid);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetFileEnum(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "NetFileEnum");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let basepath = call.get_arg();
            let username = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            let prefmaxlen = call.get_arg();
            let entriesread = call.get_arg();
            let totalentries = call.get_arg();
            let resume_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, basepath = {:?}, username = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , basepath , username , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetFileEnum(
                servername,
                basepath,
                username,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetFileGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetFileGetInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let fileid = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, fileid = {:?}, level = {:?}, bufptr = {:?}}}" , servername , fileid , level , bufptr ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetFileGetInfo(servername, fileid, level, bufptr);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasAdd(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetServerAliasAdd",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let level = call.get_arg();
            let buf = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{servername = {:?}, level = {:?}, buf = {:?}}}",
                            servername, level, buf
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NetServerAliasAdd(servername, level, buf);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasDel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetServerAliasDel",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let level = call.get_arg();
            let buf = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{servername = {:?}, level = {:?}, buf = {:?}}}",
                            servername, level, buf
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NetServerAliasDel(servername, level, buf);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetServerAliasEnum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            let prefmaxlen = call.get_arg();
            let entriesread = call.get_arg();
            let totalentries = call.get_arg();
            let resumehandle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resumehandle = {:?}}}" , servername , level , bufptr , prefmaxlen , entriesread , totalentries , resumehandle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetServerAliasEnum(
                servername,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resumehandle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetSessionDel(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetSessionDel",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let unc_client_name = call.get_arg();
            let username = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, unc_client_name = {:?}, username = {:?}}}" , servername , unc_client_name , username ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetSessionDel(servername, unc_client_name, username);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetSessionEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetSessionEnum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let unc_client_name = call.get_arg();
            let username = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            let prefmaxlen = call.get_arg();
            let entriesread = call.get_arg();
            let totalentries = call.get_arg();
            let resume_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, unc_client_name = {:?}, username = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , unc_client_name , username , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetSessionEnum(
                servername,
                unc_client_name,
                username,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetSessionGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetSessionGetInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let unc_client_name = call.get_arg();
            let username = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, unc_client_name = {:?}, username = {:?}, level = {:?}, bufptr = {:?}}}" , servername , unc_client_name , username , level , bufptr ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetSessionGetInfo(servername, unc_client_name, username, level, bufptr);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareAdd(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "NetShareAdd");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let level = call.get_arg();
            let buf = call.get_arg();
            let parm_err = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, level = {:?}, buf = {:?}, parm_err = {:?}}}" , servername , level , buf , parm_err ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetShareAdd(servername, level, buf, parm_err);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareCheck(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetShareCheck",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let device = call.get_arg();
            let r#type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{servername = {:?}, device = {:?}, r#type = {:?}}}",
                            servername, device, r#type
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NetShareCheck(servername, device, r#type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareDel(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "NetShareDel");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let netname = call.get_arg();
            let reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{servername = {:?}, netname = {:?}, reserved = {:?}}}",
                            servername, netname, reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NetShareDel(servername, netname, reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareDelEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetShareDelEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let level = call.get_arg();
            let buf = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{servername = {:?}, level = {:?}, buf = {:?}}}",
                            servername, level, buf
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NetShareDelEx(servername, level, buf);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareDelSticky(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetShareDelSticky",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let netname = call.get_arg();
            let reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{servername = {:?}, netname = {:?}, reserved = {:?}}}",
                            servername, netname, reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NetShareDelSticky(servername, netname, reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareEnum(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetShareEnum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            let prefmaxlen = call.get_arg();
            let entriesread = call.get_arg();
            let totalentries = call.get_arg();
            let resume_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetShareEnum(
                servername,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareEnumSticky(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetShareEnumSticky",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            let prefmaxlen = call.get_arg();
            let entriesread = call.get_arg();
            let totalentries = call.get_arg();
            let resume_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetShareEnumSticky(
                servername,
                level,
                bufptr,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetShareGetInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let netname = call.get_arg();
            let level = call.get_arg();
            let bufptr = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, netname = {:?}, level = {:?}, bufptr = {:?}}}" , servername , netname , level , bufptr ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetShareGetInfo(servername, netname, level, bufptr);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetShareSetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetShareSetInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let servername = call.get_arg();
            let netname = call.get_arg();
            let level = call.get_arg();
            let buf = call.get_arg();
            let parm_err = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{servername = {:?}, netname = {:?}, level = {:?}, buf = {:?}, parm_err = {:?}}}" , servername , netname , level , buf , parm_err ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetShareSetInfo(servername, netname, level, buf, parm_err);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NetStatisticsGet(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NetStatisticsGet",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let server_name = call.get_arg();
            let service = call.get_arg();
            let level = call.get_arg();
            let options = call.get_arg();
            let buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{server_name = {:?}, service = {:?}, level = {:?}, options = {:?}, buffer = {:?}}}" , server_name , service , level , options , buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NetStatisticsGet(server_name, service, level, options, buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtCreateFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtCreateFile",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let file_handle = call.get_arg();
            let desired_access = call.get_arg();
            let object_attributes = call.get_arg();
            let io_status_block = call.get_arg();
            let allocation_size = call.get_arg();
            let file_attributes = call.get_arg();
            let share_access = call.get_arg();
            let create_disposition = call.get_arg();
            let create_options = call.get_arg();
            let ea_buffer = call.get_arg();
            let ea_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, desired_access = {:?}, object_attributes = {:?}, io_status_block = {:?}, allocation_size = {:?}, file_attributes = {:?}, share_access = {:?}, create_disposition = {:?}, create_options = {:?}, ea_buffer = {:?}, ea_length = {:?}}}" , file_handle , desired_access , object_attributes , io_status_block , allocation_size , file_attributes , share_access , create_disposition , create_options , ea_buffer , ea_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtCreateFile(
                file_handle,
                desired_access,
                object_attributes,
                io_status_block,
                allocation_size,
                file_attributes,
                share_access,
                create_disposition,
                create_options,
                ea_buffer,
                ea_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenEncryptedFileRawA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenEncryptedFileRawA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let ul_flags = call.get_arg();
            let pv_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, ul_flags = {:?}, pv_context = {:?}}}" , lp_file_name , ul_flags , pv_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenEncryptedFileRawA(lp_file_name, ul_flags, pv_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenEncryptedFileRawW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenEncryptedFileRawW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let ul_flags = call.get_arg();
            let pv_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, ul_flags = {:?}, pv_context = {:?}}}" , lp_file_name , ul_flags , pv_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenEncryptedFileRawW(lp_file_name, ul_flags, pv_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenEnlistment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_desired_access = call.get_arg();
            let resource_manager_handle = call.get_arg();
            let enlistment_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, resource_manager_handle = {:?}, enlistment_id = {:?}}}" , dw_desired_access , resource_manager_handle , enlistment_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenEnlistment(dw_desired_access, resource_manager_handle, enlistment_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenFile");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let lp_re_open_buff = call.get_arg();
            let u_style = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, lp_re_open_buff = {:?}, u_style = {:?}}}" , lp_file_name , lp_re_open_buff , u_style ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenFile(lp_file_name, lp_re_open_buff, u_style);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenResourceManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_desired_access = call.get_arg();
            let tm_handle = call.get_arg();
            let resource_manager_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, tm_handle = {:?}, resource_manager_id = {:?}}}" , dw_desired_access , tm_handle , resource_manager_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenResourceManager(dw_desired_access, tm_handle, resource_manager_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenTransaction",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let dw_desired_access = call.get_arg();
            let transaction_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_desired_access = {:?}, transaction_id = {:?}}}",
                            dw_desired_access, transaction_id
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.OpenTransaction(dw_desired_access, transaction_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenTransactionManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let log_file_name = call.get_arg();
            let desired_access = call.get_arg();
            let open_options = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{log_file_name = {:?}, desired_access = {:?}, open_options = {:?}}}" , log_file_name , desired_access , open_options ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenTransactionManager(log_file_name, desired_access, open_options);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenTransactionManagerById(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenTransactionManagerById",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_manager_id = call.get_arg();
            let desired_access = call.get_arg();
            let open_options = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{transaction_manager_id = {:?}, desired_access = {:?}, open_options = {:?}}}" , transaction_manager_id , desired_access , open_options ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenTransactionManagerById(
                transaction_manager_id,
                desired_access,
                open_options,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PopIoRingCompletion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PopIoRingCompletion",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            let cqe = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{io_ring = {:?}, cqe = {:?}}}",
                            io_ring, cqe
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.PopIoRingCompletion(io_ring, cqe);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrePrepareComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PrePrepareComplete",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.PrePrepareComplete(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrePrepareEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PrePrepareEnlistment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.PrePrepareEnlistment(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrepareComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PrepareComplete",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.PrepareComplete(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrepareEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PrepareEnlistment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.PrepareEnlistment(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrepareTape(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "PrepareTape");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_operation = call.get_arg();
            let b_immediate = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_operation = {:?}, b_immediate = {:?}}}" , h_device , dw_operation , b_immediate ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PrepareTape(h_device, dw_operation, b_immediate);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryDosDeviceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryDosDeviceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_device_name = call.get_arg();
            let lp_target_path = call.get_arg();
            let ucch_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_device_name = {:?}, lp_target_path = {:?}, ucch_max = {:?}}}" , lp_device_name , lp_target_path , ucch_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueryDosDeviceA(lp_device_name, lp_target_path, ucch_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryDosDeviceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryDosDeviceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_device_name = call.get_arg();
            let lp_target_path = call.get_arg();
            let ucch_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_device_name = {:?}, lp_target_path = {:?}, ucch_max = {:?}}}" , lp_device_name , lp_target_path , ucch_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueryDosDeviceW(lp_device_name, lp_target_path, ucch_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryIoRingCapabilities(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryIoRingCapabilities",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let capabilities = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{capabilities = {:?}}}", capabilities)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.QueryIoRingCapabilities(capabilities);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReOpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ReOpenFile");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_original_file = call.get_arg();
            let dw_desired_access = call.get_arg();
            let dw_share_mode = call.get_arg();
            let dw_flags_and_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_original_file = {:?}, dw_desired_access = {:?}, dw_share_mode = {:?}, dw_flags_and_attributes = {:?}}}" , h_original_file , dw_desired_access , dw_share_mode , dw_flags_and_attributes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReOpenFile(
                h_original_file,
                dw_desired_access,
                dw_share_mode,
                dw_flags_and_attributes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadDirectoryChangesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadDirectoryChangesExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_directory = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_buffer_length = call.get_arg();
            let b_watch_subtree = call.get_arg();
            let dw_notify_filter = call.get_arg();
            let lp_bytes_returned = call.get_arg();
            let lp_overlapped = call.get_arg();
            let lp_completion_routine = call.get_arg();
            let read_directory_notify_information_class = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_directory = {:?}, lp_buffer = {:?}, n_buffer_length = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}, lp_bytes_returned = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}, read_directory_notify_information_class = {:?}}}" , h_directory , lp_buffer , n_buffer_length , b_watch_subtree , dw_notify_filter , lp_bytes_returned , lp_overlapped , lp_completion_routine , read_directory_notify_information_class ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadDirectoryChangesExW(
                h_directory,
                lp_buffer,
                n_buffer_length,
                b_watch_subtree,
                dw_notify_filter,
                lp_bytes_returned,
                lp_overlapped,
                lp_completion_routine,
                read_directory_notify_information_class,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadDirectoryChangesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadDirectoryChangesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_directory = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_buffer_length = call.get_arg();
            let b_watch_subtree = call.get_arg();
            let dw_notify_filter = call.get_arg();
            let lp_bytes_returned = call.get_arg();
            let lp_overlapped = call.get_arg();
            let lp_completion_routine = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_directory = {:?}, lp_buffer = {:?}, n_buffer_length = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}, lp_bytes_returned = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}}}" , h_directory , lp_buffer , n_buffer_length , b_watch_subtree , dw_notify_filter , lp_bytes_returned , lp_overlapped , lp_completion_routine ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadDirectoryChangesW(
                h_directory,
                lp_buffer,
                n_buffer_length,
                b_watch_subtree,
                dw_notify_filter,
                lp_bytes_returned,
                lp_overlapped,
                lp_completion_routine,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadEncryptedFileRaw",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let pf_export_callback = call.get_arg();
            let pv_callback_context = call.get_arg();
            let pv_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pf_export_callback = {:?}, pv_callback_context = {:?}, pv_context = {:?}}}" , pf_export_callback , pv_callback_context , pv_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadEncryptedFileRaw(pf_export_callback, pv_callback_context, pv_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ReadFile");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_bytes_to_read = call.get_arg();
            let lp_number_of_bytes_read = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_read = {:?}, lp_number_of_bytes_read = {:?}, lp_overlapped = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_read , lp_number_of_bytes_read , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadFile(
                h_file,
                lp_buffer,
                n_number_of_bytes_to_read,
                lp_number_of_bytes_read,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ReadFileEx");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_bytes_to_read = call.get_arg();
            let lp_overlapped = call.get_arg();
            let lp_completion_routine = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_read = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_read , lp_overlapped , lp_completion_routine ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadFileEx(
                h_file,
                lp_buffer,
                n_number_of_bytes_to_read,
                lp_overlapped,
                lp_completion_routine,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadFileScatter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadFileScatter",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let a_segment_array = call.get_arg();
            let n_number_of_bytes_to_read = call.get_arg();
            let lp_reserved = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, a_segment_array = {:?}, n_number_of_bytes_to_read = {:?}, lp_reserved = {:?}, lp_overlapped = {:?}}}" , h_file , a_segment_array , n_number_of_bytes_to_read , lp_reserved , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadFileScatter(
                h_file,
                a_segment_array,
                n_number_of_bytes_to_read,
                lp_reserved,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadOnlyEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadOnlyEnlistment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ReadOnlyEnlistment(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RecoverEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RecoverEnlistment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let enlistment_key = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, enlistment_key = {:?}}}",
                            enlistment_handle, enlistment_key
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RecoverEnlistment(enlistment_handle, enlistment_key);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RecoverResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RecoverResourceManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let resource_manager_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{resource_manager_handle = {:?}}}",
                            resource_manager_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RecoverResourceManager(resource_manager_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RecoverTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RecoverTransactionManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_manager_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{transaction_manager_handle = {:?}}}",
                            transaction_manager_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RecoverTransactionManager(transaction_manager_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RemoveDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_path_name = {:?}}}", lp_path_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RemoveDirectoryA(lp_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RemoveDirectoryFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_path_name = {:?}}}", lp_path_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RemoveDirectoryFromAppW(lp_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RemoveDirectoryTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_path_name = {:?}, h_transaction = {:?}}}",
                            lp_path_name, h_transaction
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RemoveDirectoryTransactedA(lp_path_name, h_transaction);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RemoveDirectoryTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_path_name = {:?}, h_transaction = {:?}}}",
                            lp_path_name, h_transaction
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RemoveDirectoryTransactedW(lp_path_name, h_transaction);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RemoveDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_path_name = {:?}}}", lp_path_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RemoveDirectoryW(lp_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RenameTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RenameTransactionManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let log_file_name = call.get_arg();
            let existing_transaction_manager_guid = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{log_file_name = {:?}, existing_transaction_manager_guid = {:?}}}" , log_file_name , existing_transaction_manager_guid ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.RenameTransactionManager(log_file_name, existing_transaction_manager_guid);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReplaceFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_replaced_file_name = call.get_arg();
            let lp_replacement_file_name = call.get_arg();
            let lp_backup_file_name = call.get_arg();
            let dw_replace_flags = call.get_arg();
            let lp_exclude = call.get_arg();
            let lp_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_replaced_file_name = {:?}, lp_replacement_file_name = {:?}, lp_backup_file_name = {:?}, dw_replace_flags = {:?}, lp_exclude = {:?}, lp_reserved = {:?}}}" , lp_replaced_file_name , lp_replacement_file_name , lp_backup_file_name , dw_replace_flags , lp_exclude , lp_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReplaceFileA(
                lp_replaced_file_name,
                lp_replacement_file_name,
                lp_backup_file_name,
                dw_replace_flags,
                lp_exclude,
                lp_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReplaceFileFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_replaced_file_name = call.get_arg();
            let lp_replacement_file_name = call.get_arg();
            let lp_backup_file_name = call.get_arg();
            let dw_replace_flags = call.get_arg();
            let lp_exclude = call.get_arg();
            let lp_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_replaced_file_name = {:?}, lp_replacement_file_name = {:?}, lp_backup_file_name = {:?}, dw_replace_flags = {:?}, lp_exclude = {:?}, lp_reserved = {:?}}}" , lp_replaced_file_name , lp_replacement_file_name , lp_backup_file_name , dw_replace_flags , lp_exclude , lp_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReplaceFileFromAppW(
                lp_replaced_file_name,
                lp_replacement_file_name,
                lp_backup_file_name,
                dw_replace_flags,
                lp_exclude,
                lp_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReplaceFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_replaced_file_name = call.get_arg();
            let lp_replacement_file_name = call.get_arg();
            let lp_backup_file_name = call.get_arg();
            let dw_replace_flags = call.get_arg();
            let lp_exclude = call.get_arg();
            let lp_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_replaced_file_name = {:?}, lp_replacement_file_name = {:?}, lp_backup_file_name = {:?}, dw_replace_flags = {:?}, lp_exclude = {:?}, lp_reserved = {:?}}}" , lp_replaced_file_name , lp_replacement_file_name , lp_backup_file_name , dw_replace_flags , lp_exclude , lp_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReplaceFileW(
                lp_replaced_file_name,
                lp_replacement_file_name,
                lp_backup_file_name,
                dw_replace_flags,
                lp_exclude,
                lp_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RollbackComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RollbackComplete",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RollbackComplete(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RollbackEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RollbackEnlistment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RollbackEnlistment(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RollbackTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RollbackTransaction",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{transaction_handle = {:?}}}",
                            transaction_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RollbackTransaction(transaction_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RollbackTransactionAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RollbackTransactionAsync",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{transaction_handle = {:?}}}",
                            transaction_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RollbackTransactionAsync(transaction_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RollforwardTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RollforwardTransactionManager",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_manager_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{transaction_manager_handle = {:?}, tm_virtual_clock = {:?}}}" , transaction_manager_handle , tm_virtual_clock ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.RollforwardTransactionManager(transaction_manager_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SearchPathA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SearchPathA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path = call.get_arg();
            let lp_file_name = call.get_arg();
            let lp_extension = call.get_arg();
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            let lp_file_part = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_path = {:?}, lp_file_name = {:?}, lp_extension = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_path , lp_file_name , lp_extension , n_buffer_length , lp_buffer , lp_file_part ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SearchPathA(
                lp_path,
                lp_file_name,
                lp_extension,
                n_buffer_length,
                lp_buffer,
                lp_file_part,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SearchPathW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SearchPathW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_path = call.get_arg();
            let lp_file_name = call.get_arg();
            let lp_extension = call.get_arg();
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            let lp_file_part = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_path = {:?}, lp_file_name = {:?}, lp_extension = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_path , lp_file_name , lp_extension , n_buffer_length , lp_buffer , lp_file_part ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SearchPathW(
                lp_path,
                lp_file_name,
                lp_extension,
                n_buffer_length,
                lp_buffer,
                lp_file_part,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEndOfFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetEndOfFile",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_file = {:?}}}", h_file)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetEndOfFile(h_file);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEnlistmentRecoveryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetEnlistmentRecoveryInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let buffer_size = call.get_arg();
            let buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{enlistment_handle = {:?}, buffer_size = {:?}, buffer = {:?}}}" , enlistment_handle , buffer_size , buffer ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetEnlistmentRecoveryInformation(enlistment_handle, buffer_size, buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileApisToANSI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileApisToANSI",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileApisToANSI();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileApisToOEM(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileApisToOEM",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileApisToOEM();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileAttributesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_file_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, dw_file_attributes = {:?}}}",
                            lp_file_name, dw_file_attributes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileAttributesA(lp_file_name, dw_file_attributes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileAttributesFromAppW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_file_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, dw_file_attributes = {:?}}}",
                            lp_file_name, dw_file_attributes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileAttributesFromAppW(lp_file_name, dw_file_attributes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileAttributesTransactedA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_file_attributes = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, dw_file_attributes = {:?}, h_transaction = {:?}}}" , lp_file_name , dw_file_attributes , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SetFileAttributesTransactedA(lp_file_name, dw_file_attributes, h_transaction);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileAttributesTransactedW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_file_attributes = call.get_arg();
            let h_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_name = {:?}, dw_file_attributes = {:?}, h_transaction = {:?}}}" , lp_file_name , dw_file_attributes , h_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SetFileAttributesTransactedW(lp_file_name, dw_file_attributes, h_transaction);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileAttributesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_file_name = call.get_arg();
            let dw_file_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_file_name = {:?}, dw_file_attributes = {:?}}}",
                            lp_file_name, dw_file_attributes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileAttributesW(lp_file_name, dw_file_attributes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileBandwidthReservation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileBandwidthReservation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let n_period_milliseconds = call.get_arg();
            let n_bytes_per_period = call.get_arg();
            let b_discardable = call.get_arg();
            let lp_transfer_size = call.get_arg();
            let lp_num_outstanding_requests = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, n_period_milliseconds = {:?}, n_bytes_per_period = {:?}, b_discardable = {:?}, lp_transfer_size = {:?}, lp_num_outstanding_requests = {:?}}}" , h_file , n_period_milliseconds , n_bytes_per_period , b_discardable , lp_transfer_size , lp_num_outstanding_requests ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFileBandwidthReservation(
                h_file,
                n_period_milliseconds,
                n_bytes_per_period,
                b_discardable,
                lp_transfer_size,
                lp_num_outstanding_requests,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileCompletionNotificationModes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileCompletionNotificationModes",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let file_handle = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{file_handle = {:?}, flags = {:?}}}",
                            file_handle, flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileCompletionNotificationModes(file_handle, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileInformationByHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileInformationByHandle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let file_information_class = call.get_arg();
            let lp_file_information = call.get_arg();
            let dw_buffer_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, file_information_class = {:?}, lp_file_information = {:?}, dw_buffer_size = {:?}}}" , h_file , file_information_class , lp_file_information , dw_buffer_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFileInformationByHandle(
                h_file,
                file_information_class,
                lp_file_information,
                dw_buffer_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileIoOverlappedRange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileIoOverlappedRange",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let file_handle = call.get_arg();
            let overlapped_range_start = call.get_arg();
            let length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, overlapped_range_start = {:?}, length = {:?}}}" , file_handle , overlapped_range_start , length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFileIoOverlappedRange(file_handle, overlapped_range_start, length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFilePointer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFilePointer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let l_distance_to_move = call.get_arg();
            let lp_distance_to_move_high = call.get_arg();
            let dw_move_method = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, l_distance_to_move = {:?}, lp_distance_to_move_high = {:?}, dw_move_method = {:?}}}" , h_file , l_distance_to_move , lp_distance_to_move_high , dw_move_method ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFilePointer(
                h_file,
                l_distance_to_move,
                lp_distance_to_move_high,
                dw_move_method,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFilePointerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFilePointerEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let li_distance_to_move = call.get_arg();
            let lp_new_file_pointer = call.get_arg();
            let dw_move_method = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, li_distance_to_move = {:?}, lp_new_file_pointer = {:?}, dw_move_method = {:?}}}" , h_file , li_distance_to_move , lp_new_file_pointer , dw_move_method ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFilePointerEx(
                h_file,
                li_distance_to_move,
                lp_new_file_pointer,
                dw_move_method,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileShortNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileShortNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_short_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_short_name = {:?}}}",
                            h_file, lp_short_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileShortNameA(h_file, lp_short_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileShortNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileShortNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_short_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_short_name = {:?}}}",
                            h_file, lp_short_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileShortNameW(h_file, lp_short_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetFileTime");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_creation_time = call.get_arg();
            let lp_last_access_time = call.get_arg();
            let lp_last_write_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_creation_time = {:?}, lp_last_access_time = {:?}, lp_last_write_time = {:?}}}" , h_file , lp_creation_time , lp_last_access_time , lp_last_write_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFileTime(
                h_file,
                lp_creation_time,
                lp_last_access_time,
                lp_last_write_time,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFileValidData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFileValidData",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let valid_data_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, valid_data_length = {:?}}}",
                            h_file, valid_data_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetFileValidData(h_file, valid_data_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetIoRingCompletionEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetIoRingCompletionEvent",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            let h_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{io_ring = {:?}, h_event = {:?}}}",
                            io_ring, h_event
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetIoRingCompletionEvent(io_ring, h_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetResourceManagerCompletionPort(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetResourceManagerCompletionPort",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let resource_manager_handle = call.get_arg();
            let io_completion_port_handle = call.get_arg();
            let completion_key = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{resource_manager_handle = {:?}, io_completion_port_handle = {:?}, completion_key = {:?}}}" , resource_manager_handle , io_completion_port_handle , completion_key ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetResourceManagerCompletionPort(
                resource_manager_handle,
                io_completion_port_handle,
                completion_key,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetSearchPathMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetSearchPathMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{flags = {:?}}}", flags)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetSearchPathMode(flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetTapeParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetTapeParameters",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_operation = call.get_arg();
            let lp_tape_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_operation = {:?}, lp_tape_information = {:?}}}" , h_device , dw_operation , lp_tape_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetTapeParameters(h_device, dw_operation, lp_tape_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetTapePosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetTapePosition",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_position_method = call.get_arg();
            let dw_partition = call.get_arg();
            let dw_offset_low = call.get_arg();
            let dw_offset_high = call.get_arg();
            let b_immediate = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_position_method = {:?}, dw_partition = {:?}, dw_offset_low = {:?}, dw_offset_high = {:?}, b_immediate = {:?}}}" , h_device , dw_position_method , dw_partition , dw_offset_low , dw_offset_high , b_immediate ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetTapePosition(
                h_device,
                dw_position_method,
                dw_partition,
                dw_offset_low,
                dw_offset_high,
                b_immediate,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetTransactionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetTransactionInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let transaction_handle = call.get_arg();
            let isolation_level = call.get_arg();
            let isolation_flags = call.get_arg();
            let timeout = call.get_arg();
            let description = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{transaction_handle = {:?}, isolation_level = {:?}, isolation_flags = {:?}, timeout = {:?}, description = {:?}}}" , transaction_handle , isolation_level , isolation_flags , timeout , description ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetTransactionInformation(
                transaction_handle,
                isolation_level,
                isolation_flags,
                timeout,
                description,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetVolumeLabelA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetVolumeLabelA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            let lp_volume_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_root_path_name = {:?}, lp_volume_name = {:?}}}",
                            lp_root_path_name, lp_volume_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetVolumeLabelA(lp_root_path_name, lp_volume_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetVolumeLabelW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetVolumeLabelW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lp_root_path_name = call.get_arg();
            let lp_volume_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_root_path_name = {:?}, lp_volume_name = {:?}}}",
                            lp_root_path_name, lp_volume_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetVolumeLabelW(lp_root_path_name, lp_volume_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetVolumeMountPointA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_mount_point = call.get_arg();
            let lpsz_volume_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}}}" , lpsz_volume_mount_point , lpsz_volume_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetVolumeMountPointA(lpsz_volume_mount_point, lpsz_volume_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetVolumeMountPointW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let lpsz_volume_mount_point = call.get_arg();
            let lpsz_volume_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}}}" , lpsz_volume_mount_point , lpsz_volume_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetVolumeMountPointW(lpsz_volume_mount_point, lpsz_volume_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SinglePhaseReject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SinglePhaseReject",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let enlistment_handle = call.get_arg();
            let tm_virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
                            enlistment_handle, tm_virtual_clock
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SinglePhaseReject(enlistment_handle, tm_virtual_clock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SubmitIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SubmitIoRing",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let io_ring = call.get_arg();
            let wait_operations = call.get_arg();
            let milliseconds = call.get_arg();
            let submitted_entries = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{io_ring = {:?}, wait_operations = {:?}, milliseconds = {:?}, submitted_entries = {:?}}}" , io_ring , wait_operations , milliseconds , submitted_entries ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SubmitIoRing(io_ring, wait_operations, milliseconds, submitted_entries);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfGetThreadMiniVersionForCreate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfGetThreadMiniVersionForCreate",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let mini_version = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{mini_version = {:?}}}", mini_version)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.TxfGetThreadMiniVersionForCreate(mini_version);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfLogCreateFileReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfLogCreateFileReadContext",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let log_path = call.get_arg();
            let beginning_lsn = call.get_arg();
            let ending_lsn = call.get_arg();
            let txf_file_id = call.get_arg();
            let txf_log_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{log_path = {:?}, beginning_lsn = {:?}, ending_lsn = {:?}, txf_file_id = {:?}, txf_log_context = {:?}}}" , log_path , beginning_lsn , ending_lsn , txf_file_id , txf_log_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TxfLogCreateFileReadContext(
                log_path,
                beginning_lsn,
                ending_lsn,
                txf_file_id,
                txf_log_context,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfLogCreateRangeReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfLogCreateRangeReadContext",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let log_path = call.get_arg();
            let beginning_lsn = call.get_arg();
            let ending_lsn = call.get_arg();
            let beginning_virtual_clock = call.get_arg();
            let ending_virtual_clock = call.get_arg();
            let record_type_mask = call.get_arg();
            let txf_log_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{log_path = {:?}, beginning_lsn = {:?}, ending_lsn = {:?}, beginning_virtual_clock = {:?}, ending_virtual_clock = {:?}, record_type_mask = {:?}, txf_log_context = {:?}}}" , log_path , beginning_lsn , ending_lsn , beginning_virtual_clock , ending_virtual_clock , record_type_mask , txf_log_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TxfLogCreateRangeReadContext(
                log_path,
                beginning_lsn,
                ending_lsn,
                beginning_virtual_clock,
                ending_virtual_clock,
                record_type_mask,
                txf_log_context,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfLogDestroyReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfLogDestroyReadContext",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let txf_log_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{txf_log_context = {:?}}}", txf_log_context)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.TxfLogDestroyReadContext(txf_log_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfLogReadRecords(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfLogReadRecords",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let txf_log_context = call.get_arg();
            let buffer_length = call.get_arg();
            let buffer = call.get_arg();
            let bytes_used = call.get_arg();
            let record_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{txf_log_context = {:?}, buffer_length = {:?}, buffer = {:?}, bytes_used = {:?}, record_count = {:?}}}" , txf_log_context , buffer_length , buffer , bytes_used , record_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TxfLogReadRecords(
                txf_log_context,
                buffer_length,
                buffer,
                bytes_used,
                record_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfLogRecordGetFileName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfLogRecordGetFileName",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let record_buffer = call.get_arg();
            let record_buffer_length_in_bytes = call.get_arg();
            let name_buffer = call.get_arg();
            let name_buffer_length_in_bytes = call.get_arg();
            let txf_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{record_buffer = {:?}, record_buffer_length_in_bytes = {:?}, name_buffer = {:?}, name_buffer_length_in_bytes = {:?}, txf_id = {:?}}}" , record_buffer , record_buffer_length_in_bytes , name_buffer , name_buffer_length_in_bytes , txf_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TxfLogRecordGetFileName(
                record_buffer,
                record_buffer_length_in_bytes,
                name_buffer,
                name_buffer_length_in_bytes,
                txf_id,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfLogRecordGetGenericType(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfLogRecordGetGenericType",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let record_buffer = call.get_arg();
            let record_buffer_length_in_bytes = call.get_arg();
            let generic_type = call.get_arg();
            let virtual_clock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{record_buffer = {:?}, record_buffer_length_in_bytes = {:?}, generic_type = {:?}, virtual_clock = {:?}}}" , record_buffer , record_buffer_length_in_bytes , generic_type , virtual_clock ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TxfLogRecordGetGenericType(
                record_buffer,
                record_buffer_length_in_bytes,
                generic_type,
                virtual_clock,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfReadMetadataInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfReadMetadataInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let file_handle = call.get_arg();
            let txf_file_id = call.get_arg();
            let last_lsn = call.get_arg();
            let transaction_state = call.get_arg();
            let locking_transaction = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, txf_file_id = {:?}, last_lsn = {:?}, transaction_state = {:?}, locking_transaction = {:?}}}" , file_handle , txf_file_id , last_lsn , transaction_state , locking_transaction ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TxfReadMetadataInfo(
                file_handle,
                txf_file_id,
                last_lsn,
                transaction_state,
                locking_transaction,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TxfSetThreadMiniVersionForCreate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TxfSetThreadMiniVersionForCreate",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let mini_version = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{mini_version = {:?}}}", mini_version)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.TxfSetThreadMiniVersionForCreate(mini_version);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnlockFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "UnlockFile");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let dw_file_offset_low = call.get_arg();
            let dw_file_offset_high = call.get_arg();
            let n_number_of_bytes_to_unlock_low = call.get_arg();
            let n_number_of_bytes_to_unlock_high = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, dw_file_offset_low = {:?}, dw_file_offset_high = {:?}, n_number_of_bytes_to_unlock_low = {:?}, n_number_of_bytes_to_unlock_high = {:?}}}" , h_file , dw_file_offset_low , dw_file_offset_high , n_number_of_bytes_to_unlock_low , n_number_of_bytes_to_unlock_high ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UnlockFile(
                h_file,
                dw_file_offset_low,
                dw_file_offset_high,
                n_number_of_bytes_to_unlock_low,
                n_number_of_bytes_to_unlock_high,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnlockFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnlockFileEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let dw_reserved = call.get_arg();
            let n_number_of_bytes_to_unlock_low = call.get_arg();
            let n_number_of_bytes_to_unlock_high = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, dw_reserved = {:?}, n_number_of_bytes_to_unlock_low = {:?}, n_number_of_bytes_to_unlock_high = {:?}, lp_overlapped = {:?}}}" , h_file , dw_reserved , n_number_of_bytes_to_unlock_low , n_number_of_bytes_to_unlock_high , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UnlockFileEx(
                h_file,
                dw_reserved,
                n_number_of_bytes_to_unlock_low,
                n_number_of_bytes_to_unlock_high,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerFindFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerFindFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let u_flags = call.get_arg();
            let sz_file_name = call.get_arg();
            let sz_win_dir = call.get_arg();
            let sz_app_dir = call.get_arg();
            let sz_cur_dir = call.get_arg();
            let pu_cur_dir_len = call.get_arg();
            let sz_dest_dir = call.get_arg();
            let pu_dest_dir_len = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{u_flags = {:?}, sz_file_name = {:?}, sz_win_dir = {:?}, sz_app_dir = {:?}, sz_cur_dir = {:?}, pu_cur_dir_len = {:?}, sz_dest_dir = {:?}, pu_dest_dir_len = {:?}}}" , u_flags , sz_file_name , sz_win_dir , sz_app_dir , sz_cur_dir , pu_cur_dir_len , sz_dest_dir , pu_dest_dir_len ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerFindFileA(
                u_flags,
                sz_file_name,
                sz_win_dir,
                sz_app_dir,
                sz_cur_dir,
                pu_cur_dir_len,
                sz_dest_dir,
                pu_dest_dir_len,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerFindFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerFindFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let u_flags = call.get_arg();
            let sz_file_name = call.get_arg();
            let sz_win_dir = call.get_arg();
            let sz_app_dir = call.get_arg();
            let sz_cur_dir = call.get_arg();
            let pu_cur_dir_len = call.get_arg();
            let sz_dest_dir = call.get_arg();
            let pu_dest_dir_len = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{u_flags = {:?}, sz_file_name = {:?}, sz_win_dir = {:?}, sz_app_dir = {:?}, sz_cur_dir = {:?}, pu_cur_dir_len = {:?}, sz_dest_dir = {:?}, pu_dest_dir_len = {:?}}}" , u_flags , sz_file_name , sz_win_dir , sz_app_dir , sz_cur_dir , pu_cur_dir_len , sz_dest_dir , pu_dest_dir_len ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerFindFileW(
                u_flags,
                sz_file_name,
                sz_win_dir,
                sz_app_dir,
                sz_cur_dir,
                pu_cur_dir_len,
                sz_dest_dir,
                pu_dest_dir_len,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerInstallFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerInstallFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let u_flags = call.get_arg();
            let sz_src_file_name = call.get_arg();
            let sz_dest_file_name = call.get_arg();
            let sz_src_dir = call.get_arg();
            let sz_dest_dir = call.get_arg();
            let sz_cur_dir = call.get_arg();
            let sz_tmp_file = call.get_arg();
            let pu_tmp_file_len = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{u_flags = {:?}, sz_src_file_name = {:?}, sz_dest_file_name = {:?}, sz_src_dir = {:?}, sz_dest_dir = {:?}, sz_cur_dir = {:?}, sz_tmp_file = {:?}, pu_tmp_file_len = {:?}}}" , u_flags , sz_src_file_name , sz_dest_file_name , sz_src_dir , sz_dest_dir , sz_cur_dir , sz_tmp_file , pu_tmp_file_len ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerInstallFileA(
                u_flags,
                sz_src_file_name,
                sz_dest_file_name,
                sz_src_dir,
                sz_dest_dir,
                sz_cur_dir,
                sz_tmp_file,
                pu_tmp_file_len,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerInstallFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerInstallFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let u_flags = call.get_arg();
            let sz_src_file_name = call.get_arg();
            let sz_dest_file_name = call.get_arg();
            let sz_src_dir = call.get_arg();
            let sz_dest_dir = call.get_arg();
            let sz_cur_dir = call.get_arg();
            let sz_tmp_file = call.get_arg();
            let pu_tmp_file_len = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{u_flags = {:?}, sz_src_file_name = {:?}, sz_dest_file_name = {:?}, sz_src_dir = {:?}, sz_dest_dir = {:?}, sz_cur_dir = {:?}, sz_tmp_file = {:?}, pu_tmp_file_len = {:?}}}" , u_flags , sz_src_file_name , sz_dest_file_name , sz_src_dir , sz_dest_dir , sz_cur_dir , sz_tmp_file , pu_tmp_file_len ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerInstallFileW(
                u_flags,
                sz_src_file_name,
                sz_dest_file_name,
                sz_src_dir,
                sz_dest_dir,
                sz_cur_dir,
                sz_tmp_file,
                pu_tmp_file_len,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerLanguageNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerLanguageNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let w_lang = call.get_arg();
            let sz_lang = call.get_arg();
            let cch_lang = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{w_lang = {:?}, sz_lang = {:?}, cch_lang = {:?}}}",
                            w_lang, sz_lang, cch_lang
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.VerLanguageNameA(w_lang, sz_lang, cch_lang);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerLanguageNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerLanguageNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let w_lang = call.get_arg();
            let sz_lang = call.get_arg();
            let cch_lang = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{w_lang = {:?}, sz_lang = {:?}, cch_lang = {:?}}}",
                            w_lang, sz_lang, cch_lang
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.VerLanguageNameW(w_lang, sz_lang, cch_lang);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerQueryValueA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerQueryValueA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let p_block = call.get_arg();
            let lp_sub_block = call.get_arg();
            let lplp_buffer = call.get_arg();
            let pu_len = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{p_block = {:?}, lp_sub_block = {:?}, lplp_buffer = {:?}, pu_len = {:?}}}" , p_block , lp_sub_block , lplp_buffer , pu_len ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerQueryValueA(p_block, lp_sub_block, lplp_buffer, pu_len);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerQueryValueW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerQueryValueW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let p_block = call.get_arg();
            let lp_sub_block = call.get_arg();
            let lplp_buffer = call.get_arg();
            let pu_len = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{p_block = {:?}, lp_sub_block = {:?}, lplp_buffer = {:?}, pu_len = {:?}}}" , p_block , lp_sub_block , lplp_buffer , pu_len ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerQueryValueW(p_block, lp_sub_block, lplp_buffer, pu_len);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofEnumEntries(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofEnumEntries",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume_name = call.get_arg();
            let provider = call.get_arg();
            let enum_proc = call.get_arg();
            let user_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{volume_name = {:?}, provider = {:?}, enum_proc = {:?}, user_data = {:?}}}" , volume_name , provider , enum_proc , user_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WofEnumEntries(volume_name, provider, enum_proc, user_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofFileEnumFiles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofFileEnumFiles",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume_name = call.get_arg();
            let algorithm = call.get_arg();
            let enum_proc = call.get_arg();
            let user_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{volume_name = {:?}, algorithm = {:?}, enum_proc = {:?}, user_data = {:?}}}" , volume_name , algorithm , enum_proc , user_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WofFileEnumFiles(volume_name, algorithm, enum_proc, user_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofGetDriverVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofGetDriverVersion",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let file_or_volume_handle = call.get_arg();
            let provider = call.get_arg();
            let wof_version = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_or_volume_handle = {:?}, provider = {:?}, wof_version = {:?}}}" , file_or_volume_handle , provider , wof_version ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WofGetDriverVersion(file_or_volume_handle, provider, wof_version);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofIsExternalFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofIsExternalFile",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let file_path = call.get_arg();
            let is_external_file = call.get_arg();
            let provider = call.get_arg();
            let external_file_info = call.get_arg();
            let buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_path = {:?}, is_external_file = {:?}, provider = {:?}, external_file_info = {:?}, buffer_length = {:?}}}" , file_path , is_external_file , provider , external_file_info , buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WofIsExternalFile(
                file_path,
                is_external_file,
                provider,
                external_file_info,
                buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofSetFileDataLocation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofSetFileDataLocation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let file_handle = call.get_arg();
            let provider = call.get_arg();
            let external_file_info = call.get_arg();
            let length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, provider = {:?}, external_file_info = {:?}, length = {:?}}}" , file_handle , provider , external_file_info , length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WofSetFileDataLocation(file_handle, provider, external_file_info, length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofShouldCompressBinaries(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofShouldCompressBinaries",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume = call.get_arg();
            let algorithm = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{volume = {:?}, algorithm = {:?}}}",
                            volume, algorithm
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WofShouldCompressBinaries(volume, algorithm);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofWimAddEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofWimAddEntry",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume_name = call.get_arg();
            let wim_path = call.get_arg();
            let wim_type = call.get_arg();
            let wim_index = call.get_arg();
            let data_source_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{volume_name = {:?}, wim_path = {:?}, wim_type = {:?}, wim_index = {:?}, data_source_id = {:?}}}" , volume_name , wim_path , wim_type , wim_index , data_source_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.WofWimAddEntry(volume_name, wim_path, wim_type, wim_index, data_source_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofWimEnumFiles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofWimEnumFiles",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume_name = call.get_arg();
            let data_source_id = call.get_arg();
            let enum_proc = call.get_arg();
            let user_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{volume_name = {:?}, data_source_id = {:?}, enum_proc = {:?}, user_data = {:?}}}" , volume_name , data_source_id , enum_proc , user_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WofWimEnumFiles(volume_name, data_source_id, enum_proc, user_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofWimRemoveEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofWimRemoveEntry",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume_name = call.get_arg();
            let data_source_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{volume_name = {:?}, data_source_id = {:?}}}",
                            volume_name, data_source_id
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WofWimRemoveEntry(volume_name, data_source_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofWimSuspendEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofWimSuspendEntry",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume_name = call.get_arg();
            let data_source_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{volume_name = {:?}, data_source_id = {:?}}}",
                            volume_name, data_source_id
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WofWimSuspendEntry(volume_name, data_source_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WofWimUpdateEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WofWimUpdateEntry",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let volume_name = call.get_arg();
            let data_source_id = call.get_arg();
            let new_wim_path = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{volume_name = {:?}, data_source_id = {:?}, new_wim_path = {:?}}}" , volume_name , data_source_id , new_wim_path ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WofWimUpdateEntry(volume_name, data_source_id, new_wim_path);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_Wow64DisableWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "Wow64DisableWow64FsRedirection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let old_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{old_value = {:?}}}", old_value)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.Wow64DisableWow64FsRedirection(old_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_Wow64EnableWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "Wow64EnableWow64FsRedirection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let wow_64_fs_enable_redirection = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{wow_64_fs_enable_redirection = {:?}}}",
                            wow_64_fs_enable_redirection
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.Wow64EnableWow64FsRedirection(wow_64_fs_enable_redirection);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_Wow64RevertWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "Wow64RevertWow64FsRedirection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let ol_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ol_value = {:?}}}", ol_value)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.Wow64RevertWow64FsRedirection(ol_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteEncryptedFileRaw",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let pf_import_callback = call.get_arg();
            let pv_callback_context = call.get_arg();
            let pv_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pf_import_callback = {:?}, pv_callback_context = {:?}, pv_context = {:?}}}" , pf_import_callback , pv_callback_context , pv_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.WriteEncryptedFileRaw(pf_import_callback, pv_callback_context, pv_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "WriteFile");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_bytes_to_write = call.get_arg();
            let lp_number_of_bytes_written = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_write = {:?}, lp_number_of_bytes_written = {:?}, lp_overlapped = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_write , lp_number_of_bytes_written , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteFile(
                h_file,
                lp_buffer,
                n_number_of_bytes_to_write,
                lp_number_of_bytes_written,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "WriteFileEx");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_bytes_to_write = call.get_arg();
            let lp_overlapped = call.get_arg();
            let lp_completion_routine = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_write = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_write , lp_overlapped , lp_completion_routine ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteFileEx(
                h_file,
                lp_buffer,
                n_number_of_bytes_to_write,
                lp_overlapped,
                lp_completion_routine,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteFileGather(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteFileGather",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_file = call.get_arg();
            let a_segment_array = call.get_arg();
            let n_number_of_bytes_to_write = call.get_arg();
            let lp_reserved = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, a_segment_array = {:?}, n_number_of_bytes_to_write = {:?}, lp_reserved = {:?}, lp_overlapped = {:?}}}" , h_file , a_segment_array , n_number_of_bytes_to_write , lp_reserved , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteFileGather(
                h_file,
                a_segment_array,
                n_number_of_bytes_to_write,
                lp_reserved,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteTapemark(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteTapemark",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::Storage::FileSystem::get_api(win32);
            let h_device = call.get_arg();
            let dw_tapemark_type = call.get_arg();
            let dw_tapemark_count = call.get_arg();
            let b_immediate = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_tapemark_type = {:?}, dw_tapemark_count = {:?}, b_immediate = {:?}}}" , h_device , dw_tapemark_type , dw_tapemark_count , b_immediate ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteTapemark(h_device, dw_tapemark_type, dw_tapemark_count, b_immediate);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddConsoleAliasA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddConsoleAliasA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let source = call.get_arg();
            let target = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{source = {:?}, target = {:?}, exe_name = {:?}}}",
                            source, target, exe_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AddConsoleAliasA(source, target, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddConsoleAliasW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddConsoleAliasW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let source = call.get_arg();
            let target = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{source = {:?}, target = {:?}, exe_name = {:?}}}",
                            source, target, exe_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AddConsoleAliasW(source, target, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AllocConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AllocConsole",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AllocConsole();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AttachConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AttachConsole",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let dw_process_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_process_id = {:?}}}", dw_process_id)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.AttachConsole(dw_process_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ClosePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ClosePseudoConsole",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_pc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_pc = {:?}}}", h_pc)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ClosePseudoConsole(h_pc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreatePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreatePseudoConsole",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let size = call.get_arg();
            let h_input = call.get_arg();
            let h_output = call.get_arg();
            let dw_flags = call.get_arg();
            let ph_pc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{size = {:?}, h_input = {:?}, h_output = {:?}, dw_flags = {:?}, ph_pc = {:?}}}" , size , h_input , h_output , dw_flags , ph_pc ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreatePseudoConsole(size, h_input, h_output, dw_flags, ph_pc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExpungeConsoleCommandHistoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExpungeConsoleCommandHistoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ExpungeConsoleCommandHistoryA(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExpungeConsoleCommandHistoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExpungeConsoleCommandHistoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ExpungeConsoleCommandHistoryW(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FillConsoleOutputAttribute",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let w_attribute = call.get_arg();
            let n_length = call.get_arg();
            let dw_write_coord = call.get_arg();
            let lp_number_of_attrs_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, w_attribute = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_attrs_written = {:?}}}" , h_console_output , w_attribute , n_length , dw_write_coord , lp_number_of_attrs_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FillConsoleOutputAttribute(
                h_console_output,
                w_attribute,
                n_length,
                dw_write_coord,
                lp_number_of_attrs_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FillConsoleOutputCharacterA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let c_character = call.get_arg();
            let n_length = call.get_arg();
            let dw_write_coord = call.get_arg();
            let lp_number_of_chars_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, c_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , c_character , n_length , dw_write_coord , lp_number_of_chars_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FillConsoleOutputCharacterA(
                h_console_output,
                c_character,
                n_length,
                dw_write_coord,
                lp_number_of_chars_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FillConsoleOutputCharacterW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let c_character = call.get_arg();
            let n_length = call.get_arg();
            let dw_write_coord = call.get_arg();
            let lp_number_of_chars_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, c_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , c_character , n_length , dw_write_coord , lp_number_of_chars_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FillConsoleOutputCharacterW(
                h_console_output,
                c_character,
                n_length,
                dw_write_coord,
                lp_number_of_chars_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlushConsoleInputBuffer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FlushConsoleInputBuffer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_console_input = {:?}}}", h_console_input)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FlushConsoleInputBuffer(h_console_input);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FreeConsole");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FreeConsole();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GenerateConsoleCtrlEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GenerateConsoleCtrlEvent",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let dw_ctrl_event = call.get_arg();
            let dw_process_group_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_ctrl_event = {:?}, dw_process_group_id = {:?}}}",
                            dw_ctrl_event, dw_process_group_id
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GenerateConsoleCtrlEvent(dw_ctrl_event, dw_process_group_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let source = call.get_arg();
            let target_buffer = call.get_arg();
            let target_buffer_length = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{source = {:?}, target_buffer = {:?}, target_buffer_length = {:?}, exe_name = {:?}}}" , source , target_buffer , target_buffer_length , exe_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetConsoleAliasA(source, target_buffer, target_buffer_length, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasExesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name_buffer = call.get_arg();
            let exe_name_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{exe_name_buffer = {:?}, exe_name_buffer_length = {:?}}}",
                            exe_name_buffer, exe_name_buffer_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleAliasExesA(exe_name_buffer, exe_name_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasExesLengthA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleAliasExesLengthA();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasExesLengthW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleAliasExesLengthW();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasExesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name_buffer = call.get_arg();
            let exe_name_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{exe_name_buffer = {:?}, exe_name_buffer_length = {:?}}}",
                            exe_name_buffer, exe_name_buffer_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleAliasExesW(exe_name_buffer, exe_name_buffer_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let source = call.get_arg();
            let target_buffer = call.get_arg();
            let target_buffer_length = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{source = {:?}, target_buffer = {:?}, target_buffer_length = {:?}, exe_name = {:?}}}" , source , target_buffer , target_buffer_length , exe_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetConsoleAliasW(source, target_buffer, target_buffer_length, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let alias_buffer = call.get_arg();
            let alias_buffer_length = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{alias_buffer = {:?}, alias_buffer_length = {:?}, exe_name = {:?}}}" , alias_buffer , alias_buffer_length , exe_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetConsoleAliasesA(alias_buffer, alias_buffer_length, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasesLengthA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleAliasesLengthA(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasesLengthW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleAliasesLengthW(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleAliasesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let alias_buffer = call.get_arg();
            let alias_buffer_length = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{alias_buffer = {:?}, alias_buffer_length = {:?}, exe_name = {:?}}}" , alias_buffer , alias_buffer_length , exe_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetConsoleAliasesW(alias_buffer, alias_buffer_length, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleCP",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleCP();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleCommandHistoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let commands = call.get_arg();
            let command_buffer_length = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{commands = {:?}, command_buffer_length = {:?}, exe_name = {:?}}}" , commands , command_buffer_length , exe_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetConsoleCommandHistoryA(commands, command_buffer_length, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleCommandHistoryLengthA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleCommandHistoryLengthA(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleCommandHistoryLengthW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleCommandHistoryLengthW(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleCommandHistoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let commands = call.get_arg();
            let command_buffer_length = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{commands = {:?}, command_buffer_length = {:?}, exe_name = {:?}}}" , commands , command_buffer_length , exe_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetConsoleCommandHistoryW(commands, command_buffer_length, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCursorInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleCursorInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_console_cursor_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_output = {:?}, lp_console_cursor_info = {:?}}}",
                            h_console_output, lp_console_cursor_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleCursorInfo(h_console_output, lp_console_cursor_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleDisplayMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleDisplayMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_mode_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_mode_flags = {:?}}}", lp_mode_flags)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetConsoleDisplayMode(lp_mode_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleHistoryInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleHistoryInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_history_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_history_info = {:?}}}",
                            lp_console_history_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleHistoryInfo(lp_console_history_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_handle = call.get_arg();
            let lp_mode = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_handle = {:?}, lp_mode = {:?}}}",
                            h_console_handle, lp_mode
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleMode(h_console_handle, lp_mode);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOriginalTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleOriginalTitleA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_title = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_title = {:?}, n_size = {:?}}}",
                            lp_console_title, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleOriginalTitleA(lp_console_title, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOriginalTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleOriginalTitleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_title = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_title = {:?}, n_size = {:?}}}",
                            lp_console_title, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleOriginalTitleW(lp_console_title, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOutputCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleOutputCP",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleOutputCP();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleProcessList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleProcessList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lpdw_process_list = call.get_arg();
            let dw_process_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpdw_process_list = {:?}, dw_process_count = {:?}}}",
                            lpdw_process_list, dw_process_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleProcessList(lpdw_process_list, dw_process_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleScreenBufferInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleScreenBufferInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_console_screen_buffer_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_console_screen_buffer_info = {:?}}}" , h_console_output , lp_console_screen_buffer_info ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetConsoleScreenBufferInfo(h_console_output, lp_console_screen_buffer_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleScreenBufferInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleScreenBufferInfoEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_console_screen_buffer_info_ex = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_console_screen_buffer_info_ex = {:?}}}" , h_console_output , lp_console_screen_buffer_info_ex ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api
                .GetConsoleScreenBufferInfoEx(h_console_output, lp_console_screen_buffer_info_ex);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleSelectionInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleSelectionInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_selection_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_selection_info = {:?}}}",
                            lp_console_selection_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleSelectionInfo(lp_console_selection_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleTitleA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_title = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_title = {:?}, n_size = {:?}}}",
                            lp_console_title, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleTitleA(lp_console_title, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleTitleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_title = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_title = {:?}, n_size = {:?}}}",
                            lp_console_title, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleTitleW(lp_console_title, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetConsoleWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetConsoleWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetConsoleWindow();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentConsoleFont(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentConsoleFont",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let b_maximum_window = call.get_arg();
            let lp_console_current_font = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, b_maximum_window = {:?}, lp_console_current_font = {:?}}}" , h_console_output , b_maximum_window , lp_console_current_font ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCurrentConsoleFont(
                h_console_output,
                b_maximum_window,
                lp_console_current_font,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentConsoleFontEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentConsoleFontEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let b_maximum_window = call.get_arg();
            let lp_console_current_font_ex = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, b_maximum_window = {:?}, lp_console_current_font_ex = {:?}}}" , h_console_output , b_maximum_window , lp_console_current_font_ex ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCurrentConsoleFontEx(
                h_console_output,
                b_maximum_window,
                lp_console_current_font_ex,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumberOfConsoleInputEvents(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumberOfConsoleInputEvents",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_number_of_events = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_input = {:?}, lp_number_of_events = {:?}}}",
                            h_console_input, lp_number_of_events
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumberOfConsoleInputEvents(h_console_input, lp_number_of_events);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumberOfConsoleMouseButtons(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumberOfConsoleMouseButtons",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_number_of_mouse_buttons = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_number_of_mouse_buttons = {:?}}}",
                            lp_number_of_mouse_buttons
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumberOfConsoleMouseButtons(lp_number_of_mouse_buttons);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStdHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStdHandle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let n_std_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{n_std_handle = {:?}}}", n_std_handle)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetStdHandle(n_std_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PeekConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PeekConsoleInputA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_length = call.get_arg();
            let lp_number_of_events_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PeekConsoleInputA(
                h_console_input,
                lp_buffer,
                n_length,
                lp_number_of_events_read,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PeekConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PeekConsoleInputW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_length = call.get_arg();
            let lp_number_of_events_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PeekConsoleInputW(
                h_console_input,
                lp_buffer,
                n_length,
                lp_number_of_events_read,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_chars_to_read = call.get_arg();
            let lp_number_of_chars_read = call.get_arg();
            let p_input_control = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_number_of_chars_to_read = {:?}, lp_number_of_chars_read = {:?}, p_input_control = {:?}}}" , h_console_input , lp_buffer , n_number_of_chars_to_read , lp_number_of_chars_read , p_input_control ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleA(
                h_console_input,
                lp_buffer,
                n_number_of_chars_to_read,
                lp_number_of_chars_read,
                p_input_control,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleInputA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_length = call.get_arg();
            let lp_number_of_events_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleInputA(
                h_console_input,
                lp_buffer,
                n_length,
                lp_number_of_events_read,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleInputW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_length = call.get_arg();
            let lp_number_of_events_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleInputW(
                h_console_input,
                lp_buffer,
                n_length,
                lp_number_of_events_read,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleOutputA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_buffer_size = call.get_arg();
            let dw_buffer_coord = call.get_arg();
            let lp_read_region = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_read_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_read_region ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleOutputA(
                h_console_output,
                lp_buffer,
                dw_buffer_size,
                dw_buffer_coord,
                lp_read_region,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleOutputAttribute",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_attribute = call.get_arg();
            let n_length = call.get_arg();
            let dw_read_coord = call.get_arg();
            let lp_number_of_attrs_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_attribute = {:?}, n_length = {:?}, dw_read_coord = {:?}, lp_number_of_attrs_read = {:?}}}" , h_console_output , lp_attribute , n_length , dw_read_coord , lp_number_of_attrs_read ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleOutputAttribute(
                h_console_output,
                lp_attribute,
                n_length,
                dw_read_coord,
                lp_number_of_attrs_read,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleOutputCharacterA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_character = call.get_arg();
            let n_length = call.get_arg();
            let dw_read_coord = call.get_arg();
            let lp_number_of_chars_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_read_coord = {:?}, lp_number_of_chars_read = {:?}}}" , h_console_output , lp_character , n_length , dw_read_coord , lp_number_of_chars_read ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleOutputCharacterA(
                h_console_output,
                lp_character,
                n_length,
                dw_read_coord,
                lp_number_of_chars_read,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleOutputCharacterW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_character = call.get_arg();
            let n_length = call.get_arg();
            let dw_read_coord = call.get_arg();
            let lp_number_of_chars_read = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_read_coord = {:?}, lp_number_of_chars_read = {:?}}}" , h_console_output , lp_character , n_length , dw_read_coord , lp_number_of_chars_read ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleOutputCharacterW(
                h_console_output,
                lp_character,
                n_length,
                dw_read_coord,
                lp_number_of_chars_read,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleOutputW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_buffer_size = call.get_arg();
            let dw_buffer_coord = call.get_arg();
            let lp_read_region = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_read_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_read_region ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleOutputW(
                h_console_output,
                lp_buffer,
                dw_buffer_size,
                dw_buffer_coord,
                lp_read_region,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReadConsoleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_chars_to_read = call.get_arg();
            let lp_number_of_chars_read = call.get_arg();
            let p_input_control = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_number_of_chars_to_read = {:?}, lp_number_of_chars_read = {:?}, p_input_control = {:?}}}" , h_console_input , lp_buffer , n_number_of_chars_to_read , lp_number_of_chars_read , p_input_control ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReadConsoleW(
                h_console_input,
                lp_buffer,
                n_number_of_chars_to_read,
                lp_number_of_chars_read,
                p_input_control,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ResizePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ResizePseudoConsole",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_pc = call.get_arg();
            let size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_pc = {:?}, size = {:?}}}", h_pc, size)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.ResizePseudoConsole(h_pc, size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScrollConsoleScreenBufferA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScrollConsoleScreenBufferA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_scroll_rectangle = call.get_arg();
            let lp_clip_rectangle = call.get_arg();
            let dw_destination_origin = call.get_arg();
            let lp_fill = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_scroll_rectangle = {:?}, lp_clip_rectangle = {:?}, dw_destination_origin = {:?}, lp_fill = {:?}}}" , h_console_output , lp_scroll_rectangle , lp_clip_rectangle , dw_destination_origin , lp_fill ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScrollConsoleScreenBufferA(
                h_console_output,
                lp_scroll_rectangle,
                lp_clip_rectangle,
                dw_destination_origin,
                lp_fill,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScrollConsoleScreenBufferW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScrollConsoleScreenBufferW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_scroll_rectangle = call.get_arg();
            let lp_clip_rectangle = call.get_arg();
            let dw_destination_origin = call.get_arg();
            let lp_fill = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_scroll_rectangle = {:?}, lp_clip_rectangle = {:?}, dw_destination_origin = {:?}, lp_fill = {:?}}}" , h_console_output , lp_scroll_rectangle , lp_clip_rectangle , dw_destination_origin , lp_fill ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScrollConsoleScreenBufferW(
                h_console_output,
                lp_scroll_rectangle,
                lp_clip_rectangle,
                dw_destination_origin,
                lp_fill,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleActiveScreenBuffer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleActiveScreenBuffer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_output = {:?}}}",
                            h_console_output
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleActiveScreenBuffer(h_console_output);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleCP",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let w_code_page_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{w_code_page_id = {:?}}}", w_code_page_id)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetConsoleCP(w_code_page_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCtrlHandler(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleCtrlHandler",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let handler_routine = call.get_arg();
            let add = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{handler_routine = {:?}, add = {:?}}}",
                            handler_routine, add
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleCtrlHandler(handler_routine, add);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCursorInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleCursorInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_console_cursor_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_output = {:?}, lp_console_cursor_info = {:?}}}",
                            h_console_output, lp_console_cursor_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleCursorInfo(h_console_output, lp_console_cursor_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCursorPosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleCursorPosition",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let dw_cursor_position = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_output = {:?}, dw_cursor_position = {:?}}}",
                            h_console_output, dw_cursor_position
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleCursorPosition(h_console_output, dw_cursor_position);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleDisplayMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleDisplayMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_new_screen_buffer_dimensions = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, dw_flags = {:?}, lp_new_screen_buffer_dimensions = {:?}}}" , h_console_output , dw_flags , lp_new_screen_buffer_dimensions ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetConsoleDisplayMode(
                h_console_output,
                dw_flags,
                lp_new_screen_buffer_dimensions,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleHistoryInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleHistoryInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_history_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_history_info = {:?}}}",
                            lp_console_history_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleHistoryInfo(lp_console_history_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_handle = call.get_arg();
            let dw_mode = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_handle = {:?}, dw_mode = {:?}}}",
                            h_console_handle, dw_mode
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleMode(h_console_handle, dw_mode);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleNumberOfCommandsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleNumberOfCommandsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let number = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{number = {:?}, exe_name = {:?}}}",
                            number, exe_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleNumberOfCommandsA(number, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleNumberOfCommandsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleNumberOfCommandsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let number = call.get_arg();
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{number = {:?}, exe_name = {:?}}}",
                            number, exe_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleNumberOfCommandsW(number, exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleOutputCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleOutputCP",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let w_code_page_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{w_code_page_id = {:?}}}", w_code_page_id)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetConsoleOutputCP(w_code_page_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleScreenBufferInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleScreenBufferInfoEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_console_screen_buffer_info_ex = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_console_screen_buffer_info_ex = {:?}}}" , h_console_output , lp_console_screen_buffer_info_ex ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api
                .SetConsoleScreenBufferInfoEx(h_console_output, lp_console_screen_buffer_info_ex);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleScreenBufferSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleScreenBufferSize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let dw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_output = {:?}, dw_size = {:?}}}",
                            h_console_output, dw_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleScreenBufferSize(h_console_output, dw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTextAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleTextAttribute",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let w_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_console_output = {:?}, w_attributes = {:?}}}",
                            h_console_output, w_attributes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleTextAttribute(h_console_output, w_attributes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleTitleA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_title = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_title = {:?}}}",
                            lp_console_title
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleTitleA(lp_console_title);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleTitleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let lp_console_title = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_console_title = {:?}}}",
                            lp_console_title
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetConsoleTitleW(lp_console_title);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetConsoleWindowInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetConsoleWindowInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let b_absolute = call.get_arg();
            let lp_console_window = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, b_absolute = {:?}, lp_console_window = {:?}}}" , h_console_output , b_absolute , lp_console_window ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetConsoleWindowInfo(h_console_output, b_absolute, lp_console_window);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCurrentConsoleFontEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCurrentConsoleFontEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let b_maximum_window = call.get_arg();
            let lp_console_current_font_ex = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, b_maximum_window = {:?}, lp_console_current_font_ex = {:?}}}" , h_console_output , b_maximum_window , lp_console_current_font_ex ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetCurrentConsoleFontEx(
                h_console_output,
                b_maximum_window,
                lp_console_current_font_ex,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetStdHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetStdHandle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let n_std_handle = call.get_arg();
            let h_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_std_handle = {:?}, h_handle = {:?}}}",
                            n_std_handle, h_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetStdHandle(n_std_handle, h_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetStdHandleEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetStdHandleEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let n_std_handle = call.get_arg();
            let h_handle = call.get_arg();
            let ph_prev_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{n_std_handle = {:?}, h_handle = {:?}, ph_prev_value = {:?}}}" , n_std_handle , h_handle , ph_prev_value ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetStdHandleEx(n_std_handle, h_handle, ph_prev_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_chars_to_write = call.get_arg();
            let lp_number_of_chars_written = call.get_arg();
            let lp_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_buffer = {:?}, n_number_of_chars_to_write = {:?}, lp_number_of_chars_written = {:?}, lp_reserved = {:?}}}" , h_console_output , lp_buffer , n_number_of_chars_to_write , lp_number_of_chars_written , lp_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleA(
                h_console_output,
                lp_buffer,
                n_number_of_chars_to_write,
                lp_number_of_chars_written,
                lp_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleInputA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_length = call.get_arg();
            let lp_number_of_events_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_written = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleInputA(
                h_console_input,
                lp_buffer,
                n_length,
                lp_number_of_events_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleInputW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_input = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_length = call.get_arg();
            let lp_number_of_events_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_written = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleInputW(
                h_console_input,
                lp_buffer,
                n_length,
                lp_number_of_events_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleOutputA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_buffer_size = call.get_arg();
            let dw_buffer_coord = call.get_arg();
            let lp_write_region = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_write_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_write_region ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleOutputA(
                h_console_output,
                lp_buffer,
                dw_buffer_size,
                dw_buffer_coord,
                lp_write_region,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleOutputAttribute",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_attribute = call.get_arg();
            let n_length = call.get_arg();
            let dw_write_coord = call.get_arg();
            let lp_number_of_attrs_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_attribute = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_attrs_written = {:?}}}" , h_console_output , lp_attribute , n_length , dw_write_coord , lp_number_of_attrs_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleOutputAttribute(
                h_console_output,
                lp_attribute,
                n_length,
                dw_write_coord,
                lp_number_of_attrs_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleOutputCharacterA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_character = call.get_arg();
            let n_length = call.get_arg();
            let dw_write_coord = call.get_arg();
            let lp_number_of_chars_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , lp_character , n_length , dw_write_coord , lp_number_of_chars_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleOutputCharacterA(
                h_console_output,
                lp_character,
                n_length,
                dw_write_coord,
                lp_number_of_chars_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleOutputCharacterW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_character = call.get_arg();
            let n_length = call.get_arg();
            let dw_write_coord = call.get_arg();
            let lp_number_of_chars_written = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , lp_character , n_length , dw_write_coord , lp_number_of_chars_written ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleOutputCharacterW(
                h_console_output,
                lp_character,
                n_length,
                dw_write_coord,
                lp_number_of_chars_written,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleOutputW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_buffer_size = call.get_arg();
            let dw_buffer_coord = call.get_arg();
            let lp_write_region = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_write_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_write_region ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleOutputW(
                h_console_output,
                lp_buffer,
                dw_buffer_size,
                dw_buffer_coord,
                lp_write_region,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteConsoleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Console::get_api(win32);
            let h_console_output = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_number_of_chars_to_write = call.get_arg();
            let lp_number_of_chars_written = call.get_arg();
            let lp_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_console_output = {:?}, lp_buffer = {:?}, n_number_of_chars_to_write = {:?}, lp_number_of_chars_written = {:?}, lp_reserved = {:?}}}" , h_console_output , lp_buffer , n_number_of_chars_to_write , lp_number_of_chars_written , lp_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteConsoleW(
                h_console_output,
                lp_buffer,
                n_number_of_chars_to_write,
                lp_number_of_chars_written,
                lp_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlUnwind(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RtlUnwind");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Diagnostics::Debug::get_api(win32);
            let target_frame = call.get_arg();
            let target_ip = call.get_arg();
            let exception_record = call.get_arg();
            let return_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{target_frame = {:?}, target_ip = {:?}, exception_record = {:?}, return_value = {:?}}}" , target_frame , target_ip , exception_record , return_value ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlUnwind(target_frame, target_ip, exception_record, return_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnhandledExceptionFilter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnhandledExceptionFilter",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Diagnostics::Debug::get_api(win32);
            let exception_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{exception_info = {:?}}}", exception_info)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.UnhandledExceptionFilter(exception_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CallEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CallEnclave");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_routine = call.get_arg();
            let lp_parameter = call.get_arg();
            let f_wait_for_thread = call.get_arg();
            let lp_return_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_routine = {:?}, lp_parameter = {:?}, f_wait_for_thread = {:?}, lp_return_value = {:?}}}" , lp_routine , lp_parameter , f_wait_for_thread , lp_return_value ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CallEnclave(lp_routine, lp_parameter, f_wait_for_thread, lp_return_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateEnclave",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let dw_initial_commitment = call.get_arg();
            let fl_enclave_type = call.get_arg();
            let lp_enclave_information = call.get_arg();
            let dw_info_length = call.get_arg();
            let lp_enclave_error = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, dw_initial_commitment = {:?}, fl_enclave_type = {:?}, lp_enclave_information = {:?}, dw_info_length = {:?}, lp_enclave_error = {:?}}}" , h_process , lp_address , dw_size , dw_initial_commitment , fl_enclave_type , lp_enclave_information , dw_info_length , lp_enclave_error ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateEnclave(
                h_process,
                lp_address,
                dw_size,
                dw_initial_commitment,
                fl_enclave_type,
                lp_enclave_information,
                dw_info_length,
                lp_enclave_error,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateEnvironmentBlock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateEnvironmentBlock",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_environment = call.get_arg();
            let h_token = call.get_arg();
            let b_inherit = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_environment = {:?}, h_token = {:?}, b_inherit = {:?}}}" , lp_environment , h_token , b_inherit ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateEnvironmentBlock(lp_environment, h_token, b_inherit);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteEnclave",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_address = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_address = {:?}}}", lp_address)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DeleteEnclave(lp_address);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DestroyEnvironmentBlock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DestroyEnvironmentBlock",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_environment = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_environment = {:?}}}", lp_environment)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DestroyEnvironmentBlock(lp_environment);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnclaveGetAttestationReport(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnclaveGetAttestationReport",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let enclave_data = call.get_arg();
            let report = call.get_arg();
            let buffer_size = call.get_arg();
            let output_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{enclave_data = {:?}, report = {:?}, buffer_size = {:?}, output_size = {:?}}}" , enclave_data , report , buffer_size , output_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.EnclaveGetAttestationReport(enclave_data, report, buffer_size, output_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnclaveGetEnclaveInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnclaveGetEnclaveInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let information_size = call.get_arg();
            let enclave_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{information_size = {:?}, enclave_information = {:?}}}",
                            information_size, enclave_information
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnclaveGetEnclaveInformation(information_size, enclave_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnclaveSealData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnclaveSealData",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let data_to_encrypt = call.get_arg();
            let data_to_encrypt_size = call.get_arg();
            let identity_policy = call.get_arg();
            let runtime_policy = call.get_arg();
            let protected_blob = call.get_arg();
            let buffer_size = call.get_arg();
            let protected_blob_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{data_to_encrypt = {:?}, data_to_encrypt_size = {:?}, identity_policy = {:?}, runtime_policy = {:?}, protected_blob = {:?}, buffer_size = {:?}, protected_blob_size = {:?}}}" , data_to_encrypt , data_to_encrypt_size , identity_policy , runtime_policy , protected_blob , buffer_size , protected_blob_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnclaveSealData(
                data_to_encrypt,
                data_to_encrypt_size,
                identity_policy,
                runtime_policy,
                protected_blob,
                buffer_size,
                protected_blob_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnclaveUnsealData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnclaveUnsealData",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let protected_blob = call.get_arg();
            let protected_blob_size = call.get_arg();
            let decrypted_data = call.get_arg();
            let buffer_size = call.get_arg();
            let decrypted_data_size = call.get_arg();
            let sealing_identity = call.get_arg();
            let unsealing_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{protected_blob = {:?}, protected_blob_size = {:?}, decrypted_data = {:?}, buffer_size = {:?}, decrypted_data_size = {:?}, sealing_identity = {:?}, unsealing_flags = {:?}}}" , protected_blob , protected_blob_size , decrypted_data , buffer_size , decrypted_data_size , sealing_identity , unsealing_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnclaveUnsealData(
                protected_blob,
                protected_blob_size,
                decrypted_data,
                buffer_size,
                decrypted_data_size,
                sealing_identity,
                unsealing_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnclaveVerifyAttestationReport(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnclaveVerifyAttestationReport",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let enclave_type = call.get_arg();
            let report = call.get_arg();
            let report_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enclave_type = {:?}, report = {:?}, report_size = {:?}}}",
                            enclave_type, report, report_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnclaveVerifyAttestationReport(enclave_type, report, report_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExpandEnvironmentStringsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_src = call.get_arg();
            let lp_dst = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_src = {:?}, lp_dst = {:?}, n_size = {:?}}}",
                            lp_src, lp_dst, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ExpandEnvironmentStringsA(lp_src, lp_dst, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsForUserA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExpandEnvironmentStringsForUserA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let h_token = call.get_arg();
            let lp_src = call.get_arg();
            let lp_dest = call.get_arg();
            let dw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_token = {:?}, lp_src = {:?}, lp_dest = {:?}, dw_size = {:?}}}" , h_token , lp_src , lp_dest , dw_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ExpandEnvironmentStringsForUserA(h_token, lp_src, lp_dest, dw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsForUserW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExpandEnvironmentStringsForUserW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let h_token = call.get_arg();
            let lp_src = call.get_arg();
            let lp_dest = call.get_arg();
            let dw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_token = {:?}, lp_src = {:?}, lp_dest = {:?}, dw_size = {:?}}}" , h_token , lp_src , lp_dest , dw_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ExpandEnvironmentStringsForUserW(h_token, lp_src, lp_dest, dw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExpandEnvironmentStringsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_src = call.get_arg();
            let lp_dst = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_src = {:?}, lp_dst = {:?}, n_size = {:?}}}",
                            lp_src, lp_dst, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ExpandEnvironmentStringsW(lp_src, lp_dst, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FreeEnvironmentStringsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let penv = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{penv = {:?}}}", penv)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FreeEnvironmentStringsA(penv);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FreeEnvironmentStringsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let penv = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{penv = {:?}}}", penv)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FreeEnvironmentStringsW(penv);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCommandLineA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCommandLineA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCommandLineA();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCommandLineW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCommandLineW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCommandLineW();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentDirectoryA(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentDirectoryW(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentStrings(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetEnvironmentStrings",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetEnvironmentStrings();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetEnvironmentStringsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetEnvironmentStringsW();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetEnvironmentVariableA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_name = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_name = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
                            lp_name, lp_buffer, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetEnvironmentVariableA(lp_name, lp_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetEnvironmentVariableW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_name = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_name = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
                            lp_name, lp_buffer, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetEnvironmentVariableW(lp_name, lp_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeEnclave(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeEnclave",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let lp_enclave_information = call.get_arg();
            let dw_info_length = call.get_arg();
            let lp_enclave_error = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, lp_enclave_information = {:?}, dw_info_length = {:?}, lp_enclave_error = {:?}}}" , h_process , lp_address , lp_enclave_information , dw_info_length , lp_enclave_error ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InitializeEnclave(
                h_process,
                lp_address,
                lp_enclave_information,
                dw_info_length,
                lp_enclave_error,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsEnclaveTypeSupported(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsEnclaveTypeSupported",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let fl_enclave_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{fl_enclave_type = {:?}}}", fl_enclave_type)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsEnclaveTypeSupported(fl_enclave_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadEnclaveData",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_size = call.get_arg();
            let fl_protect = call.get_arg();
            let lp_page_information = call.get_arg();
            let dw_info_length = call.get_arg();
            let lp_number_of_bytes_written = call.get_arg();
            let lp_enclave_error = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, lp_buffer = {:?}, n_size = {:?}, fl_protect = {:?}, lp_page_information = {:?}, dw_info_length = {:?}, lp_number_of_bytes_written = {:?}, lp_enclave_error = {:?}}}" , h_process , lp_address , lp_buffer , n_size , fl_protect , lp_page_information , dw_info_length , lp_number_of_bytes_written , lp_enclave_error ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LoadEnclaveData(
                h_process,
                lp_address,
                lp_buffer,
                n_size,
                fl_protect,
                lp_page_information,
                dw_info_length,
                lp_number_of_bytes_written,
                lp_enclave_error,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveImageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadEnclaveImageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_enclave_address = call.get_arg();
            let lp_image_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_enclave_address = {:?}, lp_image_name = {:?}}}",
                            lp_enclave_address, lp_image_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadEnclaveImageA(lp_enclave_address, lp_image_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveImageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadEnclaveImageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_enclave_address = call.get_arg();
            let lp_image_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_enclave_address = {:?}, lp_image_name = {:?}}}",
                            lp_enclave_address, lp_image_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadEnclaveImageW(lp_enclave_address, lp_image_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NeedCurrentDirectoryForExePathA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NeedCurrentDirectoryForExePathA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NeedCurrentDirectoryForExePathA(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NeedCurrentDirectoryForExePathW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NeedCurrentDirectoryForExePathW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let exe_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{exe_name = {:?}}}", exe_name)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NeedCurrentDirectoryForExePathW(exe_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCurrentDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCurrentDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_path_name = {:?}}}", lp_path_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetCurrentDirectoryA(lp_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCurrentDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCurrentDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_path_name = {:?}}}", lp_path_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetCurrentDirectoryW(lp_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetEnvironmentStringsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let new_environment = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{new_environment = {:?}}}", new_environment)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetEnvironmentStringsW(new_environment);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetEnvironmentVariableA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_name = call.get_arg();
            let lp_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_name = {:?}, lp_value = {:?}}}",
                            lp_name, lp_value
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetEnvironmentVariableA(lp_name, lp_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetEnvironmentVariableW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_name = call.get_arg();
            let lp_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_name = {:?}, lp_value = {:?}}}",
                            lp_name, lp_value
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetEnvironmentVariableW(lp_name, lp_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TerminateEnclave(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TerminateEnclave",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Environment::get_api(win32);
            let lp_address = call.get_arg();
            let f_wait = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_address = {:?}, f_wait = {:?}}}",
                            lp_address, f_wait
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TerminateEnclave(lp_address, f_wait);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BindIoCompletionCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "BindIoCompletionCallback",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let file_handle = call.get_arg();
            let function = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{file_handle = {:?}, function = {:?}, flags = {:?}}}",
                            file_handle, function, flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.BindIoCompletionCallback(file_handle, function, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelIo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CancelIo");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let h_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_file = {:?}}}", h_file)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CancelIo(h_file);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelIoEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CancelIoEx");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let h_file = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_overlapped = {:?}}}",
                            h_file, lp_overlapped
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CancelIoEx(h_file, lp_overlapped);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelSynchronousIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CancelSynchronousIo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let h_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_thread = {:?}}}", h_thread)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CancelSynchronousIo(h_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateIoCompletionPort(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateIoCompletionPort",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let file_handle = call.get_arg();
            let existing_completion_port = call.get_arg();
            let completion_key = call.get_arg();
            let number_of_concurrent_threads = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, existing_completion_port = {:?}, completion_key = {:?}, number_of_concurrent_threads = {:?}}}" , file_handle , existing_completion_port , completion_key , number_of_concurrent_threads ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateIoCompletionPort(
                file_handle,
                existing_completion_port,
                completion_key,
                number_of_concurrent_threads,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeviceIoControl(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeviceIoControl",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let h_device = call.get_arg();
            let dw_io_control_code = call.get_arg();
            let lp_in_buffer = call.get_arg();
            let n_in_buffer_size = call.get_arg();
            let lp_out_buffer = call.get_arg();
            let n_out_buffer_size = call.get_arg();
            let lp_bytes_returned = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_device = {:?}, dw_io_control_code = {:?}, lp_in_buffer = {:?}, n_in_buffer_size = {:?}, lp_out_buffer = {:?}, n_out_buffer_size = {:?}, lp_bytes_returned = {:?}, lp_overlapped = {:?}}}" , h_device , dw_io_control_code , lp_in_buffer , n_in_buffer_size , lp_out_buffer , n_out_buffer_size , lp_bytes_returned , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DeviceIoControl(
                h_device,
                dw_io_control_code,
                lp_in_buffer,
                n_in_buffer_size,
                lp_out_buffer,
                n_out_buffer_size,
                lp_bytes_returned,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetOverlappedResult(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetOverlappedResult",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let h_file = call.get_arg();
            let lp_overlapped = call.get_arg();
            let lp_number_of_bytes_transferred = call.get_arg();
            let b_wait = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_overlapped = {:?}, lp_number_of_bytes_transferred = {:?}, b_wait = {:?}}}" , h_file , lp_overlapped , lp_number_of_bytes_transferred , b_wait ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetOverlappedResult(
                h_file,
                lp_overlapped,
                lp_number_of_bytes_transferred,
                b_wait,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetOverlappedResultEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetOverlappedResultEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let h_file = call.get_arg();
            let lp_overlapped = call.get_arg();
            let lp_number_of_bytes_transferred = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let b_alertable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file = {:?}, lp_overlapped = {:?}, lp_number_of_bytes_transferred = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}" , h_file , lp_overlapped , lp_number_of_bytes_transferred , dw_milliseconds , b_alertable ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetOverlappedResultEx(
                h_file,
                lp_overlapped,
                lp_number_of_bytes_transferred,
                dw_milliseconds,
                b_alertable,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetQueuedCompletionStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetQueuedCompletionStatus",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let completion_port = call.get_arg();
            let lp_number_of_bytes_transferred = call.get_arg();
            let lp_completion_key = call.get_arg();
            let lp_overlapped = call.get_arg();
            let dw_milliseconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{completion_port = {:?}, lp_number_of_bytes_transferred = {:?}, lp_completion_key = {:?}, lp_overlapped = {:?}, dw_milliseconds = {:?}}}" , completion_port , lp_number_of_bytes_transferred , lp_completion_key , lp_overlapped , dw_milliseconds ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetQueuedCompletionStatus(
                completion_port,
                lp_number_of_bytes_transferred,
                lp_completion_key,
                lp_overlapped,
                dw_milliseconds,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetQueuedCompletionStatusEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetQueuedCompletionStatusEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let completion_port = call.get_arg();
            let lp_completion_port_entries = call.get_arg();
            let ul_count = call.get_arg();
            let ul_num_entries_removed = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let f_alertable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{completion_port = {:?}, lp_completion_port_entries = {:?}, ul_count = {:?}, ul_num_entries_removed = {:?}, dw_milliseconds = {:?}, f_alertable = {:?}}}" , completion_port , lp_completion_port_entries , ul_count , ul_num_entries_removed , dw_milliseconds , f_alertable ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetQueuedCompletionStatusEx(
                completion_port,
                lp_completion_port_entries,
                ul_count,
                ul_num_entries_removed,
                dw_milliseconds,
                f_alertable,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PostQueuedCompletionStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PostQueuedCompletionStatus",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::IO::get_api(win32);
            let completion_port = call.get_arg();
            let dw_number_of_bytes_transferred = call.get_arg();
            let dw_completion_key = call.get_arg();
            let lp_overlapped = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{completion_port = {:?}, dw_number_of_bytes_transferred = {:?}, dw_completion_key = {:?}, lp_overlapped = {:?}}}" , completion_port , dw_number_of_bytes_transferred , dw_completion_key , lp_overlapped ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PostQueuedCompletionStatus(
                completion_port,
                dw_number_of_bytes_transferred,
                dw_completion_key,
                lp_overlapped,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlFirstEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlFirstEntrySList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Kernel::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlFirstEntrySList(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInitializeSListHead(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInitializeSListHead",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Kernel::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInitializeSListHead(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedFlushSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInterlockedFlushSList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Kernel::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInterlockedFlushSList(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPopEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInterlockedPopEntrySList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Kernel::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInterlockedPopEntrySList(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPushEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInterlockedPushEntrySList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Kernel::get_api(win32);
            let list_head = call.get_arg();
            let list_entry = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{list_head = {:?}, list_entry = {:?}}}",
                            list_head, list_entry
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInterlockedPushEntrySList(list_head, list_entry);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPushListSListEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInterlockedPushListSListEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Kernel::get_api(win32);
            let list_head = call.get_arg();
            let list = call.get_arg();
            let list_end = call.get_arg();
            let count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{list_head = {:?}, list = {:?}, list_end = {:?}, count = {:?}}}" , list_head , list , list_end , count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlInterlockedPushListSListEx(list_head, list, list_end, count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlQueryDepthSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlQueryDepthSList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Kernel::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlQueryDepthSList(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddDllDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddDllDirectory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let new_directory = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{new_directory = {:?}}}", new_directory)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.AddDllDirectory(new_directory);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BeginUpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "BeginUpdateResourceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let p_file_name = call.get_arg();
            let b_delete_existing_resources = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{p_file_name = {:?}, b_delete_existing_resources = {:?}}}",
                            p_file_name, b_delete_existing_resources
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.BeginUpdateResourceA(p_file_name, b_delete_existing_resources);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BeginUpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "BeginUpdateResourceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let p_file_name = call.get_arg();
            let b_delete_existing_resources = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{p_file_name = {:?}, b_delete_existing_resources = {:?}}}",
                            p_file_name, b_delete_existing_resources
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.BeginUpdateResourceW(p_file_name, b_delete_existing_resources);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DisableThreadLibraryCalls(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DisableThreadLibraryCalls",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_lib_module = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_lib_module = {:?}}}", h_lib_module)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DisableThreadLibraryCalls(h_lib_module);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EndUpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EndUpdateResourceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_update = call.get_arg();
            let f_discard = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_update = {:?}, f_discard = {:?}}}",
                            h_update, f_discard
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EndUpdateResourceA(h_update, f_discard);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EndUpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EndUpdateResourceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_update = call.get_arg();
            let f_discard = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_update = {:?}, f_discard = {:?}}}",
                            h_update, f_discard
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EndUpdateResourceW(h_update, f_discard);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceLanguagesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceLanguagesA(h_module, lp_type, lp_name, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceLanguagesExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            let dw_flags = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param , dw_flags , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceLanguagesExA(
                h_module,
                lp_type,
                lp_name,
                lp_enum_func,
                l_param,
                dw_flags,
                lang_id,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceLanguagesExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            let dw_flags = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param , dw_flags , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceLanguagesExW(
                h_module,
                lp_type,
                lp_name,
                lp_enum_func,
                l_param,
                dw_flags,
                lang_id,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceLanguagesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceLanguagesW(h_module, lp_type, lp_name, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceNamesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}}}" , h_module , lp_type , lp_enum_func , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceNamesA(h_module, lp_type, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceNamesExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            let dw_flags = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_enum_func , l_param , dw_flags , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceNamesExA(
                h_module,
                lp_type,
                lp_enum_func,
                l_param,
                dw_flags,
                lang_id,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceNamesExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            let dw_flags = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_enum_func , l_param , dw_flags , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceNamesExW(
                h_module,
                lp_type,
                lp_enum_func,
                l_param,
                dw_flags,
                lang_id,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceNamesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}}}" , h_module , lp_type , lp_enum_func , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceNamesW(h_module, lp_type, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceTypesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
                            h_module, lp_enum_func, l_param
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumResourceTypesA(h_module, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceTypesExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            let dw_flags = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_enum_func , l_param , dw_flags , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceTypesExA(h_module, lp_enum_func, l_param, dw_flags, lang_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceTypesExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            let dw_flags = call.get_arg();
            let lang_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_enum_func , l_param , dw_flags , lang_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumResourceTypesExW(h_module, lp_enum_func, l_param, dw_flags, lang_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumResourceTypesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
                            h_module, lp_enum_func, l_param
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumResourceTypesW(h_module, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindResourceA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindResourceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_name = call.get_arg();
            let lp_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, lp_name = {:?}, lp_type = {:?}}}",
                            h_module, lp_name, lp_type
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindResourceA(h_module, lp_name, lp_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindResourceExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindResourceExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let w_language = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}}}" , h_module , lp_type , lp_name , w_language ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindResourceExA(h_module, lp_type, lp_name, w_language);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindResourceExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindResourceExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let w_language = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}}}" , h_module , lp_type , lp_name , w_language ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindResourceExW(h_module, lp_type, lp_name, w_language);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindResourceW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindResourceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_name = call.get_arg();
            let lp_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, lp_name = {:?}, lp_type = {:?}}}",
                            h_module, lp_name, lp_type
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindResourceW(h_module, lp_name, lp_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeLibrary(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FreeLibrary");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_lib_module = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_lib_module = {:?}}}", h_lib_module)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FreeLibrary(h_lib_module);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeLibraryAndExitThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FreeLibraryAndExitThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_lib_module = call.get_arg();
            let dw_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_lib_module = {:?}, dw_exit_code = {:?}}}",
                            h_lib_module, dw_exit_code
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FreeLibraryAndExitThread(h_lib_module, dw_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FreeResource",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_res_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_res_data = {:?}}}", h_res_data)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FreeResource(h_res_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDllDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDllDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDllDirectoryA(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDllDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDllDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let n_buffer_length = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
                            n_buffer_length, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDllDirectoryW(n_buffer_length, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetModuleFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetModuleFileNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_filename = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, lp_filename = {:?}, n_size = {:?}}}",
                            h_module, lp_filename, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetModuleFileNameA(h_module, lp_filename, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetModuleFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetModuleFileNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_filename = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, lp_filename = {:?}, n_size = {:?}}}",
                            h_module, lp_filename, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetModuleFileNameW(h_module, lp_filename, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetModuleHandleA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_module_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_module_name = {:?}}}", lp_module_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetModuleHandleA(lp_module_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetModuleHandleExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_module_name = call.get_arg();
            let ph_module = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_module_name = {:?}, ph_module = {:?}}}" , dw_flags , lp_module_name , ph_module ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetModuleHandleExA(dw_flags, lp_module_name, ph_module);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetModuleHandleExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_module_name = call.get_arg();
            let ph_module = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_module_name = {:?}, ph_module = {:?}}}" , dw_flags , lp_module_name , ph_module ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetModuleHandleExW(dw_flags, lp_module_name, ph_module);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetModuleHandleW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_module_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_module_name = {:?}}}", lp_module_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetModuleHandleW(lp_module_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcAddress(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcAddress",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let lp_proc_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, lp_proc_name = {:?}}}",
                            h_module, lp_proc_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcAddress(h_module, lp_proc_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadLibraryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_lib_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_lib_file_name = {:?}}}",
                            lp_lib_file_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadLibraryA(lp_lib_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadLibraryExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_lib_file_name = call.get_arg();
            let h_file = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_lib_file_name = {:?}, h_file = {:?}, dw_flags = {:?}}}" , lp_lib_file_name , h_file , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LoadLibraryExA(lp_lib_file_name, h_file, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadLibraryExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_lib_file_name = call.get_arg();
            let h_file = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_lib_file_name = {:?}, h_file = {:?}, dw_flags = {:?}}}" , lp_lib_file_name , h_file , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LoadLibraryExW(lp_lib_file_name, h_file, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadLibraryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_lib_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_lib_file_name = {:?}}}",
                            lp_lib_file_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadLibraryW(lp_lib_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadModule(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadModule");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_module_name = call.get_arg();
            let lp_parameter_block = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_module_name = {:?}, lp_parameter_block = {:?}}}",
                            lp_module_name, lp_parameter_block
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadModule(lp_module_name, lp_parameter_block);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadPackagedLibrary(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadPackagedLibrary",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lpw_lib_file_name = call.get_arg();
            let reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpw_lib_file_name = {:?}, reserved = {:?}}}",
                            lpw_lib_file_name, reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadPackagedLibrary(lpw_lib_file_name, reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadResource",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let h_res_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, h_res_info = {:?}}}",
                            h_module, h_res_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadResource(h_module, h_res_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LockResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LockResource",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_res_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_res_data = {:?}}}", h_res_data)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.LockResource(h_res_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveDllDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RemoveDllDirectory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let cookie = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{cookie = {:?}}}", cookie)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RemoveDllDirectory(cookie);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetDefaultDllDirectories(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetDefaultDllDirectories",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let directory_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{directory_flags = {:?}}}", directory_flags)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetDefaultDllDirectories(directory_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetDllDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetDllDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_path_name = {:?}}}", lp_path_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetDllDirectoryA(lp_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetDllDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetDllDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let lp_path_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_path_name = {:?}}}", lp_path_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetDllDirectoryW(lp_path_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SizeofResource(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SizeofResource",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_module = call.get_arg();
            let h_res_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_module = {:?}, h_res_info = {:?}}}",
                            h_module, h_res_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SizeofResource(h_module, h_res_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UpdateResourceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_update = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let w_language = call.get_arg();
            let lp_data = call.get_arg();
            let cb = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_update = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}, lp_data = {:?}, cb = {:?}}}" , h_update , lp_type , lp_name , w_language , lp_data , cb ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UpdateResourceA(h_update, lp_type, lp_name, w_language, lp_data, cb);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UpdateResourceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::LibraryLoader::get_api(win32);
            let h_update = call.get_arg();
            let lp_type = call.get_arg();
            let lp_name = call.get_arg();
            let w_language = call.get_arg();
            let lp_data = call.get_arg();
            let cb = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_update = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}, lp_data = {:?}, cb = {:?}}}" , h_update , lp_type , lp_name , w_language , lp_data , cb ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UpdateResourceW(h_update, lp_type, lp_name, w_language, lp_data, cb);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddSecureMemoryCacheCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddSecureMemoryCacheCallback",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let pfn_call_back = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pfn_call_back = {:?}}}", pfn_call_back)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.AddSecureMemoryCacheCallback(pfn_call_back);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AllocateUserPhysicalPages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let number_of_pages = call.get_arg();
            let page_array = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, number_of_pages = {:?}, page_array = {:?}}}" , h_process , number_of_pages , page_array ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AllocateUserPhysicalPages(h_process, number_of_pages, page_array);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPages2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AllocateUserPhysicalPages2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let object_handle = call.get_arg();
            let number_of_pages = call.get_arg();
            let page_array = call.get_arg();
            let extended_parameters = call.get_arg();
            let extended_parameter_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{object_handle = {:?}, number_of_pages = {:?}, page_array = {:?}, extended_parameters = {:?}, extended_parameter_count = {:?}}}" , object_handle , number_of_pages , page_array , extended_parameters , extended_parameter_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AllocateUserPhysicalPages2(
                object_handle,
                number_of_pages,
                page_array,
                extended_parameters,
                extended_parameter_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPagesNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AllocateUserPhysicalPagesNuma",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let number_of_pages = call.get_arg();
            let page_array = call.get_arg();
            let nnd_preferred = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, number_of_pages = {:?}, page_array = {:?}, nnd_preferred = {:?}}}" , h_process , number_of_pages , page_array , nnd_preferred ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AllocateUserPhysicalPagesNuma(
                h_process,
                number_of_pages,
                page_array,
                nnd_preferred,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateMemoryResourceNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateMemoryResourceNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let notification_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{notification_type = {:?}}}",
                            notification_type
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateMemoryResourceNotification(notification_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DiscardVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DiscardVirtualMemory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let virtual_address = call.get_arg();
            let size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{virtual_address = {:?}, size = {:?}}}",
                            virtual_address, size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DiscardVirtualMemory(virtual_address, size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlushViewOfFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FlushViewOfFile",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_base_address = call.get_arg();
            let dw_number_of_bytes_to_flush = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_base_address = {:?}, dw_number_of_bytes_to_flush = {:?}}}" , lp_base_address , dw_number_of_bytes_to_flush ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FlushViewOfFile(lp_base_address, dw_number_of_bytes_to_flush);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FreeUserPhysicalPages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let number_of_pages = call.get_arg();
            let page_array = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, number_of_pages = {:?}, page_array = {:?}}}" , h_process , number_of_pages , page_array ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FreeUserPhysicalPages(h_process, number_of_pages, page_array);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLargePageMinimum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLargePageMinimum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetLargePageMinimum();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMemoryErrorHandlingCapabilities(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMemoryErrorHandlingCapabilities",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let capabilities = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{capabilities = {:?}}}", capabilities)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetMemoryErrorHandlingCapabilities(capabilities);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessHeap(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessHeap",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessHeap();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessHeaps(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessHeaps",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let number_of_heaps = call.get_arg();
            let process_heaps = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{number_of_heaps = {:?}, process_heaps = {:?}}}",
                            number_of_heaps, process_heaps
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessHeaps(number_of_heaps, process_heaps);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessWorkingSetSizeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessWorkingSetSizeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let lp_minimum_working_set_size = call.get_arg();
            let lp_maximum_working_set_size = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_minimum_working_set_size = {:?}, lp_maximum_working_set_size = {:?}, flags = {:?}}}" , h_process , lp_minimum_working_set_size , lp_maximum_working_set_size , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessWorkingSetSizeEx(
                h_process,
                lp_minimum_working_set_size,
                lp_maximum_working_set_size,
                flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemFileCacheSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemFileCacheSize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_minimum_file_cache_size = call.get_arg();
            let lp_maximum_file_cache_size = call.get_arg();
            let lp_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_minimum_file_cache_size = {:?}, lp_maximum_file_cache_size = {:?}, lp_flags = {:?}}}" , lp_minimum_file_cache_size , lp_maximum_file_cache_size , lp_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemFileCacheSize(
                lp_minimum_file_cache_size,
                lp_maximum_file_cache_size,
                lp_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWriteWatch(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWriteWatch",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let dw_flags = call.get_arg();
            let lp_base_address = call.get_arg();
            let dw_region_size = call.get_arg();
            let lp_addresses = call.get_arg();
            let lpdw_count = call.get_arg();
            let lpdw_granularity = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_flags = {:?}, lp_base_address = {:?}, dw_region_size = {:?}, lp_addresses = {:?}, lpdw_count = {:?}, lpdw_granularity = {:?}}}" , dw_flags , lp_base_address , dw_region_size , lp_addresses , lpdw_count , lpdw_granularity ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetWriteWatch(
                dw_flags,
                lp_base_address,
                dw_region_size,
                lp_addresses,
                lpdw_count,
                lpdw_granularity,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalAlloc");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let u_flags = call.get_arg();
            let dw_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{u_flags = {:?}, dw_bytes = {:?}}}",
                            u_flags, dw_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalAlloc(u_flags, dw_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalFlags(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalFlags");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalFlags(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalFree");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalFree(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GlobalHandle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let p_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{p_mem = {:?}}}", p_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalHandle(p_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalLock");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalLock(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GlobalReAlloc",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            let dw_bytes = call.get_arg();
            let u_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_mem = {:?}, dw_bytes = {:?}, u_flags = {:?}}}",
                            h_mem, dw_bytes, u_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalReAlloc(h_mem, dw_bytes, u_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalSize");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalSize(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GlobalUnlock",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalUnlock(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapAlloc");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let dw_flags = call.get_arg();
            let dw_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_heap = {:?}, dw_flags = {:?}, dw_bytes = {:?}}}",
                            h_heap, dw_flags, dw_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapAlloc(h_heap, dw_flags, dw_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapCompact");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_heap = {:?}, dw_flags = {:?}}}",
                            h_heap, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapCompact(h_heap, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapCreate(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapCreate");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let fl_options = call.get_arg();
            let dw_initial_size = call.get_arg();
            let dw_maximum_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{fl_options = {:?}, dw_initial_size = {:?}, dw_maximum_size = {:?}}}" , fl_options , dw_initial_size , dw_maximum_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.HeapCreate(fl_options, dw_initial_size, dw_maximum_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapDestroy(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapDestroy");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_heap = {:?}}}", h_heap)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapDestroy(h_heap);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapFree");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}}}",
                            h_heap, dw_flags, lp_mem
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapFree(h_heap, dw_flags, lp_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapLock");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_heap = {:?}}}", h_heap)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapLock(h_heap);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapQueryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "HeapQueryInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let heap_handle = call.get_arg();
            let heap_information_class = call.get_arg();
            let heap_information = call.get_arg();
            let heap_information_length = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{heap_handle = {:?}, heap_information_class = {:?}, heap_information = {:?}, heap_information_length = {:?}, return_length = {:?}}}" , heap_handle , heap_information_class , heap_information , heap_information_length , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.HeapQueryInformation(
                heap_handle,
                heap_information_class,
                heap_information,
                heap_information_length,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapReAlloc");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_mem = call.get_arg();
            let dw_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}, dw_bytes = {:?}}}" , h_heap , dw_flags , lp_mem , dw_bytes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.HeapReAlloc(h_heap, dw_flags, lp_mem, dw_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapSetInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "HeapSetInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let heap_handle = call.get_arg();
            let heap_information_class = call.get_arg();
            let heap_information = call.get_arg();
            let heap_information_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{heap_handle = {:?}, heap_information_class = {:?}, heap_information = {:?}, heap_information_length = {:?}}}" , heap_handle , heap_information_class , heap_information , heap_information_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.HeapSetInformation(
                heap_handle,
                heap_information_class,
                heap_information,
                heap_information_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapSize");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}}}",
                            h_heap, dw_flags, lp_mem
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapSize(h_heap, dw_flags, lp_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapSummary(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapSummary");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_summary = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_heap = {:?}, dw_flags = {:?}, lp_summary = {:?}}}",
                            h_heap, dw_flags, lp_summary
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapSummary(h_heap, dw_flags, lp_summary);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapUnlock");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_heap = {:?}}}", h_heap)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapUnlock(h_heap);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapValidate(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "HeapValidate",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}}}",
                            h_heap, dw_flags, lp_mem
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapValidate(h_heap, dw_flags, lp_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HeapWalk(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HeapWalk");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_heap = call.get_arg();
            let lp_entry = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_heap = {:?}, lp_entry = {:?}}}",
                            h_heap, lp_entry
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HeapWalk(h_heap, lp_entry);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsBadCodePtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsBadCodePtr",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lpfn = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lpfn = {:?}}}", lpfn)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsBadCodePtr(lpfn);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsBadReadPtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsBadReadPtr",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp = call.get_arg();
            let ucb = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp = {:?}, ucb = {:?}}}", lp, ucb)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsBadReadPtr(lp, ucb);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsBadStringPtrA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsBadStringPtrA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lpsz = call.get_arg();
            let ucch_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz = {:?}, ucch_max = {:?}}}",
                            lpsz, ucch_max
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsBadStringPtrA(lpsz, ucch_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsBadStringPtrW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsBadStringPtrW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lpsz = call.get_arg();
            let ucch_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz = {:?}, ucch_max = {:?}}}",
                            lpsz, ucch_max
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsBadStringPtrW(lpsz, ucch_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsBadWritePtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsBadWritePtr",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp = call.get_arg();
            let ucb = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp = {:?}, ucb = {:?}}}", lp, ucb)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsBadWritePtr(lp, ucb);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalAlloc");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let u_flags = call.get_arg();
            let u_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{u_flags = {:?}, u_bytes = {:?}}}",
                            u_flags, u_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalAlloc(u_flags, u_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalFlags(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalFlags");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalFlags(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalFree");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalFree(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalHandle");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let p_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{p_mem = {:?}}}", p_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalHandle(p_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalLock");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalLock(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LocalReAlloc",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            let u_bytes = call.get_arg();
            let u_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_mem = {:?}, u_bytes = {:?}, u_flags = {:?}}}",
                            h_mem, u_bytes, u_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalReAlloc(h_mem, u_bytes, u_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalSize");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalSize(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalUnlock");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalUnlock(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapUserPhysicalPages",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let virtual_address = call.get_arg();
            let number_of_pages = call.get_arg();
            let page_array = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{virtual_address = {:?}, number_of_pages = {:?}, page_array = {:?}}}" , virtual_address , number_of_pages , page_array ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapUserPhysicalPages(virtual_address, number_of_pages, page_array);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapUserPhysicalPagesScatter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapUserPhysicalPagesScatter",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let virtual_addresses = call.get_arg();
            let number_of_pages = call.get_arg();
            let page_array = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{virtual_addresses = {:?}, number_of_pages = {:?}, page_array = {:?}}}" , virtual_addresses , number_of_pages , page_array ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.MapUserPhysicalPagesScatter(virtual_addresses, number_of_pages, page_array);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapViewOfFile",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_file_mapping_object = call.get_arg();
            let dw_desired_access = call.get_arg();
            let dw_file_offset_high = call.get_arg();
            let dw_file_offset_low = call.get_arg();
            let dw_number_of_bytes_to_map = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file_mapping_object = {:?}, dw_desired_access = {:?}, dw_file_offset_high = {:?}, dw_file_offset_low = {:?}, dw_number_of_bytes_to_map = {:?}}}" , h_file_mapping_object , dw_desired_access , dw_file_offset_high , dw_file_offset_low , dw_number_of_bytes_to_map ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapViewOfFile(
                h_file_mapping_object,
                dw_desired_access,
                dw_file_offset_high,
                dw_file_offset_low,
                dw_number_of_bytes_to_map,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile3(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapViewOfFile3",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let file_mapping = call.get_arg();
            let process = call.get_arg();
            let base_address = call.get_arg();
            let offset = call.get_arg();
            let view_size = call.get_arg();
            let allocation_type = call.get_arg();
            let page_protection = call.get_arg();
            let extended_parameters = call.get_arg();
            let parameter_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_mapping = {:?}, process = {:?}, base_address = {:?}, offset = {:?}, view_size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , file_mapping , process , base_address , offset , view_size , allocation_type , page_protection , extended_parameters , parameter_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapViewOfFile3(
                file_mapping,
                process,
                base_address,
                offset,
                view_size,
                allocation_type,
                page_protection,
                extended_parameters,
                parameter_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile3FromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapViewOfFile3FromApp",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let file_mapping = call.get_arg();
            let process = call.get_arg();
            let base_address = call.get_arg();
            let offset = call.get_arg();
            let view_size = call.get_arg();
            let allocation_type = call.get_arg();
            let page_protection = call.get_arg();
            let extended_parameters = call.get_arg();
            let parameter_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_mapping = {:?}, process = {:?}, base_address = {:?}, offset = {:?}, view_size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , file_mapping , process , base_address , offset , view_size , allocation_type , page_protection , extended_parameters , parameter_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapViewOfFile3FromApp(
                file_mapping,
                process,
                base_address,
                offset,
                view_size,
                allocation_type,
                page_protection,
                extended_parameters,
                parameter_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapViewOfFileEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_file_mapping_object = call.get_arg();
            let dw_desired_access = call.get_arg();
            let dw_file_offset_high = call.get_arg();
            let dw_file_offset_low = call.get_arg();
            let dw_number_of_bytes_to_map = call.get_arg();
            let lp_base_address = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file_mapping_object = {:?}, dw_desired_access = {:?}, dw_file_offset_high = {:?}, dw_file_offset_low = {:?}, dw_number_of_bytes_to_map = {:?}, lp_base_address = {:?}}}" , h_file_mapping_object , dw_desired_access , dw_file_offset_high , dw_file_offset_low , dw_number_of_bytes_to_map , lp_base_address ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapViewOfFileEx(
                h_file_mapping_object,
                dw_desired_access,
                dw_file_offset_high,
                dw_file_offset_low,
                dw_number_of_bytes_to_map,
                lp_base_address,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileExNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapViewOfFileExNuma",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_file_mapping_object = call.get_arg();
            let dw_desired_access = call.get_arg();
            let dw_file_offset_high = call.get_arg();
            let dw_file_offset_low = call.get_arg();
            let dw_number_of_bytes_to_map = call.get_arg();
            let lp_base_address = call.get_arg();
            let nnd_preferred = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file_mapping_object = {:?}, dw_desired_access = {:?}, dw_file_offset_high = {:?}, dw_file_offset_low = {:?}, dw_number_of_bytes_to_map = {:?}, lp_base_address = {:?}, nnd_preferred = {:?}}}" , h_file_mapping_object , dw_desired_access , dw_file_offset_high , dw_file_offset_low , dw_number_of_bytes_to_map , lp_base_address , nnd_preferred ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapViewOfFileExNuma(
                h_file_mapping_object,
                dw_desired_access,
                dw_file_offset_high,
                dw_file_offset_low,
                dw_number_of_bytes_to_map,
                lp_base_address,
                nnd_preferred,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapViewOfFileFromApp",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_file_mapping_object = call.get_arg();
            let desired_access = call.get_arg();
            let file_offset = call.get_arg();
            let number_of_bytes_to_map = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_file_mapping_object = {:?}, desired_access = {:?}, file_offset = {:?}, number_of_bytes_to_map = {:?}}}" , h_file_mapping_object , desired_access , file_offset , number_of_bytes_to_map ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapViewOfFileFromApp(
                h_file_mapping_object,
                desired_access,
                file_offset,
                number_of_bytes_to_map,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileNuma2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapViewOfFileNuma2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let file_mapping_handle = call.get_arg();
            let process_handle = call.get_arg();
            let offset = call.get_arg();
            let base_address = call.get_arg();
            let view_size = call.get_arg();
            let allocation_type = call.get_arg();
            let page_protection = call.get_arg();
            let preferred_node = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_mapping_handle = {:?}, process_handle = {:?}, offset = {:?}, base_address = {:?}, view_size = {:?}, allocation_type = {:?}, page_protection = {:?}, preferred_node = {:?}}}" , file_mapping_handle , process_handle , offset , base_address , view_size , allocation_type , page_protection , preferred_node ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MapViewOfFileNuma2(
                file_mapping_handle,
                process_handle,
                offset,
                base_address,
                view_size,
                allocation_type,
                page_protection,
                preferred_node,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OfferVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OfferVirtualMemory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let virtual_address = call.get_arg();
            let size = call.get_arg();
            let priority = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{virtual_address = {:?}, size = {:?}, priority = {:?}}}",
                            virtual_address, size, priority
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.OfferVirtualMemory(virtual_address, size, priority);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenDedicatedMemoryPartition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenDedicatedMemoryPartition",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let partition = call.get_arg();
            let dedicated_memory_type_id = call.get_arg();
            let desired_access = call.get_arg();
            let inherit_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{partition = {:?}, dedicated_memory_type_id = {:?}, desired_access = {:?}, inherit_handle = {:?}}}" , partition , dedicated_memory_type_id , desired_access , inherit_handle ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenDedicatedMemoryPartition(
                partition,
                dedicated_memory_type_id,
                desired_access,
                inherit_handle,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenFileMappingA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenFileMappingA(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenFileMappingFromApp",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let desired_access = call.get_arg();
            let inherit_handle = call.get_arg();
            let name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{desired_access = {:?}, inherit_handle = {:?}, name = {:?}}}" , desired_access , inherit_handle , name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenFileMappingFromApp(desired_access, inherit_handle, name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenFileMappingW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenFileMappingW(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrefetchVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PrefetchVirtualMemory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let number_of_entries = call.get_arg();
            let virtual_addresses = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, number_of_entries = {:?}, virtual_addresses = {:?}, flags = {:?}}}" , h_process , number_of_entries , virtual_addresses , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.PrefetchVirtualMemory(h_process, number_of_entries, virtual_addresses, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryMemoryResourceNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryMemoryResourceNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let resource_notification_handle = call.get_arg();
            let resource_state = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{resource_notification_handle = {:?}, resource_state = {:?}}}" , resource_notification_handle , resource_state ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.QueryMemoryResourceNotification(resource_notification_handle, resource_state);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryPartitionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryPartitionInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let partition = call.get_arg();
            let partition_information_class = call.get_arg();
            let partition_information = call.get_arg();
            let partition_information_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{partition = {:?}, partition_information_class = {:?}, partition_information = {:?}, partition_information_length = {:?}}}" , partition , partition_information_class , partition_information , partition_information_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueryPartitionInformation(
                partition,
                partition_information_class,
                partition_information,
                partition_information_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryVirtualMemoryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryVirtualMemoryInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let process = call.get_arg();
            let virtual_address = call.get_arg();
            let memory_information_class = call.get_arg();
            let memory_information = call.get_arg();
            let memory_information_size = call.get_arg();
            let return_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, virtual_address = {:?}, memory_information_class = {:?}, memory_information = {:?}, memory_information_size = {:?}, return_size = {:?}}}" , process , virtual_address , memory_information_class , memory_information , memory_information_size , return_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueryVirtualMemoryInformation(
                process,
                virtual_address,
                memory_information_class,
                memory_information,
                memory_information_size,
                return_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReclaimVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReclaimVirtualMemory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let virtual_address = call.get_arg();
            let size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{virtual_address = {:?}, size = {:?}}}",
                            virtual_address, size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ReclaimVirtualMemory(virtual_address, size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RegisterBadMemoryNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RegisterBadMemoryNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let callback = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{callback = {:?}}}", callback)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RegisterBadMemoryNotification(callback);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveSecureMemoryCacheCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RemoveSecureMemoryCacheCallback",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let pfn_call_back = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pfn_call_back = {:?}}}", pfn_call_back)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RemoveSecureMemoryCacheCallback(pfn_call_back);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ResetWriteWatch(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ResetWriteWatch",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_base_address = call.get_arg();
            let dw_region_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_base_address = {:?}, dw_region_size = {:?}}}",
                            lp_base_address, dw_region_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ResetWriteWatch(lp_base_address, dw_region_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlCompareMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlCompareMemory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let source_1 = call.get_arg();
            let source_2 = call.get_arg();
            let length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{source_1 = {:?}, source_2 = {:?}, length = {:?}}}",
                            source_1, source_2, length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlCompareMemory(source_1, source_2, length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlCrc32(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RtlCrc32");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let buffer = call.get_arg();
            let size = call.get_arg();
            let initial_crc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{buffer = {:?}, size = {:?}, initial_crc = {:?}}}",
                            buffer, size, initial_crc
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlCrc32(buffer, size, initial_crc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlCrc64(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RtlCrc64");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let buffer = call.get_arg();
            let size = call.get_arg();
            let initial_crc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{buffer = {:?}, size = {:?}, initial_crc = {:?}}}",
                            buffer, size, initial_crc
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlCrc64(buffer, size, initial_crc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlIsZeroMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlIsZeroMemory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let buffer = call.get_arg();
            let length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{buffer = {:?}, length = {:?}}}",
                            buffer, length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlIsZeroMemory(buffer, length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessValidCallTargets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessValidCallTargets",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let virtual_address = call.get_arg();
            let region_size = call.get_arg();
            let number_of_offsets = call.get_arg();
            let offset_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, virtual_address = {:?}, region_size = {:?}, number_of_offsets = {:?}, offset_information = {:?}}}" , h_process , virtual_address , region_size , number_of_offsets , offset_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessValidCallTargets(
                h_process,
                virtual_address,
                region_size,
                number_of_offsets,
                offset_information,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessValidCallTargetsForMappedView(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessValidCallTargetsForMappedView",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let process = call.get_arg();
            let virtual_address = call.get_arg();
            let region_size = call.get_arg();
            let number_of_offsets = call.get_arg();
            let offset_information = call.get_arg();
            let section = call.get_arg();
            let expected_file_offset = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, virtual_address = {:?}, region_size = {:?}, number_of_offsets = {:?}, offset_information = {:?}, section = {:?}, expected_file_offset = {:?}}}" , process , virtual_address , region_size , number_of_offsets , offset_information , section , expected_file_offset ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessValidCallTargetsForMappedView(
                process,
                virtual_address,
                region_size,
                number_of_offsets,
                offset_information,
                section,
                expected_file_offset,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessWorkingSetSizeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessWorkingSetSizeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let dw_minimum_working_set_size = call.get_arg();
            let dw_maximum_working_set_size = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, dw_minimum_working_set_size = {:?}, dw_maximum_working_set_size = {:?}, flags = {:?}}}" , h_process , dw_minimum_working_set_size , dw_maximum_working_set_size , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessWorkingSetSizeEx(
                h_process,
                dw_minimum_working_set_size,
                dw_maximum_working_set_size,
                flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetSystemFileCacheSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetSystemFileCacheSize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let minimum_file_cache_size = call.get_arg();
            let maximum_file_cache_size = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{minimum_file_cache_size = {:?}, maximum_file_cache_size = {:?}, flags = {:?}}}" , minimum_file_cache_size , maximum_file_cache_size , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SetSystemFileCacheSize(minimum_file_cache_size, maximum_file_cache_size, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnmapViewOfFile",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_base_address = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_base_address = {:?}}}", lp_base_address)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.UnmapViewOfFile(lp_base_address);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFile2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnmapViewOfFile2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let process = call.get_arg();
            let base_address = call.get_arg();
            let unmap_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, base_address = {:?}, unmap_flags = {:?}}}" , process , base_address , unmap_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UnmapViewOfFile2(process, base_address, unmap_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFileEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnmapViewOfFileEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let base_address = call.get_arg();
            let unmap_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{base_address = {:?}, unmap_flags = {:?}}}",
                            base_address, unmap_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.UnmapViewOfFileEx(base_address, unmap_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnregisterBadMemoryNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnregisterBadMemoryNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let registration_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{registration_handle = {:?}}}",
                            registration_handle
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.UnregisterBadMemoryNotification(registration_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualAlloc",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let fl_allocation_type = call.get_arg();
            let fl_protect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_address = {:?}, dw_size = {:?}, fl_allocation_type = {:?}, fl_protect = {:?}}}" , lp_address , dw_size , fl_allocation_type , fl_protect ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualAlloc(lp_address, dw_size, fl_allocation_type, fl_protect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualAlloc2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let process = call.get_arg();
            let base_address = call.get_arg();
            let size = call.get_arg();
            let allocation_type = call.get_arg();
            let page_protection = call.get_arg();
            let extended_parameters = call.get_arg();
            let parameter_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, base_address = {:?}, size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , process , base_address , size , allocation_type , page_protection , extended_parameters , parameter_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualAlloc2(
                process,
                base_address,
                size,
                allocation_type,
                page_protection,
                extended_parameters,
                parameter_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc2FromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualAlloc2FromApp",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let process = call.get_arg();
            let base_address = call.get_arg();
            let size = call.get_arg();
            let allocation_type = call.get_arg();
            let page_protection = call.get_arg();
            let extended_parameters = call.get_arg();
            let parameter_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, base_address = {:?}, size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , process , base_address , size , allocation_type , page_protection , extended_parameters , parameter_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualAlloc2FromApp(
                process,
                base_address,
                size,
                allocation_type,
                page_protection,
                extended_parameters,
                parameter_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualAllocEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let fl_allocation_type = call.get_arg();
            let fl_protect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, fl_allocation_type = {:?}, fl_protect = {:?}}}" , h_process , lp_address , dw_size , fl_allocation_type , fl_protect ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualAllocEx(
                h_process,
                lp_address,
                dw_size,
                fl_allocation_type,
                fl_protect,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocExNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualAllocExNuma",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let fl_allocation_type = call.get_arg();
            let fl_protect = call.get_arg();
            let nnd_preferred = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, fl_allocation_type = {:?}, fl_protect = {:?}, nnd_preferred = {:?}}}" , h_process , lp_address , dw_size , fl_allocation_type , fl_protect , nnd_preferred ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualAllocExNuma(
                h_process,
                lp_address,
                dw_size,
                fl_allocation_type,
                fl_protect,
                nnd_preferred,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualAllocFromApp",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let base_address = call.get_arg();
            let size = call.get_arg();
            let allocation_type = call.get_arg();
            let protection = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{base_address = {:?}, size = {:?}, allocation_type = {:?}, protection = {:?}}}" , base_address , size , allocation_type , protection ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualAllocFromApp(base_address, size, allocation_type, protection);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "VirtualFree");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let dw_free_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_address = {:?}, dw_size = {:?}, dw_free_type = {:?}}}",
                            lp_address, dw_size, dw_free_type
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.VirtualFree(lp_address, dw_size, dw_free_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualFreeEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualFreeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let dw_free_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, dw_free_type = {:?}}}" , h_process , lp_address , dw_size , dw_free_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualFreeEx(h_process, lp_address, dw_size, dw_free_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "VirtualLock");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_address = {:?}, dw_size = {:?}}}",
                            lp_address, dw_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.VirtualLock(lp_address, dw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualProtect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualProtect",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let fl_new_protect = call.get_arg();
            let lpfl_old_protect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_address = {:?}, dw_size = {:?}, fl_new_protect = {:?}, lpfl_old_protect = {:?}}}" , lp_address , dw_size , fl_new_protect , lpfl_old_protect ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualProtect(lp_address, dw_size, fl_new_protect, lpfl_old_protect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualProtectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualProtectEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            let fl_new_protect = call.get_arg();
            let lpfl_old_protect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, fl_new_protect = {:?}, lpfl_old_protect = {:?}}}" , h_process , lp_address , dw_size , fl_new_protect , lpfl_old_protect ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualProtectEx(
                h_process,
                lp_address,
                dw_size,
                fl_new_protect,
                lpfl_old_protect,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualProtectFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualProtectFromApp",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let address = call.get_arg();
            let size = call.get_arg();
            let new_protection = call.get_arg();
            let old_protection = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{address = {:?}, size = {:?}, new_protection = {:?}, old_protection = {:?}}}" , address , size , new_protection , old_protection ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualProtectFromApp(address, size, new_protection, old_protection);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualQuery(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualQuery",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_address = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_address = {:?}, lp_buffer = {:?}, dw_length = {:?}}}",
                            lp_address, lp_buffer, dw_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.VirtualQuery(lp_address, lp_buffer, dw_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualQueryEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualQueryEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let h_process = call.get_arg();
            let lp_address = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_address = {:?}, lp_buffer = {:?}, dw_length = {:?}}}" , h_process , lp_address , lp_buffer , dw_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VirtualQueryEx(h_process, lp_address, lp_buffer, dw_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualUnlock",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let lp_address = call.get_arg();
            let dw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_address = {:?}, dw_size = {:?}}}",
                            lp_address, dw_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.VirtualUnlock(lp_address, dw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VirtualUnlockEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VirtualUnlockEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Memory::get_api(win32);
            let process = call.get_arg();
            let address = call.get_arg();
            let size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{process = {:?}, address = {:?}, size = {:?}}}",
                            process, address, size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.VirtualUnlockEx(process, address, size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetComputerNameExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let name_type = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{name_type = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
                            name_type, lp_buffer, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetComputerNameExA(name_type, lp_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetComputerNameExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let name_type = call.get_arg();
            let lp_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{name_type = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
                            name_type, lp_buffer, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetComputerNameExW(name_type, lp_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLocalTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLocalTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_system_time = {:?}}}", lp_system_time)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetLocalTime(lp_system_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLogicalProcessorInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLogicalProcessorInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let buffer = call.get_arg();
            let returned_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{buffer = {:?}, returned_length = {:?}}}",
                            buffer, returned_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetLogicalProcessorInformation(buffer, returned_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLogicalProcessorInformationEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLogicalProcessorInformationEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let relationship_type = call.get_arg();
            let buffer = call.get_arg();
            let returned_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{relationship_type = {:?}, buffer = {:?}, returned_length = {:?}}}" , relationship_type , buffer , returned_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetLogicalProcessorInformationEx(relationship_type, buffer, returned_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNativeSystemInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNativeSystemInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_system_info = {:?}}}", lp_system_info)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetNativeSystemInfo(lp_system_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetOsManufacturingMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetOsManufacturingMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let pb_enabled = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pb_enabled = {:?}}}", pb_enabled)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetOsManufacturingMode(pb_enabled);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetOsSafeBootMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetOsSafeBootMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{flags = {:?}}}", flags)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetOsSafeBootMode(flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPhysicallyInstalledSystemMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPhysicallyInstalledSystemMemory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let total_memory_in_kilobytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{total_memory_in_kilobytes = {:?}}}",
                            total_memory_in_kilobytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetPhysicallyInstalledSystemMemory(total_memory_in_kilobytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessorSystemCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessorSystemCycleTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let group = call.get_arg();
            let buffer = call.get_arg();
            let returned_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{group = {:?}, buffer = {:?}, returned_length = {:?}}}",
                            group, buffer, returned_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessorSystemCycleTime(group, buffer, returned_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProductInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProductInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let dw_os_major_version = call.get_arg();
            let dw_os_minor_version = call.get_arg();
            let dw_sp_major_version = call.get_arg();
            let dw_sp_minor_version = call.get_arg();
            let pdw_returned_product_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_os_major_version = {:?}, dw_os_minor_version = {:?}, dw_sp_major_version = {:?}, dw_sp_minor_version = {:?}, pdw_returned_product_type = {:?}}}" , dw_os_major_version , dw_os_minor_version , dw_sp_major_version , dw_sp_minor_version , pdw_returned_product_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProductInfo(
                dw_os_major_version,
                dw_os_minor_version,
                dw_sp_major_version,
                dw_sp_minor_version,
                pdw_returned_product_type,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemCpuSetInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemCpuSetInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let information = call.get_arg();
            let buffer_length = call.get_arg();
            let returned_length = call.get_arg();
            let process = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{information = {:?}, buffer_length = {:?}, returned_length = {:?}, process = {:?}, flags = {:?}}}" , information , buffer_length , returned_length , process , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemCpuSetInformation(
                information,
                buffer_length,
                returned_length,
                process,
                flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemDEPPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemDEPPolicy();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemDirectoryA(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemDirectoryW(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemFirmwareTable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemFirmwareTable",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let firmware_table_provider_signature = call.get_arg();
            let firmware_table_id = call.get_arg();
            let p_firmware_table_buffer = call.get_arg();
            let buffer_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{firmware_table_provider_signature = {:?}, firmware_table_id = {:?}, p_firmware_table_buffer = {:?}, buffer_size = {:?}}}" , firmware_table_provider_signature , firmware_table_id , p_firmware_table_buffer , buffer_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemFirmwareTable(
                firmware_table_provider_signature,
                firmware_table_id,
                p_firmware_table_buffer,
                buffer_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_system_info = {:?}}}", lp_system_info)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetSystemInfo(lp_system_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemLeapSecondInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemLeapSecondInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let enabled = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{enabled = {:?}, flags = {:?}}}",
                            enabled, flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemLeapSecondInformation(enabled, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_system_time = {:?}}}", lp_system_time)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetSystemTime(lp_system_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAdjustment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemTimeAdjustment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_time_adjustment = call.get_arg();
            let lp_time_increment = call.get_arg();
            let lp_time_adjustment_disabled = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_time_adjustment = {:?}, lp_time_increment = {:?}, lp_time_adjustment_disabled = {:?}}}" , lp_time_adjustment , lp_time_increment , lp_time_adjustment_disabled ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemTimeAdjustment(
                lp_time_adjustment,
                lp_time_increment,
                lp_time_adjustment_disabled,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAdjustmentPrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemTimeAdjustmentPrecise",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_time_adjustment = call.get_arg();
            let lp_time_increment = call.get_arg();
            let lp_time_adjustment_disabled = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_time_adjustment = {:?}, lp_time_increment = {:?}, lp_time_adjustment_disabled = {:?}}}" , lp_time_adjustment , lp_time_increment , lp_time_adjustment_disabled ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemTimeAdjustmentPrecise(
                lp_time_adjustment,
                lp_time_increment,
                lp_time_adjustment_disabled,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAsFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemTimeAsFileTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_time_as_file_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_system_time_as_file_time = {:?}}}",
                            lp_system_time_as_file_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemTimeAsFileTime(lp_system_time_as_file_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimePreciseAsFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemTimePreciseAsFileTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_time_as_file_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_system_time_as_file_time = {:?}}}",
                            lp_system_time_as_file_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemTimePreciseAsFileTime(lp_system_time_as_file_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemWindowsDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemWindowsDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemWindowsDirectoryA(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemWindowsDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemWindowsDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemWindowsDirectoryW(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64Directory2A(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemWow64Directory2A",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            let image_file_machine_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_buffer = {:?}, u_size = {:?}, image_file_machine_type = {:?}}}" , lp_buffer , u_size , image_file_machine_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemWow64Directory2A(lp_buffer, u_size, image_file_machine_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64Directory2W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemWow64Directory2W",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            let image_file_machine_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_buffer = {:?}, u_size = {:?}, image_file_machine_type = {:?}}}" , lp_buffer , u_size , image_file_machine_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemWow64Directory2W(lp_buffer, u_size, image_file_machine_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64DirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemWow64DirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemWow64DirectoryA(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64DirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemWow64DirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemWow64DirectoryW(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTickCount(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTickCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTickCount();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTickCount64(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTickCount64",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTickCount64();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVersion(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetVersion");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetVersion();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVersionExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVersionExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_version_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_version_information = {:?}}}",
                            lp_version_information
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetVersionExA(lp_version_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVersionExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVersionExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_version_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_version_information = {:?}}}",
                            lp_version_information
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetVersionExW(lp_version_information);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowsDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowsDirectoryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowsDirectoryA(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowsDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowsDirectoryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            let u_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, u_size = {:?}}}",
                            lp_buffer, u_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowsDirectoryW(lp_buffer, u_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalMemoryStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GlobalMemoryStatus",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_buffer = {:?}}}", lp_buffer)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalMemoryStatus(lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalMemoryStatusEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GlobalMemoryStatusEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_buffer = {:?}}}", lp_buffer)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalMemoryStatusEx(lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlConvertDeviceFamilyInfoToString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlConvertDeviceFamilyInfoToString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let pul_device_family_buffer_size = call.get_arg();
            let pul_device_form_buffer_size = call.get_arg();
            let device_family = call.get_arg();
            let device_form = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pul_device_family_buffer_size = {:?}, pul_device_form_buffer_size = {:?}, device_family = {:?}, device_form = {:?}}}" , pul_device_family_buffer_size , pul_device_form_buffer_size , device_family , device_form ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlConvertDeviceFamilyInfoToString(
                pul_device_family_buffer_size,
                pul_device_form_buffer_size,
                device_family,
                device_form,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlGetDeviceFamilyInfoEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlGetDeviceFamilyInfoEnum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let pull_uap_info = call.get_arg();
            let pul_device_family = call.get_arg();
            let pul_device_form = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pull_uap_info = {:?}, pul_device_family = {:?}, pul_device_form = {:?}}}" , pull_uap_info , pul_device_family , pul_device_form ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.RtlGetDeviceFamilyInfoEnum(pull_uap_info, pul_device_family, pul_device_form);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlGetProductInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlGetProductInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let os_major_version = call.get_arg();
            let os_minor_version = call.get_arg();
            let sp_major_version = call.get_arg();
            let sp_minor_version = call.get_arg();
            let returned_product_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{os_major_version = {:?}, os_minor_version = {:?}, sp_major_version = {:?}, sp_minor_version = {:?}, returned_product_type = {:?}}}" , os_major_version , os_minor_version , sp_major_version , sp_minor_version , returned_product_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlGetProductInfo(
                os_major_version,
                os_minor_version,
                sp_major_version,
                sp_minor_version,
                returned_product_type,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlGetSystemGlobalData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlGetSystemGlobalData",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let data_id = call.get_arg();
            let buffer = call.get_arg();
            let size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{data_id = {:?}, buffer = {:?}, size = {:?}}}",
                            data_id, buffer, size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlGetSystemGlobalData(data_id, buffer, size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlOsDeploymentState(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlOsDeploymentState",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{flags = {:?}}}", flags)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlOsDeploymentState(flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlSwitchedVVI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlSwitchedVVI",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let version_info = call.get_arg();
            let type_mask = call.get_arg();
            let condition_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{version_info = {:?}, type_mask = {:?}, condition_mask = {:?}}}" , version_info , type_mask , condition_mask ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlSwitchedVVI(version_info, type_mask, condition_mask);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetComputerNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_computer_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_computer_name = {:?}}}",
                            lp_computer_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetComputerNameA(lp_computer_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameEx2W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetComputerNameEx2W",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let name_type = call.get_arg();
            let flags = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{name_type = {:?}, flags = {:?}, lp_buffer = {:?}}}",
                            name_type, flags, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetComputerNameEx2W(name_type, flags, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetComputerNameExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let name_type = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{name_type = {:?}, lp_buffer = {:?}}}",
                            name_type, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetComputerNameExA(name_type, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetComputerNameExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let name_type = call.get_arg();
            let lp_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{name_type = {:?}, lp_buffer = {:?}}}",
                            name_type, lp_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetComputerNameExW(name_type, lp_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetComputerNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_computer_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_computer_name = {:?}}}",
                            lp_computer_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetComputerNameW(lp_computer_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetLocalTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetLocalTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_system_time = {:?}}}", lp_system_time)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetLocalTime(lp_system_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetSystemTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetSystemTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_system_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_system_time = {:?}}}", lp_system_time)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetSystemTime(lp_system_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetSystemTimeAdjustment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetSystemTimeAdjustment",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let dw_time_adjustment = call.get_arg();
            let b_time_adjustment_disabled = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_time_adjustment = {:?}, b_time_adjustment_disabled = {:?}}}" , dw_time_adjustment , b_time_adjustment_disabled ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetSystemTimeAdjustment(dw_time_adjustment, b_time_adjustment_disabled);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetSystemTimeAdjustmentPrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetSystemTimeAdjustmentPrecise",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let dw_time_adjustment = call.get_arg();
            let b_time_adjustment_disabled = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_time_adjustment = {:?}, b_time_adjustment_disabled = {:?}}}" , dw_time_adjustment , b_time_adjustment_disabled ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SetSystemTimeAdjustmentPrecise(dw_time_adjustment, b_time_adjustment_disabled);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerSetConditionMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerSetConditionMask",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let condition_mask = call.get_arg();
            let type_mask = call.get_arg();
            let condition = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{condition_mask = {:?}, type_mask = {:?}, condition = {:?}}}" , condition_mask , type_mask , condition ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.VerSetConditionMask(condition_mask, type_mask, condition);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerifyVersionInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerifyVersionInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_version_information = call.get_arg();
            let dw_type_mask = call.get_arg();
            let dwl_condition_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_version_information = {:?}, dw_type_mask = {:?}, dwl_condition_mask = {:?}}}" , lp_version_information , dw_type_mask , dwl_condition_mask ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.VerifyVersionInfoA(lp_version_information, dw_type_mask, dwl_condition_mask);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_VerifyVersionInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "VerifyVersionInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::SystemInformation::get_api(win32);
            let lp_version_information = call.get_arg();
            let dw_type_mask = call.get_arg();
            let dwl_condition_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_version_information = {:?}, dw_type_mask = {:?}, dwl_condition_mask = {:?}}}" , lp_version_information , dw_type_mask , dwl_condition_mask ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.VerifyVersionInfoW(lp_version_information, dw_type_mask, dwl_condition_mask);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AcquireSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AcquireSRWLockExclusive",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let srw_lock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{srw_lock = {:?}}}", srw_lock)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AcquireSRWLockExclusive(srw_lock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AcquireSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AcquireSRWLockShared",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let srw_lock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{srw_lock = {:?}}}", srw_lock)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AcquireSRWLockShared(srw_lock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddIntegrityLabelToBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddIntegrityLabelToBoundaryDescriptor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let boundary_descriptor = call.get_arg();
            let integrity_label = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{boundary_descriptor = {:?}, integrity_label = {:?}}}",
                            boundary_descriptor, integrity_label
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res =
                api.AddIntegrityLabelToBoundaryDescriptor(boundary_descriptor, integrity_label);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddSIDToBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddSIDToBoundaryDescriptor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let boundary_descriptor = call.get_arg();
            let required_sid = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{boundary_descriptor = {:?}, required_sid = {:?}}}",
                            boundary_descriptor, required_sid
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AddSIDToBoundaryDescriptor(boundary_descriptor, required_sid);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AttachThreadInput(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AttachThreadInput",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let id_attach = call.get_arg();
            let id_attach_to = call.get_arg();
            let f_attach = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{id_attach = {:?}, id_attach_to = {:?}, f_attach = {:?}}}",
                            id_attach, id_attach_to, f_attach
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AttachThreadInput(id_attach, id_attach_to, f_attach);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvQuerySystemResponsiveness(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvQuerySystemResponsiveness",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let avrt_handle = call.get_arg();
            let system_responsiveness_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{avrt_handle = {:?}, system_responsiveness_value = {:?}}}",
                            avrt_handle, system_responsiveness_value
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AvQuerySystemResponsiveness(avrt_handle, system_responsiveness_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRevertMmThreadCharacteristics(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRevertMmThreadCharacteristics",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let avrt_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{avrt_handle = {:?}}}", avrt_handle)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.AvRevertMmThreadCharacteristics(avrt_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRtCreateThreadOrderingGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let context = call.get_arg();
            let period = call.get_arg();
            let thread_ordering_guid = call.get_arg();
            let timeout = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{context = {:?}, period = {:?}, thread_ordering_guid = {:?}, timeout = {:?}}}" , context , period , thread_ordering_guid , timeout ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.AvRtCreateThreadOrderingGroup(context, period, thread_ordering_guid, timeout);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroupExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRtCreateThreadOrderingGroupExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let context = call.get_arg();
            let period = call.get_arg();
            let thread_ordering_guid = call.get_arg();
            let timeout = call.get_arg();
            let task_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{context = {:?}, period = {:?}, thread_ordering_guid = {:?}, timeout = {:?}, task_name = {:?}}}" , context , period , thread_ordering_guid , timeout , task_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AvRtCreateThreadOrderingGroupExA(
                context,
                period,
                thread_ordering_guid,
                timeout,
                task_name,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroupExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRtCreateThreadOrderingGroupExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let context = call.get_arg();
            let period = call.get_arg();
            let thread_ordering_guid = call.get_arg();
            let timeout = call.get_arg();
            let task_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{context = {:?}, period = {:?}, thread_ordering_guid = {:?}, timeout = {:?}, task_name = {:?}}}" , context , period , thread_ordering_guid , timeout , task_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AvRtCreateThreadOrderingGroupExW(
                context,
                period,
                thread_ordering_guid,
                timeout,
                task_name,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRtDeleteThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRtDeleteThreadOrderingGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{context = {:?}}}", context)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AvRtDeleteThreadOrderingGroup(context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRtJoinThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRtJoinThreadOrderingGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let context = call.get_arg();
            let thread_ordering_guid = call.get_arg();
            let before = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{context = {:?}, thread_ordering_guid = {:?}, before = {:?}}}" , context , thread_ordering_guid , before ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AvRtJoinThreadOrderingGroup(context, thread_ordering_guid, before);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRtLeaveThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRtLeaveThreadOrderingGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{context = {:?}}}", context)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AvRtLeaveThreadOrderingGroup(context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvRtWaitOnThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvRtWaitOnThreadOrderingGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{context = {:?}}}", context)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AvRtWaitOnThreadOrderingGroup(context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvSetMmMaxThreadCharacteristicsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvSetMmMaxThreadCharacteristicsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let first_task = call.get_arg();
            let second_task = call.get_arg();
            let task_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{first_task = {:?}, second_task = {:?}, task_index = {:?}}}" , first_task , second_task , task_index ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AvSetMmMaxThreadCharacteristicsA(first_task, second_task, task_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvSetMmMaxThreadCharacteristicsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvSetMmMaxThreadCharacteristicsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let first_task = call.get_arg();
            let second_task = call.get_arg();
            let task_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{first_task = {:?}, second_task = {:?}, task_index = {:?}}}" , first_task , second_task , task_index ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AvSetMmMaxThreadCharacteristicsW(first_task, second_task, task_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadCharacteristicsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvSetMmThreadCharacteristicsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let task_name = call.get_arg();
            let task_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{task_name = {:?}, task_index = {:?}}}",
                            task_name, task_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AvSetMmThreadCharacteristicsA(task_name, task_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadCharacteristicsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvSetMmThreadCharacteristicsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let task_name = call.get_arg();
            let task_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{task_name = {:?}, task_index = {:?}}}",
                            task_name, task_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AvSetMmThreadCharacteristicsW(task_name, task_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AvSetMmThreadPriority",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let avrt_handle = call.get_arg();
            let priority = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{avrt_handle = {:?}, priority = {:?}}}",
                            avrt_handle, priority
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AvSetMmThreadPriority(avrt_handle, priority);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CallbackMayRunLong(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CallbackMayRunLong",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pci = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pci = {:?}}}" , pci ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CallbackMayRunLong(pci);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CancelThreadpoolIo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pio = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pio = {:?}}}" , pio ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CancelThreadpoolIo(pio);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelWaitableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CancelWaitableTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_timer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_timer = {:?}}}", h_timer)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CancelWaitableTimer(h_timer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ChangeTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ChangeTimerQueueTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let timer_queue = call.get_arg();
            let timer = call.get_arg();
            let due_time = call.get_arg();
            let period = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{timer_queue = {:?}, timer = {:?}, due_time = {:?}, period = {:?}}}" , timer_queue , timer , due_time , period ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ChangeTimerQueueTimer(timer_queue, timer, due_time, period);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ClosePrivateNamespace(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ClosePrivateNamespace",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let handle = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{handle = {:?}, flags = {:?}}}",
                            handle, flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ClosePrivateNamespace(handle, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpool(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseThreadpool",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ptpp = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ptpp = {:?}}}", ptpp)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CloseThreadpool(ptpp);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolCleanupGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseThreadpoolCleanupGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ptpcg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ptpcg = {:?}}}", ptpcg)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CloseThreadpoolCleanupGroup(ptpcg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolCleanupGroupMembers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseThreadpoolCleanupGroupMembers",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ptpcg = call.get_arg();
            let f_cancel_pending_callbacks = call.get_arg();
            let pv_cleanup_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ptpcg = {:?}, f_cancel_pending_callbacks = {:?}, pv_cleanup_context = {:?}}}" , ptpcg , f_cancel_pending_callbacks , pv_cleanup_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CloseThreadpoolCleanupGroupMembers(
                ptpcg,
                f_cancel_pending_callbacks,
                pv_cleanup_context,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseThreadpoolIo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pio = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pio = {:?}}}" , pio ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CloseThreadpoolIo(pio);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseThreadpoolTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pti = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pti = {:?}}}" , pti ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CloseThreadpoolTimer(pti);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseThreadpoolWait",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pwa = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwa = {:?}}}" , pwa ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CloseThreadpoolWait(pwa);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseThreadpoolWork",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pwk = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwk = {:?}}}" , pwk ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CloseThreadpoolWork(pwk);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ConvertFiberToThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ConvertFiberToThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ConvertFiberToThread();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ConvertThreadToFiber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ConvertThreadToFiber",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_parameter = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_parameter = {:?}}}", lp_parameter)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.ConvertThreadToFiber(lp_parameter);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ConvertThreadToFiberEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ConvertThreadToFiberEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_parameter = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_parameter = {:?}, dw_flags = {:?}}}",
                            lp_parameter, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ConvertThreadToFiberEx(lp_parameter, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateBoundaryDescriptorA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateBoundaryDescriptorA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let name = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{name = {:?}, flags = {:?}}}", name, flags)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.CreateBoundaryDescriptorA(name, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateBoundaryDescriptorW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateBoundaryDescriptorW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let name = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{name = {:?}, flags = {:?}}}", name, flags)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.CreateBoundaryDescriptorW(name, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CreateFiber");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_stack_size = call.get_arg();
            let lp_start_address = call.get_arg();
            let lp_parameter = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_stack_size = {:?}, lp_start_address = {:?}, lp_parameter = {:?}}}" , dw_stack_size , lp_start_address , lp_parameter ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateFiber(dw_stack_size, lp_start_address, lp_parameter);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateFiberEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateFiberEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_stack_commit_size = call.get_arg();
            let dw_stack_reserve_size = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_start_address = call.get_arg();
            let lp_parameter = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_stack_commit_size = {:?}, dw_stack_reserve_size = {:?}, dw_flags = {:?}, lp_start_address = {:?}, lp_parameter = {:?}}}" , dw_stack_commit_size , dw_stack_reserve_size , dw_flags , lp_start_address , lp_parameter ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateFiberEx(
                dw_stack_commit_size,
                dw_stack_reserve_size,
                dw_flags,
                lp_start_address,
                lp_parameter,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateProcessWithLogonW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateProcessWithLogonW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_username = call.get_arg();
            let lp_domain = call.get_arg();
            let lp_password = call.get_arg();
            let dw_logon_flags = call.get_arg();
            let lp_application_name = call.get_arg();
            let lp_command_line = call.get_arg();
            let dw_creation_flags = call.get_arg();
            let lp_environment = call.get_arg();
            let lp_current_directory = call.get_arg();
            let lp_startup_info = call.get_arg();
            let lp_process_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_username = {:?}, lp_domain = {:?}, lp_password = {:?}, dw_logon_flags = {:?}, lp_application_name = {:?}, lp_command_line = {:?}, dw_creation_flags = {:?}, lp_environment = {:?}, lp_current_directory = {:?}, lp_startup_info = {:?}, lp_process_information = {:?}}}" , lp_username , lp_domain , lp_password , dw_logon_flags , lp_application_name , lp_command_line , dw_creation_flags , lp_environment , lp_current_directory , lp_startup_info , lp_process_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateProcessWithLogonW(
                lp_username,
                lp_domain,
                lp_password,
                dw_logon_flags,
                lp_application_name,
                lp_command_line,
                dw_creation_flags,
                lp_environment,
                lp_current_directory,
                lp_startup_info,
                lp_process_information,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateProcessWithTokenW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateProcessWithTokenW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_token = call.get_arg();
            let dw_logon_flags = call.get_arg();
            let lp_application_name = call.get_arg();
            let lp_command_line = call.get_arg();
            let dw_creation_flags = call.get_arg();
            let lp_environment = call.get_arg();
            let lp_current_directory = call.get_arg();
            let lp_startup_info = call.get_arg();
            let lp_process_information = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_token = {:?}, dw_logon_flags = {:?}, lp_application_name = {:?}, lp_command_line = {:?}, dw_creation_flags = {:?}, lp_environment = {:?}, lp_current_directory = {:?}, lp_startup_info = {:?}, lp_process_information = {:?}}}" , h_token , dw_logon_flags , lp_application_name , lp_command_line , dw_creation_flags , lp_environment , lp_current_directory , lp_startup_info , lp_process_information ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateProcessWithTokenW(
                h_token,
                dw_logon_flags,
                lp_application_name,
                lp_command_line,
                dw_creation_flags,
                lp_environment,
                lp_current_directory,
                lp_startup_info,
                lp_process_information,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpool(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateThreadpool",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{reserved = {:?}}}", reserved)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateThreadpool(reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolCleanupGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateThreadpoolCleanupGroup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateThreadpoolCleanupGroup();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateThreadpoolIo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let fl = call.get_arg();
            let pfnio = call.get_arg();
            let pv = call.get_arg();
            let pcbe = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{fl = {:?}, pfnio = {:?}, pv = {:?}, pcbe = {:?}}}",
                            fl, pfnio, pv, pcbe
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateThreadpoolIo(fl, pfnio, pv, pcbe);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateThreadpoolTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pfnti = call.get_arg();
            let pv = call.get_arg();
            let pcbe = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pfnti = {:?}, pv = {:?}, pcbe = {:?}}}",
                            pfnti, pv, pcbe
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateThreadpoolTimer(pfnti, pv, pcbe);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateThreadpoolWait",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pfnwa = call.get_arg();
            let pv = call.get_arg();
            let pcbe = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pfnwa = {:?}, pv = {:?}, pcbe = {:?}}}",
                            pfnwa, pv, pcbe
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateThreadpoolWait(pfnwa, pv, pcbe);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateThreadpoolWork",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pfnwk = call.get_arg();
            let pv = call.get_arg();
            let pcbe = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pfnwk = {:?}, pv = {:?}, pcbe = {:?}}}",
                            pfnwk, pv, pcbe
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateThreadpoolWork(pfnwk, pv, pcbe);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateTimerQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateTimerQueue",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateTimerQueue();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateTimerQueueTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ph_new_timer = call.get_arg();
            let timer_queue = call.get_arg();
            let callback = call.get_arg();
            let parameter = call.get_arg();
            let due_time = call.get_arg();
            let period = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ph_new_timer = {:?}, timer_queue = {:?}, callback = {:?}, parameter = {:?}, due_time = {:?}, period = {:?}, flags = {:?}}}" , ph_new_timer , timer_queue , callback , parameter , due_time , period , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateTimerQueueTimer(
                ph_new_timer,
                timer_queue,
                callback,
                parameter,
                due_time,
                period,
                flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateUmsCompletionList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateUmsCompletionList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_completion_list = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{ums_completion_list = {:?}}}",
                            ums_completion_list
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateUmsCompletionList(ums_completion_list);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateUmsThreadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateUmsThreadContext",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_ums_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_ums_thread = {:?}}}", lp_ums_thread)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.CreateUmsThreadContext(lp_ums_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteBoundaryDescriptor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let boundary_descriptor = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{boundary_descriptor = {:?}}}",
                            boundary_descriptor
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteBoundaryDescriptor(boundary_descriptor);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteCriticalSection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_critical_section = {:?}}}",
                            lp_critical_section
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteCriticalSection(lp_critical_section);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DeleteFiber");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_fiber = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_fiber = {:?}}}", lp_fiber)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteFiber(lp_fiber);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteProcThreadAttributeList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteProcThreadAttributeList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_attribute_list = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_attribute_list = {:?}}}",
                            lp_attribute_list
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteProcThreadAttributeList(lp_attribute_list);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteSynchronizationBarrier",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_barrier = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_barrier = {:?}}}", lp_barrier)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DeleteSynchronizationBarrier(lp_barrier);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteTimerQueue",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let timer_queue = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{timer_queue = {:?}}}", timer_queue)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DeleteTimerQueue(timer_queue);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueueEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteTimerQueueEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let timer_queue = call.get_arg();
            let completion_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{timer_queue = {:?}, completion_event = {:?}}}",
                            timer_queue, completion_event
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteTimerQueueEx(timer_queue, completion_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteTimerQueueTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let timer_queue = call.get_arg();
            let timer = call.get_arg();
            let completion_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{timer_queue = {:?}, timer = {:?}, completion_event = {:?}}}" , timer_queue , timer , completion_event ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DeleteTimerQueueTimer(timer_queue, timer, completion_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteUmsCompletionList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteUmsCompletionList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_completion_list = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{ums_completion_list = {:?}}}",
                            ums_completion_list
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteUmsCompletionList(ums_completion_list);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteUmsThreadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeleteUmsThreadContext",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{ums_thread = {:?}}}", ums_thread)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.DeleteUmsThreadContext(ums_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DequeueUmsCompletionListItems(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DequeueUmsCompletionListItems",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_completion_list = call.get_arg();
            let wait_time_out = call.get_arg();
            let ums_thread_list = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ums_completion_list = {:?}, wait_time_out = {:?}, ums_thread_list = {:?}}}" , ums_completion_list , wait_time_out , ums_thread_list ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DequeueUmsCompletionListItems(
                ums_completion_list,
                wait_time_out,
                ums_thread_list,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DisassociateCurrentThreadFromCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DisassociateCurrentThreadFromCallback",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pci = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pci = {:?}}}" , pci ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DisassociateCurrentThreadFromCallback(pci);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnterCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnterCriticalSection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_critical_section = {:?}}}",
                            lp_critical_section
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnterCriticalSection(lp_critical_section);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnterSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnterSynchronizationBarrier",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_barrier = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_barrier = {:?}, dw_flags = {:?}}}",
                            lp_barrier, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnterSynchronizationBarrier(lp_barrier, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExecuteUmsThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExecuteUmsThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{ums_thread = {:?}}}", ums_thread)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.ExecuteUmsThread(ums_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExitProcess(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ExitProcess");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let u_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{u_exit_code = {:?}}}", u_exit_code)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let unwind_token = call.unwind_token();
            let res = api.ExitProcess(unwind_token, u_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExitThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ExitThread");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_exit_code = {:?}}}", dw_exit_code)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let unwind_token = call.unwind_token();
            let res = api.ExitThread(unwind_token, dw_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlsAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FlsAlloc");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_callback = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_callback = {:?}}}", lp_callback)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FlsAlloc(lp_callback);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlsFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FlsFree");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_fls_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_fls_index = {:?}}}", dw_fls_index)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FlsFree(dw_fls_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlsGetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FlsGetValue");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_fls_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_fls_index = {:?}}}", dw_fls_index)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FlsGetValue(dw_fls_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlsSetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FlsSetValue");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_fls_index = call.get_arg();
            let lp_fls_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_fls_index = {:?}, lp_fls_data = {:?}}}",
                            dw_fls_index, lp_fls_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FlsSetValue(dw_fls_index, lp_fls_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlushProcessWriteBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FlushProcessWriteBuffers",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FlushProcessWriteBuffers();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FreeLibraryWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FreeLibraryWhenCallbackReturns",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pci = call.get_arg();
            let r#mod = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pci = {:?}, r#mod = {:?}}}", pci, r#mod)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.FreeLibraryWhenCallbackReturns(pci, r#mod);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetActiveProcessorCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetActiveProcessorCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let group_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{group_number = {:?}}}", group_number)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetActiveProcessorCount(group_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetActiveProcessorGroupCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetActiveProcessorGroupCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetActiveProcessorGroupCount();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentProcess",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentProcess();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentProcessId",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentProcessId();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessorNumber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentProcessorNumber",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentProcessorNumber();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessorNumberEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentProcessorNumberEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let proc_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{proc_number = {:?}}}", proc_number)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetCurrentProcessorNumberEx(proc_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentThread();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThreadId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentThreadId",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentThreadId();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThreadStackLimits(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentThreadStackLimits",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let low_limit = call.get_arg();
            let high_limit = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{low_limit = {:?}, high_limit = {:?}}}",
                            low_limit, high_limit
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentThreadStackLimits(low_limit, high_limit);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentUmsThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentUmsThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentUmsThread();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetExitCodeProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetExitCodeProcess",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let lp_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, lp_exit_code = {:?}}}",
                            h_process, lp_exit_code
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetExitCodeProcess(h_process, lp_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetExitCodeThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetExitCodeThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let lp_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, lp_exit_code = {:?}}}",
                            h_thread, lp_exit_code
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetExitCodeThread(h_thread, lp_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetGuiResources(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetGuiResources",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let ui_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, ui_flags = {:?}}}",
                            h_process, ui_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetGuiResources(h_process, ui_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMachineTypeAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMachineTypeAttributes",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let machine = call.get_arg();
            let machine_type_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{machine = {:?}, machine_type_attributes = {:?}}}",
                            machine, machine_type_attributes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMachineTypeAttributes(machine, machine_type_attributes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMaximumProcessorCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMaximumProcessorCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let group_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{group_number = {:?}}}", group_number)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetMaximumProcessorCount(group_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMaximumProcessorGroupCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMaximumProcessorGroupCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMaximumProcessorGroupCount();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNextUmsListItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNextUmsListItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{ums_context = {:?}}}", ums_context)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetNextUmsListItem(ums_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaAvailableMemoryNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaAvailableMemoryNode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let node = call.get_arg();
            let available_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{node = {:?}, available_bytes = {:?}}}",
                            node, available_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaAvailableMemoryNode(node, available_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaAvailableMemoryNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaAvailableMemoryNodeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let node = call.get_arg();
            let available_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{node = {:?}, available_bytes = {:?}}}",
                            node, available_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaAvailableMemoryNodeEx(node, available_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaHighestNodeNumber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaHighestNodeNumber",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let highest_node_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{highest_node_number = {:?}}}",
                            highest_node_number
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaHighestNodeNumber(highest_node_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeNumberFromHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaNodeNumberFromHandle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_file = call.get_arg();
            let node_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, node_number = {:?}}}",
                            h_file, node_number
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaNodeNumberFromHandle(h_file, node_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaNodeProcessorMask",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let node = call.get_arg();
            let processor_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{node = {:?}, processor_mask = {:?}}}",
                            node, processor_mask
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaNodeProcessorMask(node, processor_mask);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMask2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaNodeProcessorMask2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let node_number = call.get_arg();
            let processor_masks = call.get_arg();
            let processor_mask_count = call.get_arg();
            let required_mask_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{node_number = {:?}, processor_masks = {:?}, processor_mask_count = {:?}, required_mask_count = {:?}}}" , node_number , processor_masks , processor_mask_count , required_mask_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetNumaNodeProcessorMask2(
                node_number,
                processor_masks,
                processor_mask_count,
                required_mask_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMaskEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaNodeProcessorMaskEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let node = call.get_arg();
            let processor_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{node = {:?}, processor_mask = {:?}}}",
                            node, processor_mask
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaNodeProcessorMaskEx(node, processor_mask);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaProcessorNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaProcessorNode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let processor = call.get_arg();
            let node_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{processor = {:?}, node_number = {:?}}}",
                            processor, node_number
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaProcessorNode(processor, node_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaProcessorNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaProcessorNodeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let processor = call.get_arg();
            let node_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{processor = {:?}, node_number = {:?}}}",
                            processor, node_number
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaProcessorNodeEx(processor, node_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaProximityNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaProximityNode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let proximity_id = call.get_arg();
            let node_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{proximity_id = {:?}, node_number = {:?}}}",
                            proximity_id, node_number
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaProximityNode(proximity_id, node_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNumaProximityNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNumaProximityNodeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let proximity_id = call.get_arg();
            let node_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{proximity_id = {:?}, node_number = {:?}}}",
                            proximity_id, node_number
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNumaProximityNodeEx(proximity_id, node_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPriorityClass(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPriorityClass",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_process = {:?}}}", h_process)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetPriorityClass(h_process);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessAffinityMask",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let lp_process_affinity_mask = call.get_arg();
            let lp_system_affinity_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_process_affinity_mask = {:?}, lp_system_affinity_mask = {:?}}}" , h_process , lp_process_affinity_mask , lp_system_affinity_mask ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessAffinityMask(
                h_process,
                lp_process_affinity_mask,
                lp_system_affinity_mask,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessDEPPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let lp_flags = call.get_arg();
            let lp_permanent = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, lp_flags = {:?}, lp_permanent = {:?}}}",
                            h_process, lp_flags, lp_permanent
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessDEPPolicy(h_process, lp_flags, lp_permanent);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessDefaultCpuSetMasks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process = call.get_arg();
            let cpu_set_masks = call.get_arg();
            let cpu_set_mask_count = call.get_arg();
            let required_mask_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}, required_mask_count = {:?}}}" , process , cpu_set_masks , cpu_set_mask_count , required_mask_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessDefaultCpuSetMasks(
                process,
                cpu_set_masks,
                cpu_set_mask_count,
                required_mask_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessDefaultCpuSets",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process = call.get_arg();
            let cpu_set_ids = call.get_arg();
            let cpu_set_id_count = call.get_arg();
            let required_id_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}, required_id_count = {:?}}}" , process , cpu_set_ids , cpu_set_id_count , required_id_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessDefaultCpuSets(
                process,
                cpu_set_ids,
                cpu_set_id_count,
                required_id_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessGroupAffinity",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let group_count = call.get_arg();
            let group_array = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, group_count = {:?}, group_array = {:?}}}" , h_process , group_count , group_array ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessGroupAffinity(h_process, group_count, group_array);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessHandleCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessHandleCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let pdw_handle_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, pdw_handle_count = {:?}}}",
                            h_process, pdw_handle_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessHandleCount(h_process, pdw_handle_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessId(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessId",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{process = {:?}}}", process)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessId(process);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessIdOfThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessIdOfThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{thread = {:?}}}", thread)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessIdOfThread(thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let process_information_class = call.get_arg();
            let process_information = call.get_arg();
            let process_information_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, process_information_class = {:?}, process_information = {:?}, process_information_size = {:?}}}" , h_process , process_information_class , process_information , process_information_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessInformation(
                h_process,
                process_information_class,
                process_information,
                process_information_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessIoCounters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessIoCounters",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let lp_io_counters = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, lp_io_counters = {:?}}}",
                            h_process, lp_io_counters
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessIoCounters(h_process, lp_io_counters);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessMitigationPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessMitigationPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let mitigation_policy = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, mitigation_policy = {:?}, lp_buffer = {:?}, dw_length = {:?}}}" , h_process , mitigation_policy , lp_buffer , dw_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.GetProcessMitigationPolicy(h_process, mitigation_policy, lp_buffer, dw_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessPriorityBoost",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let p_disable_priority_boost = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, p_disable_priority_boost = {:?}}}",
                            h_process, p_disable_priority_boost
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessPriorityBoost(h_process, p_disable_priority_boost);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessShutdownParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessShutdownParameters",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lpdw_level = call.get_arg();
            let lpdw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpdw_level = {:?}, lpdw_flags = {:?}}}",
                            lpdw_level, lpdw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessShutdownParameters(lpdw_level, lpdw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessTimes",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let lp_creation_time = call.get_arg();
            let lp_exit_time = call.get_arg();
            let lp_kernel_time = call.get_arg();
            let lp_user_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_creation_time = {:?}, lp_exit_time = {:?}, lp_kernel_time = {:?}, lp_user_time = {:?}}}" , h_process , lp_creation_time , lp_exit_time , lp_kernel_time , lp_user_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessTimes(
                h_process,
                lp_creation_time,
                lp_exit_time,
                lp_kernel_time,
                lp_user_time,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessVersion",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{process_id = {:?}}}", process_id)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetProcessVersion(process_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessWorkingSetSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessWorkingSetSize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let lp_minimum_working_set_size = call.get_arg();
            let lp_maximum_working_set_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, lp_minimum_working_set_size = {:?}, lp_maximum_working_set_size = {:?}}}" , h_process , lp_minimum_working_set_size , lp_maximum_working_set_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProcessWorkingSetSize(
                h_process,
                lp_minimum_working_set_size,
                lp_maximum_working_set_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStartupInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStartupInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_startup_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_startup_info = {:?}}}", lp_startup_info)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetStartupInfoA(lp_startup_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetStartupInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetStartupInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_startup_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_startup_info = {:?}}}", lp_startup_info)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetStartupInfoW(lp_startup_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemTimes",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_idle_time = call.get_arg();
            let lp_kernel_time = call.get_arg();
            let lp_user_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_idle_time = {:?}, lp_kernel_time = {:?}, lp_user_time = {:?}}}" , lp_idle_time , lp_kernel_time , lp_user_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetSystemTimes(lp_idle_time, lp_kernel_time, lp_user_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadDescription(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadDescription",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let ppsz_thread_description = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, ppsz_thread_description = {:?}}}",
                            h_thread, ppsz_thread_description
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadDescription(h_thread, ppsz_thread_description);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadGroupAffinity",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let group_affinity = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, group_affinity = {:?}}}",
                            h_thread, group_affinity
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadGroupAffinity(h_thread, group_affinity);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadIOPendingFlag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadIOPendingFlag",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let lp_io_is_pending = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, lp_io_is_pending = {:?}}}",
                            h_thread, lp_io_is_pending
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadIOPendingFlag(h_thread, lp_io_is_pending);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadId(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetThreadId");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{thread = {:?}}}", thread)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadId(thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadIdealProcessorEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadIdealProcessorEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let lp_ideal_processor = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, lp_ideal_processor = {:?}}}",
                            h_thread, lp_ideal_processor
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadIdealProcessorEx(h_thread, lp_ideal_processor);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let thread_information_class = call.get_arg();
            let thread_information = call.get_arg();
            let thread_information_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_thread = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_size = {:?}}}" , h_thread , thread_information_class , thread_information , thread_information_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetThreadInformation(
                h_thread,
                thread_information_class,
                thread_information,
                thread_information_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadPriority",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_thread = {:?}}}", h_thread)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadPriority(h_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadPriorityBoost",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let p_disable_priority_boost = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, p_disable_priority_boost = {:?}}}",
                            h_thread, p_disable_priority_boost
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadPriorityBoost(h_thread, p_disable_priority_boost);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadSelectedCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadSelectedCpuSetMasks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread = call.get_arg();
            let cpu_set_masks = call.get_arg();
            let cpu_set_mask_count = call.get_arg();
            let required_mask_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{thread = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}, required_mask_count = {:?}}}" , thread , cpu_set_masks , cpu_set_mask_count , required_mask_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetThreadSelectedCpuSetMasks(
                thread,
                cpu_set_masks,
                cpu_set_mask_count,
                required_mask_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadSelectedCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadSelectedCpuSets",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread = call.get_arg();
            let cpu_set_ids = call.get_arg();
            let cpu_set_id_count = call.get_arg();
            let required_id_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{thread = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}, required_id_count = {:?}}}" , thread , cpu_set_ids , cpu_set_id_count , required_id_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetThreadSelectedCpuSets(
                thread,
                cpu_set_ids,
                cpu_set_id_count,
                required_id_count,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadTimes",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let lp_creation_time = call.get_arg();
            let lp_exit_time = call.get_arg();
            let lp_kernel_time = call.get_arg();
            let lp_user_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_thread = {:?}, lp_creation_time = {:?}, lp_exit_time = {:?}, lp_kernel_time = {:?}, lp_user_time = {:?}}}" , h_thread , lp_creation_time , lp_exit_time , lp_kernel_time , lp_user_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetThreadTimes(
                h_thread,
                lp_creation_time,
                lp_exit_time,
                lp_kernel_time,
                lp_user_time,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUmsCompletionListEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUmsCompletionListEvent",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_completion_list = call.get_arg();
            let ums_completion_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ums_completion_list = {:?}, ums_completion_event = {:?}}}" , ums_completion_list , ums_completion_event ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetUmsCompletionListEvent(ums_completion_list, ums_completion_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUmsSystemThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUmsSystemThreadInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread_handle = call.get_arg();
            let system_thread_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{thread_handle = {:?}, system_thread_info = {:?}}}",
                            thread_handle, system_thread_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUmsSystemThreadInformation(thread_handle, system_thread_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitOnceBeginInitialize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitOnceBeginInitialize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_init_once = call.get_arg();
            let dw_flags = call.get_arg();
            let f_pending = call.get_arg();
            let lp_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_init_once = {:?}, dw_flags = {:?}, f_pending = {:?}, lp_context = {:?}}}" , lp_init_once , dw_flags , f_pending , lp_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InitOnceBeginInitialize(lp_init_once, dw_flags, f_pending, lp_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitOnceComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitOnceComplete",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_init_once = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_init_once = {:?}, dw_flags = {:?}, lp_context = {:?}}}" , lp_init_once , dw_flags , lp_context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InitOnceComplete(lp_init_once, dw_flags, lp_context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitOnceExecuteOnce(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitOnceExecuteOnce",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let init_once = call.get_arg();
            let init_fn = call.get_arg();
            let parameter = call.get_arg();
            let context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{init_once = {:?}, init_fn = {:?}, parameter = {:?}, context = {:?}}}" , init_once , init_fn , parameter , context ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InitOnceExecuteOnce(init_once, init_fn, parameter, context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitOnceInitialize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitOnceInitialize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let init_once = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{init_once = {:?}}}", init_once)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InitOnceInitialize(init_once);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeConditionVariable",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let condition_variable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{condition_variable = {:?}}}",
                            condition_variable
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InitializeConditionVariable(condition_variable);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeCriticalSection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_critical_section = {:?}}}",
                            lp_critical_section
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InitializeCriticalSection(lp_critical_section);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSectionAndSpinCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeCriticalSectionAndSpinCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            let dw_spin_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_critical_section = {:?}, dw_spin_count = {:?}}}",
                            lp_critical_section, dw_spin_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InitializeCriticalSectionAndSpinCount(lp_critical_section, dw_spin_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSectionEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeCriticalSectionEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            let dw_spin_count = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_critical_section = {:?}, dw_spin_count = {:?}, flags = {:?}}}" , lp_critical_section , dw_spin_count , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InitializeCriticalSectionEx(lp_critical_section, dw_spin_count, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeProcThreadAttributeList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeProcThreadAttributeList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_attribute_list = call.get_arg();
            let dw_attribute_count = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_attribute_list = {:?}, dw_attribute_count = {:?}, dw_flags = {:?}, lp_size = {:?}}}" , lp_attribute_list , dw_attribute_count , dw_flags , lp_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InitializeProcThreadAttributeList(
                lp_attribute_list,
                dw_attribute_count,
                dw_flags,
                lp_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeSListHead(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeSListHead",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InitializeSListHead(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeSRWLock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeSRWLock",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let srw_lock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{srw_lock = {:?}}}", srw_lock)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InitializeSRWLock(srw_lock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InitializeSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InitializeSynchronizationBarrier",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_barrier = call.get_arg();
            let l_total_threads = call.get_arg();
            let l_spin_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_barrier = {:?}, l_total_threads = {:?}, l_spin_count = {:?}}}" , lp_barrier , l_total_threads , l_spin_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.InitializeSynchronizationBarrier(lp_barrier, l_total_threads, l_spin_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InterlockedFlushSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InterlockedFlushSList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InterlockedFlushSList(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InterlockedPopEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InterlockedPopEntrySList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InterlockedPopEntrySList(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InterlockedPushEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InterlockedPushEntrySList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let list_head = call.get_arg();
            let list_entry = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{list_head = {:?}, list_entry = {:?}}}",
                            list_head, list_entry
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InterlockedPushEntrySList(list_head, list_entry);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InterlockedPushListSListEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InterlockedPushListSListEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let list_head = call.get_arg();
            let list = call.get_arg();
            let list_end = call.get_arg();
            let count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{list_head = {:?}, list = {:?}, list_end = {:?}, count = {:?}}}" , list_head , list , list_end , count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InterlockedPushListSListEx(list_head, list, list_end, count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsImmersiveProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsImmersiveProcess",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_process = {:?}}}", h_process)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsImmersiveProcess(h_process);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsProcessCritical(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsProcessCritical",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let critical = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, critical = {:?}}}",
                            h_process, critical
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsProcessCritical(h_process, critical);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsProcessorFeaturePresent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsProcessorFeaturePresent",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let processor_feature = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{processor_feature = {:?}}}",
                            processor_feature
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsProcessorFeaturePresent(processor_feature);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsThreadAFiber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsThreadAFiber",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsThreadAFiber();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsThreadpoolTimerSet(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsThreadpoolTimerSet",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pti = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pti = {:?}}}" , pti ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.IsThreadpoolTimerSet(pti);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsWow64Process(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsWow64Process",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let wow_64_process = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, wow_64_process = {:?}}}",
                            h_process, wow_64_process
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsWow64Process(h_process, wow_64_process);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsWow64Process2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsWow64Process2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let p_process_machine = call.get_arg();
            let p_native_machine = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, p_process_machine = {:?}, p_native_machine = {:?}}}" , h_process , p_process_machine , p_native_machine ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.IsWow64Process2(h_process, p_process_machine, p_native_machine);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LeaveCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LeaveCriticalSection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_critical_section = {:?}}}",
                            lp_critical_section
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LeaveCriticalSection(lp_critical_section);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LeaveCriticalSectionWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LeaveCriticalSectionWhenCallbackReturns",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pci = call.get_arg();
            let pcs = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pci = {:?}, pcs = {:?}}}", pci, pcs)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.LeaveCriticalSectionWhenCallbackReturns(pci, pcs);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtQueryInformationProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtQueryInformationProcess",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process_handle = call.get_arg();
            let process_information_class = call.get_arg();
            let process_information = call.get_arg();
            let process_information_length = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process_handle = {:?}, process_information_class = {:?}, process_information = {:?}, process_information_length = {:?}, return_length = {:?}}}" , process_handle , process_information_class , process_information , process_information_length , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtQueryInformationProcess(
                process_handle,
                process_information_class,
                process_information,
                process_information_length,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtQueryInformationThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtQueryInformationThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread_handle = call.get_arg();
            let thread_information_class = call.get_arg();
            let thread_information = call.get_arg();
            let thread_information_length = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{thread_handle = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_length = {:?}, return_length = {:?}}}" , thread_handle , thread_information_class , thread_information , thread_information_length , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtQueryInformationThread(
                thread_handle,
                thread_information_class,
                thread_information,
                thread_information_length,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtSetInformationThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtSetInformationThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread_handle = call.get_arg();
            let thread_information_class = call.get_arg();
            let thread_information = call.get_arg();
            let thread_information_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{thread_handle = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_length = {:?}}}" , thread_handle , thread_information_class , thread_information , thread_information_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtSetInformationThread(
                thread_handle,
                thread_information_class,
                thread_information,
                thread_information_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenEventA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenEventA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenEventA(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenEventW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenEventW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenEventW(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenMutexW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenMutexW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenMutexW(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenPrivateNamespaceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenPrivateNamespaceA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_boundary_descriptor = call.get_arg();
            let lp_alias_prefix = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_boundary_descriptor = {:?}, lp_alias_prefix = {:?}}}",
                            lp_boundary_descriptor, lp_alias_prefix
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.OpenPrivateNamespaceA(lp_boundary_descriptor, lp_alias_prefix);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenPrivateNamespaceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenPrivateNamespaceW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_boundary_descriptor = call.get_arg();
            let lp_alias_prefix = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_boundary_descriptor = {:?}, lp_alias_prefix = {:?}}}",
                            lp_boundary_descriptor, lp_alias_prefix
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.OpenPrivateNamespaceW(lp_boundary_descriptor, lp_alias_prefix);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenProcess(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenProcess");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let dw_process_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, dw_process_id = {:?}}}" , dw_desired_access , b_inherit_handle , dw_process_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenProcess(dw_desired_access, b_inherit_handle, dw_process_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenSemaphoreW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenSemaphoreW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenSemaphoreW(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenThread");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let dw_thread_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, dw_thread_id = {:?}}}" , dw_desired_access , b_inherit_handle , dw_thread_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenThread(dw_desired_access, b_inherit_handle, dw_thread_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenWaitableTimerW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenWaitableTimerW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_timer_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_timer_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_timer_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenWaitableTimerW(dw_desired_access, b_inherit_handle, lp_timer_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PulseEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "PulseEvent");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_event = {:?}}}", h_event)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.PulseEvent(h_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryDepthSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryDepthSList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let list_head = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{list_head = {:?}}}", list_head)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryDepthSList(list_head);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryFullProcessImageNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryFullProcessImageNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_exe_name = call.get_arg();
            let lpdw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, dw_flags = {:?}, lp_exe_name = {:?}, lpdw_size = {:?}}}" , h_process , dw_flags , lp_exe_name , lpdw_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueryFullProcessImageNameA(h_process, dw_flags, lp_exe_name, lpdw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryFullProcessImageNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryFullProcessImageNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let dw_flags = call.get_arg();
            let lp_exe_name = call.get_arg();
            let lpdw_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, dw_flags = {:?}, lp_exe_name = {:?}, lpdw_size = {:?}}}" , h_process , dw_flags , lp_exe_name , lpdw_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueryFullProcessImageNameW(h_process, dw_flags, lp_exe_name, lpdw_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryProcessAffinityUpdateMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryProcessAffinityUpdateMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let lpdw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, lpdw_flags = {:?}}}",
                            h_process, lpdw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryProcessAffinityUpdateMode(h_process, lpdw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryProtectedPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryProtectedPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let policy_guid = call.get_arg();
            let policy_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{policy_guid = {:?}, policy_value = {:?}}}",
                            policy_guid, policy_value
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryProtectedPolicy(policy_guid, policy_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryThreadpoolStackInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryThreadpoolStackInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ptpp = call.get_arg();
            let ptpsi = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{ptpp = {:?}, ptpsi = {:?}}}", ptpp, ptpsi)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.QueryThreadpoolStackInformation(ptpp, ptpsi);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryUmsThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryUmsThreadInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_thread = call.get_arg();
            let ums_thread_info_class = call.get_arg();
            let ums_thread_information = call.get_arg();
            let ums_thread_information_length = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ums_thread = {:?}, ums_thread_info_class = {:?}, ums_thread_information = {:?}, ums_thread_information_length = {:?}, return_length = {:?}}}" , ums_thread , ums_thread_info_class , ums_thread_information , ums_thread_information_length , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueryUmsThreadInformation(
                ums_thread,
                ums_thread_info_class,
                ums_thread_information,
                ums_thread_information_length,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueueUserAPC(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueueUserAPC",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pfn_apc = call.get_arg();
            let h_thread = call.get_arg();
            let dw_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pfn_apc = {:?}, h_thread = {:?}, dw_data = {:?}}}",
                            pfn_apc, h_thread, dw_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueueUserAPC(pfn_apc, h_thread, dw_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueueUserAPC2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueueUserAPC2",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let apc_routine = call.get_arg();
            let thread = call.get_arg();
            let data = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{apc_routine = {:?}, thread = {:?}, data = {:?}, flags = {:?}}}" , apc_routine , thread , data , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.QueueUserAPC2(apc_routine, thread, data, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueueUserWorkItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueueUserWorkItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let function = call.get_arg();
            let context = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{function = {:?}, context = {:?}, flags = {:?}}}",
                            function, context, flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueueUserWorkItem(function, context, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RegisterWaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RegisterWaitForSingleObject",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ph_new_wait_object = call.get_arg();
            let h_object = call.get_arg();
            let callback = call.get_arg();
            let context = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ph_new_wait_object = {:?}, h_object = {:?}, callback = {:?}, context = {:?}, dw_milliseconds = {:?}, dw_flags = {:?}}}" , ph_new_wait_object , h_object , callback , context , dw_milliseconds , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RegisterWaitForSingleObject(
                ph_new_wait_object,
                h_object,
                callback,
                context,
                dw_milliseconds,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReleaseMutex(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReleaseMutex",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_mutex = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mutex = {:?}}}", h_mutex)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ReleaseMutex(h_mutex);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReleaseMutexWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReleaseMutexWhenCallbackReturns",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pci = call.get_arg();
            let r#mut = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pci = {:?}, r#mut = {:?}}}", pci, r#mut)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.ReleaseMutexWhenCallbackReturns(pci, r#mut);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReleaseSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReleaseSRWLockExclusive",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let srw_lock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{srw_lock = {:?}}}", srw_lock)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ReleaseSRWLockExclusive(srw_lock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReleaseSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReleaseSRWLockShared",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let srw_lock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{srw_lock = {:?}}}", srw_lock)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ReleaseSRWLockShared(srw_lock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReleaseSemaphore(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReleaseSemaphore",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_semaphore = call.get_arg();
            let l_release_count = call.get_arg();
            let lp_previous_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_semaphore = {:?}, l_release_count = {:?}, lp_previous_count = {:?}}}" , h_semaphore , l_release_count , lp_previous_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReleaseSemaphore(h_semaphore, l_release_count, lp_previous_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReleaseSemaphoreWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReleaseSemaphoreWhenCallbackReturns",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pci = call.get_arg();
            let sem = call.get_arg();
            let crel = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pci = {:?}, sem = {:?}, crel = {:?}}}",
                            pci, sem, crel
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ReleaseSemaphoreWhenCallbackReturns(pci, sem, crel);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ResetEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ResetEvent");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_event = {:?}}}", h_event)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ResetEvent(h_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ResumeThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ResumeThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_thread = {:?}}}", h_thread)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ResumeThread(h_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCriticalSectionSpinCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCriticalSectionSpinCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            let dw_spin_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_critical_section = {:?}, dw_spin_count = {:?}}}",
                            lp_critical_section, dw_spin_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetCriticalSectionSpinCount(lp_critical_section, dw_spin_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetEvent");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_event = {:?}}}", h_event)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetEvent(h_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEventWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetEventWhenCallbackReturns",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pci = call.get_arg();
            let evt = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{pci = {:?}, evt = {:?}}}", pci, evt)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetEventWhenCallbackReturns(pci, evt);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetPriorityClass(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetPriorityClass",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let dw_priority_class = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, dw_priority_class = {:?}}}",
                            h_process, dw_priority_class
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetPriorityClass(h_process, dw_priority_class);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessAffinityMask",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let dw_process_affinity_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, dw_process_affinity_mask = {:?}}}",
                            h_process, dw_process_affinity_mask
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessAffinityMask(h_process, dw_process_affinity_mask);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessAffinityUpdateMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessAffinityUpdateMode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, dw_flags = {:?}}}",
                            h_process, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessAffinityUpdateMode(h_process, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessDEPPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{dw_flags = {:?}}}", dw_flags)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessDEPPolicy(dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessDefaultCpuSetMasks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process = call.get_arg();
            let cpu_set_masks = call.get_arg();
            let cpu_set_mask_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}}}" , process , cpu_set_masks , cpu_set_mask_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessDefaultCpuSetMasks(process, cpu_set_masks, cpu_set_mask_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessDefaultCpuSets",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process = call.get_arg();
            let cpu_set_ids = call.get_arg();
            let cpu_set_id_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}}}" , process , cpu_set_ids , cpu_set_id_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessDefaultCpuSets(process, cpu_set_ids, cpu_set_id_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessDynamicEHContinuationTargets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessDynamicEHContinuationTargets",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process = call.get_arg();
            let number_of_targets = call.get_arg();
            let targets = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{process = {:?}, number_of_targets = {:?}, targets = {:?}}}" , process , number_of_targets , targets ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SetProcessDynamicEHContinuationTargets(process, number_of_targets, targets);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessDynamicEnforcedCetCompatibleRanges(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessDynamicEnforcedCetCompatibleRanges",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let process = call.get_arg();
            let number_of_ranges = call.get_arg();
            let ranges = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{process = {:?}, number_of_ranges = {:?}, ranges = {:?}}}",
                            process, number_of_ranges, ranges
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res =
                api.SetProcessDynamicEnforcedCetCompatibleRanges(process, number_of_ranges, ranges);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let process_information_class = call.get_arg();
            let process_information = call.get_arg();
            let process_information_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, process_information_class = {:?}, process_information = {:?}, process_information_size = {:?}}}" , h_process , process_information_class , process_information , process_information_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessInformation(
                h_process,
                process_information_class,
                process_information,
                process_information_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessMitigationPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessMitigationPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let mitigation_policy = call.get_arg();
            let lp_buffer = call.get_arg();
            let dw_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{mitigation_policy = {:?}, lp_buffer = {:?}, dw_length = {:?}}}" , mitigation_policy , lp_buffer , dw_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessMitigationPolicy(mitigation_policy, lp_buffer, dw_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessPriorityBoost",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let b_disable_priority_boost = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, b_disable_priority_boost = {:?}}}",
                            h_process, b_disable_priority_boost
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessPriorityBoost(h_process, b_disable_priority_boost);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessRestrictionExemption(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessRestrictionExemption",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let f_enable_exemption = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{f_enable_exemption = {:?}}}",
                            f_enable_exemption
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessRestrictionExemption(f_enable_exemption);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessShutdownParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessShutdownParameters",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_level = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_level = {:?}, dw_flags = {:?}}}",
                            dw_level, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessShutdownParameters(dw_level, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessWorkingSetSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessWorkingSetSize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let dw_minimum_working_set_size = call.get_arg();
            let dw_maximum_working_set_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_process = {:?}, dw_minimum_working_set_size = {:?}, dw_maximum_working_set_size = {:?}}}" , h_process , dw_minimum_working_set_size , dw_maximum_working_set_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProcessWorkingSetSize(
                h_process,
                dw_minimum_working_set_size,
                dw_maximum_working_set_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProtectedPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProtectedPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let policy_guid = call.get_arg();
            let policy_value = call.get_arg();
            let old_policy_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{policy_guid = {:?}, policy_value = {:?}, old_policy_value = {:?}}}" , policy_guid , policy_value , old_policy_value ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetProtectedPolicy(policy_guid, policy_value, old_policy_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadAffinityMask",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let dw_thread_affinity_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, dw_thread_affinity_mask = {:?}}}",
                            h_thread, dw_thread_affinity_mask
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadAffinityMask(h_thread, dw_thread_affinity_mask);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadDescription(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadDescription",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let lp_thread_description = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, lp_thread_description = {:?}}}",
                            h_thread, lp_thread_description
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadDescription(h_thread, lp_thread_description);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadGroupAffinity",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let group_affinity = call.get_arg();
            let previous_group_affinity = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_thread = {:?}, group_affinity = {:?}, previous_group_affinity = {:?}}}" , h_thread , group_affinity , previous_group_affinity ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadGroupAffinity(h_thread, group_affinity, previous_group_affinity);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadIdealProcessor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadIdealProcessor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let dw_ideal_processor = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, dw_ideal_processor = {:?}}}",
                            h_thread, dw_ideal_processor
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadIdealProcessor(h_thread, dw_ideal_processor);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadIdealProcessorEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadIdealProcessorEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let lp_ideal_processor = call.get_arg();
            let lp_previous_ideal_processor = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_thread = {:?}, lp_ideal_processor = {:?}, lp_previous_ideal_processor = {:?}}}" , h_thread , lp_ideal_processor , lp_previous_ideal_processor ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadIdealProcessorEx(
                h_thread,
                lp_ideal_processor,
                lp_previous_ideal_processor,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let thread_information_class = call.get_arg();
            let thread_information = call.get_arg();
            let thread_information_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_thread = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_size = {:?}}}" , h_thread , thread_information_class , thread_information , thread_information_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadInformation(
                h_thread,
                thread_information_class,
                thread_information,
                thread_information_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadPriority",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let n_priority = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, n_priority = {:?}}}",
                            h_thread, n_priority
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadPriority(h_thread, n_priority);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadPriorityBoost",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let b_disable_priority_boost = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, b_disable_priority_boost = {:?}}}",
                            h_thread, b_disable_priority_boost
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadPriorityBoost(h_thread, b_disable_priority_boost);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadSelectedCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadSelectedCpuSetMasks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread = call.get_arg();
            let cpu_set_masks = call.get_arg();
            let cpu_set_mask_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{thread = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}}}" , thread , cpu_set_masks , cpu_set_mask_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadSelectedCpuSetMasks(thread, cpu_set_masks, cpu_set_mask_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadSelectedCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadSelectedCpuSets",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread = call.get_arg();
            let cpu_set_ids = call.get_arg();
            let cpu_set_id_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{thread = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}}}" , thread , cpu_set_ids , cpu_set_id_count ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadSelectedCpuSets(thread, cpu_set_ids, cpu_set_id_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadStackGuarantee(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadStackGuarantee",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let stack_size_in_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{stack_size_in_bytes = {:?}}}",
                            stack_size_in_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadStackGuarantee(stack_size_in_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadToken(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadToken",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let thread = call.get_arg();
            let token = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{thread = {:?}, token = {:?}}}",
                            thread, token
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadToken(thread, token);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolStackInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadpoolStackInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ptpp = call.get_arg();
            let ptpsi = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{ptpp = {:?}, ptpsi = {:?}}}", ptpp, ptpsi)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetThreadpoolStackInformation(ptpp, ptpsi);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolThreadMaximum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadpoolThreadMaximum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ptpp = call.get_arg();
            let cthrd_most = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{ptpp = {:?}, cthrd_most = {:?}}}",
                            ptpp, cthrd_most
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadpoolThreadMaximum(ptpp, cthrd_most);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolThreadMinimum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadpoolThreadMinimum",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ptpp = call.get_arg();
            let cthrd_mic = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{ptpp = {:?}, cthrd_mic = {:?}}}",
                            ptpp, cthrd_mic
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadpoolThreadMinimum(ptpp, cthrd_mic);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadpoolTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pti = call.get_arg();
            let pft_due_time = call.get_arg();
            let ms_period = call.get_arg();
            let ms_window_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pti = {:?}, pft_due_time = {:?}, ms_period = {:?}, ms_window_length = {:?}}}" , pti , pft_due_time , ms_period , ms_window_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadpoolTimer(pti, pft_due_time, ms_period, ms_window_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolTimerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadpoolTimerEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pti = call.get_arg();
            let pft_due_time = call.get_arg();
            let ms_period = call.get_arg();
            let ms_window_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pti = {:?}, pft_due_time = {:?}, ms_period = {:?}, ms_window_length = {:?}}}" , pti , pft_due_time , ms_period , ms_window_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadpoolTimerEx(pti, pft_due_time, ms_period, ms_window_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadpoolWait",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pwa = call.get_arg();
            let h = call.get_arg();
            let pft_timeout = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pwa = {:?}, h = {:?}, pft_timeout = {:?}}}",
                            pwa, h, pft_timeout
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetThreadpoolWait(pwa, h, pft_timeout);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolWaitEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetThreadpoolWaitEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pwa = call.get_arg();
            let h = call.get_arg();
            let pft_timeout = call.get_arg();
            let reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwa = {:?}, h = {:?}, pft_timeout = {:?}, reserved = {:?}}}" , pwa , h , pft_timeout , reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetThreadpoolWaitEx(pwa, h, pft_timeout, reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetTimerQueueTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let timer_queue = call.get_arg();
            let callback = call.get_arg();
            let parameter = call.get_arg();
            let due_time = call.get_arg();
            let period = call.get_arg();
            let prefer_io = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{timer_queue = {:?}, callback = {:?}, parameter = {:?}, due_time = {:?}, period = {:?}, prefer_io = {:?}}}" , timer_queue , callback , parameter , due_time , period , prefer_io ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetTimerQueueTimer(
                timer_queue,
                callback,
                parameter,
                due_time,
                period,
                prefer_io,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetUmsThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetUmsThreadInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let ums_thread = call.get_arg();
            let ums_thread_info_class = call.get_arg();
            let ums_thread_information = call.get_arg();
            let ums_thread_information_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ums_thread = {:?}, ums_thread_info_class = {:?}, ums_thread_information = {:?}, ums_thread_information_length = {:?}}}" , ums_thread , ums_thread_info_class , ums_thread_information , ums_thread_information_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetUmsThreadInformation(
                ums_thread,
                ums_thread_info_class,
                ums_thread_information,
                ums_thread_information_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWaitableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWaitableTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_timer = call.get_arg();
            let lp_due_time = call.get_arg();
            let l_period = call.get_arg();
            let pfn_completion_routine = call.get_arg();
            let lp_arg_to_completion_routine = call.get_arg();
            let f_resume = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_timer = {:?}, lp_due_time = {:?}, l_period = {:?}, pfn_completion_routine = {:?}, lp_arg_to_completion_routine = {:?}, f_resume = {:?}}}" , h_timer , lp_due_time , l_period , pfn_completion_routine , lp_arg_to_completion_routine , f_resume ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetWaitableTimer(
                h_timer,
                lp_due_time,
                l_period,
                pfn_completion_routine,
                lp_arg_to_completion_routine,
                f_resume,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWaitableTimerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWaitableTimerEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_timer = call.get_arg();
            let lp_due_time = call.get_arg();
            let l_period = call.get_arg();
            let pfn_completion_routine = call.get_arg();
            let lp_arg_to_completion_routine = call.get_arg();
            let wake_context = call.get_arg();
            let tolerable_delay = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_timer = {:?}, lp_due_time = {:?}, l_period = {:?}, pfn_completion_routine = {:?}, lp_arg_to_completion_routine = {:?}, wake_context = {:?}, tolerable_delay = {:?}}}" , h_timer , lp_due_time , l_period , pfn_completion_routine , lp_arg_to_completion_routine , wake_context , tolerable_delay ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetWaitableTimerEx(
                h_timer,
                lp_due_time,
                l_period,
                pfn_completion_routine,
                lp_arg_to_completion_routine,
                wake_context,
                tolerable_delay,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_Sleep(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "Sleep");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_milliseconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_milliseconds = {:?}}}", dw_milliseconds)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.Sleep(dw_milliseconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SleepConditionVariableCS(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SleepConditionVariableCS",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let condition_variable = call.get_arg();
            let critical_section = call.get_arg();
            let dw_milliseconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{condition_variable = {:?}, critical_section = {:?}, dw_milliseconds = {:?}}}" , condition_variable , critical_section , dw_milliseconds ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SleepConditionVariableCS(condition_variable, critical_section, dw_milliseconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SleepConditionVariableSRW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SleepConditionVariableSRW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let condition_variable = call.get_arg();
            let srw_lock = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{condition_variable = {:?}, srw_lock = {:?}, dw_milliseconds = {:?}, flags = {:?}}}" , condition_variable , srw_lock , dw_milliseconds , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.SleepConditionVariableSRW(condition_variable, srw_lock, dw_milliseconds, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SleepEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SleepEx");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_milliseconds = call.get_arg();
            let b_alertable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_milliseconds = {:?}, b_alertable = {:?}}}",
                            dw_milliseconds, b_alertable
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SleepEx(dw_milliseconds, b_alertable);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_StartThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "StartThreadpoolIo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pio = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pio = {:?}}}" , pio ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.StartThreadpoolIo(pio);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SubmitThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SubmitThreadpoolWork",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pwk = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pwk = {:?}}}" , pwk ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SubmitThreadpoolWork(pwk);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SuspendThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SuspendThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_thread = {:?}}}", h_thread)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SuspendThread(h_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SwitchToFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SwitchToFiber",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_fiber = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_fiber = {:?}}}", lp_fiber)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SwitchToFiber(lp_fiber);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SwitchToThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SwitchToThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SwitchToThread();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TerminateProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TerminateProcess",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let u_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, u_exit_code = {:?}}}",
                            h_process, u_exit_code
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TerminateProcess(h_process, u_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TerminateThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TerminateThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            let dw_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_thread = {:?}, dw_exit_code = {:?}}}",
                            h_thread, dw_exit_code
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TerminateThread(h_thread, dw_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TlsAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "TlsAlloc");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TlsAlloc();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TlsFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "TlsFree");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_tls_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_tls_index = {:?}}}", dw_tls_index)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.TlsFree(dw_tls_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TlsGetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "TlsGetValue");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_tls_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_tls_index = {:?}}}", dw_tls_index)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.TlsGetValue(dw_tls_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TlsSetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "TlsSetValue");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let dw_tls_index = call.get_arg();
            let lp_tls_value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_tls_index = {:?}, lp_tls_value = {:?}}}",
                            dw_tls_index, lp_tls_value
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TlsSetValue(dw_tls_index, lp_tls_value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TryAcquireSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TryAcquireSRWLockExclusive",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let srw_lock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{srw_lock = {:?}}}", srw_lock)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TryAcquireSRWLockExclusive(srw_lock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TryAcquireSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TryAcquireSRWLockShared",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let srw_lock = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{srw_lock = {:?}}}", srw_lock)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TryAcquireSRWLockShared(srw_lock);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TryEnterCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TryEnterCriticalSection",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_critical_section = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_critical_section = {:?}}}",
                            lp_critical_section
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TryEnterCriticalSection(lp_critical_section);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TrySubmitThreadpoolCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TrySubmitThreadpoolCallback",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pfns = call.get_arg();
            let pv = call.get_arg();
            let pcbe = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pfns = {:?}, pv = {:?}, pcbe = {:?}}}",
                            pfns, pv, pcbe
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TrySubmitThreadpoolCallback(pfns, pv, pcbe);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UmsThreadYield(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UmsThreadYield",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let scheduler_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{scheduler_param = {:?}}}", scheduler_param)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.UmsThreadYield(scheduler_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnregisterWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnregisterWait",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let wait_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{wait_handle = {:?}}}", wait_handle)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.UnregisterWait(wait_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnregisterWaitEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnregisterWaitEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let wait_handle = call.get_arg();
            let completion_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{wait_handle = {:?}, completion_event = {:?}}}",
                            wait_handle, completion_event
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.UnregisterWaitEx(wait_handle, completion_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UpdateProcThreadAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UpdateProcThreadAttribute",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_attribute_list = call.get_arg();
            let dw_flags = call.get_arg();
            let attribute = call.get_arg();
            let lp_value = call.get_arg();
            let cb_size = call.get_arg();
            let lp_previous_value = call.get_arg();
            let lp_return_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_attribute_list = {:?}, dw_flags = {:?}, attribute = {:?}, lp_value = {:?}, cb_size = {:?}, lp_previous_value = {:?}, lp_return_size = {:?}}}" , lp_attribute_list , dw_flags , attribute , lp_value , cb_size , lp_previous_value , lp_return_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UpdateProcThreadAttribute(
                lp_attribute_list,
                dw_flags,
                attribute,
                lp_value,
                cb_size,
                lp_previous_value,
                lp_return_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForInputIdle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForInputIdle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_process = call.get_arg();
            let dw_milliseconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_process = {:?}, dw_milliseconds = {:?}}}",
                            h_process, dw_milliseconds
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WaitForInputIdle(h_process, dw_milliseconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForMultipleObjects(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForMultipleObjects",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let n_count = call.get_arg();
            let lp_handles = call.get_arg();
            let b_wait_all = call.get_arg();
            let dw_milliseconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{n_count = {:?}, lp_handles = {:?}, b_wait_all = {:?}, dw_milliseconds = {:?}}}" , n_count , lp_handles , b_wait_all , dw_milliseconds ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WaitForMultipleObjects(n_count, lp_handles, b_wait_all, dw_milliseconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForMultipleObjectsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForMultipleObjectsEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let n_count = call.get_arg();
            let lp_handles = call.get_arg();
            let b_wait_all = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let b_alertable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{n_count = {:?}, lp_handles = {:?}, b_wait_all = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}" , n_count , lp_handles , b_wait_all , dw_milliseconds , b_alertable ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WaitForMultipleObjectsEx(
                n_count,
                lp_handles,
                b_wait_all,
                dw_milliseconds,
                b_alertable,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForSingleObject",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_handle = call.get_arg();
            let dw_milliseconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_handle = {:?}, dw_milliseconds = {:?}}}",
                            h_handle, dw_milliseconds
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WaitForSingleObject(h_handle, dw_milliseconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForSingleObjectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForSingleObjectEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_handle = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let b_alertable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_handle = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}" , h_handle , dw_milliseconds , b_alertable ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WaitForSingleObjectEx(h_handle, dw_milliseconds, b_alertable);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolIoCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForThreadpoolIoCallbacks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pio = call.get_arg();
            let f_cancel_pending_callbacks = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pio = {:?}, f_cancel_pending_callbacks = {:?}}}",
                            pio, f_cancel_pending_callbacks
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WaitForThreadpoolIoCallbacks(pio, f_cancel_pending_callbacks);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolTimerCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForThreadpoolTimerCallbacks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pti = call.get_arg();
            let f_cancel_pending_callbacks = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pti = {:?}, f_cancel_pending_callbacks = {:?}}}",
                            pti, f_cancel_pending_callbacks
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WaitForThreadpoolTimerCallbacks(pti, f_cancel_pending_callbacks);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolWaitCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForThreadpoolWaitCallbacks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pwa = call.get_arg();
            let f_cancel_pending_callbacks = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pwa = {:?}, f_cancel_pending_callbacks = {:?}}}",
                            pwa, f_cancel_pending_callbacks
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WaitForThreadpoolWaitCallbacks(pwa, f_cancel_pending_callbacks);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolWorkCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitForThreadpoolWorkCallbacks",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let pwk = call.get_arg();
            let f_cancel_pending_callbacks = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pwk = {:?}, f_cancel_pending_callbacks = {:?}}}",
                            pwk, f_cancel_pending_callbacks
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WaitForThreadpoolWorkCallbacks(pwk, f_cancel_pending_callbacks);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitOnAddress(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WaitOnAddress",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let address = call.get_arg();
            let compare_address = call.get_arg();
            let address_size = call.get_arg();
            let dw_milliseconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{address = {:?}, compare_address = {:?}, address_size = {:?}, dw_milliseconds = {:?}}}" , address , compare_address , address_size , dw_milliseconds ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WaitOnAddress(address, compare_address, address_size, dw_milliseconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WakeAllConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WakeAllConditionVariable",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let condition_variable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{condition_variable = {:?}}}",
                            condition_variable
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WakeAllConditionVariable(condition_variable);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WakeByAddressAll(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WakeByAddressAll",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let address = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{address = {:?}}}", address)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WakeByAddressAll(address);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WakeByAddressSingle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WakeByAddressSingle",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let address = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{address = {:?}}}", address)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WakeByAddressSingle(address);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WakeConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WakeConditionVariable",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let condition_variable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{condition_variable = {:?}}}",
                            condition_variable
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WakeConditionVariable(condition_variable);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WinExec(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "WinExec");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let lp_cmd_line = call.get_arg();
            let u_cmd_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_cmd_line = {:?}, u_cmd_show = {:?}}}",
                            lp_cmd_line, u_cmd_show
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WinExec(lp_cmd_line, u_cmd_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_Wow64SetThreadDefaultGuestMachine(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "Wow64SetThreadDefaultGuestMachine",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let machine = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{machine = {:?}}}", machine)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.Wow64SetThreadDefaultGuestMachine(machine);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_Wow64SuspendThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "Wow64SuspendThread",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::Threading::get_api(win32);
            let h_thread = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_thread = {:?}}}", h_thread)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.Wow64SuspendThread(h_thread);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddDelBackupEntryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddDelBackupEntryA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpcsz_file_list = call.get_arg();
            let lpcsz_backup_dir = call.get_arg();
            let lpcsz_base_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpcsz_file_list = {:?}, lpcsz_backup_dir = {:?}, lpcsz_base_name = {:?}, dw_flags = {:?}}}" , lpcsz_file_list , lpcsz_backup_dir , lpcsz_base_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AddDelBackupEntryA(
                lpcsz_file_list,
                lpcsz_backup_dir,
                lpcsz_base_name,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AddDelBackupEntryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AddDelBackupEntryW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpcsz_file_list = call.get_arg();
            let lpcsz_backup_dir = call.get_arg();
            let lpcsz_base_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpcsz_file_list = {:?}, lpcsz_backup_dir = {:?}, lpcsz_base_name = {:?}, dw_flags = {:?}}}" , lpcsz_file_list , lpcsz_backup_dir , lpcsz_base_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AddDelBackupEntryW(
                lpcsz_file_list,
                lpcsz_backup_dir,
                lpcsz_base_name,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AdvInstallFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AdvInstallFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let lpsz_source_dir = call.get_arg();
            let lpsz_source_file = call.get_arg();
            let lpsz_dest_dir = call.get_arg();
            let lpsz_dest_file = call.get_arg();
            let dw_flags = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, lpsz_source_dir = {:?}, lpsz_source_file = {:?}, lpsz_dest_dir = {:?}, lpsz_dest_file = {:?}, dw_flags = {:?}, dw_reserved = {:?}}}" , hwnd , lpsz_source_dir , lpsz_source_file , lpsz_dest_dir , lpsz_dest_file , dw_flags , dw_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AdvInstallFileA(
                hwnd,
                lpsz_source_dir,
                lpsz_source_file,
                lpsz_dest_dir,
                lpsz_dest_file,
                dw_flags,
                dw_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AdvInstallFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AdvInstallFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let lpsz_source_dir = call.get_arg();
            let lpsz_source_file = call.get_arg();
            let lpsz_dest_dir = call.get_arg();
            let lpsz_dest_file = call.get_arg();
            let dw_flags = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, lpsz_source_dir = {:?}, lpsz_source_file = {:?}, lpsz_dest_dir = {:?}, lpsz_dest_file = {:?}, dw_flags = {:?}, dw_reserved = {:?}}}" , hwnd , lpsz_source_dir , lpsz_source_file , lpsz_dest_dir , lpsz_dest_file , dw_flags , dw_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AdvInstallFileW(
                hwnd,
                lpsz_source_dir,
                lpsz_source_file,
                lpsz_dest_dir,
                lpsz_dest_file,
                dw_flags,
                dw_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ApphelpCheckShellObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ApphelpCheckShellObject",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let object_clsid = call.get_arg();
            let b_shim_if_necessary = call.get_arg();
            let pull_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{object_clsid = {:?}, b_shim_if_necessary = {:?}, pull_flags = {:?}}}" , object_clsid , b_shim_if_necessary , pull_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ApphelpCheckShellObject(object_clsid, b_shim_if_necessary, pull_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelDeviceWakeupRequest(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CancelDeviceWakeupRequest",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_device = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_device = {:?}}}", h_device)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CancelDeviceWakeupRequest(h_device);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CancelTimerQueueTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let timer_queue = call.get_arg();
            let timer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{timer_queue = {:?}, timer = {:?}}}",
                            timer_queue, timer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CancelTimerQueueTimer(timer_queue, timer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseINFEngine(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CloseINFEngine",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_inf = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_inf = {:?}}}", h_inf)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CloseINFEngine(h_inf);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ConvertAuxiliaryCounterToPerformanceCounter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ConvertAuxiliaryCounterToPerformanceCounter",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let ull_auxiliary_counter_value = call.get_arg();
            let lp_performance_counter_value = call.get_arg();
            let lp_conversion_error = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ull_auxiliary_counter_value = {:?}, lp_performance_counter_value = {:?}, lp_conversion_error = {:?}}}" , ull_auxiliary_counter_value , lp_performance_counter_value , lp_conversion_error ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ConvertAuxiliaryCounterToPerformanceCounter(
                ull_auxiliary_counter_value,
                lp_performance_counter_value,
                lp_conversion_error,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ConvertPerformanceCounterToAuxiliaryCounter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ConvertPerformanceCounterToAuxiliaryCounter",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let ull_performance_counter_value = call.get_arg();
            let lp_auxiliary_counter_value = call.get_arg();
            let lp_conversion_error = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ull_performance_counter_value = {:?}, lp_auxiliary_counter_value = {:?}, lp_conversion_error = {:?}}}" , ull_performance_counter_value , lp_auxiliary_counter_value , lp_conversion_error ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ConvertPerformanceCounterToAuxiliaryCounter(
                ull_performance_counter_value,
                lp_auxiliary_counter_value,
                lp_conversion_error,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DelNodeA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DelNodeA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_file_or_dir_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{psz_file_or_dir_name = {:?}, dw_flags = {:?}}}",
                            psz_file_or_dir_name, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DelNodeA(psz_file_or_dir_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DelNodeRunDLL32W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DelNodeRunDLL32W",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let h_instance = call.get_arg();
            let psz_parms = call.get_arg();
            let n_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}" , hwnd , h_instance , psz_parms , n_show ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DelNodeRunDLL32W(hwnd, h_instance, psz_parms, n_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DelNodeW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DelNodeW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_file_or_dir_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{psz_file_or_dir_name = {:?}, dw_flags = {:?}}}",
                            psz_file_or_dir_name, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DelNodeW(psz_file_or_dir_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DnsHostnameToComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DnsHostnameToComputerNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hostname = call.get_arg();
            let computer_name = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hostname = {:?}, computer_name = {:?}, n_size = {:?}}}",
                            hostname, computer_name, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DnsHostnameToComputerNameA(hostname, computer_name, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DnsHostnameToComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DnsHostnameToComputerNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hostname = call.get_arg();
            let computer_name = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hostname = {:?}, computer_name = {:?}, n_size = {:?}}}",
                            hostname, computer_name, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DnsHostnameToComputerNameW(hostname, computer_name, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DosDateTimeToFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DosDateTimeToFileTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let w_fat_date = call.get_arg();
            let w_fat_time = call.get_arg();
            let lp_file_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{w_fat_date = {:?}, w_fat_time = {:?}, lp_file_time = {:?}}}" , w_fat_date , w_fat_time , lp_file_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DosDateTimeToFileTime(w_fat_date, w_fat_time, lp_file_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnableProcessOptionalXStateFeatures(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnableProcessOptionalXStateFeatures",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let features = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{features = {:?}}}", features)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnableProcessOptionalXStateFeatures(features);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExecuteCabA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ExecuteCabA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let p_cab = call.get_arg();
            let p_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, p_cab = {:?}, p_reserved = {:?}}}",
                            hwnd, p_cab, p_reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ExecuteCabA(hwnd, p_cab, p_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExecuteCabW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ExecuteCabW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let p_cab = call.get_arg();
            let p_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, p_cab = {:?}, p_reserved = {:?}}}",
                            hwnd, p_cab, p_reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ExecuteCabW(hwnd, p_cab, p_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExtractFilesA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExtractFilesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_cab_name = call.get_arg();
            let psz_expand_dir = call.get_arg();
            let dw_flags = call.get_arg();
            let psz_file_list = call.get_arg();
            let lp_reserved = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psz_cab_name = {:?}, psz_expand_dir = {:?}, dw_flags = {:?}, psz_file_list = {:?}, lp_reserved = {:?}, dw_reserved = {:?}}}" , psz_cab_name , psz_expand_dir , dw_flags , psz_file_list , lp_reserved , dw_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ExtractFilesA(
                psz_cab_name,
                psz_expand_dir,
                dw_flags,
                psz_file_list,
                lp_reserved,
                dw_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ExtractFilesW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ExtractFilesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_cab_name = call.get_arg();
            let psz_expand_dir = call.get_arg();
            let dw_flags = call.get_arg();
            let psz_file_list = call.get_arg();
            let lp_reserved = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psz_cab_name = {:?}, psz_expand_dir = {:?}, dw_flags = {:?}, psz_file_list = {:?}, lp_reserved = {:?}, dw_reserved = {:?}}}" , psz_cab_name , psz_expand_dir , dw_flags , psz_file_list , lp_reserved , dw_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ExtractFilesW(
                psz_cab_name,
                psz_expand_dir,
                dw_flags,
                psz_file_list,
                lp_reserved,
                dw_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileSaveMarkNotExistA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileSaveMarkNotExistA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_file_list = call.get_arg();
            let lp_dir = call.get_arg();
            let lp_base_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_list = {:?}, lp_dir = {:?}, lp_base_name = {:?}}}" , lp_file_list , lp_dir , lp_base_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FileSaveMarkNotExistA(lp_file_list, lp_dir, lp_base_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileSaveMarkNotExistW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileSaveMarkNotExistW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_file_list = call.get_arg();
            let lp_dir = call.get_arg();
            let lp_base_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_list = {:?}, lp_dir = {:?}, lp_base_name = {:?}}}" , lp_file_list , lp_dir , lp_base_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FileSaveMarkNotExistW(lp_file_list, lp_dir, lp_base_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreOnINFA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileSaveRestoreOnINFA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_wnd = call.get_arg();
            let psz_title = call.get_arg();
            let psz_inf = call.get_arg();
            let psz_section = call.get_arg();
            let psz_backup_dir = call.get_arg();
            let psz_base_backup_file = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, psz_title = {:?}, psz_inf = {:?}, psz_section = {:?}, psz_backup_dir = {:?}, psz_base_backup_file = {:?}, dw_flags = {:?}}}" , h_wnd , psz_title , psz_inf , psz_section , psz_backup_dir , psz_base_backup_file , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FileSaveRestoreOnINFA(
                h_wnd,
                psz_title,
                psz_inf,
                psz_section,
                psz_backup_dir,
                psz_base_backup_file,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreOnINFW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileSaveRestoreOnINFW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_wnd = call.get_arg();
            let psz_title = call.get_arg();
            let psz_inf = call.get_arg();
            let psz_section = call.get_arg();
            let psz_backup_dir = call.get_arg();
            let psz_base_backup_file = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, psz_title = {:?}, psz_inf = {:?}, psz_section = {:?}, psz_backup_dir = {:?}, psz_base_backup_file = {:?}, dw_flags = {:?}}}" , h_wnd , psz_title , psz_inf , psz_section , psz_backup_dir , psz_base_backup_file , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FileSaveRestoreOnINFW(
                h_wnd,
                psz_title,
                psz_inf,
                psz_section,
                psz_backup_dir,
                psz_base_backup_file,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileSaveRestoreW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_dlg = call.get_arg();
            let lp_file_list = call.get_arg();
            let lp_dir = call.get_arg();
            let lp_base_name = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, lp_file_list = {:?}, lp_dir = {:?}, lp_base_name = {:?}, dw_flags = {:?}}}" , h_dlg , lp_file_list , lp_dir , lp_base_name , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FileSaveRestoreW(h_dlg, lp_file_list, lp_dir, lp_base_name, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FileTimeToDosDateTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FileTimeToDosDateTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_file_time = call.get_arg();
            let lp_fat_date = call.get_arg();
            let lp_fat_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_file_time = {:?}, lp_fat_date = {:?}, lp_fat_time = {:?}}}" , lp_file_time , lp_fat_date , lp_fat_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FileTimeToDosDateTime(lp_file_time, lp_fat_date, lp_fat_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GdiEntry13(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GdiEntry13");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GdiEntry13();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetComputerNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, n_size = {:?}}}",
                            lp_buffer, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetComputerNameA(lp_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetComputerNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, n_size = {:?}}}",
                            lp_buffer, n_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetComputerNameW(lp_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentHwProfileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentHwProfileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_hw_profile_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_hw_profile_info = {:?}}}",
                            lp_hw_profile_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentHwProfileA(lp_hw_profile_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCurrentHwProfileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCurrentHwProfileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_hw_profile_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_hw_profile_info = {:?}}}",
                            lp_hw_profile_info
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCurrentHwProfileW(lp_hw_profile_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFeatureEnabledState(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFeatureEnabledState",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let feature_id = call.get_arg();
            let change_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{feature_id = {:?}, change_time = {:?}}}",
                            feature_id, change_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetFeatureEnabledState(feature_id, change_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFeatureVariant(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFeatureVariant",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let feature_id = call.get_arg();
            let change_time = call.get_arg();
            let payload_id = call.get_arg();
            let has_notification = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{feature_id = {:?}, change_time = {:?}, payload_id = {:?}, has_notification = {:?}}}" , feature_id , change_time , payload_id , has_notification ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFeatureVariant(feature_id, change_time, payload_id, has_notification);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFirmwareEnvironmentVariableA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}}}" , lp_name , lp_guid , p_buffer , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFirmwareEnvironmentVariableA(lp_name, lp_guid, p_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFirmwareEnvironmentVariableExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_buffer = call.get_arg();
            let n_size = call.get_arg();
            let pdw_attribubutes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}, pdw_attribubutes = {:?}}}" , lp_name , lp_guid , p_buffer , n_size , pdw_attribubutes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFirmwareEnvironmentVariableExA(
                lp_name,
                lp_guid,
                p_buffer,
                n_size,
                pdw_attribubutes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFirmwareEnvironmentVariableExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_buffer = call.get_arg();
            let n_size = call.get_arg();
            let pdw_attribubutes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}, pdw_attribubutes = {:?}}}" , lp_name , lp_guid , p_buffer , n_size , pdw_attribubutes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFirmwareEnvironmentVariableExW(
                lp_name,
                lp_guid,
                p_buffer,
                n_size,
                pdw_attribubutes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetFirmwareEnvironmentVariableW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_buffer = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}}}" , lp_name , lp_guid , p_buffer , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetFirmwareEnvironmentVariableW(lp_name, lp_guid, p_buffer, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileIntA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileIntA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let n_default = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , n_default , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileIntA(lp_app_name, lp_key_name, n_default, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileIntW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileIntW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let n_default = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , n_default , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileIntW(lp_app_name, lp_key_name, n_default, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileSectionA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_returned_string , n_size , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileSectionA(
                lp_app_name,
                lp_returned_string,
                n_size,
                lp_file_name,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionNamesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileSectionNamesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_return_buffer = call.get_arg();
            let n_size = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_return_buffer = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lpsz_return_buffer , n_size , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileSectionNamesA(lpsz_return_buffer, n_size, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionNamesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileSectionNamesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_return_buffer = call.get_arg();
            let n_size = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_return_buffer = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lpsz_return_buffer , n_size , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileSectionNamesW(lpsz_return_buffer, n_size, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileSectionW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_returned_string , n_size , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileSectionW(
                lp_app_name,
                lp_returned_string,
                n_size,
                lp_file_name,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_default = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileStringA(
                lp_app_name,
                lp_key_name,
                lp_default,
                lp_returned_string,
                n_size,
                lp_file_name,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_default = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileStringW(
                lp_app_name,
                lp_key_name,
                lp_default,
                lp_returned_string,
                n_size,
                lp_file_name,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStructA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileStructA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_section = call.get_arg();
            let lpsz_key = call.get_arg();
            let lp_struct = call.get_arg();
            let u_size_struct = call.get_arg();
            let sz_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileStructA(
                lpsz_section,
                lpsz_key,
                lp_struct,
                u_size_struct,
                sz_file,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStructW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPrivateProfileStructW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_section = call.get_arg();
            let lpsz_key = call.get_arg();
            let lp_struct = call.get_arg();
            let u_size_struct = call.get_arg();
            let sz_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetPrivateProfileStructW(
                lpsz_section,
                lpsz_key,
                lp_struct,
                u_size_struct,
                sz_file,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProfileIntA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProfileIntA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let n_default = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}}}" , lp_app_name , lp_key_name , n_default ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProfileIntA(lp_app_name, lp_key_name, n_default);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProfileIntW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProfileIntW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let n_default = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}}}" , lp_app_name , lp_key_name , n_default ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProfileIntW(lp_app_name, lp_key_name, n_default);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProfileSectionA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}}}" , lp_app_name , lp_returned_string , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProfileSectionA(lp_app_name, lp_returned_string, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProfileSectionW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}}}" , lp_app_name , lp_returned_string , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProfileSectionW(lp_app_name, lp_returned_string, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProfileStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_default = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProfileStringA(
                lp_app_name,
                lp_key_name,
                lp_default,
                lp_returned_string,
                n_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProfileStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_default = call.get_arg();
            let lp_returned_string = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetProfileStringW(
                lp_app_name,
                lp_key_name,
                lp_default,
                lp_returned_string,
                n_size,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemRegistryQuota(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemRegistryQuota",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let pdw_quota_allowed = call.get_arg();
            let pdw_quota_used = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pdw_quota_allowed = {:?}, pdw_quota_used = {:?}}}",
                            pdw_quota_allowed, pdw_quota_used
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemRegistryQuota(pdw_quota_allowed, pdw_quota_used);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetThreadEnabledXStateFeatures(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetThreadEnabledXStateFeatures",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetThreadEnabledXStateFeatures();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserNameA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_buffer = call.get_arg();
            let pcb_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, pcb_buffer = {:?}}}",
                            lp_buffer, pcb_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserNameA(lp_buffer, pcb_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetUserNameW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetUserNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_buffer = call.get_arg();
            let pcb_buffer = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_buffer = {:?}, pcb_buffer = {:?}}}",
                            lp_buffer, pcb_buffer
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetUserNameW(lp_buffer, pcb_buffer);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVersionFromFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_filename = call.get_arg();
            let pdw_ms_ver = call.get_arg();
            let pdw_ls_ver = call.get_arg();
            let b_version = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVersionFromFileA(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVersionFromFileExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_filename = call.get_arg();
            let pdw_ms_ver = call.get_arg();
            let pdw_ls_ver = call.get_arg();
            let b_version = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVersionFromFileExA(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVersionFromFileExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_filename = call.get_arg();
            let pdw_ms_ver = call.get_arg();
            let pdw_ls_ver = call.get_arg();
            let b_version = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVersionFromFileExW(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetVersionFromFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_filename = call.get_arg();
            let pdw_ms_ver = call.get_arg();
            let pdw_ls_ver = call.get_arg();
            let b_version = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetVersionFromFileW(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GlobalCompact",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let dw_min_free = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_min_free = {:?}}}", dw_min_free)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GlobalCompact(dw_min_free);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalFix(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalFix");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalFix(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalUnWire(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GlobalUnWire",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalUnWire(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalUnfix(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalUnfix");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalUnfix(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GlobalWire(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GlobalWire");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_mem = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_mem = {:?}}}", h_mem)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GlobalWire(h_mem);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IMPGetIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IMPGetIMEA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IMPGetIMEA(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IMPGetIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IMPGetIMEW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IMPGetIMEW(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IMPQueryIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IMPQueryIMEA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{param_0 = {:?}}}", param_0)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IMPQueryIMEA(param_0);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IMPQueryIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IMPQueryIMEW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{param_0 = {:?}}}", param_0)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IMPQueryIMEW(param_0);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IMPSetIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IMPSetIMEA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IMPSetIMEA(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IMPSetIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IMPSetIMEW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IMPSetIMEW(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsApiSetImplemented(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsApiSetImplemented",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let contract = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{contract = {:?}}}", contract)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsApiSetImplemented(contract);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsBadHugeReadPtr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsBadHugeReadPtr",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp = call.get_arg();
            let ucb = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp = {:?}, ucb = {:?}}}", lp, ucb)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsBadHugeReadPtr(lp, ucb);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsBadHugeWritePtr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsBadHugeWritePtr",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp = call.get_arg();
            let ucb = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp = {:?}, ucb = {:?}}}", lp, ucb)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsBadHugeWritePtr(lp, ucb);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsNTAdmin(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IsNTAdmin");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let dw_reserved = call.get_arg();
            let lpdw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_reserved = {:?}, lpdw_reserved = {:?}}}",
                            dw_reserved, lpdw_reserved
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsNTAdmin(dw_reserved, lpdw_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsNativeVhdBoot(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsNativeVhdBoot",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let native_vhd_boot = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{native_vhd_boot = {:?}}}", native_vhd_boot)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsNativeVhdBoot(native_vhd_boot);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsTokenUntrusted(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsTokenUntrusted",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let token_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{token_handle = {:?}}}", token_handle)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.IsTokenUntrusted(token_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LaunchINFSectionExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LaunchINFSectionExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let h_instance = call.get_arg();
            let psz_parms = call.get_arg();
            let n_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}" , hwnd , h_instance , psz_parms , n_show ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LaunchINFSectionExW(hwnd, h_instance, psz_parms, n_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LaunchINFSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LaunchINFSectionW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd_owner = call.get_arg();
            let h_instance = call.get_arg();
            let psz_params = call.get_arg();
            let n_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd_owner = {:?}, h_instance = {:?}, psz_params = {:?}, n_show = {:?}}}" , hwnd_owner , h_instance , psz_params , n_show ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LaunchINFSectionW(hwnd_owner, h_instance, psz_params, n_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LocalCompact",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let u_min_free = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{u_min_free = {:?}}}", u_min_free)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.LocalCompact(u_min_free);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LocalShrink(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LocalShrink");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_mem = call.get_arg();
            let cb_new_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_mem = {:?}, cb_new_size = {:?}}}",
                            h_mem, cb_new_size
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LocalShrink(h_mem, cb_new_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MulDiv(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MulDiv");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let n_number = call.get_arg();
            let n_numerator = call.get_arg();
            let n_denominator = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{n_number = {:?}, n_numerator = {:?}, n_denominator = {:?}}}" , n_number , n_numerator , n_denominator ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MulDiv(n_number, n_numerator, n_denominator);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NeedReboot(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "NeedReboot");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let dw_reboot_check = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_reboot_check = {:?}}}", dw_reboot_check)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.NeedReboot(dw_reboot_check);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NeedRebootInit(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NeedRebootInit",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NeedRebootInit();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "NtClose");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{handle = {:?}}}", handle)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NtClose(handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtDeviceIoControlFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtDeviceIoControlFile",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let file_handle = call.get_arg();
            let event = call.get_arg();
            let apc_routine = call.get_arg();
            let apc_context = call.get_arg();
            let io_status_block = call.get_arg();
            let io_control_code = call.get_arg();
            let input_buffer = call.get_arg();
            let input_buffer_length = call.get_arg();
            let output_buffer = call.get_arg();
            let output_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, event = {:?}, apc_routine = {:?}, apc_context = {:?}, io_status_block = {:?}, io_control_code = {:?}, input_buffer = {:?}, input_buffer_length = {:?}, output_buffer = {:?}, output_buffer_length = {:?}}}" , file_handle , event , apc_routine , apc_context , io_status_block , io_control_code , input_buffer , input_buffer_length , output_buffer , output_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtDeviceIoControlFile(
                file_handle,
                event,
                apc_routine,
                apc_context,
                io_status_block,
                io_control_code,
                input_buffer,
                input_buffer_length,
                output_buffer,
                output_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtNotifyChangeMultipleKeys(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtNotifyChangeMultipleKeys",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let master_key_handle = call.get_arg();
            let count = call.get_arg();
            let subordinate_objects = call.get_arg();
            let event = call.get_arg();
            let apc_routine = call.get_arg();
            let apc_context = call.get_arg();
            let io_status_block = call.get_arg();
            let completion_filter = call.get_arg();
            let watch_tree = call.get_arg();
            let buffer = call.get_arg();
            let buffer_size = call.get_arg();
            let asynchronous = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{master_key_handle = {:?}, count = {:?}, subordinate_objects = {:?}, event = {:?}, apc_routine = {:?}, apc_context = {:?}, io_status_block = {:?}, completion_filter = {:?}, watch_tree = {:?}, buffer = {:?}, buffer_size = {:?}, asynchronous = {:?}}}" , master_key_handle , count , subordinate_objects , event , apc_routine , apc_context , io_status_block , completion_filter , watch_tree , buffer , buffer_size , asynchronous ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtNotifyChangeMultipleKeys(
                master_key_handle,
                count,
                subordinate_objects,
                event,
                apc_routine,
                apc_context,
                io_status_block,
                completion_filter,
                watch_tree,
                buffer,
                buffer_size,
                asynchronous,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtOpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "NtOpenFile");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let file_handle = call.get_arg();
            let desired_access = call.get_arg();
            let object_attributes = call.get_arg();
            let io_status_block = call.get_arg();
            let share_access = call.get_arg();
            let open_options = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, desired_access = {:?}, object_attributes = {:?}, io_status_block = {:?}, share_access = {:?}, open_options = {:?}}}" , file_handle , desired_access , object_attributes , io_status_block , share_access , open_options ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtOpenFile(
                file_handle,
                desired_access,
                object_attributes,
                io_status_block,
                share_access,
                open_options,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtQueryMultipleValueKey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtQueryMultipleValueKey",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let key_handle = call.get_arg();
            let value_entries = call.get_arg();
            let entry_count = call.get_arg();
            let value_buffer = call.get_arg();
            let buffer_length = call.get_arg();
            let required_buffer_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{key_handle = {:?}, value_entries = {:?}, entry_count = {:?}, value_buffer = {:?}, buffer_length = {:?}, required_buffer_length = {:?}}}" , key_handle , value_entries , entry_count , value_buffer , buffer_length , required_buffer_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtQueryMultipleValueKey(
                key_handle,
                value_entries,
                entry_count,
                value_buffer,
                buffer_length,
                required_buffer_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtQueryObject(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtQueryObject",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let handle = call.get_arg();
            let object_information_class = call.get_arg();
            let object_information = call.get_arg();
            let object_information_length = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{handle = {:?}, object_information_class = {:?}, object_information = {:?}, object_information_length = {:?}, return_length = {:?}}}" , handle , object_information_class , object_information , object_information_length , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtQueryObject(
                handle,
                object_information_class,
                object_information,
                object_information_length,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtQuerySystemInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtQuerySystemInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let system_information_class = call.get_arg();
            let system_information = call.get_arg();
            let system_information_length = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{system_information_class = {:?}, system_information = {:?}, system_information_length = {:?}, return_length = {:?}}}" , system_information_class , system_information , system_information_length , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtQuerySystemInformation(
                system_information_class,
                system_information,
                system_information_length,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtQuerySystemTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtQuerySystemTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let system_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{system_time = {:?}}}", system_time)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.NtQuerySystemTime(system_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtQueryTimerResolution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtQueryTimerResolution",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let maximum_time = call.get_arg();
            let minimum_time = call.get_arg();
            let current_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{maximum_time = {:?}, minimum_time = {:?}, current_time = {:?}}}" , maximum_time , minimum_time , current_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtQueryTimerResolution(maximum_time, minimum_time, current_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtRenameKey(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "NtRenameKey");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let key_handle = call.get_arg();
            let new_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{key_handle = {:?}, new_name = {:?}}}",
                            key_handle, new_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NtRenameKey(key_handle, new_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtSetInformationKey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtSetInformationKey",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let key_handle = call.get_arg();
            let key_set_information_class = call.get_arg();
            let key_set_information = call.get_arg();
            let key_set_information_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{key_handle = {:?}, key_set_information_class = {:?}, key_set_information = {:?}, key_set_information_length = {:?}}}" , key_handle , key_set_information_class , key_set_information , key_set_information_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.NtSetInformationKey(
                key_handle,
                key_set_information_class,
                key_set_information,
                key_set_information_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_NtWaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "NtWaitForSingleObject",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let handle = call.get_arg();
            let alertable = call.get_arg();
            let timeout = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{handle = {:?}, alertable = {:?}, timeout = {:?}}}",
                            handle, alertable, timeout
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.NtWaitForSingleObject(handle, alertable, timeout);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenINFEngineA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenINFEngineA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_inf_filename = call.get_arg();
            let psz_install_section = call.get_arg();
            let dw_flags = call.get_arg();
            let ph_inf = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, dw_flags = {:?}, ph_inf = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , dw_flags , ph_inf , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenINFEngineA(
                psz_inf_filename,
                psz_install_section,
                dw_flags,
                ph_inf,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenINFEngineW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenINFEngineW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_inf_filename = call.get_arg();
            let psz_install_section = call.get_arg();
            let dw_flags = call.get_arg();
            let ph_inf = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, dw_flags = {:?}, ph_inf = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , dw_flags , ph_inf , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenINFEngineW(
                psz_inf_filename,
                psz_install_section,
                dw_flags,
                ph_inf,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenMutexA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenMutexA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenMutexA(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenSemaphoreA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenSemaphoreA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenSemaphoreA(dw_desired_access, b_inherit_handle, lp_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenWaitableTimerA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OpenWaitableTimerA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let dw_desired_access = call.get_arg();
            let b_inherit_handle = call.get_arg();
            let lp_timer_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_timer_name = {:?}}}" , dw_desired_access , b_inherit_handle , lp_timer_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OpenWaitableTimerA(dw_desired_access, b_inherit_handle, lp_timer_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryAuxiliaryCounterFrequency(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryAuxiliaryCounterFrequency",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_auxiliary_counter_frequency = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_auxiliary_counter_frequency = {:?}}}",
                            lp_auxiliary_counter_frequency
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryAuxiliaryCounterFrequency(lp_auxiliary_counter_frequency);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryIdleProcessorCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryIdleProcessorCycleTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let buffer_length = call.get_arg();
            let processor_idle_cycle_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{buffer_length = {:?}, processor_idle_cycle_time = {:?}}}",
                            buffer_length, processor_idle_cycle_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryIdleProcessorCycleTime(buffer_length, processor_idle_cycle_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryIdleProcessorCycleTimeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryIdleProcessorCycleTimeEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let group = call.get_arg();
            let buffer_length = call.get_arg();
            let processor_idle_cycle_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{group = {:?}, buffer_length = {:?}, processor_idle_cycle_time = {:?}}}" , group , buffer_length , processor_idle_cycle_time ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.QueryIdleProcessorCycleTimeEx(group, buffer_length, processor_idle_cycle_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryInterruptTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryInterruptTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_interrupt_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_interrupt_time = {:?}}}",
                            lp_interrupt_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryInterruptTime(lp_interrupt_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryInterruptTimePrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryInterruptTimePrecise",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_interrupt_time_precise = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_interrupt_time_precise = {:?}}}",
                            lp_interrupt_time_precise
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryInterruptTimePrecise(lp_interrupt_time_precise);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryProcessCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryProcessCycleTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let process_handle = call.get_arg();
            let cycle_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{process_handle = {:?}, cycle_time = {:?}}}",
                            process_handle, cycle_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryProcessCycleTime(process_handle, cycle_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryThreadCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryThreadCycleTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let thread_handle = call.get_arg();
            let cycle_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{thread_handle = {:?}, cycle_time = {:?}}}",
                            thread_handle, cycle_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryThreadCycleTime(thread_handle, cycle_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryUnbiasedInterruptTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryUnbiasedInterruptTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let unbiased_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{unbiased_time = {:?}}}", unbiased_time)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.QueryUnbiasedInterruptTime(unbiased_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_QueryUnbiasedInterruptTimePrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "QueryUnbiasedInterruptTimePrecise",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_unbiased_interrupt_time_precise = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_unbiased_interrupt_time_precise = {:?}}}",
                            lp_unbiased_interrupt_time_precise
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.QueryUnbiasedInterruptTimePrecise(lp_unbiased_interrupt_time_precise);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RaiseCustomSystemEventTrigger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RaiseCustomSystemEventTrigger",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let custom_system_event_trigger_config = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{custom_system_event_trigger_config = {:?}}}",
                            custom_system_event_trigger_config
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RaiseCustomSystemEventTrigger(custom_system_event_trigger_config);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RebootCheckOnInstallA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RebootCheckOnInstallA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let psz_inf = call.get_arg();
            let psz_sec = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, psz_inf = {:?}, psz_sec = {:?}, dw_reserved = {:?}}}" , hwnd , psz_inf , psz_sec , dw_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RebootCheckOnInstallA(hwnd, psz_inf, psz_sec, dw_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RebootCheckOnInstallW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RebootCheckOnInstallW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let psz_inf = call.get_arg();
            let psz_sec = call.get_arg();
            let dw_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, psz_inf = {:?}, psz_sec = {:?}, dw_reserved = {:?}}}" , hwnd , psz_inf , psz_sec , dw_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RebootCheckOnInstallW(hwnd, psz_inf, psz_sec, dw_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RecordFeatureError(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RecordFeatureError",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let feature_id = call.get_arg();
            let error = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{feature_id = {:?}, error = {:?}}}",
                            feature_id, error
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RecordFeatureError(feature_id, error);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RecordFeatureUsage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RecordFeatureUsage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let feature_id = call.get_arg();
            let kind = call.get_arg();
            let addend = call.get_arg();
            let origin_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{feature_id = {:?}, kind = {:?}, addend = {:?}, origin_name = {:?}}}" , feature_id , kind , addend , origin_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RecordFeatureUsage(feature_id, kind, addend, origin_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RegInstallA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RegInstallA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hmod = call.get_arg();
            let psz_section = call.get_arg();
            let pst_table = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hmod = {:?}, psz_section = {:?}, pst_table = {:?}}}",
                            hmod, psz_section, pst_table
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RegInstallA(hmod, psz_section, pst_table);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RegInstallW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RegInstallW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hmod = call.get_arg();
            let psz_section = call.get_arg();
            let pst_table = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hmod = {:?}, psz_section = {:?}, pst_table = {:?}}}",
                            hmod, psz_section, pst_table
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RegInstallW(hmod, psz_section, pst_table);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReplacePartitionUnit(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReplacePartitionUnit",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let target_partition = call.get_arg();
            let spare_partition = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{target_partition = {:?}, spare_partition = {:?}, flags = {:?}}}" , target_partition , spare_partition , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ReplacePartitionUnit(target_partition, spare_partition, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RequestDeviceWakeup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RequestDeviceWakeup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_device = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_device = {:?}}}", h_device)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RequestDeviceWakeup(h_device);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlAnsiStringToUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlAnsiStringToUnicodeString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            let allocate_destination_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{destination_string = {:?}, source_string = {:?}, allocate_destination_string = {:?}}}" , destination_string , source_string , allocate_destination_string ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlAnsiStringToUnicodeString(
                destination_string,
                source_string,
                allocate_destination_string,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlCharToInteger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlCharToInteger",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let string = call.get_arg();
            let base = call.get_arg();
            let value = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{string = {:?}, base = {:?}, value = {:?}}}",
                            string, base, value
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlCharToInteger(string, base, value);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlFreeAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlFreeAnsiString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let ansi_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{ansi_string = {:?}}}", ansi_string)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RtlFreeAnsiString(ansi_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlFreeOemString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlFreeOemString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let oem_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{oem_string = {:?}}}", oem_string)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RtlFreeOemString(oem_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlFreeUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlFreeUnicodeString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let unicode_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{unicode_string = {:?}}}", unicode_string)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RtlFreeUnicodeString(unicode_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlGetReturnAddressHijackTarget(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlGetReturnAddressHijackTarget",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlGetReturnAddressHijackTarget();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInitAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInitAnsiString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{destination_string = {:?}, source_string = {:?}}}",
                            destination_string, source_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInitAnsiString(destination_string, source_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInitAnsiStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInitAnsiStringEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{destination_string = {:?}, source_string = {:?}}}",
                            destination_string, source_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInitAnsiStringEx(destination_string, source_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInitString(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInitString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{destination_string = {:?}, source_string = {:?}}}",
                            destination_string, source_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInitString(destination_string, source_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInitStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInitStringEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{destination_string = {:?}, source_string = {:?}}}",
                            destination_string, source_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInitStringEx(destination_string, source_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlInitUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlInitUnicodeString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{destination_string = {:?}, source_string = {:?}}}",
                            destination_string, source_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlInitUnicodeString(destination_string, source_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlIsNameLegalDOS8Dot3(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlIsNameLegalDOS8Dot3",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let name = call.get_arg();
            let oem_name = call.get_arg();
            let name_contains_spaces = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{name = {:?}, oem_name = {:?}, name_contains_spaces = {:?}}}" , name , oem_name , name_contains_spaces ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlIsNameLegalDOS8Dot3(name, oem_name, name_contains_spaces);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlLocalTimeToSystemTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlLocalTimeToSystemTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let local_time = call.get_arg();
            let system_time = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{local_time = {:?}, system_time = {:?}}}",
                            local_time, system_time
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlLocalTimeToSystemTime(local_time, system_time);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlRaiseCustomSystemEventTrigger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlRaiseCustomSystemEventTrigger",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let trigger_config = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{trigger_config = {:?}}}", trigger_config)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.RtlRaiseCustomSystemEventTrigger(trigger_config);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlTimeToSecondsSince1970(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlTimeToSecondsSince1970",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let time = call.get_arg();
            let elapsed_seconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{time = {:?}, elapsed_seconds = {:?}}}",
                            time, elapsed_seconds
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlTimeToSecondsSince1970(time, elapsed_seconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeStringToAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlUnicodeStringToAnsiString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            let allocate_destination_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{destination_string = {:?}, source_string = {:?}, allocate_destination_string = {:?}}}" , destination_string , source_string , allocate_destination_string ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlUnicodeStringToAnsiString(
                destination_string,
                source_string,
                allocate_destination_string,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeStringToOemString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlUnicodeStringToOemString",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let destination_string = call.get_arg();
            let source_string = call.get_arg();
            let allocate_destination_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{destination_string = {:?}, source_string = {:?}, allocate_destination_string = {:?}}}" , destination_string , source_string , allocate_destination_string ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlUnicodeStringToOemString(
                destination_string,
                source_string,
                allocate_destination_string,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeToMultiByteSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RtlUnicodeToMultiByteSize",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let bytes_in_multi_byte_string = call.get_arg();
            let unicode_string = call.get_arg();
            let bytes_in_unicode_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{bytes_in_multi_byte_string = {:?}, unicode_string = {:?}, bytes_in_unicode_string = {:?}}}" , bytes_in_multi_byte_string , unicode_string , bytes_in_unicode_string ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RtlUnicodeToMultiByteSize(
                bytes_in_multi_byte_string,
                unicode_string,
                bytes_in_unicode_string,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RtlUniform(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RtlUniform");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let seed = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{seed = {:?}}}", seed)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RtlUniform(seed);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RunSetupCommandA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RunSetupCommandA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_wnd = call.get_arg();
            let sz_cmd_name = call.get_arg();
            let sz_inf_section = call.get_arg();
            let sz_dir = call.get_arg();
            let lpsz_title = call.get_arg();
            let ph_exe = call.get_arg();
            let dw_flags = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, sz_cmd_name = {:?}, sz_inf_section = {:?}, sz_dir = {:?}, lpsz_title = {:?}, ph_exe = {:?}, dw_flags = {:?}, pv_reserved = {:?}}}" , h_wnd , sz_cmd_name , sz_inf_section , sz_dir , lpsz_title , ph_exe , dw_flags , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RunSetupCommandA(
                h_wnd,
                sz_cmd_name,
                sz_inf_section,
                sz_dir,
                lpsz_title,
                ph_exe,
                dw_flags,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RunSetupCommandW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RunSetupCommandW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_wnd = call.get_arg();
            let sz_cmd_name = call.get_arg();
            let sz_inf_section = call.get_arg();
            let sz_dir = call.get_arg();
            let lpsz_title = call.get_arg();
            let ph_exe = call.get_arg();
            let dw_flags = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, sz_cmd_name = {:?}, sz_inf_section = {:?}, sz_dir = {:?}, lpsz_title = {:?}, ph_exe = {:?}, dw_flags = {:?}, pv_reserved = {:?}}}" , h_wnd , sz_cmd_name , sz_inf_section , sz_dir , lpsz_title , ph_exe , dw_flags , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RunSetupCommandW(
                h_wnd,
                sz_cmd_name,
                sz_inf_section,
                sz_dir,
                lpsz_title,
                ph_exe,
                dw_flags,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendIMEMessageExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendIMEMessageExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SendIMEMessageExA(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendIMEMessageExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendIMEMessageExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SendIMEMessageExW(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetEnvironmentStringsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let new_environment = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{new_environment = {:?}}}", new_environment)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetEnvironmentStringsA(new_environment);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFirmwareEnvironmentVariableA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_value = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}}}" , lp_name , lp_guid , p_value , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFirmwareEnvironmentVariableA(lp_name, lp_guid, p_value, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFirmwareEnvironmentVariableExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_value = call.get_arg();
            let n_size = call.get_arg();
            let dw_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}, dw_attributes = {:?}}}" , lp_name , lp_guid , p_value , n_size , dw_attributes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFirmwareEnvironmentVariableExA(
                lp_name,
                lp_guid,
                p_value,
                n_size,
                dw_attributes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFirmwareEnvironmentVariableExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_value = call.get_arg();
            let n_size = call.get_arg();
            let dw_attributes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}, dw_attributes = {:?}}}" , lp_name , lp_guid , p_value , n_size , dw_attributes ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFirmwareEnvironmentVariableExW(
                lp_name,
                lp_guid,
                p_value,
                n_size,
                dw_attributes,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetFirmwareEnvironmentVariableW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_name = call.get_arg();
            let lp_guid = call.get_arg();
            let p_value = call.get_arg();
            let n_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}}}" , lp_name , lp_guid , p_value , n_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetFirmwareEnvironmentVariableW(lp_name, lp_guid, p_value, n_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetHandleCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetHandleCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let u_number = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{u_number = {:?}}}", u_number)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetHandleCount(u_number);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetMessageWaitingIndicator(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetMessageWaitingIndicator",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_msg_indicator = call.get_arg();
            let ul_msg_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_msg_indicator = {:?}, ul_msg_count = {:?}}}",
                            h_msg_indicator, ul_msg_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetMessageWaitingIndicator(h_msg_indicator, ul_msg_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetPerUserSecValuesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetPerUserSecValuesA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let p_per_user = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{p_per_user = {:?}}}", p_per_user)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetPerUserSecValuesA(p_per_user);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetPerUserSecValuesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetPerUserSecValuesW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let p_per_user = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{p_per_user = {:?}}}", p_per_user)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetPerUserSecValuesW(p_per_user);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SignalObjectAndWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SignalObjectAndWait",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_object_to_signal = call.get_arg();
            let h_object_to_wait_on = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let b_alertable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_object_to_signal = {:?}, h_object_to_wait_on = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}" , h_object_to_signal , h_object_to_wait_on , dw_milliseconds , b_alertable ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SignalObjectAndWait(
                h_object_to_signal,
                h_object_to_wait_on,
                dw_milliseconds,
                b_alertable,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SubscribeFeatureStateChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SubscribeFeatureStateChangeNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let subscription = call.get_arg();
            let callback = call.get_arg();
            let context = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{subscription = {:?}, callback = {:?}, context = {:?}}}",
                            subscription, callback, context
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SubscribeFeatureStateChangeNotification(subscription, callback, context);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateInfStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_inf_filename = call.get_arg();
            let psz_install_section = call.get_arg();
            let psz_translate_section = call.get_arg();
            let psz_translate_key = call.get_arg();
            let psz_buffer = call.get_arg();
            let cch_buffer = call.get_arg();
            let pdw_required_size = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, cch_buffer = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , psz_translate_section , psz_translate_key , psz_buffer , cch_buffer , pdw_required_size , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TranslateInfStringA(
                psz_inf_filename,
                psz_install_section,
                psz_translate_section,
                psz_translate_key,
                psz_buffer,
                cch_buffer,
                pdw_required_size,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateInfStringExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_inf = call.get_arg();
            let psz_inf_filename = call.get_arg();
            let psz_translate_section = call.get_arg();
            let psz_translate_key = call.get_arg();
            let psz_buffer = call.get_arg();
            let dw_buffer_size = call.get_arg();
            let pdw_required_size = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_inf = {:?}, psz_inf_filename = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, dw_buffer_size = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , h_inf , psz_inf_filename , psz_translate_section , psz_translate_key , psz_buffer , dw_buffer_size , pdw_required_size , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TranslateInfStringExA(
                h_inf,
                psz_inf_filename,
                psz_translate_section,
                psz_translate_key,
                psz_buffer,
                dw_buffer_size,
                pdw_required_size,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateInfStringExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_inf = call.get_arg();
            let psz_inf_filename = call.get_arg();
            let psz_translate_section = call.get_arg();
            let psz_translate_key = call.get_arg();
            let psz_buffer = call.get_arg();
            let dw_buffer_size = call.get_arg();
            let pdw_required_size = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_inf = {:?}, psz_inf_filename = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, dw_buffer_size = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , h_inf , psz_inf_filename , psz_translate_section , psz_translate_key , psz_buffer , dw_buffer_size , pdw_required_size , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TranslateInfStringExW(
                h_inf,
                psz_inf_filename,
                psz_translate_section,
                psz_translate_key,
                psz_buffer,
                dw_buffer_size,
                pdw_required_size,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateInfStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let psz_inf_filename = call.get_arg();
            let psz_install_section = call.get_arg();
            let psz_translate_section = call.get_arg();
            let psz_translate_key = call.get_arg();
            let psz_buffer = call.get_arg();
            let cch_buffer = call.get_arg();
            let pdw_required_size = call.get_arg();
            let pv_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, cch_buffer = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , psz_translate_section , psz_translate_key , psz_buffer , cch_buffer , pdw_required_size , pv_reserved ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TranslateInfStringW(
                psz_inf_filename,
                psz_install_section,
                psz_translate_section,
                psz_translate_key,
                psz_buffer,
                cch_buffer,
                pdw_required_size,
                pv_reserved,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnsubscribeFeatureStateChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnsubscribeFeatureStateChangeNotification",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let subscription = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{subscription = {:?}}}", subscription)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.UnsubscribeFeatureStateChangeNotification(subscription);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UserInstStubWrapperA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UserInstStubWrapperA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let h_instance = call.get_arg();
            let psz_parms = call.get_arg();
            let n_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}" , hwnd , h_instance , psz_parms , n_show ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UserInstStubWrapperA(hwnd, h_instance, psz_parms, n_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UserInstStubWrapperW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UserInstStubWrapperW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let h_instance = call.get_arg();
            let psz_parms = call.get_arg();
            let n_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}" , hwnd , h_instance , psz_parms , n_show ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UserInstStubWrapperW(hwnd, h_instance, psz_parms, n_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UserUnInstStubWrapperA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UserUnInstStubWrapperA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let h_instance = call.get_arg();
            let psz_parms = call.get_arg();
            let n_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}" , hwnd , h_instance , psz_parms , n_show ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UserUnInstStubWrapperA(hwnd, h_instance, psz_parms, n_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UserUnInstStubWrapperW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UserUnInstStubWrapperW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let hwnd = call.get_arg();
            let h_instance = call.get_arg();
            let psz_parms = call.get_arg();
            let n_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}" , hwnd , h_instance , psz_parms , n_show ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UserUnInstStubWrapperW(hwnd, h_instance, psz_parms, n_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WINNLSEnableIME(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WINNLSEnableIME",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WINNLSEnableIME(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WINNLSGetEnableStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WINNLSGetEnableStatus",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{param_0 = {:?}}}", param_0)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WINNLSGetEnableStatus(param_0);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WINNLSGetIMEHotkey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WINNLSGetIMEHotkey",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let param_0 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{param_0 = {:?}}}", param_0)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WINNLSGetIMEHotkey(param_0);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WldpGetLockdownPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WldpGetLockdownPolicy",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let host_information = call.get_arg();
            let lockdown_state = call.get_arg();
            let lockdown_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{host_information = {:?}, lockdown_state = {:?}, lockdown_flags = {:?}}}" , host_information , lockdown_state , lockdown_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WldpGetLockdownPolicy(host_information, lockdown_state, lockdown_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WldpIsClassInApprovedList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WldpIsClassInApprovedList",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let class_id = call.get_arg();
            let host_information = call.get_arg();
            let is_approved = call.get_arg();
            let optional_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{class_id = {:?}, host_information = {:?}, is_approved = {:?}, optional_flags = {:?}}}" , class_id , host_information , is_approved , optional_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WldpIsClassInApprovedList(
                class_id,
                host_information,
                is_approved,
                optional_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WldpIsDynamicCodePolicyEnabled(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WldpIsDynamicCodePolicyEnabled",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let is_enabled = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{is_enabled = {:?}}}", is_enabled)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.WldpIsDynamicCodePolicyEnabled(is_enabled);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WldpQueryDeviceSecurityInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WldpQueryDeviceSecurityInformation",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let information = call.get_arg();
            let information_length = call.get_arg();
            let return_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{information = {:?}, information_length = {:?}, return_length = {:?}}}" , information , information_length , return_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WldpQueryDeviceSecurityInformation(
                information,
                information_length,
                return_length,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WldpQueryDynamicCodeTrust(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WldpQueryDynamicCodeTrust",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let file_handle = call.get_arg();
            let base_image = call.get_arg();
            let image_size = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{file_handle = {:?}, base_image = {:?}, image_size = {:?}}}" , file_handle , base_image , image_size ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WldpQueryDynamicCodeTrust(file_handle, base_image, image_size);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WldpSetDynamicCodeTrust(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WldpSetDynamicCodeTrust",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let file_handle = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{file_handle = {:?}}}", file_handle)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.WldpSetDynamicCodeTrust(file_handle);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WritePrivateProfileSectionA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_string = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_string , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WritePrivateProfileSectionA(lp_app_name, lp_string, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WritePrivateProfileSectionW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_string = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_string , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WritePrivateProfileSectionW(lp_app_name, lp_string, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WritePrivateProfileStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_string = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_string , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.WritePrivateProfileStringA(lp_app_name, lp_key_name, lp_string, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WritePrivateProfileStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_string = call.get_arg();
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_string , lp_file_name ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.WritePrivateProfileStringW(lp_app_name, lp_key_name, lp_string, lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStructA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WritePrivateProfileStructA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_section = call.get_arg();
            let lpsz_key = call.get_arg();
            let lp_struct = call.get_arg();
            let u_size_struct = call.get_arg();
            let sz_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WritePrivateProfileStructA(
                lpsz_section,
                lpsz_key,
                lp_struct,
                u_size_struct,
                sz_file,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStructW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WritePrivateProfileStructW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lpsz_section = call.get_arg();
            let lpsz_key = call.get_arg();
            let lp_struct = call.get_arg();
            let u_size_struct = call.get_arg();
            let sz_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WritePrivateProfileStructW(
                lpsz_section,
                lpsz_key,
                lp_struct,
                u_size_struct,
                sz_file,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteProfileSectionA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_app_name = {:?}, lp_string = {:?}}}",
                            lp_app_name, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WriteProfileSectionA(lp_app_name, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteProfileSectionW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_app_name = {:?}, lp_string = {:?}}}",
                            lp_app_name, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WriteProfileSectionW(lp_app_name, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteProfileStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}}}" , lp_app_name , lp_key_name , lp_string ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteProfileStringA(lp_app_name, lp_key_name, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WriteProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WriteProfileStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_app_name = call.get_arg();
            let lp_key_name = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}}}" , lp_app_name , lp_key_name , lp_string ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.WriteProfileStringW(lp_app_name, lp_key_name, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__hread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_hread");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let l_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_buffer = {:?}, l_bytes = {:?}}}",
                            h_file, lp_buffer, l_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._hread(h_file, lp_buffer, l_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__hwrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_hwrite");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let l_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_buffer = {:?}, l_bytes = {:?}}}",
                            h_file, lp_buffer, l_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._hwrite(h_file, lp_buffer, l_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__lclose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_lclose");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_file = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_file = {:?}}}", h_file)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._lclose(h_file);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__lcreat(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_lcreat");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_path_name = call.get_arg();
            let i_attribute = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_path_name = {:?}, i_attribute = {:?}}}",
                            lp_path_name, i_attribute
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._lcreat(lp_path_name, i_attribute);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__llseek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_llseek");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_file = call.get_arg();
            let l_offset = call.get_arg();
            let i_origin = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, l_offset = {:?}, i_origin = {:?}}}",
                            h_file, l_offset, i_origin
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._llseek(h_file, l_offset, i_origin);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__lopen(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_lopen");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let lp_path_name = call.get_arg();
            let i_read_write = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_path_name = {:?}, i_read_write = {:?}}}",
                            lp_path_name, i_read_write
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._lopen(lp_path_name, i_read_write);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__lread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_lread");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let u_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_buffer = {:?}, u_bytes = {:?}}}",
                            h_file, lp_buffer, u_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._lread(h_file, lp_buffer, u_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk__lwrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "_lwrite");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::System::WindowsProgramming::get_api(win32);
            let h_file = call.get_arg();
            let lp_buffer = call.get_arg();
            let u_bytes = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_file = {:?}, lp_buffer = {:?}, u_bytes = {:?}}}",
                            h_file, lp_buffer, u_bytes
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api._lwrite(h_file, lp_buffer, u_bytes);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AdjustWindowRect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AdjustWindowRect",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_rect = call.get_arg();
            let dw_style = call.get_arg();
            let b_menu = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_rect = {:?}, dw_style = {:?}, b_menu = {:?}}}",
                            lp_rect, dw_style, b_menu
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AdjustWindowRect(lp_rect, dw_style, b_menu);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AdjustWindowRectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AdjustWindowRectEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_rect = call.get_arg();
            let dw_style = call.get_arg();
            let b_menu = call.get_arg();
            let dw_ex_style = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_rect = {:?}, dw_style = {:?}, b_menu = {:?}, dw_ex_style = {:?}}}" , lp_rect , dw_style , b_menu , dw_ex_style ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AdjustWindowRectEx(lp_rect, dw_style, b_menu, dw_ex_style);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AllowSetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AllowSetForegroundWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let dw_process_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{dw_process_id = {:?}}}", dw_process_id)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.AllowSetForegroundWindow(dw_process_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AnimateWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "AnimateWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let dw_time = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, dw_time = {:?}, dw_flags = {:?}}}",
                            h_wnd, dw_time, dw_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AnimateWindow(h_wnd, dw_time, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AnyPopup(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "AnyPopup");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.AnyPopup();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AppendMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "AppendMenuA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_flags = call.get_arg();
            let u_id_new_item = call.get_arg();
            let lp_new_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_menu , u_flags , u_id_new_item , lp_new_item ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AppendMenuA(h_menu, u_flags, u_id_new_item, lp_new_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_AppendMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "AppendMenuW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_flags = call.get_arg();
            let u_id_new_item = call.get_arg();
            let lp_new_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_menu , u_flags , u_id_new_item , lp_new_item ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.AppendMenuW(h_menu, u_flags, u_id_new_item, lp_new_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ArrangeIconicWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ArrangeIconicWindows",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ArrangeIconicWindows(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BeginDeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "BeginDeferWindowPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_num_windows = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{n_num_windows = {:?}}}", n_num_windows)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.BeginDeferWindowPos(n_num_windows);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_BringWindowToTop(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "BringWindowToTop",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.BringWindowToTop(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CalculatePopupWindowPosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CalculatePopupWindowPosition",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let anchor_point = call.get_arg();
            let window_size = call.get_arg();
            let flags = call.get_arg();
            let exclude_rect = call.get_arg();
            let popup_window_position = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{anchor_point = {:?}, window_size = {:?}, flags = {:?}, exclude_rect = {:?}, popup_window_position = {:?}}}" , anchor_point , window_size , flags , exclude_rect , popup_window_position ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CalculatePopupWindowPosition(
                anchor_point,
                window_size,
                flags,
                exclude_rect,
                popup_window_position,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CallMsgFilterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CallMsgFilterA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            let n_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_msg = {:?}, n_code = {:?}}}",
                            lp_msg, n_code
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CallMsgFilterA(lp_msg, n_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CallMsgFilterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CallMsgFilterW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            let n_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_msg = {:?}, n_code = {:?}}}",
                            lp_msg, n_code
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CallMsgFilterW(lp_msg, n_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CallNextHookEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CallNextHookEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hhk = call.get_arg();
            let n_code = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hhk = {:?}, n_code = {:?}, w_param = {:?}, l_param = {:?}}}" , hhk , n_code , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CallNextHookEx(hhk, n_code, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CallWindowProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CallWindowProcA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_prev_wnd_func = call.get_arg();
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_prev_wnd_func = {:?}, h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , lp_prev_wnd_func , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CallWindowProcA(lp_prev_wnd_func, h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CallWindowProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CallWindowProcW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_prev_wnd_func = call.get_arg();
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_prev_wnd_func = {:?}, h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , lp_prev_wnd_func , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CallWindowProcW(lp_prev_wnd_func, h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CancelShutdown(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CancelShutdown",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CancelShutdown();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CascadeWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CascadeWindows",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd_parent = call.get_arg();
            let w_how = call.get_arg();
            let lp_rect = call.get_arg();
            let c_kids = call.get_arg();
            let lp_kids = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd_parent = {:?}, w_how = {:?}, lp_rect = {:?}, c_kids = {:?}, lp_kids = {:?}}}" , hwnd_parent , w_how , lp_rect , c_kids , lp_kids ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CascadeWindows(hwnd_parent, w_how, lp_rect, c_kids, lp_kids);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ChangeMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ChangeMenuA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let cmd = call.get_arg();
            let lpsz_new_item = call.get_arg();
            let cmd_insert = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, cmd = {:?}, lpsz_new_item = {:?}, cmd_insert = {:?}, flags = {:?}}}" , h_menu , cmd , lpsz_new_item , cmd_insert , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ChangeMenuA(h_menu, cmd, lpsz_new_item, cmd_insert, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ChangeMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ChangeMenuW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let cmd = call.get_arg();
            let lpsz_new_item = call.get_arg();
            let cmd_insert = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, cmd = {:?}, lpsz_new_item = {:?}, cmd_insert = {:?}, flags = {:?}}}" , h_menu , cmd , lpsz_new_item , cmd_insert , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ChangeMenuW(h_menu, cmd, lpsz_new_item, cmd_insert, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ChangeWindowMessageFilter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ChangeWindowMessageFilter",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let message = call.get_arg();
            let dw_flag = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{message = {:?}, dw_flag = {:?}}}",
                            message, dw_flag
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ChangeWindowMessageFilter(message, dw_flag);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ChangeWindowMessageFilterEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ChangeWindowMessageFilterEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let message = call.get_arg();
            let action = call.get_arg();
            let p_change_filter_struct = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, message = {:?}, action = {:?}, p_change_filter_struct = {:?}}}" , hwnd , message , action , p_change_filter_struct ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.ChangeWindowMessageFilterEx(hwnd, message, action, p_change_filter_struct);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharLowerA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharLowerA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lpsz = {:?}}}", lpsz)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharLowerA(lpsz);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharLowerBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CharLowerBuffA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            let cch_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz = {:?}, cch_length = {:?}}}",
                            lpsz, cch_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharLowerBuffA(lpsz, cch_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharLowerBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CharLowerBuffW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            let cch_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz = {:?}, cch_length = {:?}}}",
                            lpsz, cch_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharLowerBuffW(lpsz, cch_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharLowerW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharLowerW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lpsz = {:?}}}", lpsz)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharLowerW(lpsz);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharNextA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharNextA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lpsz = {:?}}}", lpsz)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharNextA(lpsz);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharNextExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharNextExA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let code_page = call.get_arg();
            let lp_current_char = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{code_page = {:?}, lp_current_char = {:?}, dw_flags = {:?}}}" , code_page , lp_current_char , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CharNextExA(code_page, lp_current_char, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharNextW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharNextW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lpsz = {:?}}}", lpsz)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharNextW(lpsz);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharPrevA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharPrevA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz_start = call.get_arg();
            let lpsz_current = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_start = {:?}, lpsz_current = {:?}}}",
                            lpsz_start, lpsz_current
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharPrevA(lpsz_start, lpsz_current);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharPrevExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharPrevExA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let code_page = call.get_arg();
            let lp_start = call.get_arg();
            let lp_current_char = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{code_page = {:?}, lp_start = {:?}, lp_current_char = {:?}, dw_flags = {:?}}}" , code_page , lp_start , lp_current_char , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CharPrevExA(code_page, lp_start, lp_current_char, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharPrevW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharPrevW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz_start = call.get_arg();
            let lpsz_current = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz_start = {:?}, lpsz_current = {:?}}}",
                            lpsz_start, lpsz_current
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharPrevW(lpsz_start, lpsz_current);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharToOemA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharToOemA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let p_src = call.get_arg();
            let p_dst = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{p_src = {:?}, p_dst = {:?}}}",
                            p_src, p_dst
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharToOemA(p_src, p_dst);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharToOemBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CharToOemBuffA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz_src = call.get_arg();
            let lpsz_dst = call.get_arg();
            let cch_dst_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}" , lpsz_src , lpsz_dst , cch_dst_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CharToOemBuffA(lpsz_src, lpsz_dst, cch_dst_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharToOemBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CharToOemBuffW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz_src = call.get_arg();
            let lpsz_dst = call.get_arg();
            let cch_dst_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}" , lpsz_src , lpsz_dst , cch_dst_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CharToOemBuffW(lpsz_src, lpsz_dst, cch_dst_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharToOemW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharToOemW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let p_src = call.get_arg();
            let p_dst = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{p_src = {:?}, p_dst = {:?}}}",
                            p_src, p_dst
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharToOemW(p_src, p_dst);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharUpperA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharUpperA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lpsz = {:?}}}", lpsz)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharUpperA(lpsz);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharUpperBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CharUpperBuffA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            let cch_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz = {:?}, cch_length = {:?}}}",
                            lpsz, cch_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharUpperBuffA(lpsz, cch_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharUpperBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CharUpperBuffW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            let cch_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lpsz = {:?}, cch_length = {:?}}}",
                            lpsz, cch_length
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharUpperBuffW(lpsz, cch_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CharUpperW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CharUpperW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lpsz = {:?}}}", lpsz)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CharUpperW(lpsz);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CheckMenuItem(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CheckMenuItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_id_check_item = call.get_arg();
            let u_check = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, u_id_check_item = {:?}, u_check = {:?}}}",
                            h_menu, u_id_check_item, u_check
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CheckMenuItem(h_menu, u_id_check_item, u_check);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CheckMenuRadioItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CheckMenuRadioItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hmenu = call.get_arg();
            let first = call.get_arg();
            let last = call.get_arg();
            let check = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hmenu = {:?}, first = {:?}, last = {:?}, check = {:?}, flags = {:?}}}" , hmenu , first , last , check , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CheckMenuRadioItem(hmenu, first, last, check, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ChildWindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ChildWindowFromPoint",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd_parent = call.get_arg();
            let point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd_parent = {:?}, point = {:?}}}",
                            h_wnd_parent, point
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ChildWindowFromPoint(h_wnd_parent, point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ChildWindowFromPointEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ChildWindowFromPointEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let pt = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, pt = {:?}, flags = {:?}}}",
                            hwnd, pt, flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ChildWindowFromPointEx(hwnd, pt, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ClipCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ClipCursor");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_rect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_rect = {:?}}}", lp_rect)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ClipCursor(lp_rect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CloseWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CloseWindow");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CloseWindow(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyAcceleratorTableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CopyAcceleratorTableA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_accel_src = call.get_arg();
            let lp_accel_dst = call.get_arg();
            let c_accel_entries = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_accel_src = {:?}, lp_accel_dst = {:?}, c_accel_entries = {:?}}}" , h_accel_src , lp_accel_dst , c_accel_entries ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyAcceleratorTableA(h_accel_src, lp_accel_dst, c_accel_entries);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyAcceleratorTableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CopyAcceleratorTableW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_accel_src = call.get_arg();
            let lp_accel_dst = call.get_arg();
            let c_accel_entries = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_accel_src = {:?}, lp_accel_dst = {:?}, c_accel_entries = {:?}}}" , h_accel_src , lp_accel_dst , c_accel_entries ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyAcceleratorTableW(h_accel_src, lp_accel_dst, c_accel_entries);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyIcon");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_icon = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_icon = {:?}}}", h_icon)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CopyIcon(h_icon);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CopyImage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CopyImage");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h = call.get_arg();
            let r#type = call.get_arg();
            let cx = call.get_arg();
            let cy = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h = {:?}, r#type = {:?}, cx = {:?}, cy = {:?}, flags = {:?}}}" , h , r#type , cx , cy , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CopyImage(h, r#type, cx, cy, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateAcceleratorTableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateAcceleratorTableA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let paccel = call.get_arg();
            let c_accel = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{paccel = {:?}, c_accel = {:?}}}",
                            paccel, c_accel
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateAcceleratorTableA(paccel, c_accel);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateAcceleratorTableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateAcceleratorTableW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let paccel = call.get_arg();
            let c_accel = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{paccel = {:?}, c_accel = {:?}}}",
                            paccel, c_accel
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateAcceleratorTableW(paccel, c_accel);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateCursor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_inst = call.get_arg();
            let x_hot_spot = call.get_arg();
            let y_hot_spot = call.get_arg();
            let n_width = call.get_arg();
            let n_height = call.get_arg();
            let pv_and_plane = call.get_arg();
            let pv_xor_plane = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_inst = {:?}, x_hot_spot = {:?}, y_hot_spot = {:?}, n_width = {:?}, n_height = {:?}, pv_and_plane = {:?}, pv_xor_plane = {:?}}}" , h_inst , x_hot_spot , y_hot_spot , n_width , n_height , pv_and_plane , pv_xor_plane ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateCursor(
                h_inst,
                x_hot_spot,
                y_hot_spot,
                n_width,
                n_height,
                pv_and_plane,
                pv_xor_plane,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateDialogIndirectParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateDialogIndirectParamA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_template = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, lp_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateDialogIndirectParamA(
                h_instance,
                lp_template,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateDialogIndirectParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateDialogIndirectParamW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_template = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, lp_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateDialogIndirectParamW(
                h_instance,
                lp_template,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateDialogParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateDialogParamA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_template_name = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateDialogParamA(
                h_instance,
                lp_template_name,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateDialogParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateDialogParamW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_template_name = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateDialogParamW(
                h_instance,
                lp_template_name,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CreateIcon");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let n_width = call.get_arg();
            let n_height = call.get_arg();
            let c_planes = call.get_arg();
            let c_bits_pixel = call.get_arg();
            let lpb_an_dbits = call.get_arg();
            let lpb_xo_rbits = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, n_width = {:?}, n_height = {:?}, c_planes = {:?}, c_bits_pixel = {:?}, lpb_an_dbits = {:?}, lpb_xo_rbits = {:?}}}" , h_instance , n_width , n_height , c_planes , c_bits_pixel , lpb_an_dbits , lpb_xo_rbits ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateIcon(
                h_instance,
                n_width,
                n_height,
                c_planes,
                c_bits_pixel,
                lpb_an_dbits,
                lpb_xo_rbits,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateIconFromResource(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateIconFromResource",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let presbits = call.get_arg();
            let dw_res_size = call.get_arg();
            let f_icon = call.get_arg();
            let dw_ver = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{presbits = {:?}, dw_res_size = {:?}, f_icon = {:?}, dw_ver = {:?}}}" , presbits , dw_res_size , f_icon , dw_ver ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateIconFromResource(presbits, dw_res_size, f_icon, dw_ver);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateIconFromResourceEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateIconFromResourceEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let presbits = call.get_arg();
            let dw_res_size = call.get_arg();
            let f_icon = call.get_arg();
            let dw_ver = call.get_arg();
            let cx_desired = call.get_arg();
            let cy_desired = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{presbits = {:?}, dw_res_size = {:?}, f_icon = {:?}, dw_ver = {:?}, cx_desired = {:?}, cy_desired = {:?}, flags = {:?}}}" , presbits , dw_res_size , f_icon , dw_ver , cx_desired , cy_desired , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateIconFromResourceEx(
                presbits,
                dw_res_size,
                f_icon,
                dw_ver,
                cx_desired,
                cy_desired,
                flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateMDIWindowA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateMDIWindowA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_class_name = call.get_arg();
            let lp_window_name = call.get_arg();
            let dw_style = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let n_width = call.get_arg();
            let n_height = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let h_instance = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_instance = {:?}, l_param = {:?}}}" , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_instance , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateMDIWindowA(
                lp_class_name,
                lp_window_name,
                dw_style,
                x,
                y,
                n_width,
                n_height,
                h_wnd_parent,
                h_instance,
                l_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateMDIWindowW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateMDIWindowW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_class_name = call.get_arg();
            let lp_window_name = call.get_arg();
            let dw_style = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let n_width = call.get_arg();
            let n_height = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let h_instance = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_instance = {:?}, l_param = {:?}}}" , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_instance , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateMDIWindowW(
                lp_class_name,
                lp_window_name,
                dw_style,
                x,
                y,
                n_width,
                n_height,
                h_wnd_parent,
                h_instance,
                l_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "CreateMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreateMenu();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreatePopupMenu(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreatePopupMenu",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.CreatePopupMenu();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateWindowExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateWindowExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let dw_ex_style = call.get_arg();
            let lp_class_name = call.get_arg();
            let lp_window_name = call.get_arg();
            let dw_style = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let n_width = call.get_arg();
            let n_height = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let h_menu = call.get_arg();
            let h_instance = call.get_arg();
            let lp_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_ex_style = {:?}, lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_menu = {:?}, h_instance = {:?}, lp_param = {:?}}}" , dw_ex_style , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_menu , h_instance , lp_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateWindowExA(
                dw_ex_style,
                lp_class_name,
                lp_window_name,
                dw_style,
                x,
                y,
                n_width,
                n_height,
                h_wnd_parent,
                h_menu,
                h_instance,
                lp_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_CreateWindowExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "CreateWindowExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let dw_ex_style = call.get_arg();
            let lp_class_name = call.get_arg();
            let lp_window_name = call.get_arg();
            let dw_style = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let n_width = call.get_arg();
            let n_height = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let h_menu = call.get_arg();
            let h_instance = call.get_arg();
            let lp_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{dw_ex_style = {:?}, lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_menu = {:?}, h_instance = {:?}, lp_param = {:?}}}" , dw_ex_style , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_menu , h_instance , lp_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.CreateWindowExW(
                dw_ex_style,
                lp_class_name,
                lp_window_name,
                dw_style,
                x,
                y,
                n_width,
                n_height,
                h_wnd_parent,
                h_menu,
                h_instance,
                lp_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefDlgProcA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DefDlgProcA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_dlg , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefDlgProcA(h_dlg, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefDlgProcW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DefDlgProcW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_dlg , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefDlgProcW(h_dlg, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefFrameProcA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefFrameProcA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_wnd_mdi_client = call.get_arg();
            let u_msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, h_wnd_mdi_client = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , h_wnd_mdi_client , u_msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefFrameProcA(h_wnd, h_wnd_mdi_client, u_msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefFrameProcW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefFrameProcW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_wnd_mdi_client = call.get_arg();
            let u_msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, h_wnd_mdi_client = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , h_wnd_mdi_client , u_msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefFrameProcW(h_wnd, h_wnd_mdi_client, u_msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefMDIChildProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefMDIChildProcA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let u_msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , u_msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefMDIChildProcA(h_wnd, u_msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefMDIChildProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefMDIChildProcW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let u_msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , u_msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefMDIChildProcW(h_wnd, u_msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefWindowProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefWindowProcA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefWindowProcA(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DefWindowProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DefWindowProcW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DefWindowProcW(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeferWindowPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_win_pos_info = call.get_arg();
            let h_wnd = call.get_arg();
            let h_wnd_insert_after = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let cx = call.get_arg();
            let cy = call.get_arg();
            let u_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_win_pos_info = {:?}, h_wnd = {:?}, h_wnd_insert_after = {:?}, x = {:?}, y = {:?}, cx = {:?}, cy = {:?}, u_flags = {:?}}}" , h_win_pos_info , h_wnd , h_wnd_insert_after , x , y , cx , cy , u_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DeferWindowPos(
                h_win_pos_info,
                h_wnd,
                h_wnd_insert_after,
                x,
                y,
                cx,
                cy,
                u_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeleteMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DeleteMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_position = call.get_arg();
            let u_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}}}",
                            h_menu, u_position, u_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeleteMenu(h_menu, u_position, u_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DeregisterShellHookWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DeregisterShellHookWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{hwnd = {:?}}}", hwnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DeregisterShellHookWindow(hwnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DestroyAcceleratorTable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DestroyAcceleratorTable",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_accel = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_accel = {:?}}}", h_accel)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DestroyAcceleratorTable(h_accel);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DestroyCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DestroyCaret",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DestroyCaret();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DestroyCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DestroyCursor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_cursor = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_cursor = {:?}}}", h_cursor)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DestroyCursor(h_cursor);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DestroyIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DestroyIcon");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_icon = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_icon = {:?}}}", h_icon)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DestroyIcon(h_icon);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DestroyMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DestroyMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_menu = {:?}}}", h_menu)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DestroyMenu(h_menu);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DestroyWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DestroyWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DestroyWindow(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DialogBoxIndirectParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DialogBoxIndirectParamA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let h_dialog_template = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, h_dialog_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , h_dialog_template , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DialogBoxIndirectParamA(
                h_instance,
                h_dialog_template,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DialogBoxIndirectParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DialogBoxIndirectParamW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let h_dialog_template = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, h_dialog_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , h_dialog_template , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DialogBoxIndirectParamW(
                h_instance,
                h_dialog_template,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DialogBoxParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DialogBoxParamA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_template_name = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DialogBoxParamA(
                h_instance,
                lp_template_name,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DialogBoxParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DialogBoxParamW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_template_name = call.get_arg();
            let h_wnd_parent = call.get_arg();
            let lp_dialog_func = call.get_arg();
            let dw_init_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DialogBoxParamW(
                h_instance,
                lp_template_name,
                h_wnd_parent,
                lp_dialog_func,
                dw_init_param,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DisableProcessWindowsGhosting(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DisableProcessWindowsGhosting",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DisableProcessWindowsGhosting();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DispatchMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DispatchMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_msg = {:?}}}", lp_msg)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DispatchMessageA(lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DispatchMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "DispatchMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_msg = {:?}}}", lp_msg)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DispatchMessageW(lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DragObject(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DragObject");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd_parent = call.get_arg();
            let hwnd_from = call.get_arg();
            let fmt = call.get_arg();
            let data = call.get_arg();
            let hcur = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd_parent = {:?}, hwnd_from = {:?}, fmt = {:?}, data = {:?}, hcur = {:?}}}" , hwnd_parent , hwnd_from , fmt , data , hcur ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.DragObject(hwnd_parent, hwnd_from, fmt, data, hcur);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_DrawMenuBar(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "DrawMenuBar");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.DrawMenuBar(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnableMenuItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnableMenuItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_id_enable_item = call.get_arg();
            let u_enable = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_id_enable_item = {:?}, u_enable = {:?}}}" , h_menu , u_id_enable_item , u_enable ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnableMenuItem(h_menu, u_id_enable_item, u_enable);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EndDeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EndDeferWindowPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_win_pos_info = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{h_win_pos_info = {:?}}}", h_win_pos_info)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.EndDeferWindowPos(h_win_pos_info);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EndDialog(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "EndDialog");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_result = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, n_result = {:?}}}",
                            h_dlg, n_result
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EndDialog(h_dlg, n_result);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EndMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "EndMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EndMenu();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumChildWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumChildWindows",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd_parent = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd_parent = {:?}, lp_enum_func = {:?}, l_param = {:?}}}" , h_wnd_parent , lp_enum_func , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.EnumChildWindows(h_wnd_parent, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumPropsA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "EnumPropsA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_enum_func = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_enum_func = {:?}}}",
                            h_wnd, lp_enum_func
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumPropsA(h_wnd, lp_enum_func);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumPropsExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumPropsExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
                            h_wnd, lp_enum_func, l_param
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumPropsExA(h_wnd, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumPropsExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumPropsExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
                            h_wnd, lp_enum_func, l_param
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumPropsExW(h_wnd, lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumPropsW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "EnumPropsW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_enum_func = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_enum_func = {:?}}}",
                            h_wnd, lp_enum_func
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumPropsW(h_wnd, lp_enum_func);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumThreadWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "EnumThreadWindows",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let dw_thread_id = call.get_arg();
            let lpfn = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_thread_id = {:?}, lpfn = {:?}, l_param = {:?}}}",
                            dw_thread_id, lpfn, l_param
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumThreadWindows(dw_thread_id, lpfn, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_EnumWindows(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "EnumWindows");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_enum_func = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_enum_func = {:?}, l_param = {:?}}}",
                            lp_enum_func, l_param
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.EnumWindows(lp_enum_func, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindWindowA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FindWindowA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_class_name = call.get_arg();
            let lp_window_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_class_name = {:?}, lp_window_name = {:?}}}",
                            lp_class_name, lp_window_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindWindowA(lp_class_name, lp_window_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindWindowExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindWindowExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd_parent = call.get_arg();
            let h_wnd_child_after = call.get_arg();
            let lpsz_class = call.get_arg();
            let lpsz_window = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd_parent = {:?}, h_wnd_child_after = {:?}, lpsz_class = {:?}, lpsz_window = {:?}}}" , h_wnd_parent , h_wnd_child_after , lpsz_class , lpsz_window ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindWindowExA(h_wnd_parent, h_wnd_child_after, lpsz_class, lpsz_window);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindWindowExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FindWindowExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd_parent = call.get_arg();
            let h_wnd_child_after = call.get_arg();
            let lpsz_class = call.get_arg();
            let lpsz_window = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd_parent = {:?}, h_wnd_child_after = {:?}, lpsz_class = {:?}, lpsz_window = {:?}}}" , h_wnd_parent , h_wnd_child_after , lpsz_class , lpsz_window ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.FindWindowExW(h_wnd_parent, h_wnd_child_after, lpsz_class, lpsz_window);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FindWindowW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FindWindowW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_class_name = call.get_arg();
            let lp_window_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_class_name = {:?}, lp_window_name = {:?}}}",
                            lp_class_name, lp_window_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FindWindowW(lp_class_name, lp_window_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlashWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "FlashWindow");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let b_invert = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, b_invert = {:?}}}",
                            h_wnd, b_invert
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FlashWindow(h_wnd, b_invert);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_FlashWindowEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "FlashWindowEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let pfwi = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{pfwi = {:?}}}", pfwi)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.FlashWindowEx(pfwi);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetAltTabInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetAltTabInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let i_item = call.get_arg();
            let pati = call.get_arg();
            let psz_item_text = call.get_arg();
            let cch_item_text = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, i_item = {:?}, pati = {:?}, psz_item_text = {:?}, cch_item_text = {:?}}}" , hwnd , i_item , pati , psz_item_text , cch_item_text ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetAltTabInfoA(hwnd, i_item, pati, psz_item_text, cch_item_text);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetAltTabInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetAltTabInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let i_item = call.get_arg();
            let pati = call.get_arg();
            let psz_item_text = call.get_arg();
            let cch_item_text = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, i_item = {:?}, pati = {:?}, psz_item_text = {:?}, cch_item_text = {:?}}}" , hwnd , i_item , pati , psz_item_text , cch_item_text ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetAltTabInfoW(hwnd, i_item, pati, psz_item_text, cch_item_text);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetAncestor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetAncestor");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let ga_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, ga_flags = {:?}}}",
                            hwnd, ga_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetAncestor(hwnd, ga_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCaretBlinkTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCaretBlinkTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCaretBlinkTime();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCaretPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetCaretPos");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_point = {:?}}}", lp_point)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCaretPos(lp_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetClassLongA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetClassLongA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}}}",
                            h_wnd, n_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetClassLongA(h_wnd, n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetClassLongW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetClassLongW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}}}",
                            h_wnd, n_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetClassLongW(h_wnd, n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetClassNameA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetClassNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_class_name = call.get_arg();
            let n_max_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_class_name = {:?}, n_max_count = {:?}}}",
                            h_wnd, lp_class_name, n_max_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetClassNameA(h_wnd, lp_class_name, n_max_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetClassNameW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetClassNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_class_name = call.get_arg();
            let n_max_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_class_name = {:?}, n_max_count = {:?}}}",
                            h_wnd, lp_class_name, n_max_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetClassNameW(h_wnd, lp_class_name, n_max_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetClassWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetClassWord",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}}}",
                            h_wnd, n_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetClassWord(h_wnd, n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetClientRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetClientRect",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_rect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_rect = {:?}}}",
                            h_wnd, lp_rect
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetClientRect(h_wnd, lp_rect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetClipCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetClipCursor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_rect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_rect = {:?}}}", lp_rect)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetClipCursor(lp_rect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetCursor");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCursor();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCursorInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCursorInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let pci = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{pci = {:?}}}" , pci ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetCursorInfo(pci);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetCursorPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetCursorPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_point = {:?}}}", lp_point)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetCursorPos(lp_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDesktopWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDesktopWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDesktopWindow();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDialogBaseUnits(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDialogBaseUnits",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDialogBaseUnits();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDlgCtrlID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDlgCtrlID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDlgCtrlID(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDlgItem(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetDlgItem");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}}}",
                            h_dlg, n_id_dlg_item
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetDlgItem(h_dlg, n_id_dlg_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemInt(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDlgItemInt",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let lp_translated = call.get_arg();
            let b_signed = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_translated = {:?}, b_signed = {:?}}}" , h_dlg , n_id_dlg_item , lp_translated , b_signed ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDlgItemInt(h_dlg, n_id_dlg_item, lp_translated, b_signed);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDlgItemTextA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let lp_string = call.get_arg();
            let cch_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}, cch_max = {:?}}}" , h_dlg , n_id_dlg_item , lp_string , cch_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDlgItemTextA(h_dlg, n_id_dlg_item, lp_string, cch_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetDlgItemTextW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let lp_string = call.get_arg();
            let cch_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}, cch_max = {:?}}}" , h_dlg , n_id_dlg_item , lp_string , cch_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetDlgItemTextW(h_dlg, n_id_dlg_item, lp_string, cch_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetForegroundWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetForegroundWindow();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetGUIThreadInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetGUIThreadInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let id_thread = call.get_arg();
            let pgui = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{id_thread = {:?}, pgui = {:?}}}",
                            id_thread, pgui
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetGUIThreadInfo(id_thread, pgui);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetInputState(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetInputState",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetInputState();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLastActivePopup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLastActivePopup",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetLastActivePopup(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetLayeredWindowAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetLayeredWindowAttributes",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let pcr_key = call.get_arg();
            let pb_alpha = call.get_arg();
            let pdw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, pcr_key = {:?}, pb_alpha = {:?}, pdw_flags = {:?}}}" , hwnd , pcr_key , pb_alpha , pdw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetLayeredWindowAttributes(hwnd, pcr_key, pb_alpha, pdw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMenu(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuBarInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let id_object = call.get_arg();
            let id_item = call.get_arg();
            let pmbi = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, id_object = {:?}, id_item = {:?}, pmbi = {:?}}}" , hwnd , id_object , id_item , pmbi ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetMenuBarInfo(hwnd, id_object, id_item, pmbi);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuCheckMarkDimensions(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuCheckMarkDimensions",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMenuCheckMarkDimensions();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuDefaultItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuDefaultItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let f_by_pos = call.get_arg();
            let gmdi_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, f_by_pos = {:?}, gmdi_flags = {:?}}}",
                            h_menu, f_by_pos, gmdi_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMenuDefaultItem(h_menu, f_by_pos, gmdi_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuItemCount",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_menu = {:?}}}", h_menu)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMenuItemCount(h_menu);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuItemID",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let n_pos = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, n_pos = {:?}}}",
                            h_menu, n_pos
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMenuItemID(h_menu, n_pos);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemRect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuItemRect",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_menu = call.get_arg();
            let u_item = call.get_arg();
            let lprc_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, h_menu = {:?}, u_item = {:?}, lprc_item = {:?}}}" , h_wnd , h_menu , u_item , lprc_item ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetMenuItemRect(h_wnd, h_menu, u_item, lprc_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuState(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuState",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_id = call.get_arg();
            let u_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, u_id = {:?}, u_flags = {:?}}}",
                            h_menu, u_id, u_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMenuState(h_menu, u_id, u_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuStringA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_id_item = call.get_arg();
            let lp_string = call.get_arg();
            let cch_max = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_id_item = {:?}, lp_string = {:?}, cch_max = {:?}, flags = {:?}}}" , h_menu , u_id_item , lp_string , cch_max , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetMenuStringA(h_menu, u_id_item, lp_string, cch_max, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMenuStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMenuStringW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_id_item = call.get_arg();
            let lp_string = call.get_arg();
            let cch_max = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_id_item = {:?}, lp_string = {:?}, cch_max = {:?}, flags = {:?}}}" , h_menu , u_id_item , lp_string , cch_max , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetMenuStringW(h_menu, u_id_item, lp_string, cch_max, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetMessageA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            let h_wnd = call.get_arg();
            let w_msg_filter_min = call.get_arg();
            let w_msg_filter_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetMessageA(lp_msg, h_wnd, w_msg_filter_min, w_msg_filter_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMessageExtraInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMessageExtraInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMessageExtraInfo();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMessagePos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMessagePos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMessagePos();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMessageTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetMessageTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetMessageTime();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetMessageW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            let h_wnd = call.get_arg();
            let w_msg_filter_min = call.get_arg();
            let w_msg_filter_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetMessageW(lp_msg, h_wnd, w_msg_filter_min, w_msg_filter_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNextDlgGroupItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNextDlgGroupItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let h_ctl = call.get_arg();
            let b_previous = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, h_ctl = {:?}, b_previous = {:?}}}",
                            h_dlg, h_ctl, b_previous
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNextDlgGroupItem(h_dlg, h_ctl, b_previous);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetNextDlgTabItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetNextDlgTabItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let h_ctl = call.get_arg();
            let b_previous = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, h_ctl = {:?}, b_previous = {:?}}}",
                            h_dlg, h_ctl, b_previous
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetNextDlgTabItem(h_dlg, h_ctl, b_previous);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetParent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetParent");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetParent(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPhysicalCursorPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetPhysicalCursorPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_point = {:?}}}", lp_point)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetPhysicalCursorPos(lp_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultLayout(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetProcessDefaultLayout",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let pdw_default_layout = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{pdw_default_layout = {:?}}}",
                            pdw_default_layout
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetProcessDefaultLayout(pdw_default_layout);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetPropA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}}}",
                            h_wnd, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetPropA(h_wnd, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetPropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetPropW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}}}",
                            h_wnd, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetPropW(h_wnd, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetQueueStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetQueueStatus",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{flags = {:?}}}", flags)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetQueueStatus(flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetScrollBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetScrollBarInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let id_object = call.get_arg();
            let psbi = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, id_object = {:?}, psbi = {:?}}}",
                            hwnd, id_object, psbi
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetScrollBarInfo(hwnd, id_object, psbi);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetScrollInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetScrollInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let n_bar = call.get_arg();
            let lpsi = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, n_bar = {:?}, lpsi = {:?}}}",
                            hwnd, n_bar, lpsi
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetScrollInfo(hwnd, n_bar, lpsi);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetScrollPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetScrollPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_bar = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_bar = {:?}}}",
                            h_wnd, n_bar
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetScrollPos(h_wnd, n_bar);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetScrollRange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetScrollRange",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_bar = call.get_arg();
            let lp_min_pos = call.get_arg();
            let lp_max_pos = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, n_bar = {:?}, lp_min_pos = {:?}, lp_max_pos = {:?}}}" , h_wnd , n_bar , lp_min_pos , lp_max_pos ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetScrollRange(h_wnd, n_bar, lp_min_pos, lp_max_pos);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetShellWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetShellWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetShellWindow();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSubMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetSubMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let n_pos = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, n_pos = {:?}}}",
                            h_menu, n_pos
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSubMenu(h_menu, n_pos);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSysColor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetSysColor");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{n_index = {:?}}}", n_index)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSysColor(n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemMenu",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let b_revert = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, b_revert = {:?}}}",
                            h_wnd, b_revert
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemMenu(h_wnd, b_revert);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetSystemMetrics(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetSystemMetrics",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{n_index = {:?}}}", n_index)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetSystemMetrics(n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTitleBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTitleBarInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let pti = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{hwnd = {:?}, pti = {:?}}}", hwnd, pti)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetTitleBarInfo(hwnd, pti);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetTopWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetTopWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetTopWindow(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "GetWindow");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let u_cmd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, u_cmd = {:?}}}",
                            h_wnd, u_cmd
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindow(h_wnd, u_cmd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowDisplayAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowDisplayAffinity",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let pdw_affinity = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, pdw_affinity = {:?}}}",
                            h_wnd, pdw_affinity
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowDisplayAffinity(h_wnd, pdw_affinity);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let pwi = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{hwnd = {:?}, pwi = {:?}}}", hwnd, pwi)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.GetWindowInfo(hwnd, pwi);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowLongA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowLongA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}}}",
                            h_wnd, n_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowLongA(h_wnd, n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowLongW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowLongW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}}}",
                            h_wnd, n_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowLongW(h_wnd, n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowModuleFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowModuleFileNameA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let psz_file_name = call.get_arg();
            let cch_file_name_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, psz_file_name = {:?}, cch_file_name_max = {:?}}}" , hwnd , psz_file_name , cch_file_name_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetWindowModuleFileNameA(hwnd, psz_file_name, cch_file_name_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowModuleFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowModuleFileNameW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let psz_file_name = call.get_arg();
            let cch_file_name_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, psz_file_name = {:?}, cch_file_name_max = {:?}}}" , hwnd , psz_file_name , cch_file_name_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.GetWindowModuleFileNameW(hwnd, psz_file_name, cch_file_name_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowPlacement(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowPlacement",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lpwndpl = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lpwndpl = {:?}}}",
                            h_wnd, lpwndpl
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowPlacement(h_wnd, lpwndpl);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowRect",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_rect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_rect = {:?}}}",
                            h_wnd, lp_rect
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowRect(h_wnd, lp_rect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowTextA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            let n_max_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}, n_max_count = {:?}}}",
                            h_wnd, lp_string, n_max_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowTextA(h_wnd, lp_string, n_max_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowTextLengthA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowTextLengthA(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowTextLengthW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowTextLengthW(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowTextW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            let n_max_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}, n_max_count = {:?}}}",
                            h_wnd, lp_string, n_max_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowTextW(h_wnd, lp_string, n_max_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowThreadProcessId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowThreadProcessId",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lpdw_process_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lpdw_process_id = {:?}}}",
                            h_wnd, lpdw_process_id
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowThreadProcessId(h_wnd, lpdw_process_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_GetWindowWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "GetWindowWord",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}}}",
                            h_wnd, n_index
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.GetWindowWord(h_wnd, n_index);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HideCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "HideCaret");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.HideCaret(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_HiliteMenuItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "HiliteMenuItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_menu = call.get_arg();
            let u_id_hilite_item = call.get_arg();
            let u_hilite = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, h_menu = {:?}, u_id_hilite_item = {:?}, u_hilite = {:?}}}" , h_wnd , h_menu , u_id_hilite_item , u_hilite ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.HiliteMenuItem(h_wnd, h_menu, u_id_hilite_item, u_hilite);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InSendMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InSendMessage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InSendMessage();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InSendMessageEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InSendMessageEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_reserved = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_reserved = {:?}}}", lp_reserved)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.InSendMessageEx(lp_reserved);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InheritWindowMonitor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InheritWindowMonitor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let hwnd_inherit = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, hwnd_inherit = {:?}}}",
                            hwnd, hwnd_inherit
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InheritWindowMonitor(hwnd, hwnd_inherit);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InsertMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "InsertMenuA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_position = call.get_arg();
            let u_flags = call.get_arg();
            let u_id_new_item = call.get_arg();
            let lp_new_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_menu , u_position , u_flags , u_id_new_item , lp_new_item ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InsertMenuA(h_menu, u_position, u_flags, u_id_new_item, lp_new_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InsertMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "InsertMenuW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_position = call.get_arg();
            let u_flags = call.get_arg();
            let u_id_new_item = call.get_arg();
            let lp_new_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_menu , u_position , u_flags , u_id_new_item , lp_new_item ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.InsertMenuW(h_menu, u_position, u_flags, u_id_new_item, lp_new_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_InternalGetWindowText(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "InternalGetWindowText",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let p_string = call.get_arg();
            let cch_max_count = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, p_string = {:?}, cch_max_count = {:?}}}",
                            h_wnd, p_string, cch_max_count
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.InternalGetWindowText(h_wnd, p_string, cch_max_count);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsCharAlphaA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ch = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ch = {:?}}}", ch) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsCharAlphaA(ch);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaNumericA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsCharAlphaNumericA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ch = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ch = {:?}}}", ch) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsCharAlphaNumericA(ch);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaNumericW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsCharAlphaNumericW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ch = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ch = {:?}}}", ch) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsCharAlphaNumericW(ch);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsCharAlphaW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ch = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ch = {:?}}}", ch) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsCharAlphaW(ch);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsCharLowerA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsCharLowerA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ch = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ch = {:?}}}", ch) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsCharLowerA(ch);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsCharUpperA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsCharUpperA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ch = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ch = {:?}}}", ch) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsCharUpperA(ch);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsCharUpperW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsCharUpperW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ch = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{ch = {:?}}}", ch) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsCharUpperW(ch);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsChild(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IsChild");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd_parent = call.get_arg();
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd_parent = {:?}, h_wnd = {:?}}}",
                            h_wnd_parent, h_wnd
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsChild(h_wnd_parent, h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsDialogMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsDialogMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, lp_msg = {:?}}}",
                            h_dlg, lp_msg
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsDialogMessageA(h_dlg, lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsDialogMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsDialogMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, lp_msg = {:?}}}",
                            h_dlg, lp_msg
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsDialogMessageW(h_dlg, lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsGUIThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IsGUIThread");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let b_convert = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{b_convert = {:?}}}", b_convert)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsGUIThread(b_convert);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsHungAppWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsHungAppWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{hwnd = {:?}}}", hwnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsHungAppWindow(hwnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsIconic(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IsIconic");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsIconic(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IsMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_menu = {:?}}}", h_menu)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsMenu(h_menu);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsProcessDPIAware(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsProcessDPIAware",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsProcessDPIAware();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IsWindow");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsWindow(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsWindowUnicode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsWindowUnicode",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsWindowUnicode(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsWindowVisible(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsWindowVisible",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsWindowVisible(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsWow64Message(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "IsWow64Message",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsWow64Message();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_IsZoomed(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "IsZoomed");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.IsZoomed(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_KillTimer(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "KillTimer");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let u_id_event = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, u_id_event = {:?}}}",
                            h_wnd, u_id_event
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.KillTimer(h_wnd, u_id_event);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadAcceleratorsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadAcceleratorsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_table_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_table_name = {:?}}}",
                            h_instance, lp_table_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadAcceleratorsA(h_instance, lp_table_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadAcceleratorsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadAcceleratorsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_table_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_table_name = {:?}}}",
                            h_instance, lp_table_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadAcceleratorsW(h_instance, lp_table_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadCursorA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadCursorA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_cursor_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_cursor_name = {:?}}}",
                            h_instance, lp_cursor_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadCursorA(h_instance, lp_cursor_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadCursorFromFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadCursorFromFileA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.LoadCursorFromFileA(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadCursorFromFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadCursorFromFileW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_file_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{lp_file_name = {:?}}}", lp_file_name)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.LoadCursorFromFileW(lp_file_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadCursorW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadCursorW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_cursor_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_cursor_name = {:?}}}",
                            h_instance, lp_cursor_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadCursorW(h_instance, lp_cursor_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadIconA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadIconA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_icon_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_icon_name = {:?}}}",
                            h_instance, lp_icon_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadIconA(h_instance, lp_icon_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadIconW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadIconW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_icon_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_icon_name = {:?}}}",
                            h_instance, lp_icon_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadIconW(h_instance, lp_icon_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadImageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadImageA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_inst = call.get_arg();
            let name = call.get_arg();
            let r#type = call.get_arg();
            let cx = call.get_arg();
            let cy = call.get_arg();
            let fu_load = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_inst = {:?}, name = {:?}, r#type = {:?}, cx = {:?}, cy = {:?}, fu_load = {:?}}}" , h_inst , name , r#type , cx , cy , fu_load ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LoadImageA(h_inst, name, r#type, cx, cy, fu_load);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadImageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadImageW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_inst = call.get_arg();
            let name = call.get_arg();
            let r#type = call.get_arg();
            let cx = call.get_arg();
            let cy = call.get_arg();
            let fu_load = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_inst = {:?}, name = {:?}, r#type = {:?}, cx = {:?}, cy = {:?}, fu_load = {:?}}}" , h_inst , name , r#type , cx , cy , fu_load ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LoadImageW(h_inst, name, r#type, cx, cy, fu_load);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadMenuA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_menu_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_menu_name = {:?}}}",
                            h_instance, lp_menu_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadMenuA(h_instance, lp_menu_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadMenuIndirectA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadMenuIndirectA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_menu_template = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_menu_template = {:?}}}",
                            lp_menu_template
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadMenuIndirectA(lp_menu_template);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadMenuIndirectW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LoadMenuIndirectW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_menu_template = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_menu_template = {:?}}}",
                            lp_menu_template
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadMenuIndirectW(lp_menu_template);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadMenuW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let lp_menu_name = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_instance = {:?}, lp_menu_name = {:?}}}",
                            h_instance, lp_menu_name
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LoadMenuW(h_instance, lp_menu_name);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadStringA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let u_id = call.get_arg();
            let lp_buffer = call.get_arg();
            let cch_buffer_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, u_id = {:?}, lp_buffer = {:?}, cch_buffer_max = {:?}}}" , h_instance , u_id , lp_buffer , cch_buffer_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LoadStringA(h_instance, u_id, lp_buffer, cch_buffer_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LoadStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "LoadStringW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_instance = call.get_arg();
            let u_id = call.get_arg();
            let lp_buffer = call.get_arg();
            let cch_buffer_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_instance = {:?}, u_id = {:?}, lp_buffer = {:?}, cch_buffer_max = {:?}}}" , h_instance , u_id , lp_buffer , cch_buffer_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.LoadStringW(h_instance, u_id, lp_buffer, cch_buffer_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LockSetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LockSetForegroundWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let u_lock_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{u_lock_code = {:?}}}", u_lock_code)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.LockSetForegroundWindow(u_lock_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LogicalToPhysicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LogicalToPhysicalPoint",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_point = {:?}}}",
                            h_wnd, lp_point
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LogicalToPhysicalPoint(h_wnd, lp_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LookupIconIdFromDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LookupIconIdFromDirectory",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let presbits = call.get_arg();
            let f_icon = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{presbits = {:?}, f_icon = {:?}}}",
                            presbits, f_icon
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.LookupIconIdFromDirectory(presbits, f_icon);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_LookupIconIdFromDirectoryEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "LookupIconIdFromDirectoryEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let presbits = call.get_arg();
            let f_icon = call.get_arg();
            let cx_desired = call.get_arg();
            let cy_desired = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{presbits = {:?}, f_icon = {:?}, cx_desired = {:?}, cy_desired = {:?}, flags = {:?}}}" , presbits , f_icon , cx_desired , cy_desired , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res =
                api.LookupIconIdFromDirectoryEx(presbits, f_icon, cx_desired, cy_desired, flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MapDialogRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MapDialogRect",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let lp_rect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, lp_rect = {:?}}}",
                            h_dlg, lp_rect
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.MapDialogRect(h_dlg, lp_rect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MenuItemFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MenuItemFromPoint",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_menu = call.get_arg();
            let pt_screen = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, h_menu = {:?}, pt_screen = {:?}}}",
                            h_wnd, h_menu, pt_screen
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.MenuItemFromPoint(h_wnd, h_menu, pt_screen);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MessageBoxA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MessageBoxA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_text = call.get_arg();
            let lp_caption = call.get_arg();
            let u_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}}}" , h_wnd , lp_text , lp_caption , u_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MessageBoxA(h_wnd, lp_text, lp_caption, u_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MessageBoxExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MessageBoxExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_text = call.get_arg();
            let lp_caption = call.get_arg();
            let u_type = call.get_arg();
            let w_language_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}, w_language_id = {:?}}}" , h_wnd , lp_text , lp_caption , u_type , w_language_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MessageBoxExA(h_wnd, lp_text, lp_caption, u_type, w_language_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MessageBoxExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MessageBoxExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_text = call.get_arg();
            let lp_caption = call.get_arg();
            let u_type = call.get_arg();
            let w_language_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}, w_language_id = {:?}}}" , h_wnd , lp_text , lp_caption , u_type , w_language_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MessageBoxExW(h_wnd, lp_text, lp_caption, u_type, w_language_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MessageBoxW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MessageBoxW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_text = call.get_arg();
            let lp_caption = call.get_arg();
            let u_type = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}}}" , h_wnd , lp_text , lp_caption , u_type ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MessageBoxW(h_wnd, lp_text, lp_caption, u_type);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ModifyMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ModifyMenuA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_mnu = call.get_arg();
            let u_position = call.get_arg();
            let u_flags = call.get_arg();
            let u_id_new_item = call.get_arg();
            let lp_new_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_mnu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_mnu , u_position , u_flags , u_id_new_item , lp_new_item ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ModifyMenuA(h_mnu, u_position, u_flags, u_id_new_item, lp_new_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ModifyMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ModifyMenuW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_mnu = call.get_arg();
            let u_position = call.get_arg();
            let u_flags = call.get_arg();
            let u_id_new_item = call.get_arg();
            let lp_new_item = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_mnu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_mnu , u_position , u_flags , u_id_new_item , lp_new_item ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ModifyMenuW(h_mnu, u_position, u_flags, u_id_new_item, lp_new_item);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MoveWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "MoveWindow");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let n_width = call.get_arg();
            let n_height = call.get_arg();
            let b_repaint = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, b_repaint = {:?}}}" , h_wnd , x , y , n_width , n_height , b_repaint ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MoveWindow(h_wnd, x, y, n_width, n_height, b_repaint);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MsgWaitForMultipleObjects(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MsgWaitForMultipleObjects",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_count = call.get_arg();
            let p_handles = call.get_arg();
            let f_wait_all = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let dw_wake_mask = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{n_count = {:?}, p_handles = {:?}, f_wait_all = {:?}, dw_milliseconds = {:?}, dw_wake_mask = {:?}}}" , n_count , p_handles , f_wait_all , dw_milliseconds , dw_wake_mask ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MsgWaitForMultipleObjects(
                n_count,
                p_handles,
                f_wait_all,
                dw_milliseconds,
                dw_wake_mask,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_MsgWaitForMultipleObjectsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "MsgWaitForMultipleObjectsEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_count = call.get_arg();
            let p_handles = call.get_arg();
            let dw_milliseconds = call.get_arg();
            let dw_wake_mask = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{n_count = {:?}, p_handles = {:?}, dw_milliseconds = {:?}, dw_wake_mask = {:?}, dw_flags = {:?}}}" , n_count , p_handles , dw_milliseconds , dw_wake_mask , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.MsgWaitForMultipleObjectsEx(
                n_count,
                p_handles,
                dw_milliseconds,
                dw_wake_mask,
                dw_flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OemToCharA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OemToCharA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let p_src = call.get_arg();
            let p_dst = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{p_src = {:?}, p_dst = {:?}}}",
                            p_src, p_dst
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.OemToCharA(p_src, p_dst);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OemToCharBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OemToCharBuffA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz_src = call.get_arg();
            let lpsz_dst = call.get_arg();
            let cch_dst_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}" , lpsz_src , lpsz_dst , cch_dst_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OemToCharBuffA(lpsz_src, lpsz_dst, cch_dst_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OemToCharBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "OemToCharBuffW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lpsz_src = call.get_arg();
            let lpsz_dst = call.get_arg();
            let cch_dst_length = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}" , lpsz_src , lpsz_dst , cch_dst_length ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.OemToCharBuffW(lpsz_src, lpsz_dst, cch_dst_length);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OemToCharW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OemToCharW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let p_src = call.get_arg();
            let p_dst = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{p_src = {:?}, p_dst = {:?}}}",
                            p_src, p_dst
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.OemToCharW(p_src, p_dst);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_OpenIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "OpenIcon");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.OpenIcon(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PeekMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PeekMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            let h_wnd = call.get_arg();
            let w_msg_filter_min = call.get_arg();
            let w_msg_filter_max = call.get_arg();
            let w_remove_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}, w_remove_msg = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max , w_remove_msg ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PeekMessageA(
                lp_msg,
                h_wnd,
                w_msg_filter_min,
                w_msg_filter_max,
                w_remove_msg,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PeekMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PeekMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            let h_wnd = call.get_arg();
            let w_msg_filter_min = call.get_arg();
            let w_msg_filter_max = call.get_arg();
            let w_remove_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}, w_remove_msg = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max , w_remove_msg ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PeekMessageW(
                lp_msg,
                h_wnd,
                w_msg_filter_min,
                w_msg_filter_max,
                w_remove_msg,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PhysicalToLogicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PhysicalToLogicalPoint",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_point = {:?}}}",
                            h_wnd, lp_point
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.PhysicalToLogicalPoint(h_wnd, lp_point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PostMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PostMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PostMessageA(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PostMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PostMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PostMessageW(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PostQuitMessage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PostQuitMessage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_exit_code = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{n_exit_code = {:?}}}", n_exit_code)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.PostQuitMessage(n_exit_code);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PostThreadMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PostThreadMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let id_thread = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{id_thread = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , id_thread , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PostThreadMessageA(id_thread, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PostThreadMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PostThreadMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let id_thread = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{id_thread = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , id_thread , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PostThreadMessageW(id_thread, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrivateExtractIconsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PrivateExtractIconsA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let sz_file_name = call.get_arg();
            let n_icon_index = call.get_arg();
            let cx_icon = call.get_arg();
            let cy_icon = call.get_arg();
            let phicon = call.get_arg();
            let piconid = call.get_arg();
            let n_icons = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{sz_file_name = {:?}, n_icon_index = {:?}, cx_icon = {:?}, cy_icon = {:?}, phicon = {:?}, piconid = {:?}, n_icons = {:?}, flags = {:?}}}" , sz_file_name , n_icon_index , cx_icon , cy_icon , phicon , piconid , n_icons , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PrivateExtractIconsA(
                sz_file_name,
                n_icon_index,
                cx_icon,
                cy_icon,
                phicon,
                piconid,
                n_icons,
                flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_PrivateExtractIconsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "PrivateExtractIconsW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let sz_file_name = call.get_arg();
            let n_icon_index = call.get_arg();
            let cx_icon = call.get_arg();
            let cy_icon = call.get_arg();
            let phicon = call.get_arg();
            let piconid = call.get_arg();
            let n_icons = call.get_arg();
            let flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{sz_file_name = {:?}, n_icon_index = {:?}, cx_icon = {:?}, cy_icon = {:?}, phicon = {:?}, piconid = {:?}, n_icons = {:?}, flags = {:?}}}" , sz_file_name , n_icon_index , cx_icon , cy_icon , phicon , piconid , n_icons , flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.PrivateExtractIconsW(
                sz_file_name,
                n_icon_index,
                cx_icon,
                cy_icon,
                phicon,
                piconid,
                n_icons,
                flags,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RealChildWindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RealChildWindowFromPoint",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd_parent = call.get_arg();
            let pt_parent_client_coords = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd_parent = {:?}, pt_parent_client_coords = {:?}}}",
                            hwnd_parent, pt_parent_client_coords
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RealChildWindowFromPoint(hwnd_parent, pt_parent_client_coords);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RealGetWindowClassA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RealGetWindowClassA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let ptsz_class_name = call.get_arg();
            let cch_class_name_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, ptsz_class_name = {:?}, cch_class_name_max = {:?}}}" , hwnd , ptsz_class_name , cch_class_name_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RealGetWindowClassA(hwnd, ptsz_class_name, cch_class_name_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RealGetWindowClassW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RealGetWindowClassW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let ptsz_class_name = call.get_arg();
            let cch_class_name_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, ptsz_class_name = {:?}, cch_class_name_max = {:?}}}" , hwnd , ptsz_class_name , cch_class_name_max ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.RealGetWindowClassW(hwnd, ptsz_class_name, cch_class_name_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RegisterShellHookWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RegisterShellHookWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{hwnd = {:?}}}", hwnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RegisterShellHookWindow(hwnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RegisterWindowMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RegisterWindowMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_string = {:?}}}", lp_string)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RegisterWindowMessageA(lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RegisterWindowMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "RegisterWindowMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_string = {:?}}}", lp_string)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RegisterWindowMessageW(lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemoveMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RemoveMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_position = call.get_arg();
            let u_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}}}",
                            h_menu, u_position, u_flags
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RemoveMenu(h_menu, u_position, u_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemovePropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RemovePropA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}}}",
                            h_wnd, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RemovePropA(h_wnd, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_RemovePropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "RemovePropW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}}}",
                            h_wnd, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.RemovePropW(h_wnd, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ReplyMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ReplyMessage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let l_result = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{l_result = {:?}}}", l_result)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ReplyMessage(l_result);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ScrollWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ScrollWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let x_amount = call.get_arg();
            let y_amount = call.get_arg();
            let lp_rect = call.get_arg();
            let lp_clip_rect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, x_amount = {:?}, y_amount = {:?}, lp_rect = {:?}, lp_clip_rect = {:?}}}" , h_wnd , x_amount , y_amount , lp_rect , lp_clip_rect ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.ScrollWindow(h_wnd, x_amount, y_amount, lp_rect, lp_clip_rect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendDlgItemMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendDlgItemMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_dlg , n_id_dlg_item , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendDlgItemMessageA(h_dlg, n_id_dlg_item, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendDlgItemMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendDlgItemMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_dlg , n_id_dlg_item , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendDlgItemMessageW(h_dlg, n_id_dlg_item, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendMessageA(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendMessageCallbackA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendMessageCallbackA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            let lp_result_call_back = call.get_arg();
            let dw_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, lp_result_call_back = {:?}, dw_data = {:?}}}" , h_wnd , msg , w_param , l_param , lp_result_call_back , dw_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendMessageCallbackA(
                h_wnd,
                msg,
                w_param,
                l_param,
                lp_result_call_back,
                dw_data,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendMessageCallbackW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendMessageCallbackW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            let lp_result_call_back = call.get_arg();
            let dw_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, lp_result_call_back = {:?}, dw_data = {:?}}}" , h_wnd , msg , w_param , l_param , lp_result_call_back , dw_data ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendMessageCallbackW(
                h_wnd,
                msg,
                w_param,
                l_param,
                lp_result_call_back,
                dw_data,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendMessageTimeoutA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendMessageTimeoutA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            let fu_flags = call.get_arg();
            let u_timeout = call.get_arg();
            let lpdw_result = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, fu_flags = {:?}, u_timeout = {:?}, lpdw_result = {:?}}}" , h_wnd , msg , w_param , l_param , fu_flags , u_timeout , lpdw_result ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendMessageTimeoutA(
                h_wnd,
                msg,
                w_param,
                l_param,
                fu_flags,
                u_timeout,
                lpdw_result,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendMessageTimeoutW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendMessageTimeoutW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            let fu_flags = call.get_arg();
            let u_timeout = call.get_arg();
            let lpdw_result = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, fu_flags = {:?}, u_timeout = {:?}, lpdw_result = {:?}}}" , h_wnd , msg , w_param , l_param , fu_flags , u_timeout , lpdw_result ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendMessageTimeoutW(
                h_wnd,
                msg,
                w_param,
                l_param,
                fu_flags,
                u_timeout,
                lpdw_result,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendMessageW(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendNotifyMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendNotifyMessageA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendNotifyMessageA(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SendNotifyMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SendNotifyMessageW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let msg = call.get_arg();
            let w_param = call.get_arg();
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , msg , w_param , l_param ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SendNotifyMessageW(h_wnd, msg, w_param, l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCaretBlinkTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCaretBlinkTime",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let u_m_seconds = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{u_m_seconds = {:?}}}", u_m_seconds)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetCaretBlinkTime(u_m_seconds);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCaretPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetCaretPos");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let x = call.get_arg();
            let y = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{x = {:?}, y = {:?}}}", x, y)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetCaretPos(x, y);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetClassLongA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetClassLongA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            let dw_new_long = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
                            h_wnd, n_index, dw_new_long
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetClassLongA(h_wnd, n_index, dw_new_long);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetClassLongW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetClassLongW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            let dw_new_long = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
                            h_wnd, n_index, dw_new_long
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetClassLongW(h_wnd, n_index, dw_new_long);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetClassWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetClassWord",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            let w_new_word = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}, w_new_word = {:?}}}",
                            h_wnd, n_index, w_new_word
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetClassWord(h_wnd, n_index, w_new_word);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCoalescableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCoalescableTimer",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_id_event = call.get_arg();
            let u_elapse = call.get_arg();
            let lp_timer_func = call.get_arg();
            let u_tolerance_delay = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, n_id_event = {:?}, u_elapse = {:?}, lp_timer_func = {:?}, u_tolerance_delay = {:?}}}" , h_wnd , n_id_event , u_elapse , lp_timer_func , u_tolerance_delay ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetCoalescableTimer(
                h_wnd,
                n_id_event,
                u_elapse,
                lp_timer_func,
                u_tolerance_delay,
            );
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetCursor");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_cursor = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_cursor = {:?}}}", h_cursor)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetCursor(h_cursor);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetCursorPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetCursorPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let x = call.get_arg();
            let y = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{x = {:?}, y = {:?}}}", x, y)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetCursorPos(x, y);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetDebugErrorLevel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetDebugErrorLevel",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let dw_level = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{dw_level = {:?}}}", dw_level)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetDebugErrorLevel(dw_level);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemInt(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetDlgItemInt",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let u_value = call.get_arg();
            let b_signed = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, u_value = {:?}, b_signed = {:?}}}" , h_dlg , n_id_dlg_item , u_value , b_signed ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetDlgItemInt(h_dlg, n_id_dlg_item, u_value, b_signed);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetDlgItemTextA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}}}",
                            h_dlg, n_id_dlg_item, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetDlgItemTextA(h_dlg, n_id_dlg_item, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetDlgItemTextW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_dlg = call.get_arg();
            let n_id_dlg_item = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}}}",
                            h_dlg, n_id_dlg_item, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetDlgItemTextW(h_dlg, n_id_dlg_item, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetForegroundWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetForegroundWindow(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetLayeredWindowAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetLayeredWindowAttributes",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let cr_key = call.get_arg();
            let b_alpha = call.get_arg();
            let dw_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd = {:?}, cr_key = {:?}, b_alpha = {:?}, dw_flags = {:?}}}" , hwnd , cr_key , b_alpha , dw_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetLayeredWindowAttributes(hwnd, cr_key, b_alpha, dw_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetMenu");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_menu = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, h_menu = {:?}}}",
                            h_wnd, h_menu
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetMenu(h_wnd, h_menu);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetMenuDefaultItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetMenuDefaultItem",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_item = call.get_arg();
            let f_by_pos = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_menu = {:?}, u_item = {:?}, f_by_pos = {:?}}}",
                            h_menu, u_item, f_by_pos
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetMenuDefaultItem(h_menu, u_item, f_by_pos);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetMessageExtraInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetMessageExtraInfo",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let l_param = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{l_param = {:?}}}", l_param)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetMessageExtraInfo(l_param);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetMessageQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetMessageQueue",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let c_messages_max = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{c_messages_max = {:?}}}", c_messages_max)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetMessageQueue(c_messages_max);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetParent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetParent");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd_child = call.get_arg();
            let h_wnd_new_parent = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd_child = {:?}, h_wnd_new_parent = {:?}}}",
                            h_wnd_child, h_wnd_new_parent
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetParent(h_wnd_child, h_wnd_new_parent);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetPhysicalCursorPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetPhysicalCursorPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let x = call.get_arg();
            let y = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{x = {:?}, y = {:?}}}", x, y)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetPhysicalCursorPos(x, y);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessDPIAware(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessDPIAware",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessDPIAware();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultLayout(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetProcessDefaultLayout",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let dw_default_layout = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{dw_default_layout = {:?}}}",
                            dw_default_layout
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetProcessDefaultLayout(dw_default_layout);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetPropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetPropA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            let h_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}, h_data = {:?}}}",
                            h_wnd, lp_string, h_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetPropA(h_wnd, lp_string, h_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetPropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetPropW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            let h_data = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}, h_data = {:?}}}",
                            h_wnd, lp_string, h_data
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetPropW(h_wnd, lp_string, h_data);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetSysColors(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetSysColors",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let c_elements = call.get_arg();
            let lpa_elements = call.get_arg();
            let lpa_rgb_values = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{c_elements = {:?}, lpa_elements = {:?}, lpa_rgb_values = {:?}}}" , c_elements , lpa_elements , lpa_rgb_values ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetSysColors(c_elements, lpa_elements, lpa_rgb_values);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetSystemCursor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetSystemCursor",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hcur = call.get_arg();
            let id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(
                            &format_args!("    args = {{hcur = {:?}, id = {:?}}}", hcur, id)
                                as &dyn tracing::Value,
                        ),
                    )]),
                );
            }
            let res = api.SetSystemCursor(hcur, id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetTimer(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SetTimer");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_id_event = call.get_arg();
            let u_elapse = call.get_arg();
            let lp_timer_func = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, n_id_event = {:?}, u_elapse = {:?}, lp_timer_func = {:?}}}" , h_wnd , n_id_event , u_elapse , lp_timer_func ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetTimer(h_wnd, n_id_event, u_elapse, lp_timer_func);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowDisplayAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowDisplayAffinity",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let dw_affinity = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, dw_affinity = {:?}}}",
                            h_wnd, dw_affinity
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowDisplayAffinity(h_wnd, dw_affinity);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowLongA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowLongA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            let dw_new_long = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
                            h_wnd, n_index, dw_new_long
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowLongA(h_wnd, n_index, dw_new_long);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowLongW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowLongW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            let dw_new_long = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
                            h_wnd, n_index, dw_new_long
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowLongW(h_wnd, n_index, dw_new_long);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowPlacement(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowPlacement",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lpwndpl = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lpwndpl = {:?}}}",
                            h_wnd, lpwndpl
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowPlacement(h_wnd, lpwndpl);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowPos",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_wnd_insert_after = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let cx = call.get_arg();
            let cy = call.get_arg();
            let u_flags = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_wnd = {:?}, h_wnd_insert_after = {:?}, x = {:?}, y = {:?}, cx = {:?}, cy = {:?}, u_flags = {:?}}}" , h_wnd , h_wnd_insert_after , x , y , cx , cy , u_flags ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetWindowPos(h_wnd, h_wnd_insert_after, x, y, cx, cy, u_flags);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowTextA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}}}",
                            h_wnd, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowTextA(h_wnd, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowTextW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let lp_string = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, lp_string = {:?}}}",
                            h_wnd, lp_string
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowTextW(h_wnd, lp_string);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowWord",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_index = call.get_arg();
            let w_new_word = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_index = {:?}, w_new_word = {:?}}}",
                            h_wnd, n_index, w_new_word
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowWord(h_wnd, n_index, w_new_word);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowsHookA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_filter_type = call.get_arg();
            let pfn_filter_proc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_filter_type = {:?}, pfn_filter_proc = {:?}}}",
                            n_filter_type, pfn_filter_proc
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowsHookA(n_filter_type, pfn_filter_proc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowsHookExA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let id_hook = call.get_arg();
            let lpfn = call.get_arg();
            let hmod = call.get_arg();
            let dw_thread_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{id_hook = {:?}, lpfn = {:?}, hmod = {:?}, dw_thread_id = {:?}}}" , id_hook , lpfn , hmod , dw_thread_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetWindowsHookExA(id_hook, lpfn, hmod, dw_thread_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowsHookExW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let id_hook = call.get_arg();
            let lpfn = call.get_arg();
            let hmod = call.get_arg();
            let dw_thread_id = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{id_hook = {:?}, lpfn = {:?}, hmod = {:?}, dw_thread_id = {:?}}}" , id_hook , lpfn , hmod , dw_thread_id ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SetWindowsHookExW(id_hook, lpfn, hmod, dw_thread_id);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SetWindowsHookW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_filter_type = call.get_arg();
            let pfn_filter_proc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_filter_type = {:?}, pfn_filter_proc = {:?}}}",
                            n_filter_type, pfn_filter_proc
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SetWindowsHookW(n_filter_type, pfn_filter_proc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ShowCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ShowCaret");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{h_wnd = {:?}}}", h_wnd)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ShowCaret(h_wnd);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ShowCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ShowCursor");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let b_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{b_show = {:?}}}", b_show)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ShowCursor(b_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ShowOwnedPopups(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ShowOwnedPopups",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let f_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, f_show = {:?}}}",
                            h_wnd, f_show
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ShowOwnedPopups(h_wnd, f_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ShowWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "ShowWindow");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_cmd_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_cmd_show = {:?}}}",
                            h_wnd, n_cmd_show
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ShowWindow(h_wnd, n_cmd_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_ShowWindowAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "ShowWindowAsync",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let n_cmd_show = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, n_cmd_show = {:?}}}",
                            h_wnd, n_cmd_show
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.ShowWindowAsync(h_wnd, n_cmd_show);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SoundSentry(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "SoundSentry");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SoundSentry();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SwitchToThisWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SwitchToThisWindow",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd = call.get_arg();
            let f_unknown = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{hwnd = {:?}, f_unknown = {:?}}}",
                            hwnd, f_unknown
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.SwitchToThisWindow(hwnd, f_unknown);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SystemParametersInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SystemParametersInfoA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ui_action = call.get_arg();
            let ui_param = call.get_arg();
            let pv_param = call.get_arg();
            let f_win_ini = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ui_action = {:?}, ui_param = {:?}, pv_param = {:?}, f_win_ini = {:?}}}" , ui_action , ui_param , pv_param , f_win_ini ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SystemParametersInfoA(ui_action, ui_param, pv_param, f_win_ini);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_SystemParametersInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "SystemParametersInfoW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let ui_action = call.get_arg();
            let ui_param = call.get_arg();
            let pv_param = call.get_arg();
            let f_win_ini = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{ui_action = {:?}, ui_param = {:?}, pv_param = {:?}, f_win_ini = {:?}}}" , ui_action , ui_param , pv_param , f_win_ini ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.SystemParametersInfoW(ui_action, ui_param, pv_param, f_win_ini);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TileWindows(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "TileWindows");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hwnd_parent = call.get_arg();
            let w_how = call.get_arg();
            let lp_rect = call.get_arg();
            let c_kids = call.get_arg();
            let lp_kids = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hwnd_parent = {:?}, w_how = {:?}, lp_rect = {:?}, c_kids = {:?}, lp_kids = {:?}}}" , hwnd_parent , w_how , lp_rect , c_kids , lp_kids ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TileWindows(hwnd_parent, w_how, lp_rect, c_kids, lp_kids);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TrackPopupMenu(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TrackPopupMenu",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_flags = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let n_reserved = call.get_arg();
            let h_wnd = call.get_arg();
            let prc_rect = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_flags = {:?}, x = {:?}, y = {:?}, n_reserved = {:?}, h_wnd = {:?}, prc_rect = {:?}}}" , h_menu , u_flags , x , y , n_reserved , h_wnd , prc_rect ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TrackPopupMenu(h_menu, u_flags, x, y, n_reserved, h_wnd, prc_rect);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TrackPopupMenuEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TrackPopupMenuEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_menu = call.get_arg();
            let u_flags = call.get_arg();
            let x = call.get_arg();
            let y = call.get_arg();
            let hwnd = call.get_arg();
            let lptpm = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{h_menu = {:?}, u_flags = {:?}, x = {:?}, y = {:?}, hwnd = {:?}, lptpm = {:?}}}" , h_menu , u_flags , x , y , hwnd , lptpm ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.TrackPopupMenuEx(h_menu, u_flags, x, y, hwnd, lptpm);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateAcceleratorA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateAcceleratorA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_acc_table = call.get_arg();
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, h_acc_table = {:?}, lp_msg = {:?}}}",
                            h_wnd, h_acc_table, lp_msg
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TranslateAcceleratorA(h_wnd, h_acc_table, lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateAcceleratorW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateAcceleratorW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd = call.get_arg();
            let h_acc_table = call.get_arg();
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd = {:?}, h_acc_table = {:?}, lp_msg = {:?}}}",
                            h_wnd, h_acc_table, lp_msg
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TranslateAcceleratorW(h_wnd, h_acc_table, lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateMDISysAccel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateMDISysAccel",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let h_wnd_client = call.get_arg();
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{h_wnd_client = {:?}, lp_msg = {:?}}}",
                            h_wnd_client, lp_msg
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TranslateMDISysAccel(h_wnd_client, lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_TranslateMessage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "TranslateMessage",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_msg = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{lp_msg = {:?}}}", lp_msg)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.TranslateMessage(lp_msg);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnhookWindowsHook(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnhookWindowsHook",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let n_code = call.get_arg();
            let pfn_filter_proc = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{n_code = {:?}, pfn_filter_proc = {:?}}}",
                            n_code, pfn_filter_proc
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.UnhookWindowsHook(n_code, pfn_filter_proc);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnhookWindowsHookEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnhookWindowsHookEx",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let hhk = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing :: event :: Event :: dispatch ( callsite . metadata ( ) , & fields . value_set ( & [ ( & unsafe { fields . iter ( ) . next ( ) . unwrap_unchecked ( ) } , Some ( & format_args ! ( "    args = {{hhk = {:?}}}" , hhk ) as & dyn tracing :: Value ) , ) ] ) ) ;
            }
            let res = api.UnhookWindowsHookEx(hhk);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnregisterClassA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnregisterClassA",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_class_name = call.get_arg();
            let h_instance = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_class_name = {:?}, h_instance = {:?}}}",
                            lp_class_name, h_instance
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.UnregisterClassA(lp_class_name, h_instance);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_UnregisterClassW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "UnregisterClassW",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let lp_class_name = call.get_arg();
            let h_instance = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{lp_class_name = {:?}, h_instance = {:?}}}",
                            lp_class_name, h_instance
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.UnregisterClassW(lp_class_name, h_instance);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WaitMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "WaitMessage");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{}}",) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WaitMessage();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WindowFromPhysicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WindowFromPhysicalPoint",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{point = {:?}}}", point)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WindowFromPhysicalPoint(point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_WindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite = crate::MyCallsite::new_span(
        tracing::callsite::Identifier(&SPAN_CALLSITE),
        "WindowFromPoint",
    );
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let point = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("    args = {{point = {:?}}}", point)
                            as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.WindowFromPoint(point);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_wsprintfA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "wsprintfA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.wsprintfA(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_wsprintfW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "wsprintfW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}}}",
                            param_0, param_1
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.wsprintfW(param_0, param_1);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_wvsprintfA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "wvsprintfA");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            let arglist = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}, arglist = {:?}}}",
                            param_0, param_1, arglist
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.wvsprintfA(param_0, param_1, arglist);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
#[no_mangle]
extern "C" fn thunk_wvsprintfW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    static SPAN_CALLSITE: crate::MyCallsite =
        crate::MyCallsite::new_span(tracing::callsite::Identifier(&SPAN_CALLSITE), "wvsprintfW");
    crate::thunk_helper(
        context,
        memory,
        &SPAN_CALLSITE,
        |mut call, win32, trace_event_enabled, callsite| {
            let api = win32::Win32::UI::WindowsAndMessaging::get_api(win32);
            let param_0 = call.get_arg();
            let param_1 = call.get_arg();
            let arglist = call.get_arg();
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!(
                            "    args = {{param_0 = {:?}, param_1 = {:?}, arglist = {:?}}}",
                            param_0, param_1, arglist
                        ) as &dyn tracing::Value),
                    )]),
                );
            }
            let res = api.wvsprintfW(param_0, param_1, arglist);
            if trace_event_enabled {
                let fields = callsite.metadata().fields();
                tracing::event::Event::dispatch(
                    callsite.metadata(),
                    &fields.value_set(&[(
                        &unsafe { fields.iter().next().unwrap_unchecked() },
                        Some(&format_args!("  result = {:?}", res) as &dyn tracing::Value),
                    )]),
                );
            }
            call.finish(res)
        },
    )
}
