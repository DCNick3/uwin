#![allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clashing_extern_declarations,
    clippy::all,
    unused_mut,
    unused_variables
)]
#[allow(unused)]
use crate::ExtendedContext;
#[allow(unused)]
use core_abi::stdcall::StdCallHelper;
#[allow(unused)]
use core_mem::ctx::FlatMemoryCtx;
#[allow(unused)]
use core_mem::ptr::PtrRepr;
#[no_mangle]
extern "C" fn thunk_CloseHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseHandle");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_object = {:?}}}", h_object);
        let res = api.CloseHandle(h_object);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareObjectHandles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_first_object_handle = call.get_arg();
        let h_second_object_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CompareObjectHandles");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_first_object_handle = {:?}, h_second_object_handle = {:?}}}",
            h_first_object_handle,
            h_second_object_handle
        );
        let res = api.CompareObjectHandles(h_first_object_handle, h_second_object_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DuplicateHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_source_process_handle = call.get_arg();
        let h_source_handle = call.get_arg();
        let h_target_process_handle = call.get_arg();
        let lp_target_handle = call.get_arg();
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let dw_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DuplicateHandle");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_source_process_handle = {:?}, h_source_handle = {:?}, h_target_process_handle = {:?}, lp_target_handle = {:?}, dw_desired_access = {:?}, b_inherit_handle = {:?}, dw_options = {:?}}}" , h_source_process_handle , h_source_handle , h_target_process_handle , lp_target_handle , dw_desired_access , b_inherit_handle , dw_options );
        let res = api.DuplicateHandle(
            h_source_process_handle,
            h_source_handle,
            h_target_process_handle,
            lp_target_handle,
            dw_desired_access,
            b_inherit_handle,
            dw_options,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetHandleInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object = call.get_arg();
        let lpdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetHandleInformation");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_object = {:?}, lpdw_flags = {:?}}}",
            h_object,
            lpdw_flags
        );
        let res = api.GetHandleInformation(h_object, lpdw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLastError(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLastError");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetLastError();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetHandleInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object = call.get_arg();
        let dw_mask = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetHandleInformation");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_object = {:?}, dw_mask = {:?}, dw_flags = {:?}}}",
            h_object,
            dw_mask,
            dw_flags
        );
        let res = api.SetHandleInformation(h_object, dw_mask, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLastError(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Foundation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_err_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetLastError");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_err_code = {:?}}}", dw_err_code);
        let res = api.SetLastError(dw_err_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_cmp_flags = call.get_arg();
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CompareStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_cmp_flags = {:?}, lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}}}" , locale , dw_cmp_flags , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 );
        let res = api.CompareStringA(
            locale,
            dw_cmp_flags,
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_cmp_flags = call.get_arg();
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_reserved = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CompareStringEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_cmp_flags = {:?}, lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}, lp_version_information = {:?}, lp_reserved = {:?}, l_param = {:?}}}" , lp_locale_name , dw_cmp_flags , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 , lp_version_information , lp_reserved , l_param );
        let res = api.CompareStringEx(
            lp_locale_name,
            dw_cmp_flags,
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
            lp_version_information,
            lp_reserved,
            l_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringOrdinal(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let b_ignore_case = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CompareStringOrdinal");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}, b_ignore_case = {:?}}}" , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 , b_ignore_case );
        let res = api.CompareStringOrdinal(
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
            b_ignore_case,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_cmp_flags = call.get_arg();
        let lp_string_1 = call.get_arg();
        let cch_count_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let cch_count_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CompareStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_cmp_flags = {:?}, lp_string_1 = {:?}, cch_count_1 = {:?}, lp_string_2 = {:?}, cch_count_2 = {:?}}}" , locale , dw_cmp_flags , lp_string_1 , cch_count_1 , lp_string_2 , cch_count_2 );
        let res = api.CompareStringW(
            locale,
            dw_cmp_flags,
            lp_string_1,
            cch_count_1,
            lp_string_2,
            cch_count_2,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertDefaultLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ConvertDefaultLocale");
        let _enter = span.enter();
        tracing::trace!("  args = {{locale = {:?}}}", locale);
        let res = api.ConvertDefaultLocale(locale);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumCalendarInfoA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_cal_info_enum_proc = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc , locale , calendar , cal_type );
        let res = api.EnumCalendarInfoA(lp_cal_info_enum_proc, locale, calendar, cal_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumCalendarInfoExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_cal_info_enum_proc_ex = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc_ex , locale , calendar , cal_type );
        let res = api.EnumCalendarInfoExA(lp_cal_info_enum_proc_ex, locale, calendar, cal_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_cal_info_enum_proc_ex_ex = call.get_arg();
        let lp_locale_name = call.get_arg();
        let calendar = call.get_arg();
        let lp_reserved = call.get_arg();
        let cal_type = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumCalendarInfoExEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{p_cal_info_enum_proc_ex_ex = {:?}, lp_locale_name = {:?}, calendar = {:?}, lp_reserved = {:?}, cal_type = {:?}, l_param = {:?}}}" , p_cal_info_enum_proc_ex_ex , lp_locale_name , calendar , lp_reserved , cal_type , l_param );
        let res = api.EnumCalendarInfoExEx(
            p_cal_info_enum_proc_ex_ex,
            lp_locale_name,
            calendar,
            lp_reserved,
            cal_type,
            l_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumCalendarInfoExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_cal_info_enum_proc_ex = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc_ex , locale , calendar , cal_type );
        let res = api.EnumCalendarInfoExW(lp_cal_info_enum_proc_ex, locale, calendar, cal_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cal_info_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumCalendarInfoW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_cal_info_enum_proc = {:?}, locale = {:?}, calendar = {:?}, cal_type = {:?}}}" , lp_cal_info_enum_proc , locale , calendar , cal_type );
        let res = api.EnumCalendarInfoW(lp_cal_info_enum_proc, locale, calendar, cal_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumDateFormatsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_date_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}",
            lp_date_fmt_enum_proc,
            locale,
            dw_flags
        );
        let res = api.EnumDateFormatsA(lp_date_fmt_enum_proc, locale, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumDateFormatsExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_date_fmt_enum_proc_ex = {:?}, locale = {:?}, dw_flags = {:?}}}",
            lp_date_fmt_enum_proc_ex,
            locale,
            dw_flags
        );
        let res = api.EnumDateFormatsExA(lp_date_fmt_enum_proc_ex, locale, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc_ex_ex = call.get_arg();
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumDateFormatsExEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_date_fmt_enum_proc_ex_ex = {:?}, lp_locale_name = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_date_fmt_enum_proc_ex_ex , lp_locale_name , dw_flags , l_param );
        let res = api.EnumDateFormatsExEx(
            lp_date_fmt_enum_proc_ex_ex,
            lp_locale_name,
            dw_flags,
            l_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc_ex = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumDateFormatsExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_date_fmt_enum_proc_ex = {:?}, locale = {:?}, dw_flags = {:?}}}",
            lp_date_fmt_enum_proc_ex,
            locale,
            dw_flags
        );
        let res = api.EnumDateFormatsExW(lp_date_fmt_enum_proc_ex, locale, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumDateFormatsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_date_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumDateFormatsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_date_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}",
            lp_date_fmt_enum_proc,
            locale,
            dw_flags
        );
        let res = api.EnumDateFormatsW(lp_date_fmt_enum_proc, locale, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumLanguageGroupLocalesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lang_group_locale_enum_proc = call.get_arg();
        let language_group = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumLanguageGroupLocalesA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_lang_group_locale_enum_proc = {:?}, language_group = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_lang_group_locale_enum_proc , language_group , dw_flags , l_param );
        let res = api.EnumLanguageGroupLocalesA(
            lp_lang_group_locale_enum_proc,
            language_group,
            dw_flags,
            l_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumLanguageGroupLocalesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lang_group_locale_enum_proc = call.get_arg();
        let language_group = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumLanguageGroupLocalesW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_lang_group_locale_enum_proc = {:?}, language_group = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_lang_group_locale_enum_proc , language_group , dw_flags , l_param );
        let res = api.EnumLanguageGroupLocalesW(
            lp_lang_group_locale_enum_proc,
            language_group,
            dw_flags,
            l_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemCodePagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_code_page_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemCodePagesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_code_page_enum_proc = {:?}, dw_flags = {:?}}}",
            lp_code_page_enum_proc,
            dw_flags
        );
        let res = api.EnumSystemCodePagesA(lp_code_page_enum_proc, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemCodePagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_code_page_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemCodePagesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_code_page_enum_proc = {:?}, dw_flags = {:?}}}",
            lp_code_page_enum_proc,
            dw_flags
        );
        let res = api.EnumSystemCodePagesW(lp_code_page_enum_proc, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemGeoID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_class = call.get_arg();
        let parent_geo_id = call.get_arg();
        let lp_geo_enum_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemGeoID");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{geo_class = {:?}, parent_geo_id = {:?}, lp_geo_enum_proc = {:?}}}",
            geo_class,
            parent_geo_id,
            lp_geo_enum_proc
        );
        let res = api.EnumSystemGeoID(geo_class, parent_geo_id, lp_geo_enum_proc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemGeoNames(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_class = call.get_arg();
        let geo_enum_proc = call.get_arg();
        let data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemGeoNames");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{geo_class = {:?}, geo_enum_proc = {:?}, data = {:?}}}",
            geo_class,
            geo_enum_proc,
            data
        );
        let res = api.EnumSystemGeoNames(geo_class, geo_enum_proc, data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLanguageGroupsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_language_group_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemLanguageGroupsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_language_group_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}",
            lp_language_group_enum_proc,
            dw_flags,
            l_param
        );
        let res = api.EnumSystemLanguageGroupsA(lp_language_group_enum_proc, dw_flags, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLanguageGroupsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_language_group_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemLanguageGroupsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_language_group_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}",
            lp_language_group_enum_proc,
            dw_flags,
            l_param
        );
        let res = api.EnumSystemLanguageGroupsW(lp_language_group_enum_proc, dw_flags, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemLocalesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_locale_enum_proc = {:?}, dw_flags = {:?}}}",
            lp_locale_enum_proc,
            dw_flags
        );
        let res = api.EnumSystemLocalesA(lp_locale_enum_proc, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_enum_proc_ex = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemLocalesEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_enum_proc_ex = {:?}, dw_flags = {:?}, l_param = {:?}, lp_reserved = {:?}}}" , lp_locale_enum_proc_ex , dw_flags , l_param , lp_reserved );
        let res = api.EnumSystemLocalesEx(lp_locale_enum_proc_ex, dw_flags, l_param, lp_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumSystemLocalesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumSystemLocalesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_locale_enum_proc = {:?}, dw_flags = {:?}}}",
            lp_locale_enum_proc,
            dw_flags
        );
        let res = api.EnumSystemLocalesW(lp_locale_enum_proc, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumTimeFormatsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_time_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}",
            lp_time_fmt_enum_proc,
            locale,
            dw_flags
        );
        let res = api.EnumTimeFormatsA(lp_time_fmt_enum_proc, locale, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_fmt_enum_proc_ex = call.get_arg();
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumTimeFormatsEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_time_fmt_enum_proc_ex = {:?}, lp_locale_name = {:?}, dw_flags = {:?}, l_param = {:?}}}" , lp_time_fmt_enum_proc_ex , lp_locale_name , dw_flags , l_param );
        let res =
            api.EnumTimeFormatsEx(lp_time_fmt_enum_proc_ex, lp_locale_name, dw_flags, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumTimeFormatsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_fmt_enum_proc = call.get_arg();
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumTimeFormatsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_time_fmt_enum_proc = {:?}, locale = {:?}, dw_flags = {:?}}}",
            lp_time_fmt_enum_proc,
            locale,
            dw_flags
        );
        let res = api.EnumTimeFormatsW(lp_time_fmt_enum_proc, locale, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumUILanguagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_ui_language_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumUILanguagesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_ui_language_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}",
            lp_ui_language_enum_proc,
            dw_flags,
            l_param
        );
        let res = api.EnumUILanguagesA(lp_ui_language_enum_proc, dw_flags, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumUILanguagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_ui_language_enum_proc = call.get_arg();
        let dw_flags = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumUILanguagesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_ui_language_enum_proc = {:?}, dw_flags = {:?}, l_param = {:?}}}",
            lp_ui_language_enum_proc,
            dw_flags,
            l_param
        );
        let res = api.EnumUILanguagesW(lp_ui_language_enum_proc, dw_flags, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNLSString(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_find_nls_string_flags = call.get_arg();
        let lp_string_source = call.get_arg();
        let cch_source = call.get_arg();
        let lp_string_value = call.get_arg();
        let cch_value = call.get_arg();
        let pcch_found = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNLSString");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_find_nls_string_flags = {:?}, lp_string_source = {:?}, cch_source = {:?}, lp_string_value = {:?}, cch_value = {:?}, pcch_found = {:?}}}" , locale , dw_find_nls_string_flags , lp_string_source , cch_source , lp_string_value , cch_value , pcch_found );
        let res = api.FindNLSString(
            locale,
            dw_find_nls_string_flags,
            lp_string_source,
            cch_source,
            lp_string_value,
            cch_value,
            pcch_found,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNLSStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_find_nls_string_flags = call.get_arg();
        let lp_string_source = call.get_arg();
        let cch_source = call.get_arg();
        let lp_string_value = call.get_arg();
        let cch_value = call.get_arg();
        let pcch_found = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_reserved = call.get_arg();
        let sort_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNLSStringEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_find_nls_string_flags = {:?}, lp_string_source = {:?}, cch_source = {:?}, lp_string_value = {:?}, cch_value = {:?}, pcch_found = {:?}, lp_version_information = {:?}, lp_reserved = {:?}, sort_handle = {:?}}}" , lp_locale_name , dw_find_nls_string_flags , lp_string_source , cch_source , lp_string_value , cch_value , pcch_found , lp_version_information , lp_reserved , sort_handle );
        let res = api.FindNLSStringEx(
            lp_locale_name,
            dw_find_nls_string_flags,
            lp_string_source,
            cch_source,
            lp_string_value,
            cch_value,
            pcch_found,
            lp_version_information,
            lp_reserved,
            sort_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindStringOrdinal(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_find_string_ordinal_flags = call.get_arg();
        let lp_string_source = call.get_arg();
        let cch_source = call.get_arg();
        let lp_string_value = call.get_arg();
        let cch_value = call.get_arg();
        let b_ignore_case = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindStringOrdinal");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_find_string_ordinal_flags = {:?}, lp_string_source = {:?}, cch_source = {:?}, lp_string_value = {:?}, cch_value = {:?}, b_ignore_case = {:?}}}" , dw_find_string_ordinal_flags , lp_string_source , cch_source , lp_string_value , cch_value , b_ignore_case );
        let res = api.FindStringOrdinal(
            dw_find_string_ordinal_flags,
            lp_string_source,
            cch_source,
            lp_string_value,
            cch_value,
            b_ignore_case,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FoldStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FoldStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest );
        let res = api.FoldStringA(dw_map_flags, lp_src_str, cch_src, lp_dest_str, cch_dest);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FoldStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FoldStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest );
        let res = api.FoldStringW(dw_map_flags, lp_src_str, cch_src, lp_dest_str, cch_dest);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetACP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetACP");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetACP();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCPInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let lp_cp_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCPInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{code_page = {:?}, lp_cp_info = {:?}}}",
            code_page,
            lp_cp_info
        );
        let res = api.GetCPInfo(code_page, lp_cp_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCPInfoExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_cp_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCPInfoExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{code_page = {:?}, dw_flags = {:?}, lp_cp_info_ex = {:?}}}",
            code_page,
            dw_flags,
            lp_cp_info_ex
        );
        let res = api.GetCPInfoExA(code_page, dw_flags, lp_cp_info_ex);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCPInfoExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_cp_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCPInfoExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{code_page = {:?}, dw_flags = {:?}, lp_cp_info_ex = {:?}}}",
            code_page,
            dw_flags,
            lp_cp_info_ex
        );
        let res = api.GetCPInfoExW(code_page, dw_flags, lp_cp_info_ex);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let cch_data = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCalendarInfoA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}, cch_data = {:?}, lp_value = {:?}}}" , locale , calendar , cal_type , lp_cal_data , cch_data , lp_value );
        let res = api.GetCalendarInfoA(locale, calendar, cal_type, lp_cal_data, cch_data, lp_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let calendar = call.get_arg();
        let lp_reserved = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let cch_data = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCalendarInfoEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, calendar = {:?}, lp_reserved = {:?}, cal_type = {:?}, lp_cal_data = {:?}, cch_data = {:?}, lp_value = {:?}}}" , lp_locale_name , calendar , lp_reserved , cal_type , lp_cal_data , cch_data , lp_value );
        let res = api.GetCalendarInfoEx(
            lp_locale_name,
            calendar,
            lp_reserved,
            cal_type,
            lp_cal_data,
            cch_data,
            lp_value,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let cch_data = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCalendarInfoW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}, cch_data = {:?}, lp_value = {:?}}}" , locale , calendar , cal_type , lp_cal_data , cch_data , lp_value );
        let res = api.GetCalendarInfoW(locale, calendar, cal_type, lp_cal_data, cch_data, lp_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_currency_str = call.get_arg();
        let cch_currency = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrencyFormatA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_currency_str = {:?}, cch_currency = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_currency_str , cch_currency );
        let res = api.GetCurrencyFormatA(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_currency_str,
            cch_currency,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_currency_str = call.get_arg();
        let cch_currency = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrencyFormatEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_currency_str = {:?}, cch_currency = {:?}}}" , lp_locale_name , dw_flags , lp_value , lp_format , lp_currency_str , cch_currency );
        let res = api.GetCurrencyFormatEx(
            lp_locale_name,
            dw_flags,
            lp_value,
            lp_format,
            lp_currency_str,
            cch_currency,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrencyFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_currency_str = call.get_arg();
        let cch_currency = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrencyFormatW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_currency_str = {:?}, cch_currency = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_currency_str , cch_currency );
        let res = api.GetCurrencyFormatW(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_currency_str,
            cch_currency,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_date = call.get_arg();
        let lp_format = call.get_arg();
        let lp_date_str = call.get_arg();
        let cch_date = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDateFormatA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_date = {:?}, lp_format = {:?}, lp_date_str = {:?}, cch_date = {:?}}}" , locale , dw_flags , lp_date , lp_format , lp_date_str , cch_date );
        let res = api.GetDateFormatA(locale, dw_flags, lp_date, lp_format, lp_date_str, cch_date);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_date = call.get_arg();
        let lp_format = call.get_arg();
        let lp_date_str = call.get_arg();
        let cch_date = call.get_arg();
        let lp_calendar = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDateFormatEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_date = {:?}, lp_format = {:?}, lp_date_str = {:?}, cch_date = {:?}, lp_calendar = {:?}}}" , lp_locale_name , dw_flags , lp_date , lp_format , lp_date_str , cch_date , lp_calendar );
        let res = api.GetDateFormatEx(
            lp_locale_name,
            dw_flags,
            lp_date,
            lp_format,
            lp_date_str,
            cch_date,
            lp_calendar,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDateFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_date = call.get_arg();
        let lp_format = call.get_arg();
        let lp_date_str = call.get_arg();
        let cch_date = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDateFormatW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_date = {:?}, lp_format = {:?}, lp_date_str = {:?}, cch_date = {:?}}}" , locale , dw_flags , lp_date , lp_format , lp_date_str , cch_date );
        let res = api.GetDateFormatW(locale, dw_flags, lp_date, lp_format, lp_date_str, cch_date);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDistanceOfClosestLanguageInList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_language = call.get_arg();
        let psz_languages_list = call.get_arg();
        let wch_list_delimiter = call.get_arg();
        let p_closest_distance = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDistanceOfClosestLanguageInList");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psz_language = {:?}, psz_languages_list = {:?}, wch_list_delimiter = {:?}, p_closest_distance = {:?}}}" , psz_language , psz_languages_list , wch_list_delimiter , p_closest_distance );
        let res = api.GetDistanceOfClosestLanguageInList(
            psz_language,
            psz_languages_list,
            wch_list_delimiter,
            p_closest_distance,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDurationFormat(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_duration = call.get_arg();
        let ull_duration = call.get_arg();
        let lp_format = call.get_arg();
        let lp_duration_str = call.get_arg();
        let cch_duration = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDurationFormat");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_duration = {:?}, ull_duration = {:?}, lp_format = {:?}, lp_duration_str = {:?}, cch_duration = {:?}}}" , locale , dw_flags , lp_duration , ull_duration , lp_format , lp_duration_str , cch_duration );
        let res = api.GetDurationFormat(
            locale,
            dw_flags,
            lp_duration,
            ull_duration,
            lp_format,
            lp_duration_str,
            cch_duration,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDurationFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_duration = call.get_arg();
        let ull_duration = call.get_arg();
        let lp_format = call.get_arg();
        let lp_duration_str = call.get_arg();
        let cch_duration = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDurationFormatEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_duration = {:?}, ull_duration = {:?}, lp_format = {:?}, lp_duration_str = {:?}, cch_duration = {:?}}}" , lp_locale_name , dw_flags , lp_duration , ull_duration , lp_format , lp_duration_str , cch_duration );
        let res = api.GetDurationFormatEx(
            lp_locale_name,
            dw_flags,
            lp_duration,
            ull_duration,
            lp_format,
            lp_duration_str,
            cch_duration,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileMUIInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pcwsz_file_path = call.get_arg();
        let p_file_mui_info = call.get_arg();
        let pcb_file_mui_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileMUIInfo");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pcwsz_file_path = {:?}, p_file_mui_info = {:?}, pcb_file_mui_info = {:?}}}" , dw_flags , pcwsz_file_path , p_file_mui_info , pcb_file_mui_info );
        let res = api.GetFileMUIInfo(
            dw_flags,
            pcwsz_file_path,
            p_file_mui_info,
            pcb_file_mui_info,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileMUIPath(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pcwsz_file_path = call.get_arg();
        let pwsz_language = call.get_arg();
        let pcch_language = call.get_arg();
        let pwsz_file_mui_path = call.get_arg();
        let pcch_file_mui_path = call.get_arg();
        let pulul_enumerator = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileMUIPath");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pcwsz_file_path = {:?}, pwsz_language = {:?}, pcch_language = {:?}, pwsz_file_mui_path = {:?}, pcch_file_mui_path = {:?}, pulul_enumerator = {:?}}}" , dw_flags , pcwsz_file_path , pwsz_language , pcch_language , pwsz_file_mui_path , pcch_file_mui_path , pulul_enumerator );
        let res = api.GetFileMUIPath(
            dw_flags,
            pcwsz_file_path,
            pwsz_language,
            pcch_language,
            pwsz_file_mui_path,
            pcch_file_mui_path,
            pulul_enumerator,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let location = call.get_arg();
        let geo_type = call.get_arg();
        let lp_geo_data = call.get_arg();
        let cch_data = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetGeoInfoA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{location = {:?}, geo_type = {:?}, lp_geo_data = {:?}, cch_data = {:?}, lang_id = {:?}}}" , location , geo_type , lp_geo_data , cch_data , lang_id );
        let res = api.GetGeoInfoA(location, geo_type, lp_geo_data, cch_data, lang_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let location = call.get_arg();
        let geo_type = call.get_arg();
        let geo_data = call.get_arg();
        let geo_data_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetGeoInfoEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{location = {:?}, geo_type = {:?}, geo_data = {:?}, geo_data_count = {:?}}}",
            location,
            geo_type,
            geo_data,
            geo_data_count
        );
        let res = api.GetGeoInfoEx(location, geo_type, geo_data, geo_data_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGeoInfoW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let location = call.get_arg();
        let geo_type = call.get_arg();
        let lp_geo_data = call.get_arg();
        let cch_data = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetGeoInfoW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{location = {:?}, geo_type = {:?}, lp_geo_data = {:?}, cch_data = {:?}, lang_id = {:?}}}" , location , geo_type , lp_geo_data , cch_data , lang_id );
        let res = api.GetGeoInfoW(location, geo_type, lp_geo_data, cch_data, lang_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let cch_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLocaleInfoA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}, cch_data = {:?}}}",
            locale,
            lc_type,
            lp_lc_data,
            cch_data
        );
        let res = api.GetLocaleInfoA(locale, lc_type, lp_lc_data, cch_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let cch_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLocaleInfoEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, lc_type = {:?}, lp_lc_data = {:?}, cch_data = {:?}}}" , lp_locale_name , lc_type , lp_lc_data , cch_data );
        let res = api.GetLocaleInfoEx(lp_locale_name, lc_type, lp_lc_data, cch_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocaleInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let cch_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLocaleInfoW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}, cch_data = {:?}}}",
            locale,
            lc_type,
            lp_lc_data,
            cch_data
        );
        let res = api.GetLocaleInfoW(locale, lc_type, lp_lc_data, cch_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNLSVersion(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let locale = call.get_arg();
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNLSVersion");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{function = {:?}, locale = {:?}, lp_version_information = {:?}}}",
            function,
            locale,
            lp_version_information
        );
        let res = api.GetNLSVersion(function, locale, lp_version_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNLSVersionEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let lp_locale_name = call.get_arg();
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNLSVersionEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{function = {:?}, lp_locale_name = {:?}, lp_version_information = {:?}}}",
            function,
            lp_locale_name,
            lp_version_information
        );
        let res = api.GetNLSVersionEx(function, lp_locale_name, lp_version_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_number_str = call.get_arg();
        let cch_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumberFormatA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_number_str = {:?}, cch_number = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_number_str , cch_number );
        let res = api.GetNumberFormatA(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_number_str,
            cch_number,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_number_str = call.get_arg();
        let cch_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumberFormatEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_number_str = {:?}, cch_number = {:?}}}" , lp_locale_name , dw_flags , lp_value , lp_format , lp_number_str , cch_number );
        let res = api.GetNumberFormatEx(
            lp_locale_name,
            dw_flags,
            lp_value,
            lp_format,
            lp_number_str,
            cch_number,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_value = call.get_arg();
        let lp_format = call.get_arg();
        let lp_number_str = call.get_arg();
        let cch_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumberFormatW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_value = {:?}, lp_format = {:?}, lp_number_str = {:?}, cch_number = {:?}}}" , locale , dw_flags , lp_value , lp_format , lp_number_str , cch_number );
        let res = api.GetNumberFormatW(
            locale,
            dw_flags,
            lp_value,
            lp_format,
            lp_number_str,
            cch_number,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOEMCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetOEMCP");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetOEMCP();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessPreferredUILanguages");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer );
        let res = api.GetProcessPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringScripts(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_string = call.get_arg();
        let cch_string = call.get_arg();
        let lp_scripts = call.get_arg();
        let cch_scripts = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStringScripts");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lp_string = {:?}, cch_string = {:?}, lp_scripts = {:?}, cch_scripts = {:?}}}" , dw_flags , lp_string , cch_string , lp_scripts , cch_scripts );
        let res = api.GetStringScripts(dw_flags, lp_string, cch_string, lp_scripts, cch_scripts);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStringTypeA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , locale , dw_info_type , lp_src_str , cch_src , lp_char_type );
        let res = api.GetStringTypeA(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStringTypeExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , locale , dw_info_type , lp_src_str , cch_src , lp_char_type );
        let res = api.GetStringTypeExA(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStringTypeExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , locale , dw_info_type , lp_src_str , cch_src , lp_char_type );
        let res = api.GetStringTypeExW(locale, dw_info_type, lp_src_str, cch_src, lp_char_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStringTypeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_info_type = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_char_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStringTypeW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_info_type = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_char_type = {:?}}}" , dw_info_type , lp_src_str , cch_src , lp_char_type );
        let res = api.GetStringTypeW(dw_info_type, lp_src_str, cch_src, lp_char_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemDefaultLCID");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetSystemDefaultLCID();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLangID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemDefaultLangID");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetSystemDefaultLangID();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let cch_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemDefaultLocaleName");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_locale_name = {:?}, cch_locale_name = {:?}}}",
            lp_locale_name,
            cch_locale_name
        );
        let res = api.GetSystemDefaultLocaleName(lp_locale_name, cch_locale_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDefaultUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemDefaultUILanguage");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetSystemDefaultUILanguage();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemPreferredUILanguages");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer );
        let res = api.GetSystemPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadLocale");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetThreadLocale();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadPreferredUILanguages");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer );
        let res = api.GetThreadPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadUILanguage");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetThreadUILanguage();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_time = call.get_arg();
        let lp_format = call.get_arg();
        let lp_time_str = call.get_arg();
        let cch_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTimeFormatA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_time = {:?}, lp_format = {:?}, lp_time_str = {:?}, cch_time = {:?}}}" , locale , dw_flags , lp_time , lp_format , lp_time_str , cch_time );
        let res = api.GetTimeFormatA(locale, dw_flags, lp_time, lp_format, lp_time_str, cch_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_time = call.get_arg();
        let lp_format = call.get_arg();
        let lp_time_str = call.get_arg();
        let cch_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTimeFormatEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_flags = {:?}, lp_time = {:?}, lp_format = {:?}, lp_time_str = {:?}, cch_time = {:?}}}" , lp_locale_name , dw_flags , lp_time , lp_format , lp_time_str , cch_time );
        let res = api.GetTimeFormatEx(
            lp_locale_name,
            dw_flags,
            lp_time,
            lp_format,
            lp_time_str,
            cch_time,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTimeFormatW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_time = call.get_arg();
        let lp_format = call.get_arg();
        let lp_time_str = call.get_arg();
        let cch_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTimeFormatW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_flags = {:?}, lp_time = {:?}, lp_format = {:?}, lp_time_str = {:?}, cch_time = {:?}}}" , locale , dw_flags , lp_time , lp_format , lp_time_str , cch_time );
        let res = api.GetTimeFormatW(locale, dw_flags, lp_time, lp_format, lp_time_str, cch_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUILanguageInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pwmsz_language = call.get_arg();
        let pwsz_fallback_languages = call.get_arg();
        let pcch_fallback_languages = call.get_arg();
        let p_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUILanguageInfo");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pwmsz_language = {:?}, pwsz_fallback_languages = {:?}, pcch_fallback_languages = {:?}, p_attributes = {:?}}}" , dw_flags , pwmsz_language , pwsz_fallback_languages , pcch_fallback_languages , p_attributes );
        let res = api.GetUILanguageInfo(
            dw_flags,
            pwmsz_language,
            pwsz_fallback_languages,
            pcch_fallback_languages,
            p_attributes,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultGeoName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_name = call.get_arg();
        let geo_name_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserDefaultGeoName");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{geo_name = {:?}, geo_name_count = {:?}}}",
            geo_name,
            geo_name_count
        );
        let res = api.GetUserDefaultGeoName(geo_name, geo_name_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserDefaultLCID");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetUserDefaultLCID();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLangID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserDefaultLangID");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetUserDefaultLangID();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let cch_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserDefaultLocaleName");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_locale_name = {:?}, cch_locale_name = {:?}}}",
            lp_locale_name,
            cch_locale_name
        );
        let res = api.GetUserDefaultLocaleName(lp_locale_name, cch_locale_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserDefaultUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserDefaultUILanguage");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetUserDefaultUILanguage();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserGeoID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_class = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserGeoID");
        let _enter = span.enter();
        tracing::trace!("  args = {{geo_class = {:?}}}", geo_class);
        let res = api.GetUserGeoID(geo_class);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pul_num_languages = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pcch_languages_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserPreferredUILanguages");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pul_num_languages = {:?}, pwsz_languages_buffer = {:?}, pcch_languages_buffer = {:?}}}" , dw_flags , pul_num_languages , pwsz_languages_buffer , pcch_languages_buffer );
        let res = api.GetUserPreferredUILanguages(
            dw_flags,
            pul_num_languages,
            pwsz_languages_buffer,
            pcch_languages_buffer,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IdnToAscii(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_unicode_char_str = call.get_arg();
        let cch_unicode_char = call.get_arg();
        let lp_ascii_char_str = call.get_arg();
        let cch_ascii_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IdnToAscii");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lp_unicode_char_str = {:?}, cch_unicode_char = {:?}, lp_ascii_char_str = {:?}, cch_ascii_char = {:?}}}" , dw_flags , lp_unicode_char_str , cch_unicode_char , lp_ascii_char_str , cch_ascii_char );
        let res = api.IdnToAscii(
            dw_flags,
            lp_unicode_char_str,
            cch_unicode_char,
            lp_ascii_char_str,
            cch_ascii_char,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IdnToNameprepUnicode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_unicode_char_str = call.get_arg();
        let cch_unicode_char = call.get_arg();
        let lp_nameprep_char_str = call.get_arg();
        let cch_nameprep_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IdnToNameprepUnicode");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lp_unicode_char_str = {:?}, cch_unicode_char = {:?}, lp_nameprep_char_str = {:?}, cch_nameprep_char = {:?}}}" , dw_flags , lp_unicode_char_str , cch_unicode_char , lp_nameprep_char_str , cch_nameprep_char );
        let res = api.IdnToNameprepUnicode(
            dw_flags,
            lp_unicode_char_str,
            cch_unicode_char,
            lp_nameprep_char_str,
            cch_nameprep_char,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IdnToUnicode(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_ascii_char_str = call.get_arg();
        let cch_ascii_char = call.get_arg();
        let lp_unicode_char_str = call.get_arg();
        let cch_unicode_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IdnToUnicode");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lp_ascii_char_str = {:?}, cch_ascii_char = {:?}, lp_unicode_char_str = {:?}, cch_unicode_char = {:?}}}" , dw_flags , lp_ascii_char_str , cch_ascii_char , lp_unicode_char_str , cch_unicode_char );
        let res = api.IdnToUnicode(
            dw_flags,
            lp_ascii_char_str,
            cch_ascii_char,
            lp_unicode_char_str,
            cch_unicode_char,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDBCSLeadByte(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let test_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsDBCSLeadByte");
        let _enter = span.enter();
        tracing::trace!("  args = {{test_char = {:?}}}", test_char);
        let res = api.IsDBCSLeadByte(test_char);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDBCSLeadByteEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let test_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsDBCSLeadByteEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{code_page = {:?}, test_char = {:?}}}",
            code_page,
            test_char
        );
        let res = api.IsDBCSLeadByteEx(code_page, test_char);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNLSDefinedString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_string = call.get_arg();
        let cch_str = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsNLSDefinedString");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{function = {:?}, dw_flags = {:?}, lp_version_information = {:?}, lp_string = {:?}, cch_str = {:?}}}" , function , dw_flags , lp_version_information , lp_string , cch_str );
        let res = api.IsNLSDefinedString(
            function,
            dw_flags,
            lp_version_information,
            lp_string,
            cch_str,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNormalizedString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let norm_form = call.get_arg();
        let lp_string = call.get_arg();
        let cw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsNormalizedString");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{norm_form = {:?}, lp_string = {:?}, cw_length = {:?}}}",
            norm_form,
            lp_string,
            cw_length
        );
        let res = api.IsNormalizedString(norm_form, lp_string, cw_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsTextUnicode(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpv = call.get_arg();
        let i_size = call.get_arg();
        let lpi_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsTextUnicode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpv = {:?}, i_size = {:?}, lpi_result = {:?}}}",
            lpv,
            i_size,
            lpi_result
        );
        let res = api.IsTextUnicode(lpv, i_size, lpi_result);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidCodePage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsValidCodePage");
        let _enter = span.enter();
        tracing::trace!("  args = {{code_page = {:?}}}", code_page);
        let res = api.IsValidCodePage(code_page);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidLanguageGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let language_group = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsValidLanguageGroup");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{language_group = {:?}, dw_flags = {:?}}}",
            language_group,
            dw_flags
        );
        let res = api.IsValidLanguageGroup(language_group, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidLocale(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsValidLocale");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, dw_flags = {:?}}}",
            locale,
            dw_flags
        );
        let res = api.IsValidLocale(locale, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsValidLocaleName");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_locale_name = {:?}}}", lp_locale_name);
        let res = api.IsValidLocaleName(lp_locale_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsValidNLSVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let lp_locale_name = call.get_arg();
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsValidNLSVersion");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{function = {:?}, lp_locale_name = {:?}, lp_version_information = {:?}}}",
            function,
            lp_locale_name,
            lp_version_information
        );
        let res = api.IsValidNLSVersion(function, lp_locale_name, lp_version_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWellFormedTag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_tag = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsWellFormedTag");
        let _enter = span.enter();
        tracing::trace!("  args = {{psz_tag = {:?}}}", psz_tag);
        let res = api.IsWellFormedTag(psz_tag);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCIDToLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lp_name = call.get_arg();
        let cch_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LCIDToLocaleName");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, lp_name = {:?}, cch_name = {:?}, dw_flags = {:?}}}",
            locale,
            lp_name,
            cch_name,
            dw_flags
        );
        let res = api.LCIDToLocaleName(locale, lp_name, cch_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCMapStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LCMapStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , locale , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest );
        let res = api.LCMapStringA(
            locale,
            dw_map_flags,
            lp_src_str,
            cch_src,
            lp_dest_str,
            cch_dest,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCMapStringEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_locale_name = call.get_arg();
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let lp_version_information = call.get_arg();
        let lp_reserved = call.get_arg();
        let sort_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LCMapStringEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_locale_name = {:?}, dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}, lp_version_information = {:?}, lp_reserved = {:?}, sort_handle = {:?}}}" , lp_locale_name , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest , lp_version_information , lp_reserved , sort_handle );
        let res = api.LCMapStringEx(
            lp_locale_name,
            dw_map_flags,
            lp_src_str,
            cch_src,
            lp_dest_str,
            cch_dest,
            lp_version_information,
            lp_reserved,
            sort_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LCMapStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let dw_map_flags = call.get_arg();
        let lp_src_str = call.get_arg();
        let cch_src = call.get_arg();
        let lp_dest_str = call.get_arg();
        let cch_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LCMapStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{locale = {:?}, dw_map_flags = {:?}, lp_src_str = {:?}, cch_src = {:?}, lp_dest_str = {:?}, cch_dest = {:?}}}" , locale , dw_map_flags , lp_src_str , cch_src , lp_dest_str , cch_dest );
        let res = api.LCMapStringW(
            locale,
            dw_map_flags,
            lp_src_str,
            cch_src,
            lp_dest_str,
            cch_dest,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocaleNameToLCID(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocaleNameToLCID");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, dw_flags = {:?}}}",
            lp_name,
            dw_flags
        );
        let res = api.LocaleNameToLCID(lp_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingDoAction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_bag = call.get_arg();
        let dw_range_index = call.get_arg();
        let psz_action_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MappingDoAction");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{p_bag = {:?}, dw_range_index = {:?}, psz_action_id = {:?}}}",
            p_bag,
            dw_range_index,
            psz_action_id
        );
        let res = api.MappingDoAction(p_bag, dw_range_index, psz_action_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingFreePropertyBag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_bag = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MappingFreePropertyBag");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_bag = {:?}}}", p_bag);
        let res = api.MappingFreePropertyBag(p_bag);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingFreeServices(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_service_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MappingFreeServices");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_service_info = {:?}}}", p_service_info);
        let res = api.MappingFreeServices(p_service_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingGetServices(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_options = call.get_arg();
        let prg_services = call.get_arg();
        let pdw_services_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MappingGetServices");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{p_options = {:?}, prg_services = {:?}, pdw_services_count = {:?}}}",
            p_options,
            prg_services,
            pdw_services_count
        );
        let res = api.MappingGetServices(p_options, prg_services, pdw_services_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MappingRecognizeText(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_service_info = call.get_arg();
        let psz_text = call.get_arg();
        let dw_length = call.get_arg();
        let dw_index = call.get_arg();
        let p_options = call.get_arg();
        let pbag = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MappingRecognizeText");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{p_service_info = {:?}, psz_text = {:?}, dw_length = {:?}, dw_index = {:?}, p_options = {:?}, pbag = {:?}}}" , p_service_info , psz_text , dw_length , dw_index , p_options , pbag );
        let res = api.MappingRecognizeText(
            p_service_info,
            psz_text,
            dw_length,
            dw_index,
            p_options,
            pbag,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MultiByteToWideChar(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_multi_byte_str = call.get_arg();
        let cb_multi_byte = call.get_arg();
        let lp_wide_char_str = call.get_arg();
        let cch_wide_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MultiByteToWideChar");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{code_page = {:?}, dw_flags = {:?}, lp_multi_byte_str = {:?}, cb_multi_byte = {:?}, lp_wide_char_str = {:?}, cch_wide_char = {:?}}}" , code_page , dw_flags , lp_multi_byte_str , cb_multi_byte , lp_wide_char_str , cch_wide_char );
        let res = api.MultiByteToWideChar(
            code_page,
            dw_flags,
            lp_multi_byte_str,
            cb_multi_byte,
            lp_wide_char_str,
            cch_wide_char,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NormalizeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let norm_form = call.get_arg();
        let lp_src_string = call.get_arg();
        let cw_src_length = call.get_arg();
        let lp_dst_string = call.get_arg();
        let cw_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NormalizeString");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{norm_form = {:?}, lp_src_string = {:?}, cw_src_length = {:?}, lp_dst_string = {:?}, cw_dst_length = {:?}}}" , norm_form , lp_src_string , cw_src_length , lp_dst_string , cw_dst_length );
        let res = api.NormalizeString(
            norm_form,
            lp_src_string,
            cw_src_length,
            lp_dst_string,
            cw_dst_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NotifyUILanguageChange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pcwstr_new_language = call.get_arg();
        let pcwstr_previous_language = call.get_arg();
        let dw_reserved = call.get_arg();
        let pdw_status_rtrn = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NotifyUILanguageChange");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, pcwstr_new_language = {:?}, pcwstr_previous_language = {:?}, dw_reserved = {:?}, pdw_status_rtrn = {:?}}}" , dw_flags , pcwstr_new_language , pcwstr_previous_language , dw_reserved , pdw_status_rtrn );
        let res = api.NotifyUILanguageChange(
            dw_flags,
            pcwstr_new_language,
            pcwstr_previous_language,
            dw_reserved,
            pdw_status_rtrn,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResolveLocaleName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name_to_resolve = call.get_arg();
        let lp_locale_name = call.get_arg();
        let cch_locale_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ResolveLocaleName");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name_to_resolve = {:?}, lp_locale_name = {:?}, cch_locale_name = {:?}}}",
            lp_name_to_resolve,
            lp_locale_name,
            cch_locale_name
        );
        let res = api.ResolveLocaleName(lp_name_to_resolve, lp_locale_name, cch_locale_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RestoreThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let snapshot = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RestoreThreadPreferredUILanguages");
        let _enter = span.enter();
        tracing::trace!("  args = {{snapshot = {:?}}}", snapshot);
        let res = api.RestoreThreadPreferredUILanguages(snapshot);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptApplyDigitSubstitution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psds = call.get_arg();
        let psc = call.get_arg();
        let pss = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptApplyDigitSubstitution");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{psds = {:?}, psc = {:?}, pss = {:?}}}",
            psds,
            psc,
            pss
        );
        let res = api.ScriptApplyDigitSubstitution(psds, psc, pss);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptBreak(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_chars = call.get_arg();
        let c_chars = call.get_arg();
        let psa = call.get_arg();
        let psla = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptBreak");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pwc_chars = {:?}, c_chars = {:?}, psa = {:?}, psla = {:?}}}",
            pwc_chars,
            c_chars,
            psa,
            psla
        );
        let res = api.ScriptBreak(pwc_chars, c_chars, psa, psla);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptCPtoX(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let i_cp = call.get_arg();
        let f_trailing = call.get_arg();
        let c_chars = call.get_arg();
        let c_glyphs = call.get_arg();
        let pw_log_clust = call.get_arg();
        let psva = call.get_arg();
        let pi_advance = call.get_arg();
        let psa = call.get_arg();
        let pi_x = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptCPtoX");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{i_cp = {:?}, f_trailing = {:?}, c_chars = {:?}, c_glyphs = {:?}, pw_log_clust = {:?}, psva = {:?}, pi_advance = {:?}, psa = {:?}, pi_x = {:?}}}" , i_cp , f_trailing , c_chars , c_glyphs , pw_log_clust , psva , pi_advance , psa , pi_x );
        let res = api.ScriptCPtoX(
            i_cp,
            f_trailing,
            c_chars,
            c_glyphs,
            pw_log_clust,
            psva,
            pi_advance,
            psa,
            pi_x,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptFreeCache(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptFreeCache");
        let _enter = span.enter();
        tracing::trace!("  args = {{psc = {:?}}}", psc);
        let res = api.ScriptFreeCache(psc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptGetLogicalWidths(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psa = call.get_arg();
        let c_chars = call.get_arg();
        let c_glyphs = call.get_arg();
        let pi_glyph_width = call.get_arg();
        let pw_log_clust = call.get_arg();
        let psva = call.get_arg();
        let pi_dx = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptGetLogicalWidths");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psa = {:?}, c_chars = {:?}, c_glyphs = {:?}, pi_glyph_width = {:?}, pw_log_clust = {:?}, psva = {:?}, pi_dx = {:?}}}" , psa , c_chars , c_glyphs , pi_glyph_width , pw_log_clust , psva , pi_dx );
        let res = api.ScriptGetLogicalWidths(
            psa,
            c_chars,
            c_glyphs,
            pi_glyph_width,
            pw_log_clust,
            psva,
            pi_dx,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptGetProperties(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pp_sp = call.get_arg();
        let pi_num_scripts = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptGetProperties");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pp_sp = {:?}, pi_num_scripts = {:?}}}",
            pp_sp,
            pi_num_scripts
        );
        let res = api.ScriptGetProperties(pp_sp, pi_num_scripts);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptIsComplex(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_in_chars = call.get_arg();
        let c_in_chars = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptIsComplex");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pwc_in_chars = {:?}, c_in_chars = {:?}, dw_flags = {:?}}}",
            pwc_in_chars,
            c_in_chars,
            dw_flags
        );
        let res = api.ScriptIsComplex(pwc_in_chars, c_in_chars, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptItemize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_in_chars = call.get_arg();
        let c_in_chars = call.get_arg();
        let c_max_items = call.get_arg();
        let ps_control = call.get_arg();
        let ps_state = call.get_arg();
        let p_items = call.get_arg();
        let pc_items = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptItemize");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{pwc_in_chars = {:?}, c_in_chars = {:?}, c_max_items = {:?}, ps_control = {:?}, ps_state = {:?}, p_items = {:?}, pc_items = {:?}}}" , pwc_in_chars , c_in_chars , c_max_items , ps_control , ps_state , p_items , pc_items );
        let res = api.ScriptItemize(
            pwc_in_chars,
            c_in_chars,
            c_max_items,
            ps_control,
            ps_state,
            p_items,
            pc_items,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptItemizeOpenType(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwc_in_chars = call.get_arg();
        let c_in_chars = call.get_arg();
        let c_max_items = call.get_arg();
        let ps_control = call.get_arg();
        let ps_state = call.get_arg();
        let p_items = call.get_arg();
        let p_script_tags = call.get_arg();
        let pc_items = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptItemizeOpenType");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{pwc_in_chars = {:?}, c_in_chars = {:?}, c_max_items = {:?}, ps_control = {:?}, ps_state = {:?}, p_items = {:?}, p_script_tags = {:?}, pc_items = {:?}}}" , pwc_in_chars , c_in_chars , c_max_items , ps_control , ps_state , p_items , p_script_tags , pc_items );
        let res = api.ScriptItemizeOpenType(
            pwc_in_chars,
            c_in_chars,
            c_max_items,
            ps_control,
            ps_state,
            p_items,
            p_script_tags,
            pc_items,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptJustify(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psva = call.get_arg();
        let pi_advance = call.get_arg();
        let c_glyphs = call.get_arg();
        let i_dx = call.get_arg();
        let i_min_kashida = call.get_arg();
        let pi_justify = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptJustify");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psva = {:?}, pi_advance = {:?}, c_glyphs = {:?}, i_dx = {:?}, i_min_kashida = {:?}, pi_justify = {:?}}}" , psva , pi_advance , c_glyphs , i_dx , i_min_kashida , pi_justify );
        let res = api.ScriptJustify(psva, pi_advance, c_glyphs, i_dx, i_min_kashida, pi_justify);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptLayout(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let c_runs = call.get_arg();
        let pb_level = call.get_arg();
        let pi_visual_to_logical = call.get_arg();
        let pi_logical_to_visual = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptLayout");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{c_runs = {:?}, pb_level = {:?}, pi_visual_to_logical = {:?}, pi_logical_to_visual = {:?}}}" , c_runs , pb_level , pi_visual_to_logical , pi_logical_to_visual );
        let res = api.ScriptLayout(c_runs, pb_level, pi_visual_to_logical, pi_logical_to_visual);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptRecordDigitSubstitution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let psds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptRecordDigitSubstitution");
        let _enter = span.enter();
        tracing::trace!("  args = {{locale = {:?}, psds = {:?}}}", locale, psds);
        let res = api.ScriptRecordDigitSubstitution(locale, psds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringCPtoX(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let icp = call.get_arg();
        let f_trailing = call.get_arg();
        let p_x = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptStringCPtoX");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ssa = {:?}, icp = {:?}, f_trailing = {:?}, p_x = {:?}}}",
            ssa,
            icp,
            f_trailing,
            p_x
        );
        let res = api.ScriptStringCPtoX(ssa, icp, f_trailing, p_x);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringFree(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptStringFree");
        let _enter = span.enter();
        tracing::trace!("  args = {{pssa = {:?}}}", pssa);
        let res = api.ScriptStringFree(pssa);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringGetLogicalWidths(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let pi_dx = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptStringGetLogicalWidths");
        let _enter = span.enter();
        tracing::trace!("  args = {{ssa = {:?}, pi_dx = {:?}}}", ssa, pi_dx);
        let res = api.ScriptStringGetLogicalWidths(ssa, pi_dx);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringGetOrder(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let pu_order = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptStringGetOrder");
        let _enter = span.enter();
        tracing::trace!("  args = {{ssa = {:?}, pu_order = {:?}}}", ssa, pu_order);
        let res = api.ScriptStringGetOrder(ssa, pu_order);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringValidate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptStringValidate");
        let _enter = span.enter();
        tracing::trace!("  args = {{ssa = {:?}}}", ssa);
        let res = api.ScriptStringValidate(ssa);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptStringXtoCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let i_x = call.get_arg();
        let pi_ch = call.get_arg();
        let pi_trailing = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptStringXtoCP");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ssa = {:?}, i_x = {:?}, pi_ch = {:?}, pi_trailing = {:?}}}",
            ssa,
            i_x,
            pi_ch,
            pi_trailing
        );
        let res = api.ScriptStringXtoCP(ssa, i_x, pi_ch, pi_trailing);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pLogAttr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptString_pLogAttr");
        let _enter = span.enter();
        tracing::trace!("  args = {{ssa = {:?}}}", ssa);
        let res = api.ScriptString_pLogAttr(ssa);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptString_pSize");
        let _enter = span.enter();
        tracing::trace!("  args = {{ssa = {:?}}}", ssa);
        let res = api.ScriptString_pSize(ssa);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptString_pcOutChars(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ssa = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptString_pcOutChars");
        let _enter = span.enter();
        tracing::trace!("  args = {{ssa = {:?}}}", ssa);
        let res = api.ScriptString_pcOutChars(ssa);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScriptXtoCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let i_x = call.get_arg();
        let c_chars = call.get_arg();
        let c_glyphs = call.get_arg();
        let pw_log_clust = call.get_arg();
        let psva = call.get_arg();
        let pi_advance = call.get_arg();
        let psa = call.get_arg();
        let pi_cp = call.get_arg();
        let pi_trailing = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScriptXtoCP");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{i_x = {:?}, c_chars = {:?}, c_glyphs = {:?}, pw_log_clust = {:?}, psva = {:?}, pi_advance = {:?}, psa = {:?}, pi_cp = {:?}, pi_trailing = {:?}}}" , i_x , c_chars , c_glyphs , pw_log_clust , psva , pi_advance , psa , pi_cp , pi_trailing );
        let res = api.ScriptXtoCP(
            i_x,
            c_chars,
            c_glyphs,
            pw_log_clust,
            psva,
            pi_advance,
            psa,
            pi_cp,
            pi_trailing,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCalendarInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCalendarInfoA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}}}",
            locale,
            calendar,
            cal_type,
            lp_cal_data
        );
        let res = api.SetCalendarInfoA(locale, calendar, cal_type, lp_cal_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCalendarInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let calendar = call.get_arg();
        let cal_type = call.get_arg();
        let lp_cal_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCalendarInfoW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, calendar = {:?}, cal_type = {:?}, lp_cal_data = {:?}}}",
            locale,
            calendar,
            cal_type,
            lp_cal_data
        );
        let res = api.SetCalendarInfoW(locale, calendar, cal_type, lp_cal_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLocaleInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetLocaleInfoA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}}}",
            locale,
            lc_type,
            lp_lc_data
        );
        let res = api.SetLocaleInfoA(locale, lc_type, lp_lc_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLocaleInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let lc_type = call.get_arg();
        let lp_lc_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetLocaleInfoW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{locale = {:?}, lc_type = {:?}, lp_lc_data = {:?}}}",
            locale,
            lc_type,
            lp_lc_data
        );
        let res = api.SetLocaleInfoW(locale, lc_type, lp_lc_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pul_num_languages = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessPreferredUILanguages");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, pwsz_languages_buffer = {:?}, pul_num_languages = {:?}}}",
            dw_flags,
            pwsz_languages_buffer,
            pul_num_languages
        );
        let res =
            api.SetProcessPreferredUILanguages(dw_flags, pwsz_languages_buffer, pul_num_languages);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadLocale(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let locale = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadLocale");
        let _enter = span.enter();
        tracing::trace!("  args = {{locale = {:?}}}", locale);
        let res = api.SetThreadLocale(locale);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPreferredUILanguages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let pwsz_languages_buffer = call.get_arg();
        let pul_num_languages = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadPreferredUILanguages");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, pwsz_languages_buffer = {:?}, pul_num_languages = {:?}}}",
            dw_flags,
            pwsz_languages_buffer,
            pul_num_languages
        );
        let res =
            api.SetThreadPreferredUILanguages(dw_flags, pwsz_languages_buffer, pul_num_languages);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPreferredUILanguages2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let languages = call.get_arg();
        let num_languages_set = call.get_arg();
        let snapshot = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadPreferredUILanguages2");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{flags = {:?}, languages = {:?}, num_languages_set = {:?}, snapshot = {:?}}}" , flags , languages , num_languages_set , snapshot );
        let res = api.SetThreadPreferredUILanguages2(flags, languages, num_languages_set, snapshot);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadUILanguage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadUILanguage");
        let _enter = span.enter();
        tracing::trace!("  args = {{lang_id = {:?}}}", lang_id);
        let res = api.SetThreadUILanguage(lang_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetUserGeoID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetUserGeoID");
        let _enter = span.enter();
        tracing::trace!("  args = {{geo_id = {:?}}}", geo_id);
        let res = api.SetUserGeoID(geo_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetUserGeoName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let geo_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetUserGeoName");
        let _enter = span.enter();
        tracing::trace!("  args = {{geo_name = {:?}}}", geo_name);
        let res = api.SetUserGeoName(geo_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateCharsetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_src = call.get_arg();
        let lp_cs = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateCharsetInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_src = {:?}, lp_cs = {:?}, dw_flags = {:?}}}",
            lp_src,
            lp_cs,
            dw_flags
        );
        let res = api.TranslateCharsetInfo(lp_src, lp_cs, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerifyScripts(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_locale_scripts = call.get_arg();
        let cch_locale_scripts = call.get_arg();
        let lp_test_scripts = call.get_arg();
        let cch_test_scripts = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerifyScripts");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lp_locale_scripts = {:?}, cch_locale_scripts = {:?}, lp_test_scripts = {:?}, cch_test_scripts = {:?}}}" , dw_flags , lp_locale_scripts , cch_locale_scripts , lp_test_scripts , cch_test_scripts );
        let res = api.VerifyScripts(
            dw_flags,
            lp_locale_scripts,
            cch_locale_scripts,
            lp_test_scripts,
            cch_test_scripts,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WideCharToMultiByte(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_wide_char_str = call.get_arg();
        let cch_wide_char = call.get_arg();
        let lp_multi_byte_str = call.get_arg();
        let cb_multi_byte = call.get_arg();
        let lp_default_char = call.get_arg();
        let lp_used_default_char = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WideCharToMultiByte");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{code_page = {:?}, dw_flags = {:?}, lp_wide_char_str = {:?}, cch_wide_char = {:?}, lp_multi_byte_str = {:?}, cb_multi_byte = {:?}, lp_default_char = {:?}, lp_used_default_char = {:?}}}" , code_page , dw_flags , lp_wide_char_str , cch_wide_char , lp_multi_byte_str , cb_multi_byte , lp_default_char , lp_used_default_char );
        let res = api.WideCharToMultiByte(
            code_page,
            dw_flags,
            lp_wide_char_str,
            cch_wide_char,
            lp_multi_byte_str,
            cb_multi_byte,
            lp_default_char,
            lp_used_default_char,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcatA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcatA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcatA(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcatW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcatW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcatW(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcmpA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcmpA(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcmpW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcmpW(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpiA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcmpiA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcmpiA(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcmpiW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcmpiW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcmpiW(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpyA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcpyA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcpyA(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpyW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcpyW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}}}",
            lp_string_1,
            lp_string_2
        );
        let res = api.lstrcpyW(lp_string_1, lp_string_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpynA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let i_max_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcpynA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}, i_max_length = {:?}}}",
            lp_string_1,
            lp_string_2,
            i_max_length
        );
        let res = api.lstrcpynA(lp_string_1, lp_string_2, i_max_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrcpynW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string_1 = call.get_arg();
        let lp_string_2 = call.get_arg();
        let i_max_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrcpynW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_string_1 = {:?}, lp_string_2 = {:?}, i_max_length = {:?}}}",
            lp_string_1,
            lp_string_2,
            i_max_length
        );
        let res = api.lstrcpynW(lp_string_1, lp_string_2, i_max_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrlenA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrlenA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_string = {:?}}}", lp_string);
        let res = api.lstrlenA(lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_lstrlenW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Globalization::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("lstrlenW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_string = {:?}}}", lp_string);
        let res = api.lstrlenW(lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AreFileApisANSI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AreFileApisANSI");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.AreFileApisANSI();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AreShortNamesEnabled(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let enabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AreShortNamesEnabled");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{handle = {:?}, enabled = {:?}}}",
            handle,
            enabled
        );
        let res = api.AreShortNamesEnabled(handle, enabled);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BackupRead(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_number_of_bytes_read = call.get_arg();
        let b_abort = call.get_arg();
        let b_process_security = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BackupRead");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_read = {:?}, lp_number_of_bytes_read = {:?}, b_abort = {:?}, b_process_security = {:?}, lp_context = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_read , lp_number_of_bytes_read , b_abort , b_process_security , lp_context );
        let res = api.BackupRead(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_read,
            lp_number_of_bytes_read,
            b_abort,
            b_process_security,
            lp_context,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BackupSeek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let dw_low_bytes_to_seek = call.get_arg();
        let dw_high_bytes_to_seek = call.get_arg();
        let lpdw_low_byte_seeked = call.get_arg();
        let lpdw_high_byte_seeked = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BackupSeek");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, dw_low_bytes_to_seek = {:?}, dw_high_bytes_to_seek = {:?}, lpdw_low_byte_seeked = {:?}, lpdw_high_byte_seeked = {:?}, lp_context = {:?}}}" , h_file , dw_low_bytes_to_seek , dw_high_bytes_to_seek , lpdw_low_byte_seeked , lpdw_high_byte_seeked , lp_context );
        let res = api.BackupSeek(
            h_file,
            dw_low_bytes_to_seek,
            dw_high_bytes_to_seek,
            lpdw_low_byte_seeked,
            lpdw_high_byte_seeked,
            lp_context,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BackupWrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_number_of_bytes_written = call.get_arg();
        let b_abort = call.get_arg();
        let b_process_security = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BackupWrite");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_write = {:?}, lp_number_of_bytes_written = {:?}, b_abort = {:?}, b_process_security = {:?}, lp_context = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_write , lp_number_of_bytes_written , b_abort , b_process_security , lp_context );
        let res = api.BackupWrite(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_write,
            lp_number_of_bytes_written,
            b_abort,
            b_process_security,
            lp_context,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingRegisterBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let count = call.get_arg();
        let buffers = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BuildIoRingRegisterBuffers");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{io_ring = {:?}, count = {:?}, buffers = {:?}, user_data = {:?}}}",
            io_ring,
            count,
            buffers,
            user_data
        );
        let res = api.BuildIoRingRegisterBuffers(io_ring, count, buffers, user_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BuildIoRingRegisterFileHandles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let count = call.get_arg();
        let handles = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BuildIoRingRegisterFileHandles");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{io_ring = {:?}, count = {:?}, handles = {:?}, user_data = {:?}}}",
            io_ring,
            count,
            handles,
            user_data
        );
        let res = api.BuildIoRingRegisterFileHandles(io_ring, count, handles, user_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckNameLegalDOS8Dot3A(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_oem_name = call.get_arg();
        let oem_name_size = call.get_arg();
        let pb_name_contains_spaces = call.get_arg();
        let pb_name_legal = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CheckNameLegalDOS8Dot3A");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_name = {:?}, lp_oem_name = {:?}, oem_name_size = {:?}, pb_name_contains_spaces = {:?}, pb_name_legal = {:?}}}" , lp_name , lp_oem_name , oem_name_size , pb_name_contains_spaces , pb_name_legal );
        let res = api.CheckNameLegalDOS8Dot3A(
            lp_name,
            lp_oem_name,
            oem_name_size,
            pb_name_contains_spaces,
            pb_name_legal,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckNameLegalDOS8Dot3W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_oem_name = call.get_arg();
        let oem_name_size = call.get_arg();
        let pb_name_contains_spaces = call.get_arg();
        let pb_name_legal = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CheckNameLegalDOS8Dot3W");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_name = {:?}, lp_oem_name = {:?}, oem_name_size = {:?}, pb_name_contains_spaces = {:?}, pb_name_legal = {:?}}}" , lp_name , lp_oem_name , oem_name_size , pb_name_contains_spaces , pb_name_legal );
        let res = api.CheckNameLegalDOS8Dot3W(
            lp_name,
            lp_oem_name,
            oem_name_size,
            pb_name_contains_spaces,
            pb_name_legal,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseEncryptedFileRaw");
        let _enter = span.enter();
        tracing::trace!("  args = {{pv_context = {:?}}}", pv_context);
        let res = api.CloseEncryptedFileRaw(pv_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseIoRing");
        let _enter = span.enter();
        tracing::trace!("  args = {{io_ring = {:?}}}", io_ring);
        let res = api.CloseIoRing(io_ring);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CommitComplete");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.CommitComplete(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CommitEnlistment");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.CommitEnlistment(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CommitTransaction");
        let _enter = span.enter();
        tracing::trace!("  args = {{transaction_handle = {:?}}}", transaction_handle);
        let res = api.CommitTransaction(transaction_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CommitTransactionAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CommitTransactionAsync");
        let _enter = span.enter();
        tracing::trace!("  args = {{transaction_handle = {:?}}}", transaction_handle);
        let res = api.CommitTransactionAsync(transaction_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CompareFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_time_1 = call.get_arg();
        let lp_file_time_2 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CompareFileTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_time_1 = {:?}, lp_file_time_2 = {:?}}}",
            lp_file_time_1,
            lp_file_time_2
        );
        let res = api.CompareFileTime(lp_file_time_1, lp_file_time_2);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFile2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwsz_existing_file_name = call.get_arg();
        let pwsz_new_file_name = call.get_arg();
        let p_extended_parameters = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFile2");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{pwsz_existing_file_name = {:?}, pwsz_new_file_name = {:?}, p_extended_parameters = {:?}}}" , pwsz_existing_file_name , pwsz_new_file_name , p_extended_parameters );
        let res = api.CopyFile2(
            pwsz_existing_file_name,
            pwsz_new_file_name,
            p_extended_parameters,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let b_fail_if_exists = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFileA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, b_fail_if_exists = {:?}}}" , lp_existing_file_name , lp_new_file_name , b_fail_if_exists );
        let res = api.CopyFileA(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFileExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags );
        let res = api.CopyFileExA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFileExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags );
        let res = api.CopyFileExW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let b_fail_if_exists = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFileFromAppW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, b_fail_if_exists = {:?}}}" , lp_existing_file_name , lp_new_file_name , b_fail_if_exists );
        let res = api.CopyFileFromAppW(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFileTransactedA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags , h_transaction );
        let res = api.CopyFileTransactedA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let pb_cancel = call.get_arg();
        let dw_copy_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFileTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, pb_cancel = {:?}, dw_copy_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , pb_cancel , dw_copy_flags , h_transaction );
        let res = api.CopyFileTransactedW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            pb_cancel,
            dw_copy_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let b_fail_if_exists = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyFileW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, b_fail_if_exists = {:?}}}" , lp_existing_file_name , lp_new_file_name , b_fail_if_exists );
        let res = api.CopyFileW(lp_existing_file_name, lp_new_file_name, b_fail_if_exists);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyLZFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hf_source = call.get_arg();
        let hf_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyLZFile");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hf_source = {:?}, hf_dest = {:?}}}",
            hf_source,
            hf_dest
        );
        let res = api.CopyLZFile(hf_source, hf_dest);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ioring_version = call.get_arg();
        let flags = call.get_arg();
        let submission_queue_size = call.get_arg();
        let completion_queue_size = call.get_arg();
        let h = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateIoRing");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ioring_version = {:?}, flags = {:?}, submission_queue_size = {:?}, completion_queue_size = {:?}, h = {:?}}}" , ioring_version , flags , submission_queue_size , completion_queue_size , h );
        let res = api.CreateIoRing(
            ioring_version,
            flags,
            submission_queue_size,
            completion_queue_size,
            h,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateSymbolicLinkA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}}}",
            lp_symlink_file_name,
            lp_target_file_name,
            dw_flags
        );
        let res = api.CreateSymbolicLinkA(lp_symlink_file_name, lp_target_file_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateSymbolicLinkTransactedA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_symlink_file_name , lp_target_file_name , dw_flags , h_transaction );
        let res = api.CreateSymbolicLinkTransactedA(
            lp_symlink_file_name,
            lp_target_file_name,
            dw_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateSymbolicLinkTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_symlink_file_name , lp_target_file_name , dw_flags , h_transaction );
        let res = api.CreateSymbolicLinkTransactedW(
            lp_symlink_file_name,
            lp_target_file_name,
            dw_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateSymbolicLinkW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_symlink_file_name = call.get_arg();
        let lp_target_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateSymbolicLinkW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_symlink_file_name = {:?}, lp_target_file_name = {:?}, dw_flags = {:?}}}",
            lp_symlink_file_name,
            lp_target_file_name,
            dw_flags
        );
        let res = api.CreateSymbolicLinkW(lp_symlink_file_name, lp_target_file_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateTapePartition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_partition_method = call.get_arg();
        let dw_count = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateTapePartition");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_device = {:?}, dw_partition_method = {:?}, dw_count = {:?}, dw_size = {:?}}}" , h_device , dw_partition_method , dw_count , dw_size );
        let res = api.CreateTapePartition(h_device, dw_partition_method, dw_count, dw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DecryptFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DecryptFileA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, dw_reserved = {:?}}}",
            lp_file_name,
            dw_reserved
        );
        let res = api.DecryptFileA(lp_file_name, dw_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DecryptFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DecryptFileW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, dw_reserved = {:?}}}",
            lp_file_name,
            dw_reserved
        );
        let res = api.DecryptFileW(lp_file_name, dw_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefineDosDeviceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefineDosDeviceA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, lp_device_name = {:?}, lp_target_path = {:?}}}",
            dw_flags,
            lp_device_name,
            lp_target_path
        );
        let res = api.DefineDosDeviceA(dw_flags, lp_device_name, lp_target_path);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefineDosDeviceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefineDosDeviceW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, lp_device_name = {:?}, lp_target_path = {:?}}}",
            dw_flags,
            lp_device_name,
            lp_target_path
        );
        let res = api.DefineDosDeviceW(dw_flags, lp_device_name, lp_target_path);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteFileA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.DeleteFileA(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteFileFromAppW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.DeleteFileFromAppW(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteFileTransactedA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, h_transaction = {:?}}}",
            lp_file_name,
            h_transaction
        );
        let res = api.DeleteFileTransactedA(lp_file_name, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteFileTransactedW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, h_transaction = {:?}}}",
            lp_file_name,
            h_transaction
        );
        let res = api.DeleteFileTransactedW(lp_file_name, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteFileW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.DeleteFileW(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteVolumeMountPointA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_volume_mount_point = {:?}}}",
            lpsz_volume_mount_point
        );
        let res = api.DeleteVolumeMountPointA(lpsz_volume_mount_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteVolumeMountPointW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_volume_mount_point = {:?}}}",
            lpsz_volume_mount_point
        );
        let res = api.DeleteVolumeMountPointW(lpsz_volume_mount_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EncryptFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EncryptFileA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.EncryptFileA(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EncryptFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EncryptFileW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.EncryptFileW(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EncryptionDisable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dir_path = call.get_arg();
        let disable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EncryptionDisable");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dir_path = {:?}, disable = {:?}}}",
            dir_path,
            disable
        );
        let res = api.EncryptionDisable(dir_path, disable);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EraseTape(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_erase_type = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EraseTape");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_device = {:?}, dw_erase_type = {:?}, b_immediate = {:?}}}",
            h_device,
            dw_erase_type,
            b_immediate
        );
        let res = api.EraseTape(h_device, dw_erase_type, b_immediate);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileEncryptionStatusA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_status = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileEncryptionStatusA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_status = {:?}}}",
            lp_file_name,
            lp_status
        );
        let res = api.FileEncryptionStatusA(lp_file_name, lp_status);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileEncryptionStatusW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_status = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileEncryptionStatusW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_status = {:?}}}",
            lp_file_name,
            lp_status
        );
        let res = api.FileEncryptionStatusW(lp_file_name, lp_status);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileTimeToLocalFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_time = call.get_arg();
        let lp_local_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileTimeToLocalFileTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_time = {:?}, lp_local_file_time = {:?}}}",
            lp_file_time,
            lp_local_file_time
        );
        let res = api.FileTimeToLocalFileTime(lp_file_time, lp_local_file_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindClose");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_find_file = {:?}}}", h_find_file);
        let res = api.FindClose(h_find_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindCloseChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_change_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindCloseChangeNotification");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_change_handle = {:?}}}", h_change_handle);
        let res = api.FindCloseChangeNotification(h_change_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstChangeNotificationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstChangeNotificationA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_path_name = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}}}",
            lp_path_name,
            b_watch_subtree,
            dw_notify_filter
        );
        let res = api.FindFirstChangeNotificationA(lp_path_name, b_watch_subtree, dw_notify_filter);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstChangeNotificationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstChangeNotificationW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_path_name = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}}}",
            lp_path_name,
            b_watch_subtree,
            dw_notify_filter
        );
        let res = api.FindFirstChangeNotificationW(lp_path_name, b_watch_subtree, dw_notify_filter);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_find_file_data = {:?}}}",
            lp_file_name,
            lp_find_file_data
        );
        let res = api.FindFirstFileA(lp_file_name, lp_find_file_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags );
        let res = api.FindFirstFileExA(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileExFromAppW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags );
        let res = api.FindFirstFileExFromAppW(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags );
        let res = api.FindFirstFileExW(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let string_length = call.get_arg();
        let link_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileNameTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, dw_flags = {:?}, string_length = {:?}, link_name = {:?}, h_transaction = {:?}}}" , lp_file_name , dw_flags , string_length , link_name , h_transaction );
        let res = api.FindFirstFileNameTransactedW(
            lp_file_name,
            dw_flags,
            string_length,
            link_name,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let string_length = call.get_arg();
        let link_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileNameW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, dw_flags = {:?}, string_length = {:?}, link_name = {:?}}}" , lp_file_name , dw_flags , string_length , link_name );
        let res = api.FindFirstFileNameW(lp_file_name, dw_flags, string_length, link_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileTransactedA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags , h_transaction );
        let res = api.FindFirstFileTransactedA(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let f_search_op = call.get_arg();
        let lp_search_filter = call.get_arg();
        let dw_additional_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_find_file_data = {:?}, f_search_op = {:?}, lp_search_filter = {:?}, dw_additional_flags = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_find_file_data , f_search_op , lp_search_filter , dw_additional_flags , h_transaction );
        let res = api.FindFirstFileTransactedW(
            lp_file_name,
            f_info_level_id,
            lp_find_file_data,
            f_search_op,
            lp_search_filter,
            dw_additional_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstFileW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_find_file_data = {:?}}}",
            lp_file_name,
            lp_find_file_data
        );
        let res = api.FindFirstFileW(lp_file_name, lp_find_file_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstStreamTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let info_level = call.get_arg();
        let lp_find_stream_data = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstStreamTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, info_level = {:?}, lp_find_stream_data = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_file_name , info_level , lp_find_stream_data , dw_flags , h_transaction );
        let res = api.FindFirstStreamTransactedW(
            lp_file_name,
            info_level,
            lp_find_stream_data,
            dw_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstStreamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let info_level = call.get_arg();
        let lp_find_stream_data = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstStreamW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, info_level = {:?}, lp_find_stream_data = {:?}, dw_flags = {:?}}}" , lp_file_name , info_level , lp_find_stream_data , dw_flags );
        let res = api.FindFirstStreamW(lp_file_name, info_level, lp_find_stream_data, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstVolumeA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}",
            lpsz_volume_name,
            cch_buffer_length
        );
        let res = api.FindFirstVolumeA(lpsz_volume_name, cch_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_root_path_name = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstVolumeMountPointA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_root_path_name = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , lpsz_root_path_name , lpsz_volume_mount_point , cch_buffer_length );
        let res = api.FindFirstVolumeMountPointA(
            lpsz_root_path_name,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_root_path_name = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstVolumeMountPointW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_root_path_name = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , lpsz_root_path_name , lpsz_volume_mount_point , cch_buffer_length );
        let res = api.FindFirstVolumeMountPointW(
            lpsz_root_path_name,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindFirstVolumeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindFirstVolumeW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}",
            lpsz_volume_name,
            cch_buffer_length
        );
        let res = api.FindFirstVolumeW(lpsz_volume_name, cch_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_change_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextChangeNotification");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_change_handle = {:?}}}", h_change_handle);
        let res = api.FindNextChangeNotification(h_change_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_file = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextFileA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_find_file = {:?}, lp_find_file_data = {:?}}}",
            h_find_file,
            lp_find_file_data
        );
        let res = api.FindNextFileA(h_find_file, lp_find_file_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_stream = call.get_arg();
        let string_length = call.get_arg();
        let link_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextFileNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_find_stream = {:?}, string_length = {:?}, link_name = {:?}}}",
            h_find_stream,
            string_length,
            link_name
        );
        let res = api.FindNextFileNameW(h_find_stream, string_length, link_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_file = call.get_arg();
        let lp_find_file_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextFileW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_find_file = {:?}, lp_find_file_data = {:?}}}",
            h_find_file,
            lp_find_file_data
        );
        let res = api.FindNextFileW(h_find_file, lp_find_file_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextStreamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_stream = call.get_arg();
        let lp_find_stream_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextStreamW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_find_stream = {:?}, lp_find_stream_data = {:?}}}",
            h_find_stream,
            lp_find_stream_data
        );
        let res = api.FindNextStreamW(h_find_stream, lp_find_stream_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextVolumeA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_find_volume = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}",
            h_find_volume,
            lpsz_volume_name,
            cch_buffer_length
        );
        let res = api.FindNextVolumeA(h_find_volume, lpsz_volume_name, cch_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume_mount_point = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextVolumeMountPointA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_find_volume_mount_point = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , h_find_volume_mount_point , lpsz_volume_mount_point , cch_buffer_length );
        let res = api.FindNextVolumeMountPointA(
            h_find_volume_mount_point,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume_mount_point = call.get_arg();
        let lpsz_volume_mount_point = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextVolumeMountPointW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_find_volume_mount_point = {:?}, lpsz_volume_mount_point = {:?}, cch_buffer_length = {:?}}}" , h_find_volume_mount_point , lpsz_volume_mount_point , cch_buffer_length );
        let res = api.FindNextVolumeMountPointW(
            h_find_volume_mount_point,
            lpsz_volume_mount_point,
            cch_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindNextVolumeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindNextVolumeW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_find_volume = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}",
            h_find_volume,
            lpsz_volume_name,
            cch_buffer_length
        );
        let res = api.FindNextVolumeW(h_find_volume, lpsz_volume_name, cch_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindVolumeClose(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindVolumeClose");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_find_volume = {:?}}}", h_find_volume);
        let res = api.FindVolumeClose(h_find_volume);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindVolumeMountPointClose(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_find_volume_mount_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindVolumeMountPointClose");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_find_volume_mount_point = {:?}}}",
            h_find_volume_mount_point
        );
        let res = api.FindVolumeMountPointClose(h_find_volume_mount_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushFileBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlushFileBuffers");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_file = {:?}}}", h_file);
        let res = api.FlushFileBuffers(h_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeEncryptedFileMetadata(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pb_metadata = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeEncryptedFileMetadata");
        let _enter = span.enter();
        tracing::trace!("  args = {{pb_metadata = {:?}}}", pb_metadata);
        let res = api.FreeEncryptedFileMetadata(pb_metadata);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetBinaryTypeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_application_name = call.get_arg();
        let lp_binary_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetBinaryTypeA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_application_name = {:?}, lp_binary_type = {:?}}}",
            lp_application_name,
            lp_binary_type
        );
        let res = api.GetBinaryTypeA(lp_application_name, lp_binary_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetBinaryTypeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_application_name = call.get_arg();
        let lp_binary_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetBinaryTypeW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_application_name = {:?}, lp_binary_type = {:?}}}",
            lp_application_name,
            lp_binary_type
        );
        let res = api.GetBinaryTypeW(lp_application_name, lp_binary_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCompressedFileSizeA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_file_size_high = {:?}}}",
            lp_file_name,
            lp_file_size_high
        );
        let res = api.GetCompressedFileSizeA(lp_file_name, lp_file_size_high);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCompressedFileSizeTransactedA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_file_size_high = {:?}, h_transaction = {:?}}}",
            lp_file_name,
            lp_file_size_high,
            h_transaction
        );
        let res =
            api.GetCompressedFileSizeTransactedA(lp_file_name, lp_file_size_high, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCompressedFileSizeTransactedW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_file_size_high = {:?}, h_transaction = {:?}}}",
            lp_file_name,
            lp_file_size_high,
            h_transaction
        );
        let res =
            api.GetCompressedFileSizeTransactedW(lp_file_name, lp_file_size_high, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCompressedFileSizeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCompressedFileSizeW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_file_size_high = {:?}}}",
            lp_file_name,
            lp_file_size_high
        );
        let res = api.GetCompressedFileSizeW(lp_file_name, lp_file_size_high);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentClockTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentClockTransactionManager");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{transaction_manager_handle = {:?}, tm_virtual_clock = {:?}}}",
            transaction_manager_handle,
            tm_virtual_clock
        );
        let res =
            api.GetCurrentClockTransactionManager(transaction_manager_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_sectors_per_cluster = call.get_arg();
        let lp_bytes_per_sector = call.get_arg();
        let lp_number_of_free_clusters = call.get_arg();
        let lp_total_number_of_clusters = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDiskFreeSpaceA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_root_path_name = {:?}, lp_sectors_per_cluster = {:?}, lp_bytes_per_sector = {:?}, lp_number_of_free_clusters = {:?}, lp_total_number_of_clusters = {:?}}}" , lp_root_path_name , lp_sectors_per_cluster , lp_bytes_per_sector , lp_number_of_free_clusters , lp_total_number_of_clusters );
        let res = api.GetDiskFreeSpaceA(
            lp_root_path_name,
            lp_sectors_per_cluster,
            lp_bytes_per_sector,
            lp_number_of_free_clusters,
            lp_total_number_of_clusters,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_directory_name = call.get_arg();
        let lp_free_bytes_available_to_caller = call.get_arg();
        let lp_total_number_of_bytes = call.get_arg();
        let lp_total_number_of_free_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDiskFreeSpaceExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_directory_name = {:?}, lp_free_bytes_available_to_caller = {:?}, lp_total_number_of_bytes = {:?}, lp_total_number_of_free_bytes = {:?}}}" , lp_directory_name , lp_free_bytes_available_to_caller , lp_total_number_of_bytes , lp_total_number_of_free_bytes );
        let res = api.GetDiskFreeSpaceExA(
            lp_directory_name,
            lp_free_bytes_available_to_caller,
            lp_total_number_of_bytes,
            lp_total_number_of_free_bytes,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_directory_name = call.get_arg();
        let lp_free_bytes_available_to_caller = call.get_arg();
        let lp_total_number_of_bytes = call.get_arg();
        let lp_total_number_of_free_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDiskFreeSpaceExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_directory_name = {:?}, lp_free_bytes_available_to_caller = {:?}, lp_total_number_of_bytes = {:?}, lp_total_number_of_free_bytes = {:?}}}" , lp_directory_name , lp_free_bytes_available_to_caller , lp_total_number_of_bytes , lp_total_number_of_free_bytes );
        let res = api.GetDiskFreeSpaceExW(
            lp_directory_name,
            lp_free_bytes_available_to_caller,
            lp_total_number_of_bytes,
            lp_total_number_of_free_bytes,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskFreeSpaceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_sectors_per_cluster = call.get_arg();
        let lp_bytes_per_sector = call.get_arg();
        let lp_number_of_free_clusters = call.get_arg();
        let lp_total_number_of_clusters = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDiskFreeSpaceW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_root_path_name = {:?}, lp_sectors_per_cluster = {:?}, lp_bytes_per_sector = {:?}, lp_number_of_free_clusters = {:?}, lp_total_number_of_clusters = {:?}}}" , lp_root_path_name , lp_sectors_per_cluster , lp_bytes_per_sector , lp_number_of_free_clusters , lp_total_number_of_clusters );
        let res = api.GetDiskFreeSpaceW(
            lp_root_path_name,
            lp_sectors_per_cluster,
            lp_bytes_per_sector,
            lp_number_of_free_clusters,
            lp_total_number_of_clusters,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskSpaceInformationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let root_path = call.get_arg();
        let disk_space_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDiskSpaceInformationA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{root_path = {:?}, disk_space_info = {:?}}}",
            root_path,
            disk_space_info
        );
        let res = api.GetDiskSpaceInformationA(root_path, disk_space_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDiskSpaceInformationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let root_path = call.get_arg();
        let disk_space_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDiskSpaceInformationW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{root_path = {:?}, disk_space_info = {:?}}}",
            root_path,
            disk_space_info
        );
        let res = api.GetDiskSpaceInformationW(root_path, disk_space_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDriveTypeA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDriveTypeA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_root_path_name = {:?}}}", lp_root_path_name);
        let res = api.GetDriveTypeA(lp_root_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDriveTypeW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDriveTypeW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_root_path_name = {:?}}}", lp_root_path_name);
        let res = api.GetDriveTypeW(lp_root_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEncryptedFileMetadata(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let pcb_metadata = call.get_arg();
        let ppb_metadata = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetEncryptedFileMetadata");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, pcb_metadata = {:?}, ppb_metadata = {:?}}}",
            lp_file_name,
            pcb_metadata,
            ppb_metadata
        );
        let res = api.GetEncryptedFileMetadata(lp_file_name, pcb_metadata, ppb_metadata);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnlistmentId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let enlistment_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetEnlistmentId");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, enlistment_id = {:?}}}",
            enlistment_handle,
            enlistment_id
        );
        let res = api.GetEnlistmentId(enlistment_handle, enlistment_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnlistmentRecoveryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let buffer_size = call.get_arg();
        let buffer = call.get_arg();
        let buffer_used = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetEnlistmentRecoveryInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{enlistment_handle = {:?}, buffer_size = {:?}, buffer = {:?}, buffer_used = {:?}}}" , enlistment_handle , buffer_size , buffer , buffer_used );
        let res = api.GetEnlistmentRecoveryInformation(
            enlistment_handle,
            buffer_size,
            buffer,
            buffer_used,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExpandedNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_source = call.get_arg();
        let lpsz_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetExpandedNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_source = {:?}, lpsz_buffer = {:?}}}",
            lpsz_source,
            lpsz_buffer
        );
        let res = api.GetExpandedNameA(lpsz_source, lpsz_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExpandedNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_source = call.get_arg();
        let lpsz_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetExpandedNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_source = {:?}, lpsz_buffer = {:?}}}",
            lpsz_source,
            lpsz_buffer
        );
        let res = api.GetExpandedNameW(lpsz_source, lpsz_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileAttributesA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.GetFileAttributesA(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileAttributesExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}}}",
            lp_file_name,
            f_info_level_id,
            lp_file_information
        );
        let res = api.GetFileAttributesExA(lp_file_name, f_info_level_id, lp_file_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileAttributesExFromAppW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}}}",
            lp_file_name,
            f_info_level_id,
            lp_file_information
        );
        let res =
            api.GetFileAttributesExFromAppW(lp_file_name, f_info_level_id, lp_file_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileAttributesExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}}}",
            lp_file_name,
            f_info_level_id,
            lp_file_information
        );
        let res = api.GetFileAttributesExW(lp_file_name, f_info_level_id, lp_file_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileAttributesTransactedA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_file_information , h_transaction );
        let res = api.GetFileAttributesTransactedA(
            lp_file_name,
            f_info_level_id,
            lp_file_information,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let f_info_level_id = call.get_arg();
        let lp_file_information = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileAttributesTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, f_info_level_id = {:?}, lp_file_information = {:?}, h_transaction = {:?}}}" , lp_file_name , f_info_level_id , lp_file_information , h_transaction );
        let res = api.GetFileAttributesTransactedW(
            lp_file_name,
            f_info_level_id,
            lp_file_information,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileAttributesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileAttributesW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.GetFileAttributesW(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileBandwidthReservation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_period_milliseconds = call.get_arg();
        let lp_bytes_per_period = call.get_arg();
        let p_discardable = call.get_arg();
        let lp_transfer_size = call.get_arg();
        let lp_num_outstanding_requests = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileBandwidthReservation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_period_milliseconds = {:?}, lp_bytes_per_period = {:?}, p_discardable = {:?}, lp_transfer_size = {:?}, lp_num_outstanding_requests = {:?}}}" , h_file , lp_period_milliseconds , lp_bytes_per_period , p_discardable , lp_transfer_size , lp_num_outstanding_requests );
        let res = api.GetFileBandwidthReservation(
            h_file,
            lp_period_milliseconds,
            lp_bytes_per_period,
            p_discardable,
            lp_transfer_size,
            lp_num_outstanding_requests,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileInformationByHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_file_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileInformationByHandle");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_file_information = {:?}}}",
            h_file,
            lp_file_information
        );
        let res = api.GetFileInformationByHandle(h_file, lp_file_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileInformationByHandleEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let file_information_class = call.get_arg();
        let lp_file_information = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileInformationByHandleEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, file_information_class = {:?}, lp_file_information = {:?}, dw_buffer_size = {:?}}}" , h_file , file_information_class , lp_file_information , dw_buffer_size );
        let res = api.GetFileInformationByHandleEx(
            h_file,
            file_information_class,
            lp_file_information,
            dw_buffer_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_file_size_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileSize");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_file_size_high = {:?}}}",
            h_file,
            lp_file_size_high
        );
        let res = api.GetFileSize(h_file, lp_file_size_high);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileSizeEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_file_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileSizeEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_file_size = {:?}}}",
            h_file,
            lp_file_size
        );
        let res = api.GetFileSizeEx(h_file, lp_file_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_last_access_time = call.get_arg();
        let lp_last_write_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileTime");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_creation_time = {:?}, lp_last_access_time = {:?}, lp_last_write_time = {:?}}}" , h_file , lp_creation_time , lp_last_access_time , lp_last_write_time );
        let res = api.GetFileTime(
            h_file,
            lp_creation_time,
            lp_last_access_time,
            lp_last_write_time,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileType(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileType");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_file = {:?}}}", h_file);
        let res = api.GetFileType(h_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lptstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}",
            lptstr_filename,
            dw_handle,
            dw_len,
            lp_data
        );
        let res = api.GetFileVersionInfoA(lptstr_filename, dw_handle, dw_len, lp_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lpwstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}" , dw_flags , lpwstr_filename , dw_handle , dw_len , lp_data );
        let res = api.GetFileVersionInfoExA(dw_flags, lpwstr_filename, dw_handle, dw_len, lp_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lpwstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}" , dw_flags , lpwstr_filename , dw_handle , dw_len , lp_data );
        let res = api.GetFileVersionInfoExW(dw_flags, lpwstr_filename, dw_handle, dw_len, lp_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoSizeA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lptstr_filename = {:?}, lpdw_handle = {:?}}}",
            lptstr_filename,
            lpdw_handle
        );
        let res = api.GetFileVersionInfoSizeA(lptstr_filename, lpdw_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoSizeExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, lpwstr_filename = {:?}, lpdw_handle = {:?}}}",
            dw_flags,
            lpwstr_filename,
            lpdw_handle
        );
        let res = api.GetFileVersionInfoSizeExA(dw_flags, lpwstr_filename, lpdw_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lpwstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoSizeExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, lpwstr_filename = {:?}, lpdw_handle = {:?}}}",
            dw_flags,
            lpwstr_filename,
            lpdw_handle
        );
        let res = api.GetFileVersionInfoSizeExW(dw_flags, lpwstr_filename, lpdw_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoSizeW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let lpdw_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoSizeW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lptstr_filename = {:?}, lpdw_handle = {:?}}}",
            lptstr_filename,
            lpdw_handle
        );
        let res = api.GetFileVersionInfoSizeW(lptstr_filename, lpdw_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFileVersionInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lptstr_filename = call.get_arg();
        let dw_handle = call.get_arg();
        let dw_len = call.get_arg();
        let lp_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFileVersionInfoW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lptstr_filename = {:?}, dw_handle = {:?}, dw_len = {:?}, lp_data = {:?}}}",
            lptstr_filename,
            dw_handle,
            dw_len,
            lp_data
        );
        let res = api.GetFileVersionInfoW(lptstr_filename, dw_handle, dw_len, lp_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFinalPathNameByHandleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lpsz_file_path = call.get_arg();
        let cch_file_path = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFinalPathNameByHandleA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lpsz_file_path = {:?}, cch_file_path = {:?}, dw_flags = {:?}}}" , h_file , lpsz_file_path , cch_file_path , dw_flags );
        let res = api.GetFinalPathNameByHandleA(h_file, lpsz_file_path, cch_file_path, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFinalPathNameByHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lpsz_file_path = call.get_arg();
        let cch_file_path = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFinalPathNameByHandleW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lpsz_file_path = {:?}, cch_file_path = {:?}, dw_flags = {:?}}}" , h_file , lpsz_file_path , cch_file_path , dw_flags );
        let res = api.GetFinalPathNameByHandleW(h_file, lpsz_file_path, cch_file_path, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFullPathNameA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part );
        let res = api.GetFullPathNameA(lp_file_name, n_buffer_length, lp_buffer, lp_file_part);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFullPathNameTransactedA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}, h_transaction = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part , h_transaction );
        let res = api.GetFullPathNameTransactedA(
            lp_file_name,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFullPathNameTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}, h_transaction = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part , h_transaction );
        let res = api.GetFullPathNameTransactedW(
            lp_file_name,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFullPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFullPathNameW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_file_name = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_file_name , n_buffer_length , lp_buffer , lp_file_part );
        let res = api.GetFullPathNameW(lp_file_name, n_buffer_length, lp_buffer, lp_file_part);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetIoRingInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetIoRingInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{io_ring = {:?}, info = {:?}}}", io_ring, info);
        let res = api.GetIoRingInfo(io_ring, info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDriveStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLogicalDriveStringsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetLogicalDriveStringsA(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDriveStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLogicalDriveStringsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetLogicalDriveStringsW(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalDrives(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLogicalDrives");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetLogicalDrives();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLongPathNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}}}",
            lpsz_short_path,
            lpsz_long_path,
            cch_buffer
        );
        let res = api.GetLongPathNameA(lpsz_short_path, lpsz_long_path, cch_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLongPathNameTransactedA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}, h_transaction = {:?}}}" , lpsz_short_path , lpsz_long_path , cch_buffer , h_transaction );
        let res = api.GetLongPathNameTransactedA(
            lpsz_short_path,
            lpsz_long_path,
            cch_buffer,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLongPathNameTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}, h_transaction = {:?}}}" , lpsz_short_path , lpsz_long_path , cch_buffer , h_transaction );
        let res = api.GetLongPathNameTransactedW(
            lpsz_short_path,
            lpsz_long_path,
            cch_buffer,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLongPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_short_path = call.get_arg();
        let lpsz_long_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLongPathNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_short_path = {:?}, lpsz_long_path = {:?}, cch_buffer = {:?}}}",
            lpsz_short_path,
            lpsz_long_path,
            cch_buffer
        );
        let res = api.GetLongPathNameW(lpsz_short_path, lpsz_long_path, cch_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNotificationResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let transaction_notification = call.get_arg();
        let notification_length = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNotificationResourceManager");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{resource_manager_handle = {:?}, transaction_notification = {:?}, notification_length = {:?}, dw_milliseconds = {:?}, return_length = {:?}}}" , resource_manager_handle , transaction_notification , notification_length , dw_milliseconds , return_length );
        let res = api.GetNotificationResourceManager(
            resource_manager_handle,
            transaction_notification,
            notification_length,
            dw_milliseconds,
            return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNotificationResourceManagerAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let transaction_notification = call.get_arg();
        let transaction_notification_length = call.get_arg();
        let return_length = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNotificationResourceManagerAsync");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{resource_manager_handle = {:?}, transaction_notification = {:?}, transaction_notification_length = {:?}, return_length = {:?}, lp_overlapped = {:?}}}" , resource_manager_handle , transaction_notification , transaction_notification_length , return_length , lp_overlapped );
        let res = api.GetNotificationResourceManagerAsync(
            resource_manager_handle,
            transaction_notification,
            transaction_notification_length,
            return_length,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetShortPathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_long_path = call.get_arg();
        let lpsz_short_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetShortPathNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_long_path = {:?}, lpsz_short_path = {:?}, cch_buffer = {:?}}}",
            lpsz_long_path,
            lpsz_short_path,
            cch_buffer
        );
        let res = api.GetShortPathNameA(lpsz_long_path, lpsz_short_path, cch_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetShortPathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_long_path = call.get_arg();
        let lpsz_short_path = call.get_arg();
        let cch_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetShortPathNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_long_path = {:?}, lpsz_short_path = {:?}, cch_buffer = {:?}}}",
            lpsz_long_path,
            lpsz_short_path,
            cch_buffer
        );
        let res = api.GetShortPathNameW(lpsz_long_path, lpsz_short_path, cch_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTapeParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_operation = call.get_arg();
        let lpdw_size = call.get_arg();
        let lp_tape_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTapeParameters");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_device = {:?}, dw_operation = {:?}, lpdw_size = {:?}, lp_tape_information = {:?}}}" , h_device , dw_operation , lpdw_size , lp_tape_information );
        let res = api.GetTapeParameters(h_device, dw_operation, lpdw_size, lp_tape_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTapePosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_position_type = call.get_arg();
        let lpdw_partition = call.get_arg();
        let lpdw_offset_low = call.get_arg();
        let lpdw_offset_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTapePosition");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_device = {:?}, dw_position_type = {:?}, lpdw_partition = {:?}, lpdw_offset_low = {:?}, lpdw_offset_high = {:?}}}" , h_device , dw_position_type , lpdw_partition , lpdw_offset_low , lpdw_offset_high );
        let res = api.GetTapePosition(
            h_device,
            dw_position_type,
            lpdw_partition,
            lpdw_offset_low,
            lpdw_offset_high,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTapeStatus(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTapeStatus");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_device = {:?}}}", h_device);
        let res = api.GetTapeStatus(h_device);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let lp_prefix_string = call.get_arg();
        let u_unique = call.get_arg();
        let lp_temp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTempFileNameA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_path_name = {:?}, lp_prefix_string = {:?}, u_unique = {:?}, lp_temp_file_name = {:?}}}" , lp_path_name , lp_prefix_string , u_unique , lp_temp_file_name );
        let res = api.GetTempFileNameA(lp_path_name, lp_prefix_string, u_unique, lp_temp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let lp_prefix_string = call.get_arg();
        let u_unique = call.get_arg();
        let lp_temp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTempFileNameW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_path_name = {:?}, lp_prefix_string = {:?}, u_unique = {:?}, lp_temp_file_name = {:?}}}" , lp_path_name , lp_prefix_string , u_unique , lp_temp_file_name );
        let res = api.GetTempFileNameW(lp_path_name, lp_prefix_string, u_unique, lp_temp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPath2A(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer_length = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTempPath2A");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{buffer_length = {:?}, buffer = {:?}}}",
            buffer_length,
            buffer
        );
        let res = api.GetTempPath2A(buffer_length, buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPath2W(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer_length = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTempPath2W");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{buffer_length = {:?}, buffer = {:?}}}",
            buffer_length,
            buffer
        );
        let res = api.GetTempPath2W(buffer_length, buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPathA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTempPathA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetTempPathA(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTempPathW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTempPathW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetTempPathW(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTransactionId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let transaction_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTransactionId");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{transaction_handle = {:?}, transaction_id = {:?}}}",
            transaction_handle,
            transaction_id
        );
        let res = api.GetTransactionId(transaction_handle, transaction_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTransactionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let outcome = call.get_arg();
        let isolation_level = call.get_arg();
        let isolation_flags = call.get_arg();
        let timeout = call.get_arg();
        let buffer_length = call.get_arg();
        let description = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTransactionInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{transaction_handle = {:?}, outcome = {:?}, isolation_level = {:?}, isolation_flags = {:?}, timeout = {:?}, buffer_length = {:?}, description = {:?}}}" , transaction_handle , outcome , isolation_level , isolation_flags , timeout , buffer_length , description );
        let res = api.GetTransactionInformation(
            transaction_handle,
            outcome,
            isolation_level,
            isolation_flags,
            timeout,
            buffer_length,
            description,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTransactionManagerId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let transaction_manager_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTransactionManagerId");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{transaction_manager_handle = {:?}, transaction_manager_id = {:?}}}",
            transaction_manager_handle,
            transaction_manager_id
        );
        let res = api.GetTransactionManagerId(transaction_manager_handle, transaction_manager_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name_buffer = call.get_arg();
        let n_volume_name_size = call.get_arg();
        let lp_volume_serial_number = call.get_arg();
        let lp_maximum_component_length = call.get_arg();
        let lp_file_system_flags = call.get_arg();
        let lp_file_system_name_buffer = call.get_arg();
        let n_file_system_name_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumeInformationA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_root_path_name = {:?}, lp_volume_name_buffer = {:?}, n_volume_name_size = {:?}, lp_volume_serial_number = {:?}, lp_maximum_component_length = {:?}, lp_file_system_flags = {:?}, lp_file_system_name_buffer = {:?}, n_file_system_name_size = {:?}}}" , lp_root_path_name , lp_volume_name_buffer , n_volume_name_size , lp_volume_serial_number , lp_maximum_component_length , lp_file_system_flags , lp_file_system_name_buffer , n_file_system_name_size );
        let res = api.GetVolumeInformationA(
            lp_root_path_name,
            lp_volume_name_buffer,
            n_volume_name_size,
            lp_volume_serial_number,
            lp_maximum_component_length,
            lp_file_system_flags,
            lp_file_system_name_buffer,
            n_file_system_name_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationByHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_volume_name_buffer = call.get_arg();
        let n_volume_name_size = call.get_arg();
        let lp_volume_serial_number = call.get_arg();
        let lp_maximum_component_length = call.get_arg();
        let lp_file_system_flags = call.get_arg();
        let lp_file_system_name_buffer = call.get_arg();
        let n_file_system_name_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumeInformationByHandleW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_volume_name_buffer = {:?}, n_volume_name_size = {:?}, lp_volume_serial_number = {:?}, lp_maximum_component_length = {:?}, lp_file_system_flags = {:?}, lp_file_system_name_buffer = {:?}, n_file_system_name_size = {:?}}}" , h_file , lp_volume_name_buffer , n_volume_name_size , lp_volume_serial_number , lp_maximum_component_length , lp_file_system_flags , lp_file_system_name_buffer , n_file_system_name_size );
        let res = api.GetVolumeInformationByHandleW(
            h_file,
            lp_volume_name_buffer,
            n_volume_name_size,
            lp_volume_serial_number,
            lp_maximum_component_length,
            lp_file_system_flags,
            lp_file_system_name_buffer,
            n_file_system_name_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeInformationW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name_buffer = call.get_arg();
        let n_volume_name_size = call.get_arg();
        let lp_volume_serial_number = call.get_arg();
        let lp_maximum_component_length = call.get_arg();
        let lp_file_system_flags = call.get_arg();
        let lp_file_system_name_buffer = call.get_arg();
        let n_file_system_name_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumeInformationW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_root_path_name = {:?}, lp_volume_name_buffer = {:?}, n_volume_name_size = {:?}, lp_volume_serial_number = {:?}, lp_maximum_component_length = {:?}, lp_file_system_flags = {:?}, lp_file_system_name_buffer = {:?}, n_file_system_name_size = {:?}}}" , lp_root_path_name , lp_volume_name_buffer , n_volume_name_size , lp_volume_serial_number , lp_maximum_component_length , lp_file_system_flags , lp_file_system_name_buffer , n_file_system_name_size );
        let res = api.GetVolumeInformationW(
            lp_root_path_name,
            lp_volume_name_buffer,
            n_volume_name_size,
            lp_volume_serial_number,
            lp_maximum_component_length,
            lp_file_system_flags,
            lp_file_system_name_buffer,
            n_file_system_name_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeNameForVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumeNameForVolumeMountPointA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_volume_mount_point , lpsz_volume_name , cch_buffer_length );
        let res = api.GetVolumeNameForVolumeMountPointA(
            lpsz_volume_mount_point,
            lpsz_volume_name,
            cch_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumeNameForVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumeNameForVolumeMountPointW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_volume_mount_point , lpsz_volume_name , cch_buffer_length );
        let res = api.GetVolumeNameForVolumeMountPointW(
            lpsz_volume_mount_point,
            lpsz_volume_name,
            cch_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_file_name = call.get_arg();
        let lpsz_volume_path_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumePathNameA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_file_name = {:?}, lpsz_volume_path_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_file_name , lpsz_volume_path_name , cch_buffer_length );
        let res = api.GetVolumePathNameA(lpsz_file_name, lpsz_volume_path_name, cch_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_file_name = call.get_arg();
        let lpsz_volume_path_name = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumePathNameW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_file_name = {:?}, lpsz_volume_path_name = {:?}, cch_buffer_length = {:?}}}" , lpsz_file_name , lpsz_volume_path_name , cch_buffer_length );
        let res = api.GetVolumePathNameW(lpsz_file_name, lpsz_volume_path_name, cch_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNamesForVolumeNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let lpsz_volume_path_names = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let lpcch_return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumePathNamesForVolumeNameA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_volume_name = {:?}, lpsz_volume_path_names = {:?}, cch_buffer_length = {:?}, lpcch_return_length = {:?}}}" , lpsz_volume_name , lpsz_volume_path_names , cch_buffer_length , lpcch_return_length );
        let res = api.GetVolumePathNamesForVolumeNameA(
            lpsz_volume_name,
            lpsz_volume_path_names,
            cch_buffer_length,
            lpcch_return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVolumePathNamesForVolumeNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_name = call.get_arg();
        let lpsz_volume_path_names = call.get_arg();
        let cch_buffer_length = call.get_arg();
        let lpcch_return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVolumePathNamesForVolumeNameW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_volume_name = {:?}, lpsz_volume_path_names = {:?}, cch_buffer_length = {:?}, lpcch_return_length = {:?}}}" , lpsz_volume_name , lpsz_volume_path_names , cch_buffer_length , lpcch_return_length );
        let res = api.GetVolumePathNamesForVolumeNameW(
            lpsz_volume_name,
            lpsz_volume_path_names,
            cch_buffer_length,
            lpcch_return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsIoRingOpSupported(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let op = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsIoRingOpSupported");
        let _enter = span.enter();
        tracing::trace!("  args = {{io_ring = {:?}, op = {:?}}}", io_ring, op);
        let res = api.IsIoRingOpSupported(io_ring, op);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZClose");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_file = {:?}}}", h_file);
        let res = api.LZClose(h_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZCopy(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hf_source = call.get_arg();
        let hf_dest = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZCopy");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hf_source = {:?}, hf_dest = {:?}}}",
            hf_source,
            hf_dest
        );
        let res = api.LZCopy(hf_source, hf_dest);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZDone(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZDone");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.LZDone();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZInit(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hf_source = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZInit");
        let _enter = span.enter();
        tracing::trace!("  args = {{hf_source = {:?}}}", hf_source);
        let res = api.LZInit(hf_source);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZOpenFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_re_open_buf = call.get_arg();
        let w_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZOpenFileA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_re_open_buf = {:?}, w_style = {:?}}}",
            lp_file_name,
            lp_re_open_buf,
            w_style
        );
        let res = api.LZOpenFileA(lp_file_name, lp_re_open_buf, w_style);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZOpenFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_re_open_buf = call.get_arg();
        let w_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZOpenFileW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_re_open_buf = {:?}, w_style = {:?}}}",
            lp_file_name,
            lp_re_open_buf,
            w_style
        );
        let res = api.LZOpenFileW(lp_file_name, lp_re_open_buf, w_style);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZRead(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let cb_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZRead");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_buffer = {:?}, cb_read = {:?}}}",
            h_file,
            lp_buffer,
            cb_read
        );
        let res = api.LZRead(h_file, lp_buffer, cb_read);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZSeek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let l_offset = call.get_arg();
        let i_origin = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZSeek");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, l_offset = {:?}, i_origin = {:?}}}",
            h_file,
            l_offset,
            i_origin
        );
        let res = api.LZSeek(h_file, l_offset, i_origin);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LZStart(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LZStart");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.LZStart();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}}}",
            lp_existing_file_name,
            lp_new_file_name
        );
        let res = api.MoveFileA(lp_existing_file_name, lp_new_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, dw_flags = {:?}}}",
            lp_existing_file_name,
            lp_new_file_name,
            dw_flags
        );
        let res = api.MoveFileExA(lp_existing_file_name, lp_new_file_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, dw_flags = {:?}}}",
            lp_existing_file_name,
            lp_new_file_name,
            dw_flags
        );
        let res = api.MoveFileExW(lp_existing_file_name, lp_new_file_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileFromAppW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}}}",
            lp_existing_file_name,
            lp_new_file_name
        );
        let res = api.MoveFileFromAppW(lp_existing_file_name, lp_new_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileTransactedA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags , h_transaction );
        let res = api.MoveFileTransactedA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileTransactedW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}, h_transaction = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags , h_transaction );
        let res = api.MoveFileTransactedW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
            h_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}}}",
            lp_existing_file_name,
            lp_new_file_name
        );
        let res = api.MoveFileW(lp_existing_file_name, lp_new_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileWithProgressA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileWithProgressA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags );
        let res = api.MoveFileWithProgressA(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveFileWithProgressW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_existing_file_name = call.get_arg();
        let lp_new_file_name = call.get_arg();
        let lp_progress_routine = call.get_arg();
        let lp_data = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveFileWithProgressW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_existing_file_name = {:?}, lp_new_file_name = {:?}, lp_progress_routine = {:?}, lp_data = {:?}, dw_flags = {:?}}}" , lp_existing_file_name , lp_new_file_name , lp_progress_routine , lp_data , dw_flags );
        let res = api.MoveFileWithProgressW(
            lp_existing_file_name,
            lp_new_file_name,
            lp_progress_routine,
            lp_data,
            dw_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetConnectionEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let qualifier = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetConnectionEnum");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, qualifier = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , qualifier , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle );
        let res = api.NetConnectionEnum(
            servername,
            qualifier,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetFileClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let fileid = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetFileClose");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, fileid = {:?}}}",
            servername,
            fileid
        );
        let res = api.NetFileClose(servername, fileid);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetFileEnum(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let basepath = call.get_arg();
        let username = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetFileEnum");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, basepath = {:?}, username = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , basepath , username , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle );
        let res = api.NetFileEnum(
            servername,
            basepath,
            username,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetFileGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let fileid = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetFileGetInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, fileid = {:?}, level = {:?}, bufptr = {:?}}}",
            servername,
            fileid,
            level,
            bufptr
        );
        let res = api.NetFileGetInfo(servername, fileid, level, bufptr);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasAdd(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetServerAliasAdd");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, level = {:?}, buf = {:?}}}",
            servername,
            level,
            buf
        );
        let res = api.NetServerAliasAdd(servername, level, buf);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasDel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetServerAliasDel");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, level = {:?}, buf = {:?}}}",
            servername,
            level,
            buf
        );
        let res = api.NetServerAliasDel(servername, level, buf);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetServerAliasEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resumehandle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetServerAliasEnum");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resumehandle = {:?}}}" , servername , level , bufptr , prefmaxlen , entriesread , totalentries , resumehandle );
        let res = api.NetServerAliasEnum(
            servername,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resumehandle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetSessionDel(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let unc_client_name = call.get_arg();
        let username = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetSessionDel");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, unc_client_name = {:?}, username = {:?}}}",
            servername,
            unc_client_name,
            username
        );
        let res = api.NetSessionDel(servername, unc_client_name, username);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetSessionEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let unc_client_name = call.get_arg();
        let username = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetSessionEnum");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, unc_client_name = {:?}, username = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , unc_client_name , username , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle );
        let res = api.NetSessionEnum(
            servername,
            unc_client_name,
            username,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetSessionGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let unc_client_name = call.get_arg();
        let username = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetSessionGetInfo");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, unc_client_name = {:?}, username = {:?}, level = {:?}, bufptr = {:?}}}" , servername , unc_client_name , username , level , bufptr );
        let res = api.NetSessionGetInfo(servername, unc_client_name, username, level, bufptr);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareAdd(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let parm_err = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareAdd");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, level = {:?}, buf = {:?}, parm_err = {:?}}}",
            servername,
            level,
            buf,
            parm_err
        );
        let res = api.NetShareAdd(servername, level, buf, parm_err);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareCheck(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let device = call.get_arg();
        let r#type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareCheck");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, device = {:?}, r#type = {:?}}}",
            servername,
            device,
            r#type
        );
        let res = api.NetShareCheck(servername, device, r#type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareDel(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareDel");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, netname = {:?}, reserved = {:?}}}",
            servername,
            netname,
            reserved
        );
        let res = api.NetShareDel(servername, netname, reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareDelEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareDelEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, level = {:?}, buf = {:?}}}",
            servername,
            level,
            buf
        );
        let res = api.NetShareDelEx(servername, level, buf);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareDelSticky(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareDelSticky");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, netname = {:?}, reserved = {:?}}}",
            servername,
            netname,
            reserved
        );
        let res = api.NetShareDelSticky(servername, netname, reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareEnum(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareEnum");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle );
        let res = api.NetShareEnum(
            servername,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareEnumSticky(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let prefmaxlen = call.get_arg();
        let entriesread = call.get_arg();
        let totalentries = call.get_arg();
        let resume_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareEnumSticky");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, level = {:?}, bufptr = {:?}, prefmaxlen = {:?}, entriesread = {:?}, totalentries = {:?}, resume_handle = {:?}}}" , servername , level , bufptr , prefmaxlen , entriesread , totalentries , resume_handle );
        let res = api.NetShareEnumSticky(
            servername,
            level,
            bufptr,
            prefmaxlen,
            entriesread,
            totalentries,
            resume_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareGetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let level = call.get_arg();
        let bufptr = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareGetInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{servername = {:?}, netname = {:?}, level = {:?}, bufptr = {:?}}}",
            servername,
            netname,
            level,
            bufptr
        );
        let res = api.NetShareGetInfo(servername, netname, level, bufptr);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetShareSetInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let servername = call.get_arg();
        let netname = call.get_arg();
        let level = call.get_arg();
        let buf = call.get_arg();
        let parm_err = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetShareSetInfo");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{servername = {:?}, netname = {:?}, level = {:?}, buf = {:?}, parm_err = {:?}}}" , servername , netname , level , buf , parm_err );
        let res = api.NetShareSetInfo(servername, netname, level, buf, parm_err);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NetStatisticsGet(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let server_name = call.get_arg();
        let service = call.get_arg();
        let level = call.get_arg();
        let options = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NetStatisticsGet");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{server_name = {:?}, service = {:?}, level = {:?}, options = {:?}, buffer = {:?}}}" , server_name , service , level , options , buffer );
        let res = api.NetStatisticsGet(server_name, service, level, options, buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtCreateFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let desired_access = call.get_arg();
        let object_attributes = call.get_arg();
        let io_status_block = call.get_arg();
        let allocation_size = call.get_arg();
        let file_attributes = call.get_arg();
        let share_access = call.get_arg();
        let create_disposition = call.get_arg();
        let create_options = call.get_arg();
        let ea_buffer = call.get_arg();
        let ea_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtCreateFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_handle = {:?}, desired_access = {:?}, object_attributes = {:?}, io_status_block = {:?}, allocation_size = {:?}, file_attributes = {:?}, share_access = {:?}, create_disposition = {:?}, create_options = {:?}, ea_buffer = {:?}, ea_length = {:?}}}" , file_handle , desired_access , object_attributes , io_status_block , allocation_size , file_attributes , share_access , create_disposition , create_options , ea_buffer , ea_length );
        let res = api.NtCreateFile(
            file_handle,
            desired_access,
            object_attributes,
            io_status_block,
            allocation_size,
            file_attributes,
            share_access,
            create_disposition,
            create_options,
            ea_buffer,
            ea_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEncryptedFileRawA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let ul_flags = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenEncryptedFileRawA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, ul_flags = {:?}, pv_context = {:?}}}",
            lp_file_name,
            ul_flags,
            pv_context
        );
        let res = api.OpenEncryptedFileRawA(lp_file_name, ul_flags, pv_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEncryptedFileRawW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let ul_flags = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenEncryptedFileRawW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, ul_flags = {:?}, pv_context = {:?}}}",
            lp_file_name,
            ul_flags,
            pv_context
        );
        let res = api.OpenEncryptedFileRawW(lp_file_name, ul_flags, pv_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let resource_manager_handle = call.get_arg();
        let enlistment_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenEnlistment");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_desired_access = {:?}, resource_manager_handle = {:?}, enlistment_id = {:?}}}" , dw_desired_access , resource_manager_handle , enlistment_id );
        let res = api.OpenEnlistment(dw_desired_access, resource_manager_handle, enlistment_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let lp_re_open_buff = call.get_arg();
        let u_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenFile");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, lp_re_open_buff = {:?}, u_style = {:?}}}",
            lp_file_name,
            lp_re_open_buff,
            u_style
        );
        let res = api.OpenFile(lp_file_name, lp_re_open_buff, u_style);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let tm_handle = call.get_arg();
        let resource_manager_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenResourceManager");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, tm_handle = {:?}, resource_manager_id = {:?}}}",
            dw_desired_access,
            tm_handle,
            resource_manager_id
        );
        let res = api.OpenResourceManager(dw_desired_access, tm_handle, resource_manager_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let transaction_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenTransaction");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, transaction_id = {:?}}}",
            dw_desired_access,
            transaction_id
        );
        let res = api.OpenTransaction(dw_desired_access, transaction_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_file_name = call.get_arg();
        let desired_access = call.get_arg();
        let open_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenTransactionManager");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{log_file_name = {:?}, desired_access = {:?}, open_options = {:?}}}",
            log_file_name,
            desired_access,
            open_options
        );
        let res = api.OpenTransactionManager(log_file_name, desired_access, open_options);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenTransactionManagerById(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_id = call.get_arg();
        let desired_access = call.get_arg();
        let open_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenTransactionManagerById");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{transaction_manager_id = {:?}, desired_access = {:?}, open_options = {:?}}}" , transaction_manager_id , desired_access , open_options );
        let res =
            api.OpenTransactionManagerById(transaction_manager_id, desired_access, open_options);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PopIoRingCompletion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let cqe = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PopIoRingCompletion");
        let _enter = span.enter();
        tracing::trace!("  args = {{io_ring = {:?}, cqe = {:?}}}", io_ring, cqe);
        let res = api.PopIoRingCompletion(io_ring, cqe);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrePrepareComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrePrepareComplete");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.PrePrepareComplete(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrePrepareEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrePrepareEnlistment");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.PrePrepareEnlistment(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrepareComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrepareComplete");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.PrepareComplete(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrepareEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrepareEnlistment");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.PrepareEnlistment(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrepareTape(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_operation = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrepareTape");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_device = {:?}, dw_operation = {:?}, b_immediate = {:?}}}",
            h_device,
            dw_operation,
            b_immediate
        );
        let res = api.PrepareTape(h_device, dw_operation, b_immediate);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryDosDeviceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryDosDeviceA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_device_name = {:?}, lp_target_path = {:?}, ucch_max = {:?}}}",
            lp_device_name,
            lp_target_path,
            ucch_max
        );
        let res = api.QueryDosDeviceA(lp_device_name, lp_target_path, ucch_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryDosDeviceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_device_name = call.get_arg();
        let lp_target_path = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryDosDeviceW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_device_name = {:?}, lp_target_path = {:?}, ucch_max = {:?}}}",
            lp_device_name,
            lp_target_path,
            ucch_max
        );
        let res = api.QueryDosDeviceW(lp_device_name, lp_target_path, ucch_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryIoRingCapabilities(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let capabilities = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryIoRingCapabilities");
        let _enter = span.enter();
        tracing::trace!("  args = {{capabilities = {:?}}}", capabilities);
        let res = api.QueryIoRingCapabilities(capabilities);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReOpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_original_file = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_share_mode = call.get_arg();
        let dw_flags_and_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReOpenFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_original_file = {:?}, dw_desired_access = {:?}, dw_share_mode = {:?}, dw_flags_and_attributes = {:?}}}" , h_original_file , dw_desired_access , dw_share_mode , dw_flags_and_attributes );
        let res = api.ReOpenFile(
            h_original_file,
            dw_desired_access,
            dw_share_mode,
            dw_flags_and_attributes,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadDirectoryChangesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_directory = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_buffer_length = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let lp_bytes_returned = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let read_directory_notify_information_class = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadDirectoryChangesExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_directory = {:?}, lp_buffer = {:?}, n_buffer_length = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}, lp_bytes_returned = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}, read_directory_notify_information_class = {:?}}}" , h_directory , lp_buffer , n_buffer_length , b_watch_subtree , dw_notify_filter , lp_bytes_returned , lp_overlapped , lp_completion_routine , read_directory_notify_information_class );
        let res = api.ReadDirectoryChangesExW(
            h_directory,
            lp_buffer,
            n_buffer_length,
            b_watch_subtree,
            dw_notify_filter,
            lp_bytes_returned,
            lp_overlapped,
            lp_completion_routine,
            read_directory_notify_information_class,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadDirectoryChangesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_directory = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_buffer_length = call.get_arg();
        let b_watch_subtree = call.get_arg();
        let dw_notify_filter = call.get_arg();
        let lp_bytes_returned = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadDirectoryChangesW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_directory = {:?}, lp_buffer = {:?}, n_buffer_length = {:?}, b_watch_subtree = {:?}, dw_notify_filter = {:?}, lp_bytes_returned = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}}}" , h_directory , lp_buffer , n_buffer_length , b_watch_subtree , dw_notify_filter , lp_bytes_returned , lp_overlapped , lp_completion_routine );
        let res = api.ReadDirectoryChangesW(
            h_directory,
            lp_buffer,
            n_buffer_length,
            b_watch_subtree,
            dw_notify_filter,
            lp_bytes_returned,
            lp_overlapped,
            lp_completion_routine,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pf_export_callback = call.get_arg();
        let pv_callback_context = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadEncryptedFileRaw");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pf_export_callback = {:?}, pv_callback_context = {:?}, pv_context = {:?}}}",
            pf_export_callback,
            pv_callback_context,
            pv_context
        );
        let res = api.ReadEncryptedFileRaw(pf_export_callback, pv_callback_context, pv_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_number_of_bytes_read = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_read = {:?}, lp_number_of_bytes_read = {:?}, lp_overlapped = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_read , lp_number_of_bytes_read , lp_overlapped );
        let res = api.ReadFile(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_read,
            lp_number_of_bytes_read,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadFileEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_read = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_read , lp_overlapped , lp_completion_routine );
        let res = api.ReadFileEx(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_read,
            lp_overlapped,
            lp_completion_routine,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadFileScatter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let a_segment_array = call.get_arg();
        let n_number_of_bytes_to_read = call.get_arg();
        let lp_reserved = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadFileScatter");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, a_segment_array = {:?}, n_number_of_bytes_to_read = {:?}, lp_reserved = {:?}, lp_overlapped = {:?}}}" , h_file , a_segment_array , n_number_of_bytes_to_read , lp_reserved , lp_overlapped );
        let res = api.ReadFileScatter(
            h_file,
            a_segment_array,
            n_number_of_bytes_to_read,
            lp_reserved,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadOnlyEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadOnlyEnlistment");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.ReadOnlyEnlistment(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecoverEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let enlistment_key = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RecoverEnlistment");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, enlistment_key = {:?}}}",
            enlistment_handle,
            enlistment_key
        );
        let res = api.RecoverEnlistment(enlistment_handle, enlistment_key);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecoverResourceManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RecoverResourceManager");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{resource_manager_handle = {:?}}}",
            resource_manager_handle
        );
        let res = api.RecoverResourceManager(resource_manager_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecoverTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RecoverTransactionManager");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{transaction_manager_handle = {:?}}}",
            transaction_manager_handle
        );
        let res = api.RecoverTransactionManager(transaction_manager_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveDirectoryA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_path_name = {:?}}}", lp_path_name);
        let res = api.RemoveDirectoryA(lp_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveDirectoryFromAppW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_path_name = {:?}}}", lp_path_name);
        let res = api.RemoveDirectoryFromAppW(lp_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveDirectoryTransactedA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_path_name = {:?}, h_transaction = {:?}}}",
            lp_path_name,
            h_transaction
        );
        let res = api.RemoveDirectoryTransactedA(lp_path_name, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveDirectoryTransactedW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_path_name = {:?}, h_transaction = {:?}}}",
            lp_path_name,
            h_transaction
        );
        let res = api.RemoveDirectoryTransactedW(lp_path_name, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveDirectoryW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_path_name = {:?}}}", lp_path_name);
        let res = api.RemoveDirectoryW(lp_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RenameTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_file_name = call.get_arg();
        let existing_transaction_manager_guid = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RenameTransactionManager");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{log_file_name = {:?}, existing_transaction_manager_guid = {:?}}}",
            log_file_name,
            existing_transaction_manager_guid
        );
        let res = api.RenameTransactionManager(log_file_name, existing_transaction_manager_guid);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_replaced_file_name = call.get_arg();
        let lp_replacement_file_name = call.get_arg();
        let lp_backup_file_name = call.get_arg();
        let dw_replace_flags = call.get_arg();
        let lp_exclude = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReplaceFileA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_replaced_file_name = {:?}, lp_replacement_file_name = {:?}, lp_backup_file_name = {:?}, dw_replace_flags = {:?}, lp_exclude = {:?}, lp_reserved = {:?}}}" , lp_replaced_file_name , lp_replacement_file_name , lp_backup_file_name , dw_replace_flags , lp_exclude , lp_reserved );
        let res = api.ReplaceFileA(
            lp_replaced_file_name,
            lp_replacement_file_name,
            lp_backup_file_name,
            dw_replace_flags,
            lp_exclude,
            lp_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_replaced_file_name = call.get_arg();
        let lp_replacement_file_name = call.get_arg();
        let lp_backup_file_name = call.get_arg();
        let dw_replace_flags = call.get_arg();
        let lp_exclude = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReplaceFileFromAppW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_replaced_file_name = {:?}, lp_replacement_file_name = {:?}, lp_backup_file_name = {:?}, dw_replace_flags = {:?}, lp_exclude = {:?}, lp_reserved = {:?}}}" , lp_replaced_file_name , lp_replacement_file_name , lp_backup_file_name , dw_replace_flags , lp_exclude , lp_reserved );
        let res = api.ReplaceFileFromAppW(
            lp_replaced_file_name,
            lp_replacement_file_name,
            lp_backup_file_name,
            dw_replace_flags,
            lp_exclude,
            lp_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplaceFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_replaced_file_name = call.get_arg();
        let lp_replacement_file_name = call.get_arg();
        let lp_backup_file_name = call.get_arg();
        let dw_replace_flags = call.get_arg();
        let lp_exclude = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReplaceFileW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_replaced_file_name = {:?}, lp_replacement_file_name = {:?}, lp_backup_file_name = {:?}, dw_replace_flags = {:?}, lp_exclude = {:?}, lp_reserved = {:?}}}" , lp_replaced_file_name , lp_replacement_file_name , lp_backup_file_name , dw_replace_flags , lp_exclude , lp_reserved );
        let res = api.ReplaceFileW(
            lp_replaced_file_name,
            lp_replacement_file_name,
            lp_backup_file_name,
            dw_replace_flags,
            lp_exclude,
            lp_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RollbackComplete");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.RollbackComplete(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackEnlistment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RollbackEnlistment");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.RollbackEnlistment(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackTransaction(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RollbackTransaction");
        let _enter = span.enter();
        tracing::trace!("  args = {{transaction_handle = {:?}}}", transaction_handle);
        let res = api.RollbackTransaction(transaction_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollbackTransactionAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RollbackTransactionAsync");
        let _enter = span.enter();
        tracing::trace!("  args = {{transaction_handle = {:?}}}", transaction_handle);
        let res = api.RollbackTransactionAsync(transaction_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RollforwardTransactionManager(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_manager_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RollforwardTransactionManager");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{transaction_manager_handle = {:?}, tm_virtual_clock = {:?}}}",
            transaction_manager_handle,
            tm_virtual_clock
        );
        let res = api.RollforwardTransactionManager(transaction_manager_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SearchPathA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path = call.get_arg();
        let lp_file_name = call.get_arg();
        let lp_extension = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SearchPathA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_path = {:?}, lp_file_name = {:?}, lp_extension = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_path , lp_file_name , lp_extension , n_buffer_length , lp_buffer , lp_file_part );
        let res = api.SearchPathA(
            lp_path,
            lp_file_name,
            lp_extension,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SearchPathW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path = call.get_arg();
        let lp_file_name = call.get_arg();
        let lp_extension = call.get_arg();
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let lp_file_part = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SearchPathW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_path = {:?}, lp_file_name = {:?}, lp_extension = {:?}, n_buffer_length = {:?}, lp_buffer = {:?}, lp_file_part = {:?}}}" , lp_path , lp_file_name , lp_extension , n_buffer_length , lp_buffer , lp_file_part );
        let res = api.SearchPathW(
            lp_path,
            lp_file_name,
            lp_extension,
            n_buffer_length,
            lp_buffer,
            lp_file_part,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEndOfFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEndOfFile");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_file = {:?}}}", h_file);
        let res = api.SetEndOfFile(h_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnlistmentRecoveryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let buffer_size = call.get_arg();
        let buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEnlistmentRecoveryInformation");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, buffer_size = {:?}, buffer = {:?}}}",
            enlistment_handle,
            buffer_size,
            buffer
        );
        let res = api.SetEnlistmentRecoveryInformation(enlistment_handle, buffer_size, buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileApisToANSI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileApisToANSI");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.SetFileApisToANSI();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileApisToOEM(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileApisToOEM");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.SetFileApisToOEM();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileAttributesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, dw_file_attributes = {:?}}}",
            lp_file_name,
            dw_file_attributes
        );
        let res = api.SetFileAttributesA(lp_file_name, dw_file_attributes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesFromAppW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileAttributesFromAppW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, dw_file_attributes = {:?}}}",
            lp_file_name,
            dw_file_attributes
        );
        let res = api.SetFileAttributesFromAppW(lp_file_name, dw_file_attributes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesTransactedA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileAttributesTransactedA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, dw_file_attributes = {:?}, h_transaction = {:?}}}",
            lp_file_name,
            dw_file_attributes,
            h_transaction
        );
        let res = api.SetFileAttributesTransactedA(lp_file_name, dw_file_attributes, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesTransactedW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let h_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileAttributesTransactedW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, dw_file_attributes = {:?}, h_transaction = {:?}}}",
            lp_file_name,
            dw_file_attributes,
            h_transaction
        );
        let res = api.SetFileAttributesTransactedW(lp_file_name, dw_file_attributes, h_transaction);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileAttributesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let dw_file_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileAttributesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_name = {:?}, dw_file_attributes = {:?}}}",
            lp_file_name,
            dw_file_attributes
        );
        let res = api.SetFileAttributesW(lp_file_name, dw_file_attributes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileBandwidthReservation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let n_period_milliseconds = call.get_arg();
        let n_bytes_per_period = call.get_arg();
        let b_discardable = call.get_arg();
        let lp_transfer_size = call.get_arg();
        let lp_num_outstanding_requests = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileBandwidthReservation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, n_period_milliseconds = {:?}, n_bytes_per_period = {:?}, b_discardable = {:?}, lp_transfer_size = {:?}, lp_num_outstanding_requests = {:?}}}" , h_file , n_period_milliseconds , n_bytes_per_period , b_discardable , lp_transfer_size , lp_num_outstanding_requests );
        let res = api.SetFileBandwidthReservation(
            h_file,
            n_period_milliseconds,
            n_bytes_per_period,
            b_discardable,
            lp_transfer_size,
            lp_num_outstanding_requests,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileCompletionNotificationModes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileCompletionNotificationModes");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{file_handle = {:?}, flags = {:?}}}",
            file_handle,
            flags
        );
        let res = api.SetFileCompletionNotificationModes(file_handle, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileInformationByHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let file_information_class = call.get_arg();
        let lp_file_information = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileInformationByHandle");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, file_information_class = {:?}, lp_file_information = {:?}, dw_buffer_size = {:?}}}" , h_file , file_information_class , lp_file_information , dw_buffer_size );
        let res = api.SetFileInformationByHandle(
            h_file,
            file_information_class,
            lp_file_information,
            dw_buffer_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileIoOverlappedRange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let overlapped_range_start = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileIoOverlappedRange");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{file_handle = {:?}, overlapped_range_start = {:?}, length = {:?}}}",
            file_handle,
            overlapped_range_start,
            length
        );
        let res = api.SetFileIoOverlappedRange(file_handle, overlapped_range_start, length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFilePointer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let l_distance_to_move = call.get_arg();
        let lp_distance_to_move_high = call.get_arg();
        let dw_move_method = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFilePointer");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, l_distance_to_move = {:?}, lp_distance_to_move_high = {:?}, dw_move_method = {:?}}}" , h_file , l_distance_to_move , lp_distance_to_move_high , dw_move_method );
        let res = api.SetFilePointer(
            h_file,
            l_distance_to_move,
            lp_distance_to_move_high,
            dw_move_method,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFilePointerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let li_distance_to_move = call.get_arg();
        let lp_new_file_pointer = call.get_arg();
        let dw_move_method = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFilePointerEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, li_distance_to_move = {:?}, lp_new_file_pointer = {:?}, dw_move_method = {:?}}}" , h_file , li_distance_to_move , lp_new_file_pointer , dw_move_method );
        let res = api.SetFilePointerEx(
            h_file,
            li_distance_to_move,
            lp_new_file_pointer,
            dw_move_method,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileShortNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_short_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileShortNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_short_name = {:?}}}",
            h_file,
            lp_short_name
        );
        let res = api.SetFileShortNameA(h_file, lp_short_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileShortNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_short_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileShortNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_short_name = {:?}}}",
            h_file,
            lp_short_name
        );
        let res = api.SetFileShortNameW(h_file, lp_short_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_last_access_time = call.get_arg();
        let lp_last_write_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileTime");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_creation_time = {:?}, lp_last_access_time = {:?}, lp_last_write_time = {:?}}}" , h_file , lp_creation_time , lp_last_access_time , lp_last_write_time );
        let res = api.SetFileTime(
            h_file,
            lp_creation_time,
            lp_last_access_time,
            lp_last_write_time,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFileValidData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let valid_data_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFileValidData");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, valid_data_length = {:?}}}",
            h_file,
            valid_data_length
        );
        let res = api.SetFileValidData(h_file, valid_data_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetIoRingCompletionEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetIoRingCompletionEvent");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{io_ring = {:?}, h_event = {:?}}}",
            io_ring,
            h_event
        );
        let res = api.SetIoRingCompletionEvent(io_ring, h_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetResourceManagerCompletionPort(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_manager_handle = call.get_arg();
        let io_completion_port_handle = call.get_arg();
        let completion_key = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetResourceManagerCompletionPort");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{resource_manager_handle = {:?}, io_completion_port_handle = {:?}, completion_key = {:?}}}" , resource_manager_handle , io_completion_port_handle , completion_key );
        let res = api.SetResourceManagerCompletionPort(
            resource_manager_handle,
            io_completion_port_handle,
            completion_key,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSearchPathMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetSearchPathMode");
        let _enter = span.enter();
        tracing::trace!("  args = {{flags = {:?}}}", flags);
        let res = api.SetSearchPathMode(flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTapeParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_operation = call.get_arg();
        let lp_tape_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetTapeParameters");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_device = {:?}, dw_operation = {:?}, lp_tape_information = {:?}}}",
            h_device,
            dw_operation,
            lp_tape_information
        );
        let res = api.SetTapeParameters(h_device, dw_operation, lp_tape_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTapePosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_position_method = call.get_arg();
        let dw_partition = call.get_arg();
        let dw_offset_low = call.get_arg();
        let dw_offset_high = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetTapePosition");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_device = {:?}, dw_position_method = {:?}, dw_partition = {:?}, dw_offset_low = {:?}, dw_offset_high = {:?}, b_immediate = {:?}}}" , h_device , dw_position_method , dw_partition , dw_offset_low , dw_offset_high , b_immediate );
        let res = api.SetTapePosition(
            h_device,
            dw_position_method,
            dw_partition,
            dw_offset_low,
            dw_offset_high,
            b_immediate,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTransactionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let transaction_handle = call.get_arg();
        let isolation_level = call.get_arg();
        let isolation_flags = call.get_arg();
        let timeout = call.get_arg();
        let description = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetTransactionInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{transaction_handle = {:?}, isolation_level = {:?}, isolation_flags = {:?}, timeout = {:?}, description = {:?}}}" , transaction_handle , isolation_level , isolation_flags , timeout , description );
        let res = api.SetTransactionInformation(
            transaction_handle,
            isolation_level,
            isolation_flags,
            timeout,
            description,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeLabelA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetVolumeLabelA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_root_path_name = {:?}, lp_volume_name = {:?}}}",
            lp_root_path_name,
            lp_volume_name
        );
        let res = api.SetVolumeLabelA(lp_root_path_name, lp_volume_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeLabelW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_root_path_name = call.get_arg();
        let lp_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetVolumeLabelW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_root_path_name = {:?}, lp_volume_name = {:?}}}",
            lp_root_path_name,
            lp_volume_name
        );
        let res = api.SetVolumeLabelW(lp_root_path_name, lp_volume_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeMountPointA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetVolumeMountPointA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}}}",
            lpsz_volume_mount_point,
            lpsz_volume_name
        );
        let res = api.SetVolumeMountPointA(lpsz_volume_mount_point, lpsz_volume_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetVolumeMountPointW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_volume_mount_point = call.get_arg();
        let lpsz_volume_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetVolumeMountPointW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_volume_mount_point = {:?}, lpsz_volume_name = {:?}}}",
            lpsz_volume_mount_point,
            lpsz_volume_name
        );
        let res = api.SetVolumeMountPointW(lpsz_volume_mount_point, lpsz_volume_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SinglePhaseReject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enlistment_handle = call.get_arg();
        let tm_virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SinglePhaseReject");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enlistment_handle = {:?}, tm_virtual_clock = {:?}}}",
            enlistment_handle,
            tm_virtual_clock
        );
        let res = api.SinglePhaseReject(enlistment_handle, tm_virtual_clock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SubmitIoRing(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let io_ring = call.get_arg();
        let wait_operations = call.get_arg();
        let milliseconds = call.get_arg();
        let submitted_entries = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SubmitIoRing");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{io_ring = {:?}, wait_operations = {:?}, milliseconds = {:?}, submitted_entries = {:?}}}" , io_ring , wait_operations , milliseconds , submitted_entries );
        let res = api.SubmitIoRing(io_ring, wait_operations, milliseconds, submitted_entries);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfGetThreadMiniVersionForCreate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let mini_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfGetThreadMiniVersionForCreate");
        let _enter = span.enter();
        tracing::trace!("  args = {{mini_version = {:?}}}", mini_version);
        let res = api.TxfGetThreadMiniVersionForCreate(mini_version);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogCreateFileReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_path = call.get_arg();
        let beginning_lsn = call.get_arg();
        let ending_lsn = call.get_arg();
        let txf_file_id = call.get_arg();
        let txf_log_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfLogCreateFileReadContext");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{log_path = {:?}, beginning_lsn = {:?}, ending_lsn = {:?}, txf_file_id = {:?}, txf_log_context = {:?}}}" , log_path , beginning_lsn , ending_lsn , txf_file_id , txf_log_context );
        let res = api.TxfLogCreateFileReadContext(
            log_path,
            beginning_lsn,
            ending_lsn,
            txf_file_id,
            txf_log_context,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogCreateRangeReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let log_path = call.get_arg();
        let beginning_lsn = call.get_arg();
        let ending_lsn = call.get_arg();
        let beginning_virtual_clock = call.get_arg();
        let ending_virtual_clock = call.get_arg();
        let record_type_mask = call.get_arg();
        let txf_log_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfLogCreateRangeReadContext");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{log_path = {:?}, beginning_lsn = {:?}, ending_lsn = {:?}, beginning_virtual_clock = {:?}, ending_virtual_clock = {:?}, record_type_mask = {:?}, txf_log_context = {:?}}}" , log_path , beginning_lsn , ending_lsn , beginning_virtual_clock , ending_virtual_clock , record_type_mask , txf_log_context );
        let res = api.TxfLogCreateRangeReadContext(
            log_path,
            beginning_lsn,
            ending_lsn,
            beginning_virtual_clock,
            ending_virtual_clock,
            record_type_mask,
            txf_log_context,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogDestroyReadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let txf_log_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfLogDestroyReadContext");
        let _enter = span.enter();
        tracing::trace!("  args = {{txf_log_context = {:?}}}", txf_log_context);
        let res = api.TxfLogDestroyReadContext(txf_log_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogReadRecords(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let txf_log_context = call.get_arg();
        let buffer_length = call.get_arg();
        let buffer = call.get_arg();
        let bytes_used = call.get_arg();
        let record_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfLogReadRecords");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{txf_log_context = {:?}, buffer_length = {:?}, buffer = {:?}, bytes_used = {:?}, record_count = {:?}}}" , txf_log_context , buffer_length , buffer , bytes_used , record_count );
        let res = api.TxfLogReadRecords(
            txf_log_context,
            buffer_length,
            buffer,
            bytes_used,
            record_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogRecordGetFileName(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let record_buffer = call.get_arg();
        let record_buffer_length_in_bytes = call.get_arg();
        let name_buffer = call.get_arg();
        let name_buffer_length_in_bytes = call.get_arg();
        let txf_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfLogRecordGetFileName");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{record_buffer = {:?}, record_buffer_length_in_bytes = {:?}, name_buffer = {:?}, name_buffer_length_in_bytes = {:?}, txf_id = {:?}}}" , record_buffer , record_buffer_length_in_bytes , name_buffer , name_buffer_length_in_bytes , txf_id );
        let res = api.TxfLogRecordGetFileName(
            record_buffer,
            record_buffer_length_in_bytes,
            name_buffer,
            name_buffer_length_in_bytes,
            txf_id,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfLogRecordGetGenericType(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let record_buffer = call.get_arg();
        let record_buffer_length_in_bytes = call.get_arg();
        let generic_type = call.get_arg();
        let virtual_clock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfLogRecordGetGenericType");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{record_buffer = {:?}, record_buffer_length_in_bytes = {:?}, generic_type = {:?}, virtual_clock = {:?}}}" , record_buffer , record_buffer_length_in_bytes , generic_type , virtual_clock );
        let res = api.TxfLogRecordGetGenericType(
            record_buffer,
            record_buffer_length_in_bytes,
            generic_type,
            virtual_clock,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfReadMetadataInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let txf_file_id = call.get_arg();
        let last_lsn = call.get_arg();
        let transaction_state = call.get_arg();
        let locking_transaction = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfReadMetadataInfo");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_handle = {:?}, txf_file_id = {:?}, last_lsn = {:?}, transaction_state = {:?}, locking_transaction = {:?}}}" , file_handle , txf_file_id , last_lsn , transaction_state , locking_transaction );
        let res = api.TxfReadMetadataInfo(
            file_handle,
            txf_file_id,
            last_lsn,
            transaction_state,
            locking_transaction,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TxfSetThreadMiniVersionForCreate(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let mini_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TxfSetThreadMiniVersionForCreate");
        let _enter = span.enter();
        tracing::trace!("  args = {{mini_version = {:?}}}", mini_version);
        let res = api.TxfSetThreadMiniVersionForCreate(mini_version);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnlockFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let n_number_of_bytes_to_unlock_low = call.get_arg();
        let n_number_of_bytes_to_unlock_high = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnlockFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, dw_file_offset_low = {:?}, dw_file_offset_high = {:?}, n_number_of_bytes_to_unlock_low = {:?}, n_number_of_bytes_to_unlock_high = {:?}}}" , h_file , dw_file_offset_low , dw_file_offset_high , n_number_of_bytes_to_unlock_low , n_number_of_bytes_to_unlock_high );
        let res = api.UnlockFile(
            h_file,
            dw_file_offset_low,
            dw_file_offset_high,
            n_number_of_bytes_to_unlock_low,
            n_number_of_bytes_to_unlock_high,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnlockFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let dw_reserved = call.get_arg();
        let n_number_of_bytes_to_unlock_low = call.get_arg();
        let n_number_of_bytes_to_unlock_high = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnlockFileEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, dw_reserved = {:?}, n_number_of_bytes_to_unlock_low = {:?}, n_number_of_bytes_to_unlock_high = {:?}, lp_overlapped = {:?}}}" , h_file , dw_reserved , n_number_of_bytes_to_unlock_low , n_number_of_bytes_to_unlock_high , lp_overlapped );
        let res = api.UnlockFileEx(
            h_file,
            dw_reserved,
            n_number_of_bytes_to_unlock_low,
            n_number_of_bytes_to_unlock_high,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerFindFileA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_file_name = call.get_arg();
        let sz_win_dir = call.get_arg();
        let sz_app_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let pu_cur_dir_len = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let pu_dest_dir_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerFindFileA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{u_flags = {:?}, sz_file_name = {:?}, sz_win_dir = {:?}, sz_app_dir = {:?}, sz_cur_dir = {:?}, pu_cur_dir_len = {:?}, sz_dest_dir = {:?}, pu_dest_dir_len = {:?}}}" , u_flags , sz_file_name , sz_win_dir , sz_app_dir , sz_cur_dir , pu_cur_dir_len , sz_dest_dir , pu_dest_dir_len );
        let res = api.VerFindFileA(
            u_flags,
            sz_file_name,
            sz_win_dir,
            sz_app_dir,
            sz_cur_dir,
            pu_cur_dir_len,
            sz_dest_dir,
            pu_dest_dir_len,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerFindFileW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_file_name = call.get_arg();
        let sz_win_dir = call.get_arg();
        let sz_app_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let pu_cur_dir_len = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let pu_dest_dir_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerFindFileW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{u_flags = {:?}, sz_file_name = {:?}, sz_win_dir = {:?}, sz_app_dir = {:?}, sz_cur_dir = {:?}, pu_cur_dir_len = {:?}, sz_dest_dir = {:?}, pu_dest_dir_len = {:?}}}" , u_flags , sz_file_name , sz_win_dir , sz_app_dir , sz_cur_dir , pu_cur_dir_len , sz_dest_dir , pu_dest_dir_len );
        let res = api.VerFindFileW(
            u_flags,
            sz_file_name,
            sz_win_dir,
            sz_app_dir,
            sz_cur_dir,
            pu_cur_dir_len,
            sz_dest_dir,
            pu_dest_dir_len,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerInstallFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_src_file_name = call.get_arg();
        let sz_dest_file_name = call.get_arg();
        let sz_src_dir = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let sz_tmp_file = call.get_arg();
        let pu_tmp_file_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerInstallFileA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{u_flags = {:?}, sz_src_file_name = {:?}, sz_dest_file_name = {:?}, sz_src_dir = {:?}, sz_dest_dir = {:?}, sz_cur_dir = {:?}, sz_tmp_file = {:?}, pu_tmp_file_len = {:?}}}" , u_flags , sz_src_file_name , sz_dest_file_name , sz_src_dir , sz_dest_dir , sz_cur_dir , sz_tmp_file , pu_tmp_file_len );
        let res = api.VerInstallFileA(
            u_flags,
            sz_src_file_name,
            sz_dest_file_name,
            sz_src_dir,
            sz_dest_dir,
            sz_cur_dir,
            sz_tmp_file,
            pu_tmp_file_len,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerInstallFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let sz_src_file_name = call.get_arg();
        let sz_dest_file_name = call.get_arg();
        let sz_src_dir = call.get_arg();
        let sz_dest_dir = call.get_arg();
        let sz_cur_dir = call.get_arg();
        let sz_tmp_file = call.get_arg();
        let pu_tmp_file_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerInstallFileW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{u_flags = {:?}, sz_src_file_name = {:?}, sz_dest_file_name = {:?}, sz_src_dir = {:?}, sz_dest_dir = {:?}, sz_cur_dir = {:?}, sz_tmp_file = {:?}, pu_tmp_file_len = {:?}}}" , u_flags , sz_src_file_name , sz_dest_file_name , sz_src_dir , sz_dest_dir , sz_cur_dir , sz_tmp_file , pu_tmp_file_len );
        let res = api.VerInstallFileW(
            u_flags,
            sz_src_file_name,
            sz_dest_file_name,
            sz_src_dir,
            sz_dest_dir,
            sz_cur_dir,
            sz_tmp_file,
            pu_tmp_file_len,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerLanguageNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_lang = call.get_arg();
        let sz_lang = call.get_arg();
        let cch_lang = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerLanguageNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{w_lang = {:?}, sz_lang = {:?}, cch_lang = {:?}}}",
            w_lang,
            sz_lang,
            cch_lang
        );
        let res = api.VerLanguageNameA(w_lang, sz_lang, cch_lang);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerLanguageNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_lang = call.get_arg();
        let sz_lang = call.get_arg();
        let cch_lang = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerLanguageNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{w_lang = {:?}, sz_lang = {:?}, cch_lang = {:?}}}",
            w_lang,
            sz_lang,
            cch_lang
        );
        let res = api.VerLanguageNameW(w_lang, sz_lang, cch_lang);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerQueryValueA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_block = call.get_arg();
        let lp_sub_block = call.get_arg();
        let lplp_buffer = call.get_arg();
        let pu_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerQueryValueA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{p_block = {:?}, lp_sub_block = {:?}, lplp_buffer = {:?}, pu_len = {:?}}}",
            p_block,
            lp_sub_block,
            lplp_buffer,
            pu_len
        );
        let res = api.VerQueryValueA(p_block, lp_sub_block, lplp_buffer, pu_len);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerQueryValueW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_block = call.get_arg();
        let lp_sub_block = call.get_arg();
        let lplp_buffer = call.get_arg();
        let pu_len = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerQueryValueW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{p_block = {:?}, lp_sub_block = {:?}, lplp_buffer = {:?}, pu_len = {:?}}}",
            p_block,
            lp_sub_block,
            lplp_buffer,
            pu_len
        );
        let res = api.VerQueryValueW(p_block, lp_sub_block, lplp_buffer, pu_len);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofEnumEntries(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let provider = call.get_arg();
        let enum_proc = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofEnumEntries");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{volume_name = {:?}, provider = {:?}, enum_proc = {:?}, user_data = {:?}}}",
            volume_name,
            provider,
            enum_proc,
            user_data
        );
        let res = api.WofEnumEntries(volume_name, provider, enum_proc, user_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofFileEnumFiles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let algorithm = call.get_arg();
        let enum_proc = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofFileEnumFiles");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{volume_name = {:?}, algorithm = {:?}, enum_proc = {:?}, user_data = {:?}}}",
            volume_name,
            algorithm,
            enum_proc,
            user_data
        );
        let res = api.WofFileEnumFiles(volume_name, algorithm, enum_proc, user_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofGetDriverVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_or_volume_handle = call.get_arg();
        let provider = call.get_arg();
        let wof_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofGetDriverVersion");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{file_or_volume_handle = {:?}, provider = {:?}, wof_version = {:?}}}",
            file_or_volume_handle,
            provider,
            wof_version
        );
        let res = api.WofGetDriverVersion(file_or_volume_handle, provider, wof_version);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofIsExternalFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_path = call.get_arg();
        let is_external_file = call.get_arg();
        let provider = call.get_arg();
        let external_file_info = call.get_arg();
        let buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofIsExternalFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_path = {:?}, is_external_file = {:?}, provider = {:?}, external_file_info = {:?}, buffer_length = {:?}}}" , file_path , is_external_file , provider , external_file_info , buffer_length );
        let res = api.WofIsExternalFile(
            file_path,
            is_external_file,
            provider,
            external_file_info,
            buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofSetFileDataLocation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let provider = call.get_arg();
        let external_file_info = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofSetFileDataLocation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_handle = {:?}, provider = {:?}, external_file_info = {:?}, length = {:?}}}" , file_handle , provider , external_file_info , length );
        let res = api.WofSetFileDataLocation(file_handle, provider, external_file_info, length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofShouldCompressBinaries(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume = call.get_arg();
        let algorithm = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofShouldCompressBinaries");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{volume = {:?}, algorithm = {:?}}}",
            volume,
            algorithm
        );
        let res = api.WofShouldCompressBinaries(volume, algorithm);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimAddEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let wim_path = call.get_arg();
        let wim_type = call.get_arg();
        let wim_index = call.get_arg();
        let data_source_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofWimAddEntry");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{volume_name = {:?}, wim_path = {:?}, wim_type = {:?}, wim_index = {:?}, data_source_id = {:?}}}" , volume_name , wim_path , wim_type , wim_index , data_source_id );
        let res = api.WofWimAddEntry(volume_name, wim_path, wim_type, wim_index, data_source_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimEnumFiles(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let enum_proc = call.get_arg();
        let user_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofWimEnumFiles");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{volume_name = {:?}, data_source_id = {:?}, enum_proc = {:?}, user_data = {:?}}}" , volume_name , data_source_id , enum_proc , user_data );
        let res = api.WofWimEnumFiles(volume_name, data_source_id, enum_proc, user_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimRemoveEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofWimRemoveEntry");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{volume_name = {:?}, data_source_id = {:?}}}",
            volume_name,
            data_source_id
        );
        let res = api.WofWimRemoveEntry(volume_name, data_source_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimSuspendEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofWimSuspendEntry");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{volume_name = {:?}, data_source_id = {:?}}}",
            volume_name,
            data_source_id
        );
        let res = api.WofWimSuspendEntry(volume_name, data_source_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WofWimUpdateEntry(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let volume_name = call.get_arg();
        let data_source_id = call.get_arg();
        let new_wim_path = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WofWimUpdateEntry");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{volume_name = {:?}, data_source_id = {:?}, new_wim_path = {:?}}}",
            volume_name,
            data_source_id,
            new_wim_path
        );
        let res = api.WofWimUpdateEntry(volume_name, data_source_id, new_wim_path);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64DisableWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let old_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("Wow64DisableWow64FsRedirection");
        let _enter = span.enter();
        tracing::trace!("  args = {{old_value = {:?}}}", old_value);
        let res = api.Wow64DisableWow64FsRedirection(old_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64EnableWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let wow_64_fs_enable_redirection = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("Wow64EnableWow64FsRedirection");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{wow_64_fs_enable_redirection = {:?}}}",
            wow_64_fs_enable_redirection
        );
        let res = api.Wow64EnableWow64FsRedirection(wow_64_fs_enable_redirection);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64RevertWow64FsRedirection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ol_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("Wow64RevertWow64FsRedirection");
        let _enter = span.enter();
        tracing::trace!("  args = {{ol_value = {:?}}}", ol_value);
        let res = api.Wow64RevertWow64FsRedirection(ol_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteEncryptedFileRaw(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pf_import_callback = call.get_arg();
        let pv_callback_context = call.get_arg();
        let pv_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteEncryptedFileRaw");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pf_import_callback = {:?}, pv_callback_context = {:?}, pv_context = {:?}}}",
            pf_import_callback,
            pv_callback_context,
            pv_context
        );
        let res = api.WriteEncryptedFileRaw(pf_import_callback, pv_callback_context, pv_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_number_of_bytes_written = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_write = {:?}, lp_number_of_bytes_written = {:?}, lp_overlapped = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_write , lp_number_of_bytes_written , lp_overlapped );
        let res = api.WriteFile(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_write,
            lp_number_of_bytes_written,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteFileEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_completion_routine = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteFileEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_buffer = {:?}, n_number_of_bytes_to_write = {:?}, lp_overlapped = {:?}, lp_completion_routine = {:?}}}" , h_file , lp_buffer , n_number_of_bytes_to_write , lp_overlapped , lp_completion_routine );
        let res = api.WriteFileEx(
            h_file,
            lp_buffer,
            n_number_of_bytes_to_write,
            lp_overlapped,
            lp_completion_routine,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteFileGather(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let a_segment_array = call.get_arg();
        let n_number_of_bytes_to_write = call.get_arg();
        let lp_reserved = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteFileGather");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, a_segment_array = {:?}, n_number_of_bytes_to_write = {:?}, lp_reserved = {:?}, lp_overlapped = {:?}}}" , h_file , a_segment_array , n_number_of_bytes_to_write , lp_reserved , lp_overlapped );
        let res = api.WriteFileGather(
            h_file,
            a_segment_array,
            n_number_of_bytes_to_write,
            lp_reserved,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteTapemark(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::Storage::FileSystem::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_tapemark_type = call.get_arg();
        let dw_tapemark_count = call.get_arg();
        let b_immediate = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteTapemark");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_device = {:?}, dw_tapemark_type = {:?}, dw_tapemark_count = {:?}, b_immediate = {:?}}}" , h_device , dw_tapemark_type , dw_tapemark_count , b_immediate );
        let res = api.WriteTapemark(h_device, dw_tapemark_type, dw_tapemark_count, b_immediate);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddConsoleAliasA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddConsoleAliasA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{source = {:?}, target = {:?}, exe_name = {:?}}}",
            source,
            target,
            exe_name
        );
        let res = api.AddConsoleAliasA(source, target, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddConsoleAliasW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddConsoleAliasW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{source = {:?}, target = {:?}, exe_name = {:?}}}",
            source,
            target,
            exe_name
        );
        let res = api.AddConsoleAliasW(source, target, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AllocConsole");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.AllocConsole();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AttachConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AttachConsole");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_process_id = {:?}}}", dw_process_id);
        let res = api.AttachConsole(dw_process_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ClosePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_pc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ClosePseudoConsole");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_pc = {:?}}}", h_pc);
        let res = api.ClosePseudoConsole(h_pc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreatePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let size = call.get_arg();
        let h_input = call.get_arg();
        let h_output = call.get_arg();
        let dw_flags = call.get_arg();
        let ph_pc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreatePseudoConsole");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{size = {:?}, h_input = {:?}, h_output = {:?}, dw_flags = {:?}, ph_pc = {:?}}}" , size , h_input , h_output , dw_flags , ph_pc );
        let res = api.CreatePseudoConsole(size, h_input, h_output, dw_flags, ph_pc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpungeConsoleCommandHistoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExpungeConsoleCommandHistoryA");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.ExpungeConsoleCommandHistoryA(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpungeConsoleCommandHistoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExpungeConsoleCommandHistoryW");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.ExpungeConsoleCommandHistoryW(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let w_attribute = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_attrs_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FillConsoleOutputAttribute");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, w_attribute = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_attrs_written = {:?}}}" , h_console_output , w_attribute , n_length , dw_write_coord , lp_number_of_attrs_written );
        let res = api.FillConsoleOutputAttribute(
            h_console_output,
            w_attribute,
            n_length,
            dw_write_coord,
            lp_number_of_attrs_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let c_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FillConsoleOutputCharacterA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, c_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , c_character , n_length , dw_write_coord , lp_number_of_chars_written );
        let res = api.FillConsoleOutputCharacterA(
            h_console_output,
            c_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FillConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let c_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FillConsoleOutputCharacterW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, c_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , c_character , n_length , dw_write_coord , lp_number_of_chars_written );
        let res = api.FillConsoleOutputCharacterW(
            h_console_output,
            c_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushConsoleInputBuffer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlushConsoleInputBuffer");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_console_input = {:?}}}", h_console_input);
        let res = api.FlushConsoleInputBuffer(h_console_input);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeConsole(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeConsole");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.FreeConsole();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GenerateConsoleCtrlEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_ctrl_event = call.get_arg();
        let dw_process_group_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GenerateConsoleCtrlEvent");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_ctrl_event = {:?}, dw_process_group_id = {:?}}}",
            dw_ctrl_event,
            dw_process_group_id
        );
        let res = api.GenerateConsoleCtrlEvent(dw_ctrl_event, dw_process_group_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target_buffer = call.get_arg();
        let target_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{source = {:?}, target_buffer = {:?}, target_buffer_length = {:?}, exe_name = {:?}}}" , source , target_buffer , target_buffer_length , exe_name );
        let res = api.GetConsoleAliasA(source, target_buffer, target_buffer_length, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name_buffer = call.get_arg();
        let exe_name_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasExesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{exe_name_buffer = {:?}, exe_name_buffer_length = {:?}}}",
            exe_name_buffer,
            exe_name_buffer_length
        );
        let res = api.GetConsoleAliasExesA(exe_name_buffer, exe_name_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasExesLengthA");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetConsoleAliasExesLengthA();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasExesLengthW");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetConsoleAliasExesLengthW();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasExesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name_buffer = call.get_arg();
        let exe_name_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasExesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{exe_name_buffer = {:?}, exe_name_buffer_length = {:?}}}",
            exe_name_buffer,
            exe_name_buffer_length
        );
        let res = api.GetConsoleAliasExesW(exe_name_buffer, exe_name_buffer_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source = call.get_arg();
        let target_buffer = call.get_arg();
        let target_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{source = {:?}, target_buffer = {:?}, target_buffer_length = {:?}, exe_name = {:?}}}" , source , target_buffer , target_buffer_length , exe_name );
        let res = api.GetConsoleAliasW(source, target_buffer, target_buffer_length, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let alias_buffer = call.get_arg();
        let alias_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{alias_buffer = {:?}, alias_buffer_length = {:?}, exe_name = {:?}}}",
            alias_buffer,
            alias_buffer_length,
            exe_name
        );
        let res = api.GetConsoleAliasesA(alias_buffer, alias_buffer_length, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasesLengthA");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.GetConsoleAliasesLengthA(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasesLengthW");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.GetConsoleAliasesLengthW(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleAliasesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let alias_buffer = call.get_arg();
        let alias_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleAliasesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{alias_buffer = {:?}, alias_buffer_length = {:?}, exe_name = {:?}}}",
            alias_buffer,
            alias_buffer_length,
            exe_name
        );
        let res = api.GetConsoleAliasesW(alias_buffer, alias_buffer_length, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleCP");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetConsoleCP();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let commands = call.get_arg();
        let command_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleCommandHistoryA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{commands = {:?}, command_buffer_length = {:?}, exe_name = {:?}}}",
            commands,
            command_buffer_length,
            exe_name
        );
        let res = api.GetConsoleCommandHistoryA(commands, command_buffer_length, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleCommandHistoryLengthA");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.GetConsoleCommandHistoryLengthA(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleCommandHistoryLengthW");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.GetConsoleCommandHistoryLengthW(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCommandHistoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let commands = call.get_arg();
        let command_buffer_length = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleCommandHistoryW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{commands = {:?}, command_buffer_length = {:?}, exe_name = {:?}}}",
            commands,
            command_buffer_length,
            exe_name
        );
        let res = api.GetConsoleCommandHistoryW(commands, command_buffer_length, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleCursorInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_cursor_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleCursorInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, lp_console_cursor_info = {:?}}}",
            h_console_output,
            lp_console_cursor_info
        );
        let res = api.GetConsoleCursorInfo(h_console_output, lp_console_cursor_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleDisplayMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_mode_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleDisplayMode");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_mode_flags = {:?}}}", lp_mode_flags);
        let res = api.GetConsoleDisplayMode(lp_mode_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleHistoryInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_history_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleHistoryInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_console_history_info = {:?}}}",
            lp_console_history_info
        );
        let res = api.GetConsoleHistoryInfo(lp_console_history_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_handle = call.get_arg();
        let lp_mode = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleMode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_handle = {:?}, lp_mode = {:?}}}",
            h_console_handle,
            lp_mode
        );
        let res = api.GetConsoleMode(h_console_handle, lp_mode);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOriginalTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleOriginalTitleA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_console_title = {:?}, n_size = {:?}}}",
            lp_console_title,
            n_size
        );
        let res = api.GetConsoleOriginalTitleA(lp_console_title, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOriginalTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleOriginalTitleW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_console_title = {:?}, n_size = {:?}}}",
            lp_console_title,
            n_size
        );
        let res = api.GetConsoleOriginalTitleW(lp_console_title, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleOutputCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleOutputCP");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetConsoleOutputCP();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleProcessList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpdw_process_list = call.get_arg();
        let dw_process_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleProcessList");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpdw_process_list = {:?}, dw_process_count = {:?}}}",
            lpdw_process_list,
            dw_process_count
        );
        let res = api.GetConsoleProcessList(lpdw_process_list, dw_process_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleScreenBufferInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_screen_buffer_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleScreenBufferInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, lp_console_screen_buffer_info = {:?}}}",
            h_console_output,
            lp_console_screen_buffer_info
        );
        let res = api.GetConsoleScreenBufferInfo(h_console_output, lp_console_screen_buffer_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleScreenBufferInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_screen_buffer_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleScreenBufferInfoEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, lp_console_screen_buffer_info_ex = {:?}}}",
            h_console_output,
            lp_console_screen_buffer_info_ex
        );
        let res =
            api.GetConsoleScreenBufferInfoEx(h_console_output, lp_console_screen_buffer_info_ex);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleSelectionInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_selection_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleSelectionInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_console_selection_info = {:?}}}",
            lp_console_selection_info
        );
        let res = api.GetConsoleSelectionInfo(lp_console_selection_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleTitleA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_console_title = {:?}, n_size = {:?}}}",
            lp_console_title,
            n_size
        );
        let res = api.GetConsoleTitleA(lp_console_title, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleTitleW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_console_title = {:?}, n_size = {:?}}}",
            lp_console_title,
            n_size
        );
        let res = api.GetConsoleTitleW(lp_console_title, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetConsoleWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetConsoleWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetConsoleWindow();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentConsoleFont(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_maximum_window = call.get_arg();
        let lp_console_current_font = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentConsoleFont");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, b_maximum_window = {:?}, lp_console_current_font = {:?}}}" , h_console_output , b_maximum_window , lp_console_current_font );
        let res =
            api.GetCurrentConsoleFont(h_console_output, b_maximum_window, lp_console_current_font);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentConsoleFontEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_maximum_window = call.get_arg();
        let lp_console_current_font_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentConsoleFontEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, b_maximum_window = {:?}, lp_console_current_font_ex = {:?}}}" , h_console_output , b_maximum_window , lp_console_current_font_ex );
        let res = api.GetCurrentConsoleFontEx(
            h_console_output,
            b_maximum_window,
            lp_console_current_font_ex,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberOfConsoleInputEvents(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_number_of_events = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumberOfConsoleInputEvents");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_input = {:?}, lp_number_of_events = {:?}}}",
            h_console_input,
            lp_number_of_events
        );
        let res = api.GetNumberOfConsoleInputEvents(h_console_input, lp_number_of_events);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumberOfConsoleMouseButtons(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_number_of_mouse_buttons = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumberOfConsoleMouseButtons");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_number_of_mouse_buttons = {:?}}}",
            lp_number_of_mouse_buttons
        );
        let res = api.GetNumberOfConsoleMouseButtons(lp_number_of_mouse_buttons);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStdHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_std_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStdHandle");
        let _enter = span.enter();
        tracing::trace!("  args = {{n_std_handle = {:?}}}", n_std_handle);
        let res = api.GetStdHandle(n_std_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PeekConsoleInputA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read );
        let res = api.PeekConsoleInputA(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PeekConsoleInputW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read );
        let res = api.PeekConsoleInputW(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_read = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let p_input_control = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_number_of_chars_to_read = {:?}, lp_number_of_chars_read = {:?}, p_input_control = {:?}}}" , h_console_input , lp_buffer , n_number_of_chars_to_read , lp_number_of_chars_read , p_input_control );
        let res = api.ReadConsoleA(
            h_console_input,
            lp_buffer,
            n_number_of_chars_to_read,
            lp_number_of_chars_read,
            p_input_control,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleInputA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read );
        let res = api.ReadConsoleInputA(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleInputW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_read = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_read );
        let res = api.ReadConsoleInputW(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_read,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_read_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleOutputA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_read_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_read_region );
        let res = api.ReadConsoleOutputA(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_read_region,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_attribute = call.get_arg();
        let n_length = call.get_arg();
        let dw_read_coord = call.get_arg();
        let lp_number_of_attrs_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleOutputAttribute");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_attribute = {:?}, n_length = {:?}, dw_read_coord = {:?}, lp_number_of_attrs_read = {:?}}}" , h_console_output , lp_attribute , n_length , dw_read_coord , lp_number_of_attrs_read );
        let res = api.ReadConsoleOutputAttribute(
            h_console_output,
            lp_attribute,
            n_length,
            dw_read_coord,
            lp_number_of_attrs_read,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_read_coord = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleOutputCharacterA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_read_coord = {:?}, lp_number_of_chars_read = {:?}}}" , h_console_output , lp_character , n_length , dw_read_coord , lp_number_of_chars_read );
        let res = api.ReadConsoleOutputCharacterA(
            h_console_output,
            lp_character,
            n_length,
            dw_read_coord,
            lp_number_of_chars_read,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_read_coord = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleOutputCharacterW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_read_coord = {:?}, lp_number_of_chars_read = {:?}}}" , h_console_output , lp_character , n_length , dw_read_coord , lp_number_of_chars_read );
        let res = api.ReadConsoleOutputCharacterW(
            h_console_output,
            lp_character,
            n_length,
            dw_read_coord,
            lp_number_of_chars_read,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleOutputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_read_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleOutputW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_read_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_read_region );
        let res = api.ReadConsoleOutputW(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_read_region,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReadConsoleW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_read = call.get_arg();
        let lp_number_of_chars_read = call.get_arg();
        let p_input_control = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReadConsoleW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_number_of_chars_to_read = {:?}, lp_number_of_chars_read = {:?}, p_input_control = {:?}}}" , h_console_input , lp_buffer , n_number_of_chars_to_read , lp_number_of_chars_read , p_input_control );
        let res = api.ReadConsoleW(
            h_console_input,
            lp_buffer,
            n_number_of_chars_to_read,
            lp_number_of_chars_read,
            p_input_control,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResizePseudoConsole(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_pc = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ResizePseudoConsole");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_pc = {:?}, size = {:?}}}", h_pc, size);
        let res = api.ResizePseudoConsole(h_pc, size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScrollConsoleScreenBufferA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_scroll_rectangle = call.get_arg();
        let lp_clip_rectangle = call.get_arg();
        let dw_destination_origin = call.get_arg();
        let lp_fill = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScrollConsoleScreenBufferA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_scroll_rectangle = {:?}, lp_clip_rectangle = {:?}, dw_destination_origin = {:?}, lp_fill = {:?}}}" , h_console_output , lp_scroll_rectangle , lp_clip_rectangle , dw_destination_origin , lp_fill );
        let res = api.ScrollConsoleScreenBufferA(
            h_console_output,
            lp_scroll_rectangle,
            lp_clip_rectangle,
            dw_destination_origin,
            lp_fill,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScrollConsoleScreenBufferW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_scroll_rectangle = call.get_arg();
        let lp_clip_rectangle = call.get_arg();
        let dw_destination_origin = call.get_arg();
        let lp_fill = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScrollConsoleScreenBufferW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_scroll_rectangle = {:?}, lp_clip_rectangle = {:?}, dw_destination_origin = {:?}, lp_fill = {:?}}}" , h_console_output , lp_scroll_rectangle , lp_clip_rectangle , dw_destination_origin , lp_fill );
        let res = api.ScrollConsoleScreenBufferW(
            h_console_output,
            lp_scroll_rectangle,
            lp_clip_rectangle,
            dw_destination_origin,
            lp_fill,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleActiveScreenBuffer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleActiveScreenBuffer");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_console_output = {:?}}}", h_console_output);
        let res = api.SetConsoleActiveScreenBuffer(h_console_output);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCP(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_code_page_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleCP");
        let _enter = span.enter();
        tracing::trace!("  args = {{w_code_page_id = {:?}}}", w_code_page_id);
        let res = api.SetConsoleCP(w_code_page_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCtrlHandler(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handler_routine = call.get_arg();
        let add = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleCtrlHandler");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{handler_routine = {:?}, add = {:?}}}",
            handler_routine,
            add
        );
        let res = api.SetConsoleCtrlHandler(handler_routine, add);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCursorInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_cursor_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleCursorInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, lp_console_cursor_info = {:?}}}",
            h_console_output,
            lp_console_cursor_info
        );
        let res = api.SetConsoleCursorInfo(h_console_output, lp_console_cursor_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleCursorPosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let dw_cursor_position = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleCursorPosition");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, dw_cursor_position = {:?}}}",
            h_console_output,
            dw_cursor_position
        );
        let res = api.SetConsoleCursorPosition(h_console_output, dw_cursor_position);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleDisplayMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_new_screen_buffer_dimensions = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleDisplayMode");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, dw_flags = {:?}, lp_new_screen_buffer_dimensions = {:?}}}" , h_console_output , dw_flags , lp_new_screen_buffer_dimensions );
        let res =
            api.SetConsoleDisplayMode(h_console_output, dw_flags, lp_new_screen_buffer_dimensions);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleHistoryInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_history_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleHistoryInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_console_history_info = {:?}}}",
            lp_console_history_info
        );
        let res = api.SetConsoleHistoryInfo(lp_console_history_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_handle = call.get_arg();
        let dw_mode = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleMode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_handle = {:?}, dw_mode = {:?}}}",
            h_console_handle,
            dw_mode
        );
        let res = api.SetConsoleMode(h_console_handle, dw_mode);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleNumberOfCommandsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let number = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleNumberOfCommandsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{number = {:?}, exe_name = {:?}}}",
            number,
            exe_name
        );
        let res = api.SetConsoleNumberOfCommandsA(number, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleNumberOfCommandsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let number = call.get_arg();
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleNumberOfCommandsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{number = {:?}, exe_name = {:?}}}",
            number,
            exe_name
        );
        let res = api.SetConsoleNumberOfCommandsW(number, exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleOutputCP(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_code_page_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleOutputCP");
        let _enter = span.enter();
        tracing::trace!("  args = {{w_code_page_id = {:?}}}", w_code_page_id);
        let res = api.SetConsoleOutputCP(w_code_page_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleScreenBufferInfoEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_console_screen_buffer_info_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleScreenBufferInfoEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, lp_console_screen_buffer_info_ex = {:?}}}",
            h_console_output,
            lp_console_screen_buffer_info_ex
        );
        let res =
            api.SetConsoleScreenBufferInfoEx(h_console_output, lp_console_screen_buffer_info_ex);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleScreenBufferSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleScreenBufferSize");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, dw_size = {:?}}}",
            h_console_output,
            dw_size
        );
        let res = api.SetConsoleScreenBufferSize(h_console_output, dw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTextAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let w_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleTextAttribute");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, w_attributes = {:?}}}",
            h_console_output,
            w_attributes
        );
        let res = api.SetConsoleTextAttribute(h_console_output, w_attributes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTitleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleTitleA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_console_title = {:?}}}", lp_console_title);
        let res = api.SetConsoleTitleA(lp_console_title);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleTitleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_console_title = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleTitleW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_console_title = {:?}}}", lp_console_title);
        let res = api.SetConsoleTitleW(lp_console_title);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetConsoleWindowInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_absolute = call.get_arg();
        let lp_console_window = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetConsoleWindowInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_console_output = {:?}, b_absolute = {:?}, lp_console_window = {:?}}}",
            h_console_output,
            b_absolute,
            lp_console_window
        );
        let res = api.SetConsoleWindowInfo(h_console_output, b_absolute, lp_console_window);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCurrentConsoleFontEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let b_maximum_window = call.get_arg();
        let lp_console_current_font_ex = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCurrentConsoleFontEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, b_maximum_window = {:?}, lp_console_current_font_ex = {:?}}}" , h_console_output , b_maximum_window , lp_console_current_font_ex );
        let res = api.SetCurrentConsoleFontEx(
            h_console_output,
            b_maximum_window,
            lp_console_current_font_ex,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetStdHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_std_handle = call.get_arg();
        let h_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetStdHandle");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_std_handle = {:?}, h_handle = {:?}}}",
            n_std_handle,
            h_handle
        );
        let res = api.SetStdHandle(n_std_handle, h_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetStdHandleEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_std_handle = call.get_arg();
        let h_handle = call.get_arg();
        let ph_prev_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetStdHandleEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_std_handle = {:?}, h_handle = {:?}, ph_prev_value = {:?}}}",
            n_std_handle,
            h_handle,
            ph_prev_value
        );
        let res = api.SetStdHandleEx(n_std_handle, h_handle, ph_prev_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_write = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_buffer = {:?}, n_number_of_chars_to_write = {:?}, lp_number_of_chars_written = {:?}, lp_reserved = {:?}}}" , h_console_output , lp_buffer , n_number_of_chars_to_write , lp_number_of_chars_written , lp_reserved );
        let res = api.WriteConsoleA(
            h_console_output,
            lp_buffer,
            n_number_of_chars_to_write,
            lp_number_of_chars_written,
            lp_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleInputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleInputA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_written = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_written );
        let res = api.WriteConsoleInputA(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleInputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_input = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_length = call.get_arg();
        let lp_number_of_events_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleInputW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_input = {:?}, lp_buffer = {:?}, n_length = {:?}, lp_number_of_events_written = {:?}}}" , h_console_input , lp_buffer , n_length , lp_number_of_events_written );
        let res = api.WriteConsoleInputW(
            h_console_input,
            lp_buffer,
            n_length,
            lp_number_of_events_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_write_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleOutputA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_write_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_write_region );
        let res = api.WriteConsoleOutputA(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_write_region,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_attribute = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_attrs_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleOutputAttribute");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_attribute = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_attrs_written = {:?}}}" , h_console_output , lp_attribute , n_length , dw_write_coord , lp_number_of_attrs_written );
        let res = api.WriteConsoleOutputAttribute(
            h_console_output,
            lp_attribute,
            n_length,
            dw_write_coord,
            lp_number_of_attrs_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputCharacterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleOutputCharacterA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , lp_character , n_length , dw_write_coord , lp_number_of_chars_written );
        let res = api.WriteConsoleOutputCharacterA(
            h_console_output,
            lp_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputCharacterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_character = call.get_arg();
        let n_length = call.get_arg();
        let dw_write_coord = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleOutputCharacterW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_character = {:?}, n_length = {:?}, dw_write_coord = {:?}, lp_number_of_chars_written = {:?}}}" , h_console_output , lp_character , n_length , dw_write_coord , lp_number_of_chars_written );
        let res = api.WriteConsoleOutputCharacterW(
            h_console_output,
            lp_character,
            n_length,
            dw_write_coord,
            lp_number_of_chars_written,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleOutputW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let dw_buffer_coord = call.get_arg();
        let lp_write_region = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleOutputW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_buffer = {:?}, dw_buffer_size = {:?}, dw_buffer_coord = {:?}, lp_write_region = {:?}}}" , h_console_output , lp_buffer , dw_buffer_size , dw_buffer_coord , lp_write_region );
        let res = api.WriteConsoleOutputW(
            h_console_output,
            lp_buffer,
            dw_buffer_size,
            dw_buffer_coord,
            lp_write_region,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteConsoleW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Console::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_console_output = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_number_of_chars_to_write = call.get_arg();
        let lp_number_of_chars_written = call.get_arg();
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteConsoleW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_console_output = {:?}, lp_buffer = {:?}, n_number_of_chars_to_write = {:?}, lp_number_of_chars_written = {:?}, lp_reserved = {:?}}}" , h_console_output , lp_buffer , n_number_of_chars_to_write , lp_number_of_chars_written , lp_reserved );
        let res = api.WriteConsoleW(
            h_console_output,
            lp_buffer,
            n_number_of_chars_to_write,
            lp_number_of_chars_written,
            lp_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnwind(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Diagnostics::Debug::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let target_frame = call.get_arg();
        let target_ip = call.get_arg();
        let exception_record = call.get_arg();
        let return_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlUnwind");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{target_frame = {:?}, target_ip = {:?}, exception_record = {:?}, return_value = {:?}}}" , target_frame , target_ip , exception_record , return_value );
        let res = api.RtlUnwind(target_frame, target_ip, exception_record, return_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnhandledExceptionFilter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Diagnostics::Debug::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exception_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnhandledExceptionFilter");
        let _enter = span.enter();
        tracing::trace!("  args = {{exception_info = {:?}}}", exception_info);
        let res = api.UnhandledExceptionFilter(exception_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_routine = call.get_arg();
        let lp_parameter = call.get_arg();
        let f_wait_for_thread = call.get_arg();
        let lp_return_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CallEnclave");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_routine = {:?}, lp_parameter = {:?}, f_wait_for_thread = {:?}, lp_return_value = {:?}}}" , lp_routine , lp_parameter , f_wait_for_thread , lp_return_value );
        let res = api.CallEnclave(lp_routine, lp_parameter, f_wait_for_thread, lp_return_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let dw_initial_commitment = call.get_arg();
        let fl_enclave_type = call.get_arg();
        let lp_enclave_information = call.get_arg();
        let dw_info_length = call.get_arg();
        let lp_enclave_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateEnclave");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, dw_initial_commitment = {:?}, fl_enclave_type = {:?}, lp_enclave_information = {:?}, dw_info_length = {:?}, lp_enclave_error = {:?}}}" , h_process , lp_address , dw_size , dw_initial_commitment , fl_enclave_type , lp_enclave_information , dw_info_length , lp_enclave_error );
        let res = api.CreateEnclave(
            h_process,
            lp_address,
            dw_size,
            dw_initial_commitment,
            fl_enclave_type,
            lp_enclave_information,
            dw_info_length,
            lp_enclave_error,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateEnvironmentBlock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_environment = call.get_arg();
        let h_token = call.get_arg();
        let b_inherit = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateEnvironmentBlock");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_environment = {:?}, h_token = {:?}, b_inherit = {:?}}}",
            lp_environment,
            h_token,
            b_inherit
        );
        let res = api.CreateEnvironmentBlock(lp_environment, h_token, b_inherit);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteEnclave(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteEnclave");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_address = {:?}}}", lp_address);
        let res = api.DeleteEnclave(lp_address);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyEnvironmentBlock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_environment = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DestroyEnvironmentBlock");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_environment = {:?}}}", lp_environment);
        let res = api.DestroyEnvironmentBlock(lp_environment);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveGetAttestationReport(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enclave_data = call.get_arg();
        let report = call.get_arg();
        let buffer_size = call.get_arg();
        let output_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnclaveGetAttestationReport");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{enclave_data = {:?}, report = {:?}, buffer_size = {:?}, output_size = {:?}}}" , enclave_data , report , buffer_size , output_size );
        let res = api.EnclaveGetAttestationReport(enclave_data, report, buffer_size, output_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveGetEnclaveInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let information_size = call.get_arg();
        let enclave_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnclaveGetEnclaveInformation");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{information_size = {:?}, enclave_information = {:?}}}",
            information_size,
            enclave_information
        );
        let res = api.EnclaveGetEnclaveInformation(information_size, enclave_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveSealData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let data_to_encrypt = call.get_arg();
        let data_to_encrypt_size = call.get_arg();
        let identity_policy = call.get_arg();
        let runtime_policy = call.get_arg();
        let protected_blob = call.get_arg();
        let buffer_size = call.get_arg();
        let protected_blob_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnclaveSealData");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{data_to_encrypt = {:?}, data_to_encrypt_size = {:?}, identity_policy = {:?}, runtime_policy = {:?}, protected_blob = {:?}, buffer_size = {:?}, protected_blob_size = {:?}}}" , data_to_encrypt , data_to_encrypt_size , identity_policy , runtime_policy , protected_blob , buffer_size , protected_blob_size );
        let res = api.EnclaveSealData(
            data_to_encrypt,
            data_to_encrypt_size,
            identity_policy,
            runtime_policy,
            protected_blob,
            buffer_size,
            protected_blob_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveUnsealData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let protected_blob = call.get_arg();
        let protected_blob_size = call.get_arg();
        let decrypted_data = call.get_arg();
        let buffer_size = call.get_arg();
        let decrypted_data_size = call.get_arg();
        let sealing_identity = call.get_arg();
        let unsealing_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnclaveUnsealData");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{protected_blob = {:?}, protected_blob_size = {:?}, decrypted_data = {:?}, buffer_size = {:?}, decrypted_data_size = {:?}, sealing_identity = {:?}, unsealing_flags = {:?}}}" , protected_blob , protected_blob_size , decrypted_data , buffer_size , decrypted_data_size , sealing_identity , unsealing_flags );
        let res = api.EnclaveUnsealData(
            protected_blob,
            protected_blob_size,
            decrypted_data,
            buffer_size,
            decrypted_data_size,
            sealing_identity,
            unsealing_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnclaveVerifyAttestationReport(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enclave_type = call.get_arg();
        let report = call.get_arg();
        let report_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnclaveVerifyAttestationReport");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{enclave_type = {:?}, report = {:?}, report_size = {:?}}}",
            enclave_type,
            report,
            report_size
        );
        let res = api.EnclaveVerifyAttestationReport(enclave_type, report, report_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_src = call.get_arg();
        let lp_dst = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExpandEnvironmentStringsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_src = {:?}, lp_dst = {:?}, n_size = {:?}}}",
            lp_src,
            lp_dst,
            n_size
        );
        let res = api.ExpandEnvironmentStringsA(lp_src, lp_dst, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsForUserA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_token = call.get_arg();
        let lp_src = call.get_arg();
        let lp_dest = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExpandEnvironmentStringsForUserA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_token = {:?}, lp_src = {:?}, lp_dest = {:?}, dw_size = {:?}}}",
            h_token,
            lp_src,
            lp_dest,
            dw_size
        );
        let res = api.ExpandEnvironmentStringsForUserA(h_token, lp_src, lp_dest, dw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsForUserW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_token = call.get_arg();
        let lp_src = call.get_arg();
        let lp_dest = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExpandEnvironmentStringsForUserW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_token = {:?}, lp_src = {:?}, lp_dest = {:?}, dw_size = {:?}}}",
            h_token,
            lp_src,
            lp_dest,
            dw_size
        );
        let res = api.ExpandEnvironmentStringsForUserW(h_token, lp_src, lp_dest, dw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExpandEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_src = call.get_arg();
        let lp_dst = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExpandEnvironmentStringsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_src = {:?}, lp_dst = {:?}, n_size = {:?}}}",
            lp_src,
            lp_dst,
            n_size
        );
        let res = api.ExpandEnvironmentStringsW(lp_src, lp_dst, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let penv = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeEnvironmentStringsA");
        let _enter = span.enter();
        tracing::trace!("  args = {{penv = {:?}}}", penv);
        let res = api.FreeEnvironmentStringsA(penv);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let penv = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeEnvironmentStringsW");
        let _enter = span.enter();
        tracing::trace!("  args = {{penv = {:?}}}", penv);
        let res = api.FreeEnvironmentStringsW(penv);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCommandLineA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCommandLineA");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCommandLineA();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCommandLineW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCommandLineW");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCommandLineW();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentDirectoryA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetCurrentDirectoryA(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentDirectoryW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetCurrentDirectoryW(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentStrings(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetEnvironmentStrings");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetEnvironmentStrings();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetEnvironmentStringsW");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetEnvironmentStringsW();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetEnvironmentVariableA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
            lp_name,
            lp_buffer,
            n_size
        );
        let res = api.GetEnvironmentVariableA(lp_name, lp_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetEnvironmentVariableW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
            lp_name,
            lp_buffer,
            n_size
        );
        let res = api.GetEnvironmentVariableW(lp_name, lp_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeEnclave(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let lp_enclave_information = call.get_arg();
        let dw_info_length = call.get_arg();
        let lp_enclave_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeEnclave");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_address = {:?}, lp_enclave_information = {:?}, dw_info_length = {:?}, lp_enclave_error = {:?}}}" , h_process , lp_address , lp_enclave_information , dw_info_length , lp_enclave_error );
        let res = api.InitializeEnclave(
            h_process,
            lp_address,
            lp_enclave_information,
            dw_info_length,
            lp_enclave_error,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsEnclaveTypeSupported(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let fl_enclave_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsEnclaveTypeSupported");
        let _enter = span.enter();
        tracing::trace!("  args = {{fl_enclave_type = {:?}}}", fl_enclave_type);
        let res = api.IsEnclaveTypeSupported(fl_enclave_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let fl_protect = call.get_arg();
        let lp_page_information = call.get_arg();
        let dw_info_length = call.get_arg();
        let lp_number_of_bytes_written = call.get_arg();
        let lp_enclave_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadEnclaveData");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_address = {:?}, lp_buffer = {:?}, n_size = {:?}, fl_protect = {:?}, lp_page_information = {:?}, dw_info_length = {:?}, lp_number_of_bytes_written = {:?}, lp_enclave_error = {:?}}}" , h_process , lp_address , lp_buffer , n_size , fl_protect , lp_page_information , dw_info_length , lp_number_of_bytes_written , lp_enclave_error );
        let res = api.LoadEnclaveData(
            h_process,
            lp_address,
            lp_buffer,
            n_size,
            fl_protect,
            lp_page_information,
            dw_info_length,
            lp_number_of_bytes_written,
            lp_enclave_error,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveImageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_enclave_address = call.get_arg();
        let lp_image_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadEnclaveImageA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_enclave_address = {:?}, lp_image_name = {:?}}}",
            lp_enclave_address,
            lp_image_name
        );
        let res = api.LoadEnclaveImageA(lp_enclave_address, lp_image_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadEnclaveImageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_enclave_address = call.get_arg();
        let lp_image_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadEnclaveImageW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_enclave_address = {:?}, lp_image_name = {:?}}}",
            lp_enclave_address,
            lp_image_name
        );
        let res = api.LoadEnclaveImageW(lp_enclave_address, lp_image_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedCurrentDirectoryForExePathA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NeedCurrentDirectoryForExePathA");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.NeedCurrentDirectoryForExePathA(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedCurrentDirectoryForExePathW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let exe_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NeedCurrentDirectoryForExePathW");
        let _enter = span.enter();
        tracing::trace!("  args = {{exe_name = {:?}}}", exe_name);
        let res = api.NeedCurrentDirectoryForExePathW(exe_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCurrentDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCurrentDirectoryA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_path_name = {:?}}}", lp_path_name);
        let res = api.SetCurrentDirectoryA(lp_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCurrentDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCurrentDirectoryW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_path_name = {:?}}}", lp_path_name);
        let res = api.SetCurrentDirectoryW(lp_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentStringsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let new_environment = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEnvironmentStringsW");
        let _enter = span.enter();
        tracing::trace!("  args = {{new_environment = {:?}}}", new_environment);
        let res = api.SetEnvironmentStringsW(new_environment);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEnvironmentVariableA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_value = {:?}}}",
            lp_name,
            lp_value
        );
        let res = api.SetEnvironmentVariableA(lp_name, lp_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEnvironmentVariableW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_value = {:?}}}",
            lp_name,
            lp_value
        );
        let res = api.SetEnvironmentVariableW(lp_name, lp_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TerminateEnclave(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Environment::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let f_wait = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TerminateEnclave");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_address = {:?}, f_wait = {:?}}}",
            lp_address,
            f_wait
        );
        let res = api.TerminateEnclave(lp_address, f_wait);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BindIoCompletionCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let function = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BindIoCompletionCallback");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{file_handle = {:?}, function = {:?}, flags = {:?}}}",
            file_handle,
            function,
            flags
        );
        let res = api.BindIoCompletionCallback(file_handle, function, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelIo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelIo");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_file = {:?}}}", h_file);
        let res = api.CancelIo(h_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelIoEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelIoEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_overlapped = {:?}}}",
            h_file,
            lp_overlapped
        );
        let res = api.CancelIoEx(h_file, lp_overlapped);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelSynchronousIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelSynchronousIo");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_thread = {:?}}}", h_thread);
        let res = api.CancelSynchronousIo(h_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIoCompletionPort(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let existing_completion_port = call.get_arg();
        let completion_key = call.get_arg();
        let number_of_concurrent_threads = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateIoCompletionPort");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_handle = {:?}, existing_completion_port = {:?}, completion_key = {:?}, number_of_concurrent_threads = {:?}}}" , file_handle , existing_completion_port , completion_key , number_of_concurrent_threads );
        let res = api.CreateIoCompletionPort(
            file_handle,
            existing_completion_port,
            completion_key,
            number_of_concurrent_threads,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeviceIoControl(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let dw_io_control_code = call.get_arg();
        let lp_in_buffer = call.get_arg();
        let n_in_buffer_size = call.get_arg();
        let lp_out_buffer = call.get_arg();
        let n_out_buffer_size = call.get_arg();
        let lp_bytes_returned = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeviceIoControl");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_device = {:?}, dw_io_control_code = {:?}, lp_in_buffer = {:?}, n_in_buffer_size = {:?}, lp_out_buffer = {:?}, n_out_buffer_size = {:?}, lp_bytes_returned = {:?}, lp_overlapped = {:?}}}" , h_device , dw_io_control_code , lp_in_buffer , n_in_buffer_size , lp_out_buffer , n_out_buffer_size , lp_bytes_returned , lp_overlapped );
        let res = api.DeviceIoControl(
            h_device,
            dw_io_control_code,
            lp_in_buffer,
            n_in_buffer_size,
            lp_out_buffer,
            n_out_buffer_size,
            lp_bytes_returned,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOverlappedResult(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_number_of_bytes_transferred = call.get_arg();
        let b_wait = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetOverlappedResult");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_overlapped = {:?}, lp_number_of_bytes_transferred = {:?}, b_wait = {:?}}}" , h_file , lp_overlapped , lp_number_of_bytes_transferred , b_wait );
        let res = api.GetOverlappedResult(
            h_file,
            lp_overlapped,
            lp_number_of_bytes_transferred,
            b_wait,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOverlappedResultEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_overlapped = call.get_arg();
        let lp_number_of_bytes_transferred = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetOverlappedResultEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file = {:?}, lp_overlapped = {:?}, lp_number_of_bytes_transferred = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}" , h_file , lp_overlapped , lp_number_of_bytes_transferred , dw_milliseconds , b_alertable );
        let res = api.GetOverlappedResultEx(
            h_file,
            lp_overlapped,
            lp_number_of_bytes_transferred,
            dw_milliseconds,
            b_alertable,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetQueuedCompletionStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let completion_port = call.get_arg();
        let lp_number_of_bytes_transferred = call.get_arg();
        let lp_completion_key = call.get_arg();
        let lp_overlapped = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetQueuedCompletionStatus");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{completion_port = {:?}, lp_number_of_bytes_transferred = {:?}, lp_completion_key = {:?}, lp_overlapped = {:?}, dw_milliseconds = {:?}}}" , completion_port , lp_number_of_bytes_transferred , lp_completion_key , lp_overlapped , dw_milliseconds );
        let res = api.GetQueuedCompletionStatus(
            completion_port,
            lp_number_of_bytes_transferred,
            lp_completion_key,
            lp_overlapped,
            dw_milliseconds,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetQueuedCompletionStatusEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let completion_port = call.get_arg();
        let lp_completion_port_entries = call.get_arg();
        let ul_count = call.get_arg();
        let ul_num_entries_removed = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let f_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetQueuedCompletionStatusEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{completion_port = {:?}, lp_completion_port_entries = {:?}, ul_count = {:?}, ul_num_entries_removed = {:?}, dw_milliseconds = {:?}, f_alertable = {:?}}}" , completion_port , lp_completion_port_entries , ul_count , ul_num_entries_removed , dw_milliseconds , f_alertable );
        let res = api.GetQueuedCompletionStatusEx(
            completion_port,
            lp_completion_port_entries,
            ul_count,
            ul_num_entries_removed,
            dw_milliseconds,
            f_alertable,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostQueuedCompletionStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::IO::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let completion_port = call.get_arg();
        let dw_number_of_bytes_transferred = call.get_arg();
        let dw_completion_key = call.get_arg();
        let lp_overlapped = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PostQueuedCompletionStatus");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{completion_port = {:?}, dw_number_of_bytes_transferred = {:?}, dw_completion_key = {:?}, lp_overlapped = {:?}}}" , completion_port , dw_number_of_bytes_transferred , dw_completion_key , lp_overlapped );
        let res = api.PostQueuedCompletionStatus(
            completion_port,
            dw_number_of_bytes_transferred,
            dw_completion_key,
            lp_overlapped,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFirstEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlFirstEntrySList");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.RtlFirstEntrySList(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitializeSListHead(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInitializeSListHead");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.RtlInitializeSListHead(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedFlushSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInterlockedFlushSList");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.RtlInterlockedFlushSList(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPopEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInterlockedPopEntrySList");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.RtlInterlockedPopEntrySList(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPushEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list_entry = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInterlockedPushEntrySList");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{list_head = {:?}, list_entry = {:?}}}",
            list_head,
            list_entry
        );
        let res = api.RtlInterlockedPushEntrySList(list_head, list_entry);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInterlockedPushListSListEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list = call.get_arg();
        let list_end = call.get_arg();
        let count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInterlockedPushListSListEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{list_head = {:?}, list = {:?}, list_end = {:?}, count = {:?}}}",
            list_head,
            list,
            list_end,
            count
        );
        let res = api.RtlInterlockedPushListSListEx(list_head, list, list_end, count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlQueryDepthSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Kernel::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlQueryDepthSList");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.RtlQueryDepthSList(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddDllDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let new_directory = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddDllDirectory");
        let _enter = span.enter();
        tracing::trace!("  args = {{new_directory = {:?}}}", new_directory);
        let res = api.AddDllDirectory(new_directory);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BeginUpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_file_name = call.get_arg();
        let b_delete_existing_resources = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BeginUpdateResourceA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{p_file_name = {:?}, b_delete_existing_resources = {:?}}}",
            p_file_name,
            b_delete_existing_resources
        );
        let res = api.BeginUpdateResourceA(p_file_name, b_delete_existing_resources);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BeginUpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_file_name = call.get_arg();
        let b_delete_existing_resources = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BeginUpdateResourceW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{p_file_name = {:?}, b_delete_existing_resources = {:?}}}",
            p_file_name,
            b_delete_existing_resources
        );
        let res = api.BeginUpdateResourceW(p_file_name, b_delete_existing_resources);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DisableThreadLibraryCalls(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_lib_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DisableThreadLibraryCalls");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_lib_module = {:?}}}", h_lib_module);
        let res = api.DisableThreadLibraryCalls(h_lib_module);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndUpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let f_discard = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EndUpdateResourceA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_update = {:?}, f_discard = {:?}}}",
            h_update,
            f_discard
        );
        let res = api.EndUpdateResourceA(h_update, f_discard);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndUpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let f_discard = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EndUpdateResourceW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_update = {:?}, f_discard = {:?}}}",
            h_update,
            f_discard
        );
        let res = api.EndUpdateResourceW(h_update, f_discard);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceLanguagesA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param );
        let res = api.EnumResourceLanguagesA(h_module, lp_type, lp_name, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceLanguagesExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param , dw_flags , lang_id );
        let res = api.EnumResourceLanguagesExA(
            h_module,
            lp_type,
            lp_name,
            lp_enum_func,
            l_param,
            dw_flags,
            lang_id,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceLanguagesExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param , dw_flags , lang_id );
        let res = api.EnumResourceLanguagesExW(
            h_module,
            lp_type,
            lp_name,
            lp_enum_func,
            l_param,
            dw_flags,
            lang_id,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceLanguagesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceLanguagesW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, lp_enum_func = {:?}, l_param = {:?}}}" , h_module , lp_type , lp_name , lp_enum_func , l_param );
        let res = api.EnumResourceLanguagesW(h_module, lp_type, lp_name, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceNamesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
            h_module,
            lp_type,
            lp_enum_func,
            l_param
        );
        let res = api.EnumResourceNamesA(h_module, lp_type, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceNamesExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_enum_func , l_param , dw_flags , lang_id );
        let res =
            api.EnumResourceNamesExA(h_module, lp_type, lp_enum_func, l_param, dw_flags, lang_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceNamesExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_type , lp_enum_func , l_param , dw_flags , lang_id );
        let res =
            api.EnumResourceNamesExW(h_module, lp_type, lp_enum_func, l_param, dw_flags, lang_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceNamesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceNamesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_type = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
            h_module,
            lp_type,
            lp_enum_func,
            l_param
        );
        let res = api.EnumResourceNamesW(h_module, lp_type, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceTypesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
            h_module,
            lp_enum_func,
            l_param
        );
        let res = api.EnumResourceTypesA(h_module, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceTypesExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_enum_func , l_param , dw_flags , lang_id );
        let res = api.EnumResourceTypesExA(h_module, lp_enum_func, l_param, dw_flags, lang_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let dw_flags = call.get_arg();
        let lang_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceTypesExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}, dw_flags = {:?}, lang_id = {:?}}}" , h_module , lp_enum_func , l_param , dw_flags , lang_id );
        let res = api.EnumResourceTypesExW(h_module, lp_enum_func, l_param, dw_flags, lang_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumResourceTypesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumResourceTypesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
            h_module,
            lp_enum_func,
            l_param
        );
        let res = api.EnumResourceTypesW(h_module, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_name = call.get_arg();
        let lp_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindResourceA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_name = {:?}, lp_type = {:?}}}",
            h_module,
            lp_name,
            lp_type
        );
        let res = api.FindResourceA(h_module, lp_name, lp_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindResourceExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}}}",
            h_module,
            lp_type,
            lp_name,
            w_language
        );
        let res = api.FindResourceExA(h_module, lp_type, lp_name, w_language);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindResourceExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}}}",
            h_module,
            lp_type,
            lp_name,
            w_language
        );
        let res = api.FindResourceExW(h_module, lp_type, lp_name, w_language);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindResourceW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_name = call.get_arg();
        let lp_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindResourceW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_name = {:?}, lp_type = {:?}}}",
            h_module,
            lp_name,
            lp_type
        );
        let res = api.FindResourceW(h_module, lp_name, lp_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeLibrary(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_lib_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeLibrary");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_lib_module = {:?}}}", h_lib_module);
        let res = api.FreeLibrary(h_lib_module);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeLibraryAndExitThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_lib_module = call.get_arg();
        let dw_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeLibraryAndExitThread");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_lib_module = {:?}, dw_exit_code = {:?}}}",
            h_lib_module,
            dw_exit_code
        );
        let res = api.FreeLibraryAndExitThread(h_lib_module, dw_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_res_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeResource");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_res_data = {:?}}}", h_res_data);
        let res = api.FreeResource(h_res_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDllDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDllDirectoryA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetDllDirectoryA(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDllDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_buffer_length = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDllDirectoryW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_buffer_length = {:?}, lp_buffer = {:?}}}",
            n_buffer_length,
            lp_buffer
        );
        let res = api.GetDllDirectoryW(n_buffer_length, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_filename = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetModuleFileNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_filename = {:?}, n_size = {:?}}}",
            h_module,
            lp_filename,
            n_size
        );
        let res = api.GetModuleFileNameA(h_module, lp_filename, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_filename = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetModuleFileNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_filename = {:?}, n_size = {:?}}}",
            h_module,
            lp_filename,
            n_size
        );
        let res = api.GetModuleFileNameW(h_module, lp_filename, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_module_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetModuleHandleA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_module_name = {:?}}}", lp_module_name);
        let res = api.GetModuleHandleA(lp_module_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_module_name = call.get_arg();
        let ph_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetModuleHandleExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, lp_module_name = {:?}, ph_module = {:?}}}",
            dw_flags,
            lp_module_name,
            ph_module
        );
        let res = api.GetModuleHandleExA(dw_flags, lp_module_name, ph_module);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_module_name = call.get_arg();
        let ph_module = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetModuleHandleExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_flags = {:?}, lp_module_name = {:?}, ph_module = {:?}}}",
            dw_flags,
            lp_module_name,
            ph_module
        );
        let res = api.GetModuleHandleExW(dw_flags, lp_module_name, ph_module);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetModuleHandleW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_module_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetModuleHandleW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_module_name = {:?}}}", lp_module_name);
        let res = api.GetModuleHandleW(lp_module_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcAddress(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let lp_proc_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcAddress");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, lp_proc_name = {:?}}}",
            h_module,
            lp_proc_name
        );
        let res = api.GetProcAddress(h_module, lp_proc_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadLibraryA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_lib_file_name = {:?}}}", lp_lib_file_name);
        let res = api.LoadLibraryA(lp_lib_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let h_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadLibraryExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_lib_file_name = {:?}, h_file = {:?}, dw_flags = {:?}}}",
            lp_lib_file_name,
            h_file,
            dw_flags
        );
        let res = api.LoadLibraryExA(lp_lib_file_name, h_file, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let h_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadLibraryExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_lib_file_name = {:?}, h_file = {:?}, dw_flags = {:?}}}",
            lp_lib_file_name,
            h_file,
            dw_flags
        );
        let res = api.LoadLibraryExW(lp_lib_file_name, h_file, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadLibraryW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_lib_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadLibraryW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_lib_file_name = {:?}}}", lp_lib_file_name);
        let res = api.LoadLibraryW(lp_lib_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadModule(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_module_name = call.get_arg();
        let lp_parameter_block = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadModule");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_module_name = {:?}, lp_parameter_block = {:?}}}",
            lp_module_name,
            lp_parameter_block
        );
        let res = api.LoadModule(lp_module_name, lp_parameter_block);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadPackagedLibrary(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpw_lib_file_name = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadPackagedLibrary");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpw_lib_file_name = {:?}, reserved = {:?}}}",
            lpw_lib_file_name,
            reserved
        );
        let res = api.LoadPackagedLibrary(lpw_lib_file_name, reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let h_res_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadResource");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, h_res_info = {:?}}}",
            h_module,
            h_res_info
        );
        let res = api.LoadResource(h_module, h_res_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LockResource(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_res_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LockResource");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_res_data = {:?}}}", h_res_data);
        let res = api.LockResource(h_res_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveDllDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let cookie = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveDllDirectory");
        let _enter = span.enter();
        tracing::trace!("  args = {{cookie = {:?}}}", cookie);
        let res = api.RemoveDllDirectory(cookie);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDefaultDllDirectories(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let directory_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetDefaultDllDirectories");
        let _enter = span.enter();
        tracing::trace!("  args = {{directory_flags = {:?}}}", directory_flags);
        let res = api.SetDefaultDllDirectories(directory_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDllDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetDllDirectoryA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_path_name = {:?}}}", lp_path_name);
        let res = api.SetDllDirectoryA(lp_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDllDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetDllDirectoryW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_path_name = {:?}}}", lp_path_name);
        let res = api.SetDllDirectoryW(lp_path_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SizeofResource(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_module = call.get_arg();
        let h_res_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SizeofResource");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_module = {:?}, h_res_info = {:?}}}",
            h_module,
            h_res_info
        );
        let res = api.SizeofResource(h_module, h_res_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UpdateResourceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let lp_data = call.get_arg();
        let cb = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UpdateResourceA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_update = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}, lp_data = {:?}, cb = {:?}}}" , h_update , lp_type , lp_name , w_language , lp_data , cb );
        let res = api.UpdateResourceA(h_update, lp_type, lp_name, w_language, lp_data, cb);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UpdateResourceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::LibraryLoader::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_update = call.get_arg();
        let lp_type = call.get_arg();
        let lp_name = call.get_arg();
        let w_language = call.get_arg();
        let lp_data = call.get_arg();
        let cb = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UpdateResourceW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_update = {:?}, lp_type = {:?}, lp_name = {:?}, w_language = {:?}, lp_data = {:?}, cb = {:?}}}" , h_update , lp_type , lp_name , w_language , lp_data , cb );
        let res = api.UpdateResourceW(h_update, lp_type, lp_name, w_language, lp_data, cb);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddSecureMemoryCacheCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfn_call_back = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddSecureMemoryCacheCallback");
        let _enter = span.enter();
        tracing::trace!("  args = {{pfn_call_back = {:?}}}", pfn_call_back);
        let res = api.AddSecureMemoryCacheCallback(pfn_call_back);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AllocateUserPhysicalPages");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, number_of_pages = {:?}, page_array = {:?}}}",
            h_process,
            number_of_pages,
            page_array
        );
        let res = api.AllocateUserPhysicalPages(h_process, number_of_pages, page_array);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPages2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let object_handle = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let extended_parameters = call.get_arg();
        let extended_parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AllocateUserPhysicalPages2");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{object_handle = {:?}, number_of_pages = {:?}, page_array = {:?}, extended_parameters = {:?}, extended_parameter_count = {:?}}}" , object_handle , number_of_pages , page_array , extended_parameters , extended_parameter_count );
        let res = api.AllocateUserPhysicalPages2(
            object_handle,
            number_of_pages,
            page_array,
            extended_parameters,
            extended_parameter_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllocateUserPhysicalPagesNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let nnd_preferred = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AllocateUserPhysicalPagesNuma");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, number_of_pages = {:?}, page_array = {:?}, nnd_preferred = {:?}}}" , h_process , number_of_pages , page_array , nnd_preferred );
        let res = api.AllocateUserPhysicalPagesNuma(
            h_process,
            number_of_pages,
            page_array,
            nnd_preferred,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMemoryResourceNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let notification_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateMemoryResourceNotification");
        let _enter = span.enter();
        tracing::trace!("  args = {{notification_type = {:?}}}", notification_type);
        let res = api.CreateMemoryResourceNotification(notification_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DiscardVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DiscardVirtualMemory");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{virtual_address = {:?}, size = {:?}}}",
            virtual_address,
            size
        );
        let res = api.DiscardVirtualMemory(virtual_address, size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushViewOfFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_base_address = call.get_arg();
        let dw_number_of_bytes_to_flush = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlushViewOfFile");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_base_address = {:?}, dw_number_of_bytes_to_flush = {:?}}}",
            lp_base_address,
            dw_number_of_bytes_to_flush
        );
        let res = api.FlushViewOfFile(lp_base_address, dw_number_of_bytes_to_flush);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeUserPhysicalPages");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, number_of_pages = {:?}, page_array = {:?}}}",
            h_process,
            number_of_pages,
            page_array
        );
        let res = api.FreeUserPhysicalPages(h_process, number_of_pages, page_array);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLargePageMinimum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLargePageMinimum");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetLargePageMinimum();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMemoryErrorHandlingCapabilities(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let capabilities = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMemoryErrorHandlingCapabilities");
        let _enter = span.enter();
        tracing::trace!("  args = {{capabilities = {:?}}}", capabilities);
        let res = api.GetMemoryErrorHandlingCapabilities(capabilities);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessHeap(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessHeap");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetProcessHeap();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessHeaps(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let number_of_heaps = call.get_arg();
        let process_heaps = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessHeaps");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{number_of_heaps = {:?}, process_heaps = {:?}}}",
            number_of_heaps,
            process_heaps
        );
        let res = api.GetProcessHeaps(number_of_heaps, process_heaps);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessWorkingSetSizeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_minimum_working_set_size = call.get_arg();
        let lp_maximum_working_set_size = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessWorkingSetSizeEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_minimum_working_set_size = {:?}, lp_maximum_working_set_size = {:?}, flags = {:?}}}" , h_process , lp_minimum_working_set_size , lp_maximum_working_set_size , flags );
        let res = api.GetProcessWorkingSetSizeEx(
            h_process,
            lp_minimum_working_set_size,
            lp_maximum_working_set_size,
            flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemFileCacheSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_minimum_file_cache_size = call.get_arg();
        let lp_maximum_file_cache_size = call.get_arg();
        let lp_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemFileCacheSize");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_minimum_file_cache_size = {:?}, lp_maximum_file_cache_size = {:?}, lp_flags = {:?}}}" , lp_minimum_file_cache_size , lp_maximum_file_cache_size , lp_flags );
        let res = api.GetSystemFileCacheSize(
            lp_minimum_file_cache_size,
            lp_maximum_file_cache_size,
            lp_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWriteWatch(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let lp_base_address = call.get_arg();
        let dw_region_size = call.get_arg();
        let lp_addresses = call.get_arg();
        let lpdw_count = call.get_arg();
        let lpdw_granularity = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWriteWatch");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_flags = {:?}, lp_base_address = {:?}, dw_region_size = {:?}, lp_addresses = {:?}, lpdw_count = {:?}, lpdw_granularity = {:?}}}" , dw_flags , lp_base_address , dw_region_size , lp_addresses , lpdw_count , lpdw_granularity );
        let res = api.GetWriteWatch(
            dw_flags,
            lp_base_address,
            dw_region_size,
            lp_addresses,
            lpdw_count,
            lpdw_granularity,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let dw_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalAlloc");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{u_flags = {:?}, dw_bytes = {:?}}}",
            u_flags,
            dw_bytes
        );
        let res = api.GlobalAlloc(u_flags, dw_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalFlags(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalFlags");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalFlags(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalFree");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalFree(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalHandle");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_mem = {:?}}}", p_mem);
        let res = api.GlobalHandle(p_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalLock");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalLock(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let dw_bytes = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalReAlloc");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_mem = {:?}, dw_bytes = {:?}, u_flags = {:?}}}",
            h_mem,
            dw_bytes,
            u_flags
        );
        let res = api.GlobalReAlloc(h_mem, dw_bytes, u_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalSize");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalSize(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalUnlock");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalUnlock(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let dw_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapAlloc");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, dw_flags = {:?}, dw_bytes = {:?}}}",
            h_heap,
            dw_flags,
            dw_bytes
        );
        let res = api.HeapAlloc(h_heap, dw_flags, dw_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapCompact");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, dw_flags = {:?}}}",
            h_heap,
            dw_flags
        );
        let res = api.HeapCompact(h_heap, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapCreate(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let fl_options = call.get_arg();
        let dw_initial_size = call.get_arg();
        let dw_maximum_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapCreate");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{fl_options = {:?}, dw_initial_size = {:?}, dw_maximum_size = {:?}}}",
            fl_options,
            dw_initial_size,
            dw_maximum_size
        );
        let res = api.HeapCreate(fl_options, dw_initial_size, dw_maximum_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapDestroy(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapDestroy");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_heap = {:?}}}", h_heap);
        let res = api.HeapDestroy(h_heap);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapFree");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}}}",
            h_heap,
            dw_flags,
            lp_mem
        );
        let res = api.HeapFree(h_heap, dw_flags, lp_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapLock");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_heap = {:?}}}", h_heap);
        let res = api.HeapLock(h_heap);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapQueryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let heap_handle = call.get_arg();
        let heap_information_class = call.get_arg();
        let heap_information = call.get_arg();
        let heap_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapQueryInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{heap_handle = {:?}, heap_information_class = {:?}, heap_information = {:?}, heap_information_length = {:?}, return_length = {:?}}}" , heap_handle , heap_information_class , heap_information , heap_information_length , return_length );
        let res = api.HeapQueryInformation(
            heap_handle,
            heap_information_class,
            heap_information,
            heap_information_length,
            return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let dw_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapReAlloc");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}, dw_bytes = {:?}}}",
            h_heap,
            dw_flags,
            lp_mem,
            dw_bytes
        );
        let res = api.HeapReAlloc(h_heap, dw_flags, lp_mem, dw_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapSetInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let heap_handle = call.get_arg();
        let heap_information_class = call.get_arg();
        let heap_information = call.get_arg();
        let heap_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapSetInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{heap_handle = {:?}, heap_information_class = {:?}, heap_information = {:?}, heap_information_length = {:?}}}" , heap_handle , heap_information_class , heap_information , heap_information_length );
        let res = api.HeapSetInformation(
            heap_handle,
            heap_information_class,
            heap_information,
            heap_information_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapSize");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}}}",
            h_heap,
            dw_flags,
            lp_mem
        );
        let res = api.HeapSize(h_heap, dw_flags, lp_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapSummary(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_summary = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapSummary");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, dw_flags = {:?}, lp_summary = {:?}}}",
            h_heap,
            dw_flags,
            lp_summary
        );
        let res = api.HeapSummary(h_heap, dw_flags, lp_summary);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapUnlock");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_heap = {:?}}}", h_heap);
        let res = api.HeapUnlock(h_heap);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapValidate(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapValidate");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, dw_flags = {:?}, lp_mem = {:?}}}",
            h_heap,
            dw_flags,
            lp_mem
        );
        let res = api.HeapValidate(h_heap, dw_flags, lp_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HeapWalk(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_heap = call.get_arg();
        let lp_entry = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HeapWalk");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_heap = {:?}, lp_entry = {:?}}}",
            h_heap,
            lp_entry
        );
        let res = api.HeapWalk(h_heap, lp_entry);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadCodePtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpfn = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsBadCodePtr");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpfn = {:?}}}", lpfn);
        let res = api.IsBadCodePtr(lpfn);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadReadPtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsBadReadPtr");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp = {:?}, ucb = {:?}}}", lp, ucb);
        let res = api.IsBadReadPtr(lp, ucb);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadStringPtrA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsBadStringPtrA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}, ucch_max = {:?}}}", lpsz, ucch_max);
        let res = api.IsBadStringPtrA(lpsz, ucch_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadStringPtrW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let ucch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsBadStringPtrW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}, ucch_max = {:?}}}", lpsz, ucch_max);
        let res = api.IsBadStringPtrW(lpsz, ucch_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadWritePtr(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsBadWritePtr");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp = {:?}, ucb = {:?}}}", lp, ucb);
        let res = api.IsBadWritePtr(lp, ucb);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_flags = call.get_arg();
        let u_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalAlloc");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{u_flags = {:?}, u_bytes = {:?}}}",
            u_flags,
            u_bytes
        );
        let res = api.LocalAlloc(u_flags, u_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalFlags(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalFlags");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.LocalFlags(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalFree");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.LocalFree(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalHandle(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalHandle");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_mem = {:?}}}", p_mem);
        let res = api.LocalHandle(p_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalLock");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.LocalLock(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalReAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let u_bytes = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalReAlloc");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_mem = {:?}, u_bytes = {:?}, u_flags = {:?}}}",
            h_mem,
            u_bytes,
            u_flags
        );
        let res = api.LocalReAlloc(h_mem, u_bytes, u_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalSize(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalSize");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.LocalSize(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalUnlock");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.LocalUnlock(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapUserPhysicalPages(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapUserPhysicalPages");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{virtual_address = {:?}, number_of_pages = {:?}, page_array = {:?}}}",
            virtual_address,
            number_of_pages,
            page_array
        );
        let res = api.MapUserPhysicalPages(virtual_address, number_of_pages, page_array);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapUserPhysicalPagesScatter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_addresses = call.get_arg();
        let number_of_pages = call.get_arg();
        let page_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapUserPhysicalPagesScatter");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{virtual_addresses = {:?}, number_of_pages = {:?}, page_array = {:?}}}",
            virtual_addresses,
            number_of_pages,
            page_array
        );
        let res = api.MapUserPhysicalPagesScatter(virtual_addresses, number_of_pages, page_array);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_number_of_bytes_to_map = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapViewOfFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file_mapping_object = {:?}, dw_desired_access = {:?}, dw_file_offset_high = {:?}, dw_file_offset_low = {:?}, dw_number_of_bytes_to_map = {:?}}}" , h_file_mapping_object , dw_desired_access , dw_file_offset_high , dw_file_offset_low , dw_number_of_bytes_to_map );
        let res = api.MapViewOfFile(
            h_file_mapping_object,
            dw_desired_access,
            dw_file_offset_high,
            dw_file_offset_low,
            dw_number_of_bytes_to_map,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile3(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_mapping = call.get_arg();
        let process = call.get_arg();
        let base_address = call.get_arg();
        let offset = call.get_arg();
        let view_size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapViewOfFile3");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_mapping = {:?}, process = {:?}, base_address = {:?}, offset = {:?}, view_size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , file_mapping , process , base_address , offset , view_size , allocation_type , page_protection , extended_parameters , parameter_count );
        let res = api.MapViewOfFile3(
            file_mapping,
            process,
            base_address,
            offset,
            view_size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFile3FromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_mapping = call.get_arg();
        let process = call.get_arg();
        let base_address = call.get_arg();
        let offset = call.get_arg();
        let view_size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapViewOfFile3FromApp");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_mapping = {:?}, process = {:?}, base_address = {:?}, offset = {:?}, view_size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , file_mapping , process , base_address , offset , view_size , allocation_type , page_protection , extended_parameters , parameter_count );
        let res = api.MapViewOfFile3FromApp(
            file_mapping,
            process,
            base_address,
            offset,
            view_size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_number_of_bytes_to_map = call.get_arg();
        let lp_base_address = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapViewOfFileEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file_mapping_object = {:?}, dw_desired_access = {:?}, dw_file_offset_high = {:?}, dw_file_offset_low = {:?}, dw_number_of_bytes_to_map = {:?}, lp_base_address = {:?}}}" , h_file_mapping_object , dw_desired_access , dw_file_offset_high , dw_file_offset_low , dw_number_of_bytes_to_map , lp_base_address );
        let res = api.MapViewOfFileEx(
            h_file_mapping_object,
            dw_desired_access,
            dw_file_offset_high,
            dw_file_offset_low,
            dw_number_of_bytes_to_map,
            lp_base_address,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileExNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let dw_desired_access = call.get_arg();
        let dw_file_offset_high = call.get_arg();
        let dw_file_offset_low = call.get_arg();
        let dw_number_of_bytes_to_map = call.get_arg();
        let lp_base_address = call.get_arg();
        let nnd_preferred = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapViewOfFileExNuma");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file_mapping_object = {:?}, dw_desired_access = {:?}, dw_file_offset_high = {:?}, dw_file_offset_low = {:?}, dw_number_of_bytes_to_map = {:?}, lp_base_address = {:?}, nnd_preferred = {:?}}}" , h_file_mapping_object , dw_desired_access , dw_file_offset_high , dw_file_offset_low , dw_number_of_bytes_to_map , lp_base_address , nnd_preferred );
        let res = api.MapViewOfFileExNuma(
            h_file_mapping_object,
            dw_desired_access,
            dw_file_offset_high,
            dw_file_offset_low,
            dw_number_of_bytes_to_map,
            lp_base_address,
            nnd_preferred,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file_mapping_object = call.get_arg();
        let desired_access = call.get_arg();
        let file_offset = call.get_arg();
        let number_of_bytes_to_map = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapViewOfFileFromApp");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_file_mapping_object = {:?}, desired_access = {:?}, file_offset = {:?}, number_of_bytes_to_map = {:?}}}" , h_file_mapping_object , desired_access , file_offset , number_of_bytes_to_map );
        let res = api.MapViewOfFileFromApp(
            h_file_mapping_object,
            desired_access,
            file_offset,
            number_of_bytes_to_map,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapViewOfFileNuma2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_mapping_handle = call.get_arg();
        let process_handle = call.get_arg();
        let offset = call.get_arg();
        let base_address = call.get_arg();
        let view_size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let preferred_node = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapViewOfFileNuma2");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_mapping_handle = {:?}, process_handle = {:?}, offset = {:?}, base_address = {:?}, view_size = {:?}, allocation_type = {:?}, page_protection = {:?}, preferred_node = {:?}}}" , file_mapping_handle , process_handle , offset , base_address , view_size , allocation_type , page_protection , preferred_node );
        let res = api.MapViewOfFileNuma2(
            file_mapping_handle,
            process_handle,
            offset,
            base_address,
            view_size,
            allocation_type,
            page_protection,
            preferred_node,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OfferVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let size = call.get_arg();
        let priority = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OfferVirtualMemory");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{virtual_address = {:?}, size = {:?}, priority = {:?}}}",
            virtual_address,
            size,
            priority
        );
        let res = api.OfferVirtualMemory(virtual_address, size, priority);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenDedicatedMemoryPartition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let partition = call.get_arg();
        let dedicated_memory_type_id = call.get_arg();
        let desired_access = call.get_arg();
        let inherit_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenDedicatedMemoryPartition");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{partition = {:?}, dedicated_memory_type_id = {:?}, desired_access = {:?}, inherit_handle = {:?}}}" , partition , dedicated_memory_type_id , desired_access , inherit_handle );
        let res = api.OpenDedicatedMemoryPartition(
            partition,
            dedicated_memory_type_id,
            desired_access,
            inherit_handle,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenFileMappingA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenFileMappingA(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let desired_access = call.get_arg();
        let inherit_handle = call.get_arg();
        let name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenFileMappingFromApp");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{desired_access = {:?}, inherit_handle = {:?}, name = {:?}}}",
            desired_access,
            inherit_handle,
            name
        );
        let res = api.OpenFileMappingFromApp(desired_access, inherit_handle, name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenFileMappingW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenFileMappingW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenFileMappingW(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrefetchVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let number_of_entries = call.get_arg();
        let virtual_addresses = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrefetchVirtualMemory");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, number_of_entries = {:?}, virtual_addresses = {:?}, flags = {:?}}}" , h_process , number_of_entries , virtual_addresses , flags );
        let res = api.PrefetchVirtualMemory(h_process, number_of_entries, virtual_addresses, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryMemoryResourceNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let resource_notification_handle = call.get_arg();
        let resource_state = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryMemoryResourceNotification");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{resource_notification_handle = {:?}, resource_state = {:?}}}",
            resource_notification_handle,
            resource_state
        );
        let res = api.QueryMemoryResourceNotification(resource_notification_handle, resource_state);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryPartitionInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let partition = call.get_arg();
        let partition_information_class = call.get_arg();
        let partition_information = call.get_arg();
        let partition_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryPartitionInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{partition = {:?}, partition_information_class = {:?}, partition_information = {:?}, partition_information_length = {:?}}}" , partition , partition_information_class , partition_information , partition_information_length );
        let res = api.QueryPartitionInformation(
            partition,
            partition_information_class,
            partition_information,
            partition_information_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryVirtualMemoryInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let virtual_address = call.get_arg();
        let memory_information_class = call.get_arg();
        let memory_information = call.get_arg();
        let memory_information_size = call.get_arg();
        let return_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryVirtualMemoryInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{process = {:?}, virtual_address = {:?}, memory_information_class = {:?}, memory_information = {:?}, memory_information_size = {:?}, return_size = {:?}}}" , process , virtual_address , memory_information_class , memory_information , memory_information_size , return_size );
        let res = api.QueryVirtualMemoryInformation(
            process,
            virtual_address,
            memory_information_class,
            memory_information,
            memory_information_size,
            return_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReclaimVirtualMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let virtual_address = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReclaimVirtualMemory");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{virtual_address = {:?}, size = {:?}}}",
            virtual_address,
            size
        );
        let res = api.ReclaimVirtualMemory(virtual_address, size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterBadMemoryNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let callback = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RegisterBadMemoryNotification");
        let _enter = span.enter();
        tracing::trace!("  args = {{callback = {:?}}}", callback);
        let res = api.RegisterBadMemoryNotification(callback);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveSecureMemoryCacheCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfn_call_back = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveSecureMemoryCacheCallback");
        let _enter = span.enter();
        tracing::trace!("  args = {{pfn_call_back = {:?}}}", pfn_call_back);
        let res = api.RemoveSecureMemoryCacheCallback(pfn_call_back);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResetWriteWatch(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_base_address = call.get_arg();
        let dw_region_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ResetWriteWatch");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_base_address = {:?}, dw_region_size = {:?}}}",
            lp_base_address,
            dw_region_size
        );
        let res = api.ResetWriteWatch(lp_base_address, dw_region_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCompareMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let source_1 = call.get_arg();
        let source_2 = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlCompareMemory");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{source_1 = {:?}, source_2 = {:?}, length = {:?}}}",
            source_1,
            source_2,
            length
        );
        let res = api.RtlCompareMemory(source_1, source_2, length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCrc32(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let size = call.get_arg();
        let initial_crc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlCrc32");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{buffer = {:?}, size = {:?}, initial_crc = {:?}}}",
            buffer,
            size,
            initial_crc
        );
        let res = api.RtlCrc32(buffer, size, initial_crc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCrc64(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let size = call.get_arg();
        let initial_crc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlCrc64");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{buffer = {:?}, size = {:?}, initial_crc = {:?}}}",
            buffer,
            size,
            initial_crc
        );
        let res = api.RtlCrc64(buffer, size, initial_crc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlIsZeroMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlIsZeroMemory");
        let _enter = span.enter();
        tracing::trace!("  args = {{buffer = {:?}, length = {:?}}}", buffer, length);
        let res = api.RtlIsZeroMemory(buffer, length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessValidCallTargets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let virtual_address = call.get_arg();
        let region_size = call.get_arg();
        let number_of_offsets = call.get_arg();
        let offset_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessValidCallTargets");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, virtual_address = {:?}, region_size = {:?}, number_of_offsets = {:?}, offset_information = {:?}}}" , h_process , virtual_address , region_size , number_of_offsets , offset_information );
        let res = api.SetProcessValidCallTargets(
            h_process,
            virtual_address,
            region_size,
            number_of_offsets,
            offset_information,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessValidCallTargetsForMappedView(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let virtual_address = call.get_arg();
        let region_size = call.get_arg();
        let number_of_offsets = call.get_arg();
        let offset_information = call.get_arg();
        let section = call.get_arg();
        let expected_file_offset = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessValidCallTargetsForMappedView");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{process = {:?}, virtual_address = {:?}, region_size = {:?}, number_of_offsets = {:?}, offset_information = {:?}, section = {:?}, expected_file_offset = {:?}}}" , process , virtual_address , region_size , number_of_offsets , offset_information , section , expected_file_offset );
        let res = api.SetProcessValidCallTargetsForMappedView(
            process,
            virtual_address,
            region_size,
            number_of_offsets,
            offset_information,
            section,
            expected_file_offset,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessWorkingSetSizeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_minimum_working_set_size = call.get_arg();
        let dw_maximum_working_set_size = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessWorkingSetSizeEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, dw_minimum_working_set_size = {:?}, dw_maximum_working_set_size = {:?}, flags = {:?}}}" , h_process , dw_minimum_working_set_size , dw_maximum_working_set_size , flags );
        let res = api.SetProcessWorkingSetSizeEx(
            h_process,
            dw_minimum_working_set_size,
            dw_maximum_working_set_size,
            flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemFileCacheSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let minimum_file_cache_size = call.get_arg();
        let maximum_file_cache_size = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetSystemFileCacheSize");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{minimum_file_cache_size = {:?}, maximum_file_cache_size = {:?}, flags = {:?}}}" , minimum_file_cache_size , maximum_file_cache_size , flags );
        let res =
            api.SetSystemFileCacheSize(minimum_file_cache_size, maximum_file_cache_size, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_base_address = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnmapViewOfFile");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_base_address = {:?}}}", lp_base_address);
        let res = api.UnmapViewOfFile(lp_base_address);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFile2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let base_address = call.get_arg();
        let unmap_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnmapViewOfFile2");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{process = {:?}, base_address = {:?}, unmap_flags = {:?}}}",
            process,
            base_address,
            unmap_flags
        );
        let res = api.UnmapViewOfFile2(process, base_address, unmap_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnmapViewOfFileEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let base_address = call.get_arg();
        let unmap_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnmapViewOfFileEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{base_address = {:?}, unmap_flags = {:?}}}",
            base_address,
            unmap_flags
        );
        let res = api.UnmapViewOfFileEx(base_address, unmap_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterBadMemoryNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let registration_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnregisterBadMemoryNotification");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{registration_handle = {:?}}}",
            registration_handle
        );
        let res = api.UnregisterBadMemoryNotification(registration_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_allocation_type = call.get_arg();
        let fl_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualAlloc");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_address = {:?}, dw_size = {:?}, fl_allocation_type = {:?}, fl_protect = {:?}}}" , lp_address , dw_size , fl_allocation_type , fl_protect );
        let res = api.VirtualAlloc(lp_address, dw_size, fl_allocation_type, fl_protect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let base_address = call.get_arg();
        let size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualAlloc2");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{process = {:?}, base_address = {:?}, size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , process , base_address , size , allocation_type , page_protection , extended_parameters , parameter_count );
        let res = api.VirtualAlloc2(
            process,
            base_address,
            size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAlloc2FromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let base_address = call.get_arg();
        let size = call.get_arg();
        let allocation_type = call.get_arg();
        let page_protection = call.get_arg();
        let extended_parameters = call.get_arg();
        let parameter_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualAlloc2FromApp");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{process = {:?}, base_address = {:?}, size = {:?}, allocation_type = {:?}, page_protection = {:?}, extended_parameters = {:?}, parameter_count = {:?}}}" , process , base_address , size , allocation_type , page_protection , extended_parameters , parameter_count );
        let res = api.VirtualAlloc2FromApp(
            process,
            base_address,
            size,
            allocation_type,
            page_protection,
            extended_parameters,
            parameter_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_allocation_type = call.get_arg();
        let fl_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualAllocEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, fl_allocation_type = {:?}, fl_protect = {:?}}}" , h_process , lp_address , dw_size , fl_allocation_type , fl_protect );
        let res = api.VirtualAllocEx(
            h_process,
            lp_address,
            dw_size,
            fl_allocation_type,
            fl_protect,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocExNuma(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_allocation_type = call.get_arg();
        let fl_protect = call.get_arg();
        let nnd_preferred = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualAllocExNuma");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, fl_allocation_type = {:?}, fl_protect = {:?}, nnd_preferred = {:?}}}" , h_process , lp_address , dw_size , fl_allocation_type , fl_protect , nnd_preferred );
        let res = api.VirtualAllocExNuma(
            h_process,
            lp_address,
            dw_size,
            fl_allocation_type,
            fl_protect,
            nnd_preferred,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualAllocFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let base_address = call.get_arg();
        let size = call.get_arg();
        let allocation_type = call.get_arg();
        let protection = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualAllocFromApp");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{base_address = {:?}, size = {:?}, allocation_type = {:?}, protection = {:?}}}" , base_address , size , allocation_type , protection );
        let res = api.VirtualAllocFromApp(base_address, size, allocation_type, protection);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let dw_free_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualFree");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_address = {:?}, dw_size = {:?}, dw_free_type = {:?}}}",
            lp_address,
            dw_size,
            dw_free_type
        );
        let res = api.VirtualFree(lp_address, dw_size, dw_free_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualFreeEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let dw_free_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualFreeEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, dw_free_type = {:?}}}",
            h_process,
            lp_address,
            dw_size,
            dw_free_type
        );
        let res = api.VirtualFreeEx(h_process, lp_address, dw_size, dw_free_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualLock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualLock");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_address = {:?}, dw_size = {:?}}}",
            lp_address,
            dw_size
        );
        let res = api.VirtualLock(lp_address, dw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualProtect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_new_protect = call.get_arg();
        let lpfl_old_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualProtect");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_address = {:?}, dw_size = {:?}, fl_new_protect = {:?}, lpfl_old_protect = {:?}}}" , lp_address , dw_size , fl_new_protect , lpfl_old_protect );
        let res = api.VirtualProtect(lp_address, dw_size, fl_new_protect, lpfl_old_protect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualProtectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let fl_new_protect = call.get_arg();
        let lpfl_old_protect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualProtectEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_address = {:?}, dw_size = {:?}, fl_new_protect = {:?}, lpfl_old_protect = {:?}}}" , h_process , lp_address , dw_size , fl_new_protect , lpfl_old_protect );
        let res = api.VirtualProtectEx(
            h_process,
            lp_address,
            dw_size,
            fl_new_protect,
            lpfl_old_protect,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualProtectFromApp(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let size = call.get_arg();
        let new_protection = call.get_arg();
        let old_protection = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualProtectFromApp");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{address = {:?}, size = {:?}, new_protection = {:?}, old_protection = {:?}}}" , address , size , new_protection , old_protection );
        let res = api.VirtualProtectFromApp(address, size, new_protection, old_protection);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualQuery(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualQuery");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_address = {:?}, lp_buffer = {:?}, dw_length = {:?}}}",
            lp_address,
            lp_buffer,
            dw_length
        );
        let res = api.VirtualQuery(lp_address, lp_buffer, dw_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualQueryEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_address = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualQueryEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, lp_address = {:?}, lp_buffer = {:?}, dw_length = {:?}}}",
            h_process,
            lp_address,
            lp_buffer,
            dw_length
        );
        let res = api.VirtualQueryEx(h_process, lp_address, lp_buffer, dw_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualUnlock(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_address = call.get_arg();
        let dw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualUnlock");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_address = {:?}, dw_size = {:?}}}",
            lp_address,
            dw_size
        );
        let res = api.VirtualUnlock(lp_address, dw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VirtualUnlockEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Memory::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let address = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VirtualUnlockEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{process = {:?}, address = {:?}, size = {:?}}}",
            process,
            address,
            size
        );
        let res = api.VirtualUnlockEx(process, address, size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetComputerNameExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{name_type = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
            name_type,
            lp_buffer,
            n_size
        );
        let res = api.GetComputerNameExA(name_type, lp_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetComputerNameExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{name_type = {:?}, lp_buffer = {:?}, n_size = {:?}}}",
            name_type,
            lp_buffer,
            n_size
        );
        let res = api.GetComputerNameExW(name_type, lp_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLocalTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLocalTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_system_time = {:?}}}", lp_system_time);
        let res = api.GetLocalTime(lp_system_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalProcessorInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer = call.get_arg();
        let returned_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLogicalProcessorInformation");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{buffer = {:?}, returned_length = {:?}}}",
            buffer,
            returned_length
        );
        let res = api.GetLogicalProcessorInformation(buffer, returned_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLogicalProcessorInformationEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let relationship_type = call.get_arg();
        let buffer = call.get_arg();
        let returned_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLogicalProcessorInformationEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{relationship_type = {:?}, buffer = {:?}, returned_length = {:?}}}",
            relationship_type,
            buffer,
            returned_length
        );
        let res = api.GetLogicalProcessorInformationEx(relationship_type, buffer, returned_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNativeSystemInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNativeSystemInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_system_info = {:?}}}", lp_system_info);
        let res = api.GetNativeSystemInfo(lp_system_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOsManufacturingMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pb_enabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetOsManufacturingMode");
        let _enter = span.enter();
        tracing::trace!("  args = {{pb_enabled = {:?}}}", pb_enabled);
        let res = api.GetOsManufacturingMode(pb_enabled);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetOsSafeBootMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetOsSafeBootMode");
        let _enter = span.enter();
        tracing::trace!("  args = {{flags = {:?}}}", flags);
        let res = api.GetOsSafeBootMode(flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPhysicallyInstalledSystemMemory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let total_memory_in_kilobytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPhysicallyInstalledSystemMemory");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{total_memory_in_kilobytes = {:?}}}",
            total_memory_in_kilobytes
        );
        let res = api.GetPhysicallyInstalledSystemMemory(total_memory_in_kilobytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessorSystemCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group = call.get_arg();
        let buffer = call.get_arg();
        let returned_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessorSystemCycleTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{group = {:?}, buffer = {:?}, returned_length = {:?}}}",
            group,
            buffer,
            returned_length
        );
        let res = api.GetProcessorSystemCycleTime(group, buffer, returned_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProductInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_os_major_version = call.get_arg();
        let dw_os_minor_version = call.get_arg();
        let dw_sp_major_version = call.get_arg();
        let dw_sp_minor_version = call.get_arg();
        let pdw_returned_product_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProductInfo");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_os_major_version = {:?}, dw_os_minor_version = {:?}, dw_sp_major_version = {:?}, dw_sp_minor_version = {:?}, pdw_returned_product_type = {:?}}}" , dw_os_major_version , dw_os_minor_version , dw_sp_major_version , dw_sp_minor_version , pdw_returned_product_type );
        let res = api.GetProductInfo(
            dw_os_major_version,
            dw_os_minor_version,
            dw_sp_major_version,
            dw_sp_minor_version,
            pdw_returned_product_type,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemCpuSetInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let information = call.get_arg();
        let buffer_length = call.get_arg();
        let returned_length = call.get_arg();
        let process = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemCpuSetInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{information = {:?}, buffer_length = {:?}, returned_length = {:?}, process = {:?}, flags = {:?}}}" , information , buffer_length , returned_length , process , flags );
        let res = api.GetSystemCpuSetInformation(
            information,
            buffer_length,
            returned_length,
            process,
            flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemDEPPolicy");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetSystemDEPPolicy();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemDirectoryA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetSystemDirectoryA(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemDirectoryW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetSystemDirectoryW(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemFirmwareTable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let firmware_table_provider_signature = call.get_arg();
        let firmware_table_id = call.get_arg();
        let p_firmware_table_buffer = call.get_arg();
        let buffer_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemFirmwareTable");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{firmware_table_provider_signature = {:?}, firmware_table_id = {:?}, p_firmware_table_buffer = {:?}, buffer_size = {:?}}}" , firmware_table_provider_signature , firmware_table_id , p_firmware_table_buffer , buffer_size );
        let res = api.GetSystemFirmwareTable(
            firmware_table_provider_signature,
            firmware_table_id,
            p_firmware_table_buffer,
            buffer_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_system_info = {:?}}}", lp_system_info);
        let res = api.GetSystemInfo(lp_system_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemLeapSecondInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let enabled = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemLeapSecondInformation");
        let _enter = span.enter();
        tracing::trace!("  args = {{enabled = {:?}, flags = {:?}}}", enabled, flags);
        let res = api.GetSystemLeapSecondInformation(enabled, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_system_time = {:?}}}", lp_system_time);
        let res = api.GetSystemTime(lp_system_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAdjustment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_adjustment = call.get_arg();
        let lp_time_increment = call.get_arg();
        let lp_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemTimeAdjustment");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_time_adjustment = {:?}, lp_time_increment = {:?}, lp_time_adjustment_disabled = {:?}}}" , lp_time_adjustment , lp_time_increment , lp_time_adjustment_disabled );
        let res = api.GetSystemTimeAdjustment(
            lp_time_adjustment,
            lp_time_increment,
            lp_time_adjustment_disabled,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAdjustmentPrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_time_adjustment = call.get_arg();
        let lp_time_increment = call.get_arg();
        let lp_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemTimeAdjustmentPrecise");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_time_adjustment = {:?}, lp_time_increment = {:?}, lp_time_adjustment_disabled = {:?}}}" , lp_time_adjustment , lp_time_increment , lp_time_adjustment_disabled );
        let res = api.GetSystemTimeAdjustmentPrecise(
            lp_time_adjustment,
            lp_time_increment,
            lp_time_adjustment_disabled,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimeAsFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time_as_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemTimeAsFileTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_system_time_as_file_time = {:?}}}",
            lp_system_time_as_file_time
        );
        let res = api.GetSystemTimeAsFileTime(lp_system_time_as_file_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimePreciseAsFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time_as_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemTimePreciseAsFileTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_system_time_as_file_time = {:?}}}",
            lp_system_time_as_file_time
        );
        let res = api.GetSystemTimePreciseAsFileTime(lp_system_time_as_file_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWindowsDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemWindowsDirectoryA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetSystemWindowsDirectoryA(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWindowsDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemWindowsDirectoryW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetSystemWindowsDirectoryW(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64Directory2A(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let image_file_machine_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemWow64Directory2A");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}, image_file_machine_type = {:?}}}",
            lp_buffer,
            u_size,
            image_file_machine_type
        );
        let res = api.GetSystemWow64Directory2A(lp_buffer, u_size, image_file_machine_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64Directory2W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let image_file_machine_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemWow64Directory2W");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}, image_file_machine_type = {:?}}}",
            lp_buffer,
            u_size,
            image_file_machine_type
        );
        let res = api.GetSystemWow64Directory2W(lp_buffer, u_size, image_file_machine_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64DirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemWow64DirectoryA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetSystemWow64DirectoryA(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemWow64DirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemWow64DirectoryW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetSystemWow64DirectoryW(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTickCount(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTickCount");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetTickCount();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTickCount64(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTickCount64");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetTickCount64();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersion(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVersion");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetVersion();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVersionExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_version_information = {:?}}}",
            lp_version_information
        );
        let res = api.GetVersionExA(lp_version_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVersionExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_version_information = {:?}}}",
            lp_version_information
        );
        let res = api.GetVersionExW(lp_version_information);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowsDirectoryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowsDirectoryA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetWindowsDirectoryA(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowsDirectoryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let u_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowsDirectoryW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, u_size = {:?}}}",
            lp_buffer,
            u_size
        );
        let res = api.GetWindowsDirectoryW(lp_buffer, u_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalMemoryStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalMemoryStatus");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_buffer = {:?}}}", lp_buffer);
        let res = api.GlobalMemoryStatus(lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalMemoryStatusEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalMemoryStatusEx");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_buffer = {:?}}}", lp_buffer);
        let res = api.GlobalMemoryStatusEx(lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlConvertDeviceFamilyInfoToString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pul_device_family_buffer_size = call.get_arg();
        let pul_device_form_buffer_size = call.get_arg();
        let device_family = call.get_arg();
        let device_form = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlConvertDeviceFamilyInfoToString");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{pul_device_family_buffer_size = {:?}, pul_device_form_buffer_size = {:?}, device_family = {:?}, device_form = {:?}}}" , pul_device_family_buffer_size , pul_device_form_buffer_size , device_family , device_form );
        let res = api.RtlConvertDeviceFamilyInfoToString(
            pul_device_family_buffer_size,
            pul_device_form_buffer_size,
            device_family,
            device_form,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetDeviceFamilyInfoEnum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pull_uap_info = call.get_arg();
        let pul_device_family = call.get_arg();
        let pul_device_form = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlGetDeviceFamilyInfoEnum");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pull_uap_info = {:?}, pul_device_family = {:?}, pul_device_form = {:?}}}",
            pull_uap_info,
            pul_device_family,
            pul_device_form
        );
        let res = api.RtlGetDeviceFamilyInfoEnum(pull_uap_info, pul_device_family, pul_device_form);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetProductInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let os_major_version = call.get_arg();
        let os_minor_version = call.get_arg();
        let sp_major_version = call.get_arg();
        let sp_minor_version = call.get_arg();
        let returned_product_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlGetProductInfo");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{os_major_version = {:?}, os_minor_version = {:?}, sp_major_version = {:?}, sp_minor_version = {:?}, returned_product_type = {:?}}}" , os_major_version , os_minor_version , sp_major_version , sp_minor_version , returned_product_type );
        let res = api.RtlGetProductInfo(
            os_major_version,
            os_minor_version,
            sp_major_version,
            sp_minor_version,
            returned_product_type,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetSystemGlobalData(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let data_id = call.get_arg();
        let buffer = call.get_arg();
        let size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlGetSystemGlobalData");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{data_id = {:?}, buffer = {:?}, size = {:?}}}",
            data_id,
            buffer,
            size
        );
        let res = api.RtlGetSystemGlobalData(data_id, buffer, size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlOsDeploymentState(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlOsDeploymentState");
        let _enter = span.enter();
        tracing::trace!("  args = {{flags = {:?}}}", flags);
        let res = api.RtlOsDeploymentState(flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlSwitchedVVI(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let version_info = call.get_arg();
        let type_mask = call.get_arg();
        let condition_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlSwitchedVVI");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{version_info = {:?}, type_mask = {:?}, condition_mask = {:?}}}",
            version_info,
            type_mask,
            condition_mask
        );
        let res = api.RtlSwitchedVVI(version_info, type_mask, condition_mask);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_computer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetComputerNameA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_computer_name = {:?}}}", lp_computer_name);
        let res = api.SetComputerNameA(lp_computer_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameEx2W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let flags = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetComputerNameEx2W");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{name_type = {:?}, flags = {:?}, lp_buffer = {:?}}}",
            name_type,
            flags,
            lp_buffer
        );
        let res = api.SetComputerNameEx2W(name_type, flags, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetComputerNameExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{name_type = {:?}, lp_buffer = {:?}}}",
            name_type,
            lp_buffer
        );
        let res = api.SetComputerNameExA(name_type, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name_type = call.get_arg();
        let lp_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetComputerNameExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{name_type = {:?}, lp_buffer = {:?}}}",
            name_type,
            lp_buffer
        );
        let res = api.SetComputerNameExW(name_type, lp_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_computer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetComputerNameW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_computer_name = {:?}}}", lp_computer_name);
        let res = api.SetComputerNameW(lp_computer_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLocalTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetLocalTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_system_time = {:?}}}", lp_system_time);
        let res = api.SetLocalTime(lp_system_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemTime(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetSystemTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_system_time = {:?}}}", lp_system_time);
        let res = api.SetSystemTime(lp_system_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemTimeAdjustment(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_time_adjustment = call.get_arg();
        let b_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetSystemTimeAdjustment");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_time_adjustment = {:?}, b_time_adjustment_disabled = {:?}}}",
            dw_time_adjustment,
            b_time_adjustment_disabled
        );
        let res = api.SetSystemTimeAdjustment(dw_time_adjustment, b_time_adjustment_disabled);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemTimeAdjustmentPrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_time_adjustment = call.get_arg();
        let b_time_adjustment_disabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetSystemTimeAdjustmentPrecise");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_time_adjustment = {:?}, b_time_adjustment_disabled = {:?}}}",
            dw_time_adjustment,
            b_time_adjustment_disabled
        );
        let res =
            api.SetSystemTimeAdjustmentPrecise(dw_time_adjustment, b_time_adjustment_disabled);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerSetConditionMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_mask = call.get_arg();
        let type_mask = call.get_arg();
        let condition = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerSetConditionMask");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{condition_mask = {:?}, type_mask = {:?}, condition = {:?}}}",
            condition_mask,
            type_mask,
            condition
        );
        let res = api.VerSetConditionMask(condition_mask, type_mask, condition);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerifyVersionInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let dw_type_mask = call.get_arg();
        let dwl_condition_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerifyVersionInfoA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_version_information = {:?}, dw_type_mask = {:?}, dwl_condition_mask = {:?}}}" , lp_version_information , dw_type_mask , dwl_condition_mask );
        let res = api.VerifyVersionInfoA(lp_version_information, dw_type_mask, dwl_condition_mask);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_VerifyVersionInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::SystemInformation::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_version_information = call.get_arg();
        let dw_type_mask = call.get_arg();
        let dwl_condition_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("VerifyVersionInfoW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_version_information = {:?}, dw_type_mask = {:?}, dwl_condition_mask = {:?}}}" , lp_version_information , dw_type_mask , dwl_condition_mask );
        let res = api.VerifyVersionInfoW(lp_version_information, dw_type_mask, dwl_condition_mask);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AcquireSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AcquireSRWLockExclusive");
        let _enter = span.enter();
        tracing::trace!("  args = {{srw_lock = {:?}}}", srw_lock);
        let res = api.AcquireSRWLockExclusive(srw_lock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AcquireSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AcquireSRWLockShared");
        let _enter = span.enter();
        tracing::trace!("  args = {{srw_lock = {:?}}}", srw_lock);
        let res = api.AcquireSRWLockShared(srw_lock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddIntegrityLabelToBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let boundary_descriptor = call.get_arg();
        let integrity_label = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddIntegrityLabelToBoundaryDescriptor");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{boundary_descriptor = {:?}, integrity_label = {:?}}}",
            boundary_descriptor,
            integrity_label
        );
        let res = api.AddIntegrityLabelToBoundaryDescriptor(boundary_descriptor, integrity_label);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddSIDToBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let boundary_descriptor = call.get_arg();
        let required_sid = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddSIDToBoundaryDescriptor");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{boundary_descriptor = {:?}, required_sid = {:?}}}",
            boundary_descriptor,
            required_sid
        );
        let res = api.AddSIDToBoundaryDescriptor(boundary_descriptor, required_sid);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AttachThreadInput(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_attach = call.get_arg();
        let id_attach_to = call.get_arg();
        let f_attach = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AttachThreadInput");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{id_attach = {:?}, id_attach_to = {:?}, f_attach = {:?}}}",
            id_attach,
            id_attach_to,
            f_attach
        );
        let res = api.AttachThreadInput(id_attach, id_attach_to, f_attach);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvQuerySystemResponsiveness(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let avrt_handle = call.get_arg();
        let system_responsiveness_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvQuerySystemResponsiveness");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{avrt_handle = {:?}, system_responsiveness_value = {:?}}}",
            avrt_handle,
            system_responsiveness_value
        );
        let res = api.AvQuerySystemResponsiveness(avrt_handle, system_responsiveness_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRevertMmThreadCharacteristics(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let avrt_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRevertMmThreadCharacteristics");
        let _enter = span.enter();
        tracing::trace!("  args = {{avrt_handle = {:?}}}", avrt_handle);
        let res = api.AvRevertMmThreadCharacteristics(avrt_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let period = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let timeout = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRtCreateThreadOrderingGroup");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{context = {:?}, period = {:?}, thread_ordering_guid = {:?}, timeout = {:?}}}" , context , period , thread_ordering_guid , timeout );
        let res = api.AvRtCreateThreadOrderingGroup(context, period, thread_ordering_guid, timeout);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroupExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let period = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let timeout = call.get_arg();
        let task_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRtCreateThreadOrderingGroupExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{context = {:?}, period = {:?}, thread_ordering_guid = {:?}, timeout = {:?}, task_name = {:?}}}" , context , period , thread_ordering_guid , timeout , task_name );
        let res = api.AvRtCreateThreadOrderingGroupExA(
            context,
            period,
            thread_ordering_guid,
            timeout,
            task_name,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtCreateThreadOrderingGroupExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let period = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let timeout = call.get_arg();
        let task_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRtCreateThreadOrderingGroupExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{context = {:?}, period = {:?}, thread_ordering_guid = {:?}, timeout = {:?}, task_name = {:?}}}" , context , period , thread_ordering_guid , timeout , task_name );
        let res = api.AvRtCreateThreadOrderingGroupExW(
            context,
            period,
            thread_ordering_guid,
            timeout,
            task_name,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtDeleteThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRtDeleteThreadOrderingGroup");
        let _enter = span.enter();
        tracing::trace!("  args = {{context = {:?}}}", context);
        let res = api.AvRtDeleteThreadOrderingGroup(context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtJoinThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let thread_ordering_guid = call.get_arg();
        let before = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRtJoinThreadOrderingGroup");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{context = {:?}, thread_ordering_guid = {:?}, before = {:?}}}",
            context,
            thread_ordering_guid,
            before
        );
        let res = api.AvRtJoinThreadOrderingGroup(context, thread_ordering_guid, before);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtLeaveThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRtLeaveThreadOrderingGroup");
        let _enter = span.enter();
        tracing::trace!("  args = {{context = {:?}}}", context);
        let res = api.AvRtLeaveThreadOrderingGroup(context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvRtWaitOnThreadOrderingGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvRtWaitOnThreadOrderingGroup");
        let _enter = span.enter();
        tracing::trace!("  args = {{context = {:?}}}", context);
        let res = api.AvRtWaitOnThreadOrderingGroup(context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmMaxThreadCharacteristicsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let first_task = call.get_arg();
        let second_task = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvSetMmMaxThreadCharacteristicsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{first_task = {:?}, second_task = {:?}, task_index = {:?}}}",
            first_task,
            second_task,
            task_index
        );
        let res = api.AvSetMmMaxThreadCharacteristicsA(first_task, second_task, task_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmMaxThreadCharacteristicsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let first_task = call.get_arg();
        let second_task = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvSetMmMaxThreadCharacteristicsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{first_task = {:?}, second_task = {:?}, task_index = {:?}}}",
            first_task,
            second_task,
            task_index
        );
        let res = api.AvSetMmMaxThreadCharacteristicsW(first_task, second_task, task_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadCharacteristicsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let task_name = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvSetMmThreadCharacteristicsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{task_name = {:?}, task_index = {:?}}}",
            task_name,
            task_index
        );
        let res = api.AvSetMmThreadCharacteristicsA(task_name, task_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadCharacteristicsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let task_name = call.get_arg();
        let task_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvSetMmThreadCharacteristicsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{task_name = {:?}, task_index = {:?}}}",
            task_name,
            task_index
        );
        let res = api.AvSetMmThreadCharacteristicsW(task_name, task_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AvSetMmThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let avrt_handle = call.get_arg();
        let priority = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AvSetMmThreadPriority");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{avrt_handle = {:?}, priority = {:?}}}",
            avrt_handle,
            priority
        );
        let res = api.AvSetMmThreadPriority(avrt_handle, priority);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallbackMayRunLong(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CallbackMayRunLong");
        let _enter = span.enter();
        tracing::trace!("  args = {{pci = {:?}}}", pci);
        let res = api.CallbackMayRunLong(pci);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelThreadpoolIo");
        let _enter = span.enter();
        tracing::trace!("  args = {{pio = {:?}}}", pio);
        let res = api.CancelThreadpoolIo(pio);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelWaitableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_timer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelWaitableTimer");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_timer = {:?}}}", h_timer);
        let res = api.CancelWaitableTimer(h_timer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let timer = call.get_arg();
        let due_time = call.get_arg();
        let period = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ChangeTimerQueueTimer");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{timer_queue = {:?}, timer = {:?}, due_time = {:?}, period = {:?}}}",
            timer_queue,
            timer,
            due_time,
            period
        );
        let res = api.ChangeTimerQueueTimer(timer_queue, timer, due_time, period);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ClosePrivateNamespace(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ClosePrivateNamespace");
        let _enter = span.enter();
        tracing::trace!("  args = {{handle = {:?}, flags = {:?}}}", handle, flags);
        let res = api.ClosePrivateNamespace(handle, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpool(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseThreadpool");
        let _enter = span.enter();
        tracing::trace!("  args = {{ptpp = {:?}}}", ptpp);
        let res = api.CloseThreadpool(ptpp);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolCleanupGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpcg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseThreadpoolCleanupGroup");
        let _enter = span.enter();
        tracing::trace!("  args = {{ptpcg = {:?}}}", ptpcg);
        let res = api.CloseThreadpoolCleanupGroup(ptpcg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolCleanupGroupMembers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpcg = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let pv_cleanup_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseThreadpoolCleanupGroupMembers");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ptpcg = {:?}, f_cancel_pending_callbacks = {:?}, pv_cleanup_context = {:?}}}" , ptpcg , f_cancel_pending_callbacks , pv_cleanup_context );
        let res = api.CloseThreadpoolCleanupGroupMembers(
            ptpcg,
            f_cancel_pending_callbacks,
            pv_cleanup_context,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseThreadpoolIo");
        let _enter = span.enter();
        tracing::trace!("  args = {{pio = {:?}}}", pio);
        let res = api.CloseThreadpoolIo(pio);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseThreadpoolTimer");
        let _enter = span.enter();
        tracing::trace!("  args = {{pti = {:?}}}", pti);
        let res = api.CloseThreadpoolTimer(pti);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseThreadpoolWait");
        let _enter = span.enter();
        tracing::trace!("  args = {{pwa = {:?}}}", pwa);
        let res = api.CloseThreadpoolWait(pwa);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwk = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseThreadpoolWork");
        let _enter = span.enter();
        tracing::trace!("  args = {{pwk = {:?}}}", pwk);
        let res = api.CloseThreadpoolWork(pwk);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertFiberToThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ConvertFiberToThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.ConvertFiberToThread();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertThreadToFiber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_parameter = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ConvertThreadToFiber");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_parameter = {:?}}}", lp_parameter);
        let res = api.ConvertThreadToFiber(lp_parameter);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertThreadToFiberEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_parameter = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ConvertThreadToFiberEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_parameter = {:?}, dw_flags = {:?}}}",
            lp_parameter,
            dw_flags
        );
        let res = api.ConvertThreadToFiberEx(lp_parameter, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateBoundaryDescriptorA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateBoundaryDescriptorA");
        let _enter = span.enter();
        tracing::trace!("  args = {{name = {:?}, flags = {:?}}}", name, flags);
        let res = api.CreateBoundaryDescriptorA(name, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateBoundaryDescriptorW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateBoundaryDescriptorW");
        let _enter = span.enter();
        tracing::trace!("  args = {{name = {:?}, flags = {:?}}}", name, flags);
        let res = api.CreateBoundaryDescriptorW(name, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_stack_size = call.get_arg();
        let lp_start_address = call.get_arg();
        let lp_parameter = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateFiber");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_stack_size = {:?}, lp_start_address = {:?}, lp_parameter = {:?}}}",
            dw_stack_size,
            lp_start_address,
            lp_parameter
        );
        let res = api.CreateFiber(dw_stack_size, lp_start_address, lp_parameter);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateFiberEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_stack_commit_size = call.get_arg();
        let dw_stack_reserve_size = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_start_address = call.get_arg();
        let lp_parameter = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateFiberEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_stack_commit_size = {:?}, dw_stack_reserve_size = {:?}, dw_flags = {:?}, lp_start_address = {:?}, lp_parameter = {:?}}}" , dw_stack_commit_size , dw_stack_reserve_size , dw_flags , lp_start_address , lp_parameter );
        let res = api.CreateFiberEx(
            dw_stack_commit_size,
            dw_stack_reserve_size,
            dw_flags,
            lp_start_address,
            lp_parameter,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateProcessWithLogonW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_username = call.get_arg();
        let lp_domain = call.get_arg();
        let lp_password = call.get_arg();
        let dw_logon_flags = call.get_arg();
        let lp_application_name = call.get_arg();
        let lp_command_line = call.get_arg();
        let dw_creation_flags = call.get_arg();
        let lp_environment = call.get_arg();
        let lp_current_directory = call.get_arg();
        let lp_startup_info = call.get_arg();
        let lp_process_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateProcessWithLogonW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_username = {:?}, lp_domain = {:?}, lp_password = {:?}, dw_logon_flags = {:?}, lp_application_name = {:?}, lp_command_line = {:?}, dw_creation_flags = {:?}, lp_environment = {:?}, lp_current_directory = {:?}, lp_startup_info = {:?}, lp_process_information = {:?}}}" , lp_username , lp_domain , lp_password , dw_logon_flags , lp_application_name , lp_command_line , dw_creation_flags , lp_environment , lp_current_directory , lp_startup_info , lp_process_information );
        let res = api.CreateProcessWithLogonW(
            lp_username,
            lp_domain,
            lp_password,
            dw_logon_flags,
            lp_application_name,
            lp_command_line,
            dw_creation_flags,
            lp_environment,
            lp_current_directory,
            lp_startup_info,
            lp_process_information,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateProcessWithTokenW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_token = call.get_arg();
        let dw_logon_flags = call.get_arg();
        let lp_application_name = call.get_arg();
        let lp_command_line = call.get_arg();
        let dw_creation_flags = call.get_arg();
        let lp_environment = call.get_arg();
        let lp_current_directory = call.get_arg();
        let lp_startup_info = call.get_arg();
        let lp_process_information = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateProcessWithTokenW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_token = {:?}, dw_logon_flags = {:?}, lp_application_name = {:?}, lp_command_line = {:?}, dw_creation_flags = {:?}, lp_environment = {:?}, lp_current_directory = {:?}, lp_startup_info = {:?}, lp_process_information = {:?}}}" , h_token , dw_logon_flags , lp_application_name , lp_command_line , dw_creation_flags , lp_environment , lp_current_directory , lp_startup_info , lp_process_information );
        let res = api.CreateProcessWithTokenW(
            h_token,
            dw_logon_flags,
            lp_application_name,
            lp_command_line,
            dw_creation_flags,
            lp_environment,
            lp_current_directory,
            lp_startup_info,
            lp_process_information,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpool(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateThreadpool");
        let _enter = span.enter();
        tracing::trace!("  args = {{reserved = {:?}}}", reserved);
        let res = api.CreateThreadpool(reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolCleanupGroup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateThreadpoolCleanupGroup");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.CreateThreadpoolCleanupGroup();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let fl = call.get_arg();
        let pfnio = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateThreadpoolIo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{fl = {:?}, pfnio = {:?}, pv = {:?}, pcbe = {:?}}}",
            fl,
            pfnio,
            pv,
            pcbe
        );
        let res = api.CreateThreadpoolIo(fl, pfnio, pv, pcbe);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfnti = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateThreadpoolTimer");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pfnti = {:?}, pv = {:?}, pcbe = {:?}}}",
            pfnti,
            pv,
            pcbe
        );
        let res = api.CreateThreadpoolTimer(pfnti, pv, pcbe);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfnwa = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateThreadpoolWait");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pfnwa = {:?}, pv = {:?}, pcbe = {:?}}}",
            pfnwa,
            pv,
            pcbe
        );
        let res = api.CreateThreadpoolWait(pfnwa, pv, pcbe);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfnwk = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateThreadpoolWork");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pfnwk = {:?}, pv = {:?}, pcbe = {:?}}}",
            pfnwk,
            pv,
            pcbe
        );
        let res = api.CreateThreadpoolWork(pfnwk, pv, pcbe);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateTimerQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateTimerQueue");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.CreateTimerQueue();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ph_new_timer = call.get_arg();
        let timer_queue = call.get_arg();
        let callback = call.get_arg();
        let parameter = call.get_arg();
        let due_time = call.get_arg();
        let period = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateTimerQueueTimer");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ph_new_timer = {:?}, timer_queue = {:?}, callback = {:?}, parameter = {:?}, due_time = {:?}, period = {:?}, flags = {:?}}}" , ph_new_timer , timer_queue , callback , parameter , due_time , period , flags );
        let res = api.CreateTimerQueueTimer(
            ph_new_timer,
            timer_queue,
            callback,
            parameter,
            due_time,
            period,
            flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateUmsCompletionList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateUmsCompletionList");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ums_completion_list = {:?}}}",
            ums_completion_list
        );
        let res = api.CreateUmsCompletionList(ums_completion_list);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateUmsThreadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_ums_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateUmsThreadContext");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_ums_thread = {:?}}}", lp_ums_thread);
        let res = api.CreateUmsThreadContext(lp_ums_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteBoundaryDescriptor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let boundary_descriptor = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteBoundaryDescriptor");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{boundary_descriptor = {:?}}}",
            boundary_descriptor
        );
        let res = api.DeleteBoundaryDescriptor(boundary_descriptor);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteCriticalSection");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}}}",
            lp_critical_section
        );
        let res = api.DeleteCriticalSection(lp_critical_section);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_fiber = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteFiber");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_fiber = {:?}}}", lp_fiber);
        let res = api.DeleteFiber(lp_fiber);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteProcThreadAttributeList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_attribute_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteProcThreadAttributeList");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_attribute_list = {:?}}}", lp_attribute_list);
        let res = api.DeleteProcThreadAttributeList(lp_attribute_list);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_barrier = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteSynchronizationBarrier");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_barrier = {:?}}}", lp_barrier);
        let res = api.DeleteSynchronizationBarrier(lp_barrier);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteTimerQueue");
        let _enter = span.enter();
        tracing::trace!("  args = {{timer_queue = {:?}}}", timer_queue);
        let res = api.DeleteTimerQueue(timer_queue);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueueEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteTimerQueueEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{timer_queue = {:?}, completion_event = {:?}}}",
            timer_queue,
            completion_event
        );
        let res = api.DeleteTimerQueueEx(timer_queue, completion_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let timer = call.get_arg();
        let completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteTimerQueueTimer");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{timer_queue = {:?}, timer = {:?}, completion_event = {:?}}}",
            timer_queue,
            timer,
            completion_event
        );
        let res = api.DeleteTimerQueueTimer(timer_queue, timer, completion_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteUmsCompletionList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteUmsCompletionList");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ums_completion_list = {:?}}}",
            ums_completion_list
        );
        let res = api.DeleteUmsCompletionList(ums_completion_list);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteUmsThreadContext(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteUmsThreadContext");
        let _enter = span.enter();
        tracing::trace!("  args = {{ums_thread = {:?}}}", ums_thread);
        let res = api.DeleteUmsThreadContext(ums_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DequeueUmsCompletionListItems(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let wait_time_out = call.get_arg();
        let ums_thread_list = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DequeueUmsCompletionListItems");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ums_completion_list = {:?}, wait_time_out = {:?}, ums_thread_list = {:?}}}",
            ums_completion_list,
            wait_time_out,
            ums_thread_list
        );
        let res =
            api.DequeueUmsCompletionListItems(ums_completion_list, wait_time_out, ums_thread_list);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DisassociateCurrentThreadFromCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DisassociateCurrentThreadFromCallback");
        let _enter = span.enter();
        tracing::trace!("  args = {{pci = {:?}}}", pci);
        let res = api.DisassociateCurrentThreadFromCallback(pci);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnterCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnterCriticalSection");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}}}",
            lp_critical_section
        );
        let res = api.EnterCriticalSection(lp_critical_section);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnterSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_barrier = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnterSynchronizationBarrier");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_barrier = {:?}, dw_flags = {:?}}}",
            lp_barrier,
            dw_flags
        );
        let res = api.EnterSynchronizationBarrier(lp_barrier, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExecuteUmsThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExecuteUmsThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{ums_thread = {:?}}}", ums_thread);
        let res = api.ExecuteUmsThread(ums_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExitProcess(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExitProcess");
        let _enter = span.enter();
        tracing::trace!("  args = {{u_exit_code = {:?}}}", u_exit_code);
        let res = api.ExitProcess(unwind_token, u_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExitThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExitThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_exit_code = {:?}}}", dw_exit_code);
        let res = api.ExitThread(unwind_token, dw_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_callback = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlsAlloc");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_callback = {:?}}}", lp_callback);
        let res = api.FlsAlloc(lp_callback);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_fls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlsFree");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_fls_index = {:?}}}", dw_fls_index);
        let res = api.FlsFree(dw_fls_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsGetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_fls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlsGetValue");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_fls_index = {:?}}}", dw_fls_index);
        let res = api.FlsGetValue(dw_fls_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlsSetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_fls_index = call.get_arg();
        let lp_fls_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlsSetValue");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_fls_index = {:?}, lp_fls_data = {:?}}}",
            dw_fls_index,
            lp_fls_data
        );
        let res = api.FlsSetValue(dw_fls_index, lp_fls_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlushProcessWriteBuffers(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlushProcessWriteBuffers");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.FlushProcessWriteBuffers();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FreeLibraryWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let r#mod = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FreeLibraryWhenCallbackReturns");
        let _enter = span.enter();
        tracing::trace!("  args = {{pci = {:?}, r#mod = {:?}}}", pci, r#mod);
        let res = api.FreeLibraryWhenCallbackReturns(pci, r#mod);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetActiveProcessorCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetActiveProcessorCount");
        let _enter = span.enter();
        tracing::trace!("  args = {{group_number = {:?}}}", group_number);
        let res = api.GetActiveProcessorCount(group_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetActiveProcessorGroupCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetActiveProcessorGroupCount");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetActiveProcessorGroupCount();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentProcess");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCurrentProcess();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentProcessId");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCurrentProcessId();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessorNumber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentProcessorNumber");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCurrentProcessorNumber();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentProcessorNumberEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let proc_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentProcessorNumberEx");
        let _enter = span.enter();
        tracing::trace!("  args = {{proc_number = {:?}}}", proc_number);
        let res = api.GetCurrentProcessorNumberEx(proc_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCurrentThread();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThreadId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentThreadId");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCurrentThreadId();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentThreadStackLimits(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let low_limit = call.get_arg();
        let high_limit = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentThreadStackLimits");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{low_limit = {:?}, high_limit = {:?}}}",
            low_limit,
            high_limit
        );
        let res = api.GetCurrentThreadStackLimits(low_limit, high_limit);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentUmsThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentUmsThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCurrentUmsThread();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExitCodeProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetExitCodeProcess");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, lp_exit_code = {:?}}}",
            h_process,
            lp_exit_code
        );
        let res = api.GetExitCodeProcess(h_process, lp_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetExitCodeThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetExitCodeThread");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, lp_exit_code = {:?}}}",
            h_thread,
            lp_exit_code
        );
        let res = api.GetExitCodeThread(h_thread, lp_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGuiResources(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let ui_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetGuiResources");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, ui_flags = {:?}}}",
            h_process,
            ui_flags
        );
        let res = api.GetGuiResources(h_process, ui_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMachineTypeAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let machine = call.get_arg();
        let machine_type_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMachineTypeAttributes");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{machine = {:?}, machine_type_attributes = {:?}}}",
            machine,
            machine_type_attributes
        );
        let res = api.GetMachineTypeAttributes(machine, machine_type_attributes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMaximumProcessorCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMaximumProcessorCount");
        let _enter = span.enter();
        tracing::trace!("  args = {{group_number = {:?}}}", group_number);
        let res = api.GetMaximumProcessorCount(group_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMaximumProcessorGroupCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMaximumProcessorGroupCount");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetMaximumProcessorGroupCount();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNextUmsListItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNextUmsListItem");
        let _enter = span.enter();
        tracing::trace!("  args = {{ums_context = {:?}}}", ums_context);
        let res = api.GetNextUmsListItem(ums_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaAvailableMemoryNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let available_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaAvailableMemoryNode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{node = {:?}, available_bytes = {:?}}}",
            node,
            available_bytes
        );
        let res = api.GetNumaAvailableMemoryNode(node, available_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaAvailableMemoryNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let available_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaAvailableMemoryNodeEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{node = {:?}, available_bytes = {:?}}}",
            node,
            available_bytes
        );
        let res = api.GetNumaAvailableMemoryNodeEx(node, available_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaHighestNodeNumber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let highest_node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaHighestNodeNumber");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{highest_node_number = {:?}}}",
            highest_node_number
        );
        let res = api.GetNumaHighestNodeNumber(highest_node_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeNumberFromHandle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaNodeNumberFromHandle");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, node_number = {:?}}}",
            h_file,
            node_number
        );
        let res = api.GetNumaNodeNumberFromHandle(h_file, node_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let processor_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaNodeProcessorMask");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{node = {:?}, processor_mask = {:?}}}",
            node,
            processor_mask
        );
        let res = api.GetNumaNodeProcessorMask(node, processor_mask);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMask2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node_number = call.get_arg();
        let processor_masks = call.get_arg();
        let processor_mask_count = call.get_arg();
        let required_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaNodeProcessorMask2");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{node_number = {:?}, processor_masks = {:?}, processor_mask_count = {:?}, required_mask_count = {:?}}}" , node_number , processor_masks , processor_mask_count , required_mask_count );
        let res = api.GetNumaNodeProcessorMask2(
            node_number,
            processor_masks,
            processor_mask_count,
            required_mask_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaNodeProcessorMaskEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let node = call.get_arg();
        let processor_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaNodeProcessorMaskEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{node = {:?}, processor_mask = {:?}}}",
            node,
            processor_mask
        );
        let res = api.GetNumaNodeProcessorMaskEx(node, processor_mask);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProcessorNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let processor = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaProcessorNode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{processor = {:?}, node_number = {:?}}}",
            processor,
            node_number
        );
        let res = api.GetNumaProcessorNode(processor, node_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProcessorNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let processor = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaProcessorNodeEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{processor = {:?}, node_number = {:?}}}",
            processor,
            node_number
        );
        let res = api.GetNumaProcessorNodeEx(processor, node_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProximityNode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let proximity_id = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaProximityNode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{proximity_id = {:?}, node_number = {:?}}}",
            proximity_id,
            node_number
        );
        let res = api.GetNumaProximityNode(proximity_id, node_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNumaProximityNodeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let proximity_id = call.get_arg();
        let node_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNumaProximityNodeEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{proximity_id = {:?}, node_number = {:?}}}",
            proximity_id,
            node_number
        );
        let res = api.GetNumaProximityNodeEx(proximity_id, node_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPriorityClass(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPriorityClass");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_process = {:?}}}", h_process);
        let res = api.GetPriorityClass(h_process);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_process_affinity_mask = call.get_arg();
        let lp_system_affinity_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessAffinityMask");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_process_affinity_mask = {:?}, lp_system_affinity_mask = {:?}}}" , h_process , lp_process_affinity_mask , lp_system_affinity_mask );
        let res = api.GetProcessAffinityMask(
            h_process,
            lp_process_affinity_mask,
            lp_system_affinity_mask,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_flags = call.get_arg();
        let lp_permanent = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessDEPPolicy");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, lp_flags = {:?}, lp_permanent = {:?}}}",
            h_process,
            lp_flags,
            lp_permanent
        );
        let res = api.GetProcessDEPPolicy(h_process, lp_flags, lp_permanent);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let required_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessDefaultCpuSetMasks");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{process = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}, required_mask_count = {:?}}}" , process , cpu_set_masks , cpu_set_mask_count , required_mask_count );
        let res = api.GetProcessDefaultCpuSetMasks(
            process,
            cpu_set_masks,
            cpu_set_mask_count,
            required_mask_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let required_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessDefaultCpuSets");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{process = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}, required_id_count = {:?}}}" , process , cpu_set_ids , cpu_set_id_count , required_id_count );
        let res =
            api.GetProcessDefaultCpuSets(process, cpu_set_ids, cpu_set_id_count, required_id_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let group_count = call.get_arg();
        let group_array = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessGroupAffinity");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, group_count = {:?}, group_array = {:?}}}",
            h_process,
            group_count,
            group_array
        );
        let res = api.GetProcessGroupAffinity(h_process, group_count, group_array);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessHandleCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let pdw_handle_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessHandleCount");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, pdw_handle_count = {:?}}}",
            h_process,
            pdw_handle_count
        );
        let res = api.GetProcessHandleCount(h_process, pdw_handle_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessId(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessId");
        let _enter = span.enter();
        tracing::trace!("  args = {{process = {:?}}}", process);
        let res = api.GetProcessId(process);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessIdOfThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessIdOfThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{thread = {:?}}}", thread);
        let res = api.GetProcessIdOfThread(thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let process_information_class = call.get_arg();
        let process_information = call.get_arg();
        let process_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, process_information_class = {:?}, process_information = {:?}, process_information_size = {:?}}}" , h_process , process_information_class , process_information , process_information_size );
        let res = api.GetProcessInformation(
            h_process,
            process_information_class,
            process_information,
            process_information_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessIoCounters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_io_counters = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessIoCounters");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, lp_io_counters = {:?}}}",
            h_process,
            lp_io_counters
        );
        let res = api.GetProcessIoCounters(h_process, lp_io_counters);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessMitigationPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let mitigation_policy = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessMitigationPolicy");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, mitigation_policy = {:?}, lp_buffer = {:?}, dw_length = {:?}}}" , h_process , mitigation_policy , lp_buffer , dw_length );
        let res =
            api.GetProcessMitigationPolicy(h_process, mitigation_policy, lp_buffer, dw_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let p_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessPriorityBoost");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, p_disable_priority_boost = {:?}}}",
            h_process,
            p_disable_priority_boost
        );
        let res = api.GetProcessPriorityBoost(h_process, p_disable_priority_boost);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessShutdownParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpdw_level = call.get_arg();
        let lpdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessShutdownParameters");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpdw_level = {:?}, lpdw_flags = {:?}}}",
            lpdw_level,
            lpdw_flags
        );
        let res = api.GetProcessShutdownParameters(lpdw_level, lpdw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_exit_time = call.get_arg();
        let lp_kernel_time = call.get_arg();
        let lp_user_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessTimes");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_creation_time = {:?}, lp_exit_time = {:?}, lp_kernel_time = {:?}, lp_user_time = {:?}}}" , h_process , lp_creation_time , lp_exit_time , lp_kernel_time , lp_user_time );
        let res = api.GetProcessTimes(
            h_process,
            lp_creation_time,
            lp_exit_time,
            lp_kernel_time,
            lp_user_time,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessVersion(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessVersion");
        let _enter = span.enter();
        tracing::trace!("  args = {{process_id = {:?}}}", process_id);
        let res = api.GetProcessVersion(process_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessWorkingSetSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lp_minimum_working_set_size = call.get_arg();
        let lp_maximum_working_set_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessWorkingSetSize");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, lp_minimum_working_set_size = {:?}, lp_maximum_working_set_size = {:?}}}" , h_process , lp_minimum_working_set_size , lp_maximum_working_set_size );
        let res = api.GetProcessWorkingSetSize(
            h_process,
            lp_minimum_working_set_size,
            lp_maximum_working_set_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStartupInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_startup_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStartupInfoA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_startup_info = {:?}}}", lp_startup_info);
        let res = api.GetStartupInfoA(lp_startup_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetStartupInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_startup_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetStartupInfoW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_startup_info = {:?}}}", lp_startup_info);
        let res = api.GetStartupInfoW(lp_startup_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_idle_time = call.get_arg();
        let lp_kernel_time = call.get_arg();
        let lp_user_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemTimes");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_idle_time = {:?}, lp_kernel_time = {:?}, lp_user_time = {:?}}}",
            lp_idle_time,
            lp_kernel_time,
            lp_user_time
        );
        let res = api.GetSystemTimes(lp_idle_time, lp_kernel_time, lp_user_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadDescription(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let ppsz_thread_description = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadDescription");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, ppsz_thread_description = {:?}}}",
            h_thread,
            ppsz_thread_description
        );
        let res = api.GetThreadDescription(h_thread, ppsz_thread_description);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let group_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadGroupAffinity");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, group_affinity = {:?}}}",
            h_thread,
            group_affinity
        );
        let res = api.GetThreadGroupAffinity(h_thread, group_affinity);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadIOPendingFlag(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_io_is_pending = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadIOPendingFlag");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, lp_io_is_pending = {:?}}}",
            h_thread,
            lp_io_is_pending
        );
        let res = api.GetThreadIOPendingFlag(h_thread, lp_io_is_pending);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadId(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadId");
        let _enter = span.enter();
        tracing::trace!("  args = {{thread = {:?}}}", thread);
        let res = api.GetThreadId(thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadIdealProcessorEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_ideal_processor = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadIdealProcessorEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, lp_ideal_processor = {:?}}}",
            h_thread,
            lp_ideal_processor
        );
        let res = api.GetThreadIdealProcessorEx(h_thread, lp_ideal_processor);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_thread = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_size = {:?}}}" , h_thread , thread_information_class , thread_information , thread_information_size );
        let res = api.GetThreadInformation(
            h_thread,
            thread_information_class,
            thread_information,
            thread_information_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadPriority");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_thread = {:?}}}", h_thread);
        let res = api.GetThreadPriority(h_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let p_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadPriorityBoost");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, p_disable_priority_boost = {:?}}}",
            h_thread,
            p_disable_priority_boost
        );
        let res = api.GetThreadPriorityBoost(h_thread, p_disable_priority_boost);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadSelectedCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let required_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadSelectedCpuSetMasks");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{thread = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}, required_mask_count = {:?}}}" , thread , cpu_set_masks , cpu_set_mask_count , required_mask_count );
        let res = api.GetThreadSelectedCpuSetMasks(
            thread,
            cpu_set_masks,
            cpu_set_mask_count,
            required_mask_count,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadSelectedCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let required_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadSelectedCpuSets");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{thread = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}, required_id_count = {:?}}}" , thread , cpu_set_ids , cpu_set_id_count , required_id_count );
        let res =
            api.GetThreadSelectedCpuSets(thread, cpu_set_ids, cpu_set_id_count, required_id_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadTimes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_creation_time = call.get_arg();
        let lp_exit_time = call.get_arg();
        let lp_kernel_time = call.get_arg();
        let lp_user_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadTimes");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_thread = {:?}, lp_creation_time = {:?}, lp_exit_time = {:?}, lp_kernel_time = {:?}, lp_user_time = {:?}}}" , h_thread , lp_creation_time , lp_exit_time , lp_kernel_time , lp_user_time );
        let res = api.GetThreadTimes(
            h_thread,
            lp_creation_time,
            lp_exit_time,
            lp_kernel_time,
            lp_user_time,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUmsCompletionListEvent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_completion_list = call.get_arg();
        let ums_completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUmsCompletionListEvent");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ums_completion_list = {:?}, ums_completion_event = {:?}}}",
            ums_completion_list,
            ums_completion_event
        );
        let res = api.GetUmsCompletionListEvent(ums_completion_list, ums_completion_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUmsSystemThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let system_thread_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUmsSystemThreadInformation");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{thread_handle = {:?}, system_thread_info = {:?}}}",
            thread_handle,
            system_thread_info
        );
        let res = api.GetUmsSystemThreadInformation(thread_handle, system_thread_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceBeginInitialize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_init_once = call.get_arg();
        let dw_flags = call.get_arg();
        let f_pending = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitOnceBeginInitialize");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_init_once = {:?}, dw_flags = {:?}, f_pending = {:?}, lp_context = {:?}}}" , lp_init_once , dw_flags , f_pending , lp_context );
        let res = api.InitOnceBeginInitialize(lp_init_once, dw_flags, f_pending, lp_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceComplete(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_init_once = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitOnceComplete");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_init_once = {:?}, dw_flags = {:?}, lp_context = {:?}}}",
            lp_init_once,
            dw_flags,
            lp_context
        );
        let res = api.InitOnceComplete(lp_init_once, dw_flags, lp_context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceExecuteOnce(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let init_once = call.get_arg();
        let init_fn = call.get_arg();
        let parameter = call.get_arg();
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitOnceExecuteOnce");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{init_once = {:?}, init_fn = {:?}, parameter = {:?}, context = {:?}}}",
            init_once,
            init_fn,
            parameter,
            context
        );
        let res = api.InitOnceExecuteOnce(init_once, init_fn, parameter, context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitOnceInitialize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let init_once = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitOnceInitialize");
        let _enter = span.enter();
        tracing::trace!("  args = {{init_once = {:?}}}", init_once);
        let res = api.InitOnceInitialize(init_once);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeConditionVariable");
        let _enter = span.enter();
        tracing::trace!("  args = {{condition_variable = {:?}}}", condition_variable);
        let res = api.InitializeConditionVariable(condition_variable);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeCriticalSection");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}}}",
            lp_critical_section
        );
        let res = api.InitializeCriticalSection(lp_critical_section);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSectionAndSpinCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let dw_spin_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeCriticalSectionAndSpinCount");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}, dw_spin_count = {:?}}}",
            lp_critical_section,
            dw_spin_count
        );
        let res = api.InitializeCriticalSectionAndSpinCount(lp_critical_section, dw_spin_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeCriticalSectionEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let dw_spin_count = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeCriticalSectionEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}, dw_spin_count = {:?}, flags = {:?}}}",
            lp_critical_section,
            dw_spin_count,
            flags
        );
        let res = api.InitializeCriticalSectionEx(lp_critical_section, dw_spin_count, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeProcThreadAttributeList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_attribute_list = call.get_arg();
        let dw_attribute_count = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeProcThreadAttributeList");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_attribute_list = {:?}, dw_attribute_count = {:?}, dw_flags = {:?}, lp_size = {:?}}}" , lp_attribute_list , dw_attribute_count , dw_flags , lp_size );
        let res = api.InitializeProcThreadAttributeList(
            lp_attribute_list,
            dw_attribute_count,
            dw_flags,
            lp_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeSListHead(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeSListHead");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.InitializeSListHead(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeSRWLock(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeSRWLock");
        let _enter = span.enter();
        tracing::trace!("  args = {{srw_lock = {:?}}}", srw_lock);
        let res = api.InitializeSRWLock(srw_lock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InitializeSynchronizationBarrier(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_barrier = call.get_arg();
        let l_total_threads = call.get_arg();
        let l_spin_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InitializeSynchronizationBarrier");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_barrier = {:?}, l_total_threads = {:?}, l_spin_count = {:?}}}",
            lp_barrier,
            l_total_threads,
            l_spin_count
        );
        let res = api.InitializeSynchronizationBarrier(lp_barrier, l_total_threads, l_spin_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedFlushSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InterlockedFlushSList");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.InterlockedFlushSList(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedPopEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InterlockedPopEntrySList");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.InterlockedPopEntrySList(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedPushEntrySList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list_entry = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InterlockedPushEntrySList");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{list_head = {:?}, list_entry = {:?}}}",
            list_head,
            list_entry
        );
        let res = api.InterlockedPushEntrySList(list_head, list_entry);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InterlockedPushListSListEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let list = call.get_arg();
        let list_end = call.get_arg();
        let count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InterlockedPushListSListEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{list_head = {:?}, list = {:?}, list_end = {:?}, count = {:?}}}",
            list_head,
            list,
            list_end,
            count
        );
        let res = api.InterlockedPushListSListEx(list_head, list, list_end, count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsImmersiveProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsImmersiveProcess");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_process = {:?}}}", h_process);
        let res = api.IsImmersiveProcess(h_process);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsProcessCritical(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let critical = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsProcessCritical");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, critical = {:?}}}",
            h_process,
            critical
        );
        let res = api.IsProcessCritical(h_process, critical);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsProcessorFeaturePresent(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let processor_feature = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsProcessorFeaturePresent");
        let _enter = span.enter();
        tracing::trace!("  args = {{processor_feature = {:?}}}", processor_feature);
        let res = api.IsProcessorFeaturePresent(processor_feature);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsThreadAFiber(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsThreadAFiber");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.IsThreadAFiber();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsThreadpoolTimerSet(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsThreadpoolTimerSet");
        let _enter = span.enter();
        tracing::trace!("  args = {{pti = {:?}}}", pti);
        let res = api.IsThreadpoolTimerSet(pti);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWow64Process(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let wow_64_process = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsWow64Process");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, wow_64_process = {:?}}}",
            h_process,
            wow_64_process
        );
        let res = api.IsWow64Process(h_process, wow_64_process);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWow64Process2(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let p_process_machine = call.get_arg();
        let p_native_machine = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsWow64Process2");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, p_process_machine = {:?}, p_native_machine = {:?}}}",
            h_process,
            p_process_machine,
            p_native_machine
        );
        let res = api.IsWow64Process2(h_process, p_process_machine, p_native_machine);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LeaveCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LeaveCriticalSection");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}}}",
            lp_critical_section
        );
        let res = api.LeaveCriticalSection(lp_critical_section);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LeaveCriticalSectionWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let pcs = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LeaveCriticalSectionWhenCallbackReturns");
        let _enter = span.enter();
        tracing::trace!("  args = {{pci = {:?}, pcs = {:?}}}", pci, pcs);
        let res = api.LeaveCriticalSectionWhenCallbackReturns(pci, pcs);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryInformationProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process_handle = call.get_arg();
        let process_information_class = call.get_arg();
        let process_information = call.get_arg();
        let process_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtQueryInformationProcess");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{process_handle = {:?}, process_information_class = {:?}, process_information = {:?}, process_information_length = {:?}, return_length = {:?}}}" , process_handle , process_information_class , process_information , process_information_length , return_length );
        let res = api.NtQueryInformationProcess(
            process_handle,
            process_information_class,
            process_information,
            process_information_length,
            return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryInformationThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtQueryInformationThread");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{thread_handle = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_length = {:?}, return_length = {:?}}}" , thread_handle , thread_information_class , thread_information , thread_information_length , return_length );
        let res = api.NtQueryInformationThread(
            thread_handle,
            thread_information_class,
            thread_information,
            thread_information_length,
            return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtSetInformationThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtSetInformationThread");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{thread_handle = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_length = {:?}}}" , thread_handle , thread_information_class , thread_information , thread_information_length );
        let res = api.NtSetInformationThread(
            thread_handle,
            thread_information_class,
            thread_information,
            thread_information_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEventA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenEventA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenEventA(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenEventW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenEventW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenEventW(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenMutexW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenMutexW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenMutexW(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenPrivateNamespaceA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_boundary_descriptor = call.get_arg();
        let lp_alias_prefix = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenPrivateNamespaceA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_boundary_descriptor = {:?}, lp_alias_prefix = {:?}}}",
            lp_boundary_descriptor,
            lp_alias_prefix
        );
        let res = api.OpenPrivateNamespaceA(lp_boundary_descriptor, lp_alias_prefix);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenPrivateNamespaceW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_boundary_descriptor = call.get_arg();
        let lp_alias_prefix = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenPrivateNamespaceW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_boundary_descriptor = {:?}, lp_alias_prefix = {:?}}}",
            lp_boundary_descriptor,
            lp_alias_prefix
        );
        let res = api.OpenPrivateNamespaceW(lp_boundary_descriptor, lp_alias_prefix);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenProcess(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let dw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenProcess");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, dw_process_id = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            dw_process_id
        );
        let res = api.OpenProcess(dw_desired_access, b_inherit_handle, dw_process_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenSemaphoreW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenSemaphoreW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenSemaphoreW(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let dw_thread_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenThread");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, dw_thread_id = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            dw_thread_id
        );
        let res = api.OpenThread(dw_desired_access, b_inherit_handle, dw_thread_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenWaitableTimerW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_timer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenWaitableTimerW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_timer_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_timer_name
        );
        let res = api.OpenWaitableTimerW(dw_desired_access, b_inherit_handle, lp_timer_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PulseEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PulseEvent");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_event = {:?}}}", h_event);
        let res = api.PulseEvent(h_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryDepthSList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let list_head = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryDepthSList");
        let _enter = span.enter();
        tracing::trace!("  args = {{list_head = {:?}}}", list_head);
        let res = api.QueryDepthSList(list_head);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryFullProcessImageNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_exe_name = call.get_arg();
        let lpdw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryFullProcessImageNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, dw_flags = {:?}, lp_exe_name = {:?}, lpdw_size = {:?}}}",
            h_process,
            dw_flags,
            lp_exe_name,
            lpdw_size
        );
        let res = api.QueryFullProcessImageNameA(h_process, dw_flags, lp_exe_name, lpdw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryFullProcessImageNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_flags = call.get_arg();
        let lp_exe_name = call.get_arg();
        let lpdw_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryFullProcessImageNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, dw_flags = {:?}, lp_exe_name = {:?}, lpdw_size = {:?}}}",
            h_process,
            dw_flags,
            lp_exe_name,
            lpdw_size
        );
        let res = api.QueryFullProcessImageNameW(h_process, dw_flags, lp_exe_name, lpdw_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryProcessAffinityUpdateMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let lpdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryProcessAffinityUpdateMode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, lpdw_flags = {:?}}}",
            h_process,
            lpdw_flags
        );
        let res = api.QueryProcessAffinityUpdateMode(h_process, lpdw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryProtectedPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let policy_guid = call.get_arg();
        let policy_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryProtectedPolicy");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{policy_guid = {:?}, policy_value = {:?}}}",
            policy_guid,
            policy_value
        );
        let res = api.QueryProtectedPolicy(policy_guid, policy_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryThreadpoolStackInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let ptpsi = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryThreadpoolStackInformation");
        let _enter = span.enter();
        tracing::trace!("  args = {{ptpp = {:?}, ptpsi = {:?}}}", ptpp, ptpsi);
        let res = api.QueryThreadpoolStackInformation(ptpp, ptpsi);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryUmsThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let ums_thread_info_class = call.get_arg();
        let ums_thread_information = call.get_arg();
        let ums_thread_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryUmsThreadInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ums_thread = {:?}, ums_thread_info_class = {:?}, ums_thread_information = {:?}, ums_thread_information_length = {:?}, return_length = {:?}}}" , ums_thread , ums_thread_info_class , ums_thread_information , ums_thread_information_length , return_length );
        let res = api.QueryUmsThreadInformation(
            ums_thread,
            ums_thread_info_class,
            ums_thread_information,
            ums_thread_information_length,
            return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueueUserAPC(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfn_apc = call.get_arg();
        let h_thread = call.get_arg();
        let dw_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueueUserAPC");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pfn_apc = {:?}, h_thread = {:?}, dw_data = {:?}}}",
            pfn_apc,
            h_thread,
            dw_data
        );
        let res = api.QueueUserAPC(pfn_apc, h_thread, dw_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueueUserAPC2(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let apc_routine = call.get_arg();
        let thread = call.get_arg();
        let data = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueueUserAPC2");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{apc_routine = {:?}, thread = {:?}, data = {:?}, flags = {:?}}}",
            apc_routine,
            thread,
            data,
            flags
        );
        let res = api.QueueUserAPC2(apc_routine, thread, data, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueueUserWorkItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let function = call.get_arg();
        let context = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueueUserWorkItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{function = {:?}, context = {:?}, flags = {:?}}}",
            function,
            context,
            flags
        );
        let res = api.QueueUserWorkItem(function, context, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterWaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ph_new_wait_object = call.get_arg();
        let h_object = call.get_arg();
        let callback = call.get_arg();
        let context = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RegisterWaitForSingleObject");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ph_new_wait_object = {:?}, h_object = {:?}, callback = {:?}, context = {:?}, dw_milliseconds = {:?}, dw_flags = {:?}}}" , ph_new_wait_object , h_object , callback , context , dw_milliseconds , dw_flags );
        let res = api.RegisterWaitForSingleObject(
            ph_new_wait_object,
            h_object,
            callback,
            context,
            dw_milliseconds,
            dw_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseMutex(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mutex = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReleaseMutex");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mutex = {:?}}}", h_mutex);
        let res = api.ReleaseMutex(h_mutex);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseMutexWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let r#mut = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReleaseMutexWhenCallbackReturns");
        let _enter = span.enter();
        tracing::trace!("  args = {{pci = {:?}, r#mut = {:?}}}", pci, r#mut);
        let res = api.ReleaseMutexWhenCallbackReturns(pci, r#mut);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReleaseSRWLockExclusive");
        let _enter = span.enter();
        tracing::trace!("  args = {{srw_lock = {:?}}}", srw_lock);
        let res = api.ReleaseSRWLockExclusive(srw_lock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReleaseSRWLockShared");
        let _enter = span.enter();
        tracing::trace!("  args = {{srw_lock = {:?}}}", srw_lock);
        let res = api.ReleaseSRWLockShared(srw_lock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSemaphore(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_semaphore = call.get_arg();
        let l_release_count = call.get_arg();
        let lp_previous_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReleaseSemaphore");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_semaphore = {:?}, l_release_count = {:?}, lp_previous_count = {:?}}}",
            h_semaphore,
            l_release_count,
            lp_previous_count
        );
        let res = api.ReleaseSemaphore(h_semaphore, l_release_count, lp_previous_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReleaseSemaphoreWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let sem = call.get_arg();
        let crel = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReleaseSemaphoreWhenCallbackReturns");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pci = {:?}, sem = {:?}, crel = {:?}}}",
            pci,
            sem,
            crel
        );
        let res = api.ReleaseSemaphoreWhenCallbackReturns(pci, sem, crel);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResetEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ResetEvent");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_event = {:?}}}", h_event);
        let res = api.ResetEvent(h_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ResumeThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ResumeThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_thread = {:?}}}", h_thread);
        let res = api.ResumeThread(h_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCriticalSectionSpinCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let dw_spin_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCriticalSectionSpinCount");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}, dw_spin_count = {:?}}}",
            lp_critical_section,
            dw_spin_count
        );
        let res = api.SetCriticalSectionSpinCount(lp_critical_section, dw_spin_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEvent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEvent");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_event = {:?}}}", h_event);
        let res = api.SetEvent(h_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEventWhenCallbackReturns(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let evt = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEventWhenCallbackReturns");
        let _enter = span.enter();
        tracing::trace!("  args = {{pci = {:?}, evt = {:?}}}", pci, evt);
        let res = api.SetEventWhenCallbackReturns(pci, evt);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPriorityClass(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_priority_class = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetPriorityClass");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, dw_priority_class = {:?}}}",
            h_process,
            dw_priority_class
        );
        let res = api.SetPriorityClass(h_process, dw_priority_class);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_process_affinity_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessAffinityMask");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, dw_process_affinity_mask = {:?}}}",
            h_process,
            dw_process_affinity_mask
        );
        let res = api.SetProcessAffinityMask(h_process, dw_process_affinity_mask);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessAffinityUpdateMode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessAffinityUpdateMode");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, dw_flags = {:?}}}",
            h_process,
            dw_flags
        );
        let res = api.SetProcessAffinityUpdateMode(h_process, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDEPPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessDEPPolicy");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_flags = {:?}}}", dw_flags);
        let res = api.SetProcessDEPPolicy(dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessDefaultCpuSetMasks");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{process = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}}}",
            process,
            cpu_set_masks,
            cpu_set_mask_count
        );
        let res = api.SetProcessDefaultCpuSetMasks(process, cpu_set_masks, cpu_set_mask_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessDefaultCpuSets");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{process = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}}}",
            process,
            cpu_set_ids,
            cpu_set_id_count
        );
        let res = api.SetProcessDefaultCpuSets(process, cpu_set_ids, cpu_set_id_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDynamicEHContinuationTargets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let number_of_targets = call.get_arg();
        let targets = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessDynamicEHContinuationTargets");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{process = {:?}, number_of_targets = {:?}, targets = {:?}}}",
            process,
            number_of_targets,
            targets
        );
        let res = api.SetProcessDynamicEHContinuationTargets(process, number_of_targets, targets);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDynamicEnforcedCetCompatibleRanges(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process = call.get_arg();
        let number_of_ranges = call.get_arg();
        let ranges = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessDynamicEnforcedCetCompatibleRanges");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{process = {:?}, number_of_ranges = {:?}, ranges = {:?}}}",
            process,
            number_of_ranges,
            ranges
        );
        let res =
            api.SetProcessDynamicEnforcedCetCompatibleRanges(process, number_of_ranges, ranges);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let process_information_class = call.get_arg();
        let process_information = call.get_arg();
        let process_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, process_information_class = {:?}, process_information = {:?}, process_information_size = {:?}}}" , h_process , process_information_class , process_information , process_information_size );
        let res = api.SetProcessInformation(
            h_process,
            process_information_class,
            process_information,
            process_information_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessMitigationPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let mitigation_policy = call.get_arg();
        let lp_buffer = call.get_arg();
        let dw_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessMitigationPolicy");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{mitigation_policy = {:?}, lp_buffer = {:?}, dw_length = {:?}}}",
            mitigation_policy,
            lp_buffer,
            dw_length
        );
        let res = api.SetProcessMitigationPolicy(mitigation_policy, lp_buffer, dw_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let b_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessPriorityBoost");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, b_disable_priority_boost = {:?}}}",
            h_process,
            b_disable_priority_boost
        );
        let res = api.SetProcessPriorityBoost(h_process, b_disable_priority_boost);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessRestrictionExemption(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let f_enable_exemption = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessRestrictionExemption");
        let _enter = span.enter();
        tracing::trace!("  args = {{f_enable_exemption = {:?}}}", f_enable_exemption);
        let res = api.SetProcessRestrictionExemption(f_enable_exemption);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessShutdownParameters(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_level = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessShutdownParameters");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_level = {:?}, dw_flags = {:?}}}",
            dw_level,
            dw_flags
        );
        let res = api.SetProcessShutdownParameters(dw_level, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessWorkingSetSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_minimum_working_set_size = call.get_arg();
        let dw_maximum_working_set_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessWorkingSetSize");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_process = {:?}, dw_minimum_working_set_size = {:?}, dw_maximum_working_set_size = {:?}}}" , h_process , dw_minimum_working_set_size , dw_maximum_working_set_size );
        let res = api.SetProcessWorkingSetSize(
            h_process,
            dw_minimum_working_set_size,
            dw_maximum_working_set_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProtectedPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let policy_guid = call.get_arg();
        let policy_value = call.get_arg();
        let old_policy_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProtectedPolicy");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{policy_guid = {:?}, policy_value = {:?}, old_policy_value = {:?}}}",
            policy_guid,
            policy_value,
            old_policy_value
        );
        let res = api.SetProtectedPolicy(policy_guid, policy_value, old_policy_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadAffinityMask(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let dw_thread_affinity_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadAffinityMask");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, dw_thread_affinity_mask = {:?}}}",
            h_thread,
            dw_thread_affinity_mask
        );
        let res = api.SetThreadAffinityMask(h_thread, dw_thread_affinity_mask);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadDescription(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_thread_description = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadDescription");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, lp_thread_description = {:?}}}",
            h_thread,
            lp_thread_description
        );
        let res = api.SetThreadDescription(h_thread, lp_thread_description);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadGroupAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let group_affinity = call.get_arg();
        let previous_group_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadGroupAffinity");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, group_affinity = {:?}, previous_group_affinity = {:?}}}",
            h_thread,
            group_affinity,
            previous_group_affinity
        );
        let res = api.SetThreadGroupAffinity(h_thread, group_affinity, previous_group_affinity);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadIdealProcessor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let dw_ideal_processor = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadIdealProcessor");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, dw_ideal_processor = {:?}}}",
            h_thread,
            dw_ideal_processor
        );
        let res = api.SetThreadIdealProcessor(h_thread, dw_ideal_processor);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadIdealProcessorEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let lp_ideal_processor = call.get_arg();
        let lp_previous_ideal_processor = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadIdealProcessorEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_thread = {:?}, lp_ideal_processor = {:?}, lp_previous_ideal_processor = {:?}}}" , h_thread , lp_ideal_processor , lp_previous_ideal_processor );
        let res = api.SetThreadIdealProcessorEx(
            h_thread,
            lp_ideal_processor,
            lp_previous_ideal_processor,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let thread_information_class = call.get_arg();
        let thread_information = call.get_arg();
        let thread_information_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_thread = {:?}, thread_information_class = {:?}, thread_information = {:?}, thread_information_size = {:?}}}" , h_thread , thread_information_class , thread_information , thread_information_size );
        let res = api.SetThreadInformation(
            h_thread,
            thread_information_class,
            thread_information,
            thread_information_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPriority(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let n_priority = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadPriority");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, n_priority = {:?}}}",
            h_thread,
            n_priority
        );
        let res = api.SetThreadPriority(h_thread, n_priority);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadPriorityBoost(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let b_disable_priority_boost = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadPriorityBoost");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, b_disable_priority_boost = {:?}}}",
            h_thread,
            b_disable_priority_boost
        );
        let res = api.SetThreadPriorityBoost(h_thread, b_disable_priority_boost);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadSelectedCpuSetMasks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_masks = call.get_arg();
        let cpu_set_mask_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadSelectedCpuSetMasks");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{thread = {:?}, cpu_set_masks = {:?}, cpu_set_mask_count = {:?}}}",
            thread,
            cpu_set_masks,
            cpu_set_mask_count
        );
        let res = api.SetThreadSelectedCpuSetMasks(thread, cpu_set_masks, cpu_set_mask_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadSelectedCpuSets(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let cpu_set_ids = call.get_arg();
        let cpu_set_id_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadSelectedCpuSets");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{thread = {:?}, cpu_set_ids = {:?}, cpu_set_id_count = {:?}}}",
            thread,
            cpu_set_ids,
            cpu_set_id_count
        );
        let res = api.SetThreadSelectedCpuSets(thread, cpu_set_ids, cpu_set_id_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadStackGuarantee(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let stack_size_in_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadStackGuarantee");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{stack_size_in_bytes = {:?}}}",
            stack_size_in_bytes
        );
        let res = api.SetThreadStackGuarantee(stack_size_in_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadToken(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread = call.get_arg();
        let token = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadToken");
        let _enter = span.enter();
        tracing::trace!("  args = {{thread = {:?}, token = {:?}}}", thread, token);
        let res = api.SetThreadToken(thread, token);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolStackInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let ptpsi = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadpoolStackInformation");
        let _enter = span.enter();
        tracing::trace!("  args = {{ptpp = {:?}, ptpsi = {:?}}}", ptpp, ptpsi);
        let res = api.SetThreadpoolStackInformation(ptpp, ptpsi);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolThreadMaximum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let cthrd_most = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadpoolThreadMaximum");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ptpp = {:?}, cthrd_most = {:?}}}",
            ptpp,
            cthrd_most
        );
        let res = api.SetThreadpoolThreadMaximum(ptpp, cthrd_most);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolThreadMinimum(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ptpp = call.get_arg();
        let cthrd_mic = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadpoolThreadMinimum");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ptpp = {:?}, cthrd_mic = {:?}}}",
            ptpp,
            cthrd_mic
        );
        let res = api.SetThreadpoolThreadMinimum(ptpp, cthrd_mic);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let pft_due_time = call.get_arg();
        let ms_period = call.get_arg();
        let ms_window_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadpoolTimer");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{pti = {:?}, pft_due_time = {:?}, ms_period = {:?}, ms_window_length = {:?}}}" , pti , pft_due_time , ms_period , ms_window_length );
        let res = api.SetThreadpoolTimer(pti, pft_due_time, ms_period, ms_window_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolTimerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let pft_due_time = call.get_arg();
        let ms_period = call.get_arg();
        let ms_window_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadpoolTimerEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{pti = {:?}, pft_due_time = {:?}, ms_period = {:?}, ms_window_length = {:?}}}" , pti , pft_due_time , ms_period , ms_window_length );
        let res = api.SetThreadpoolTimerEx(pti, pft_due_time, ms_period, ms_window_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let h = call.get_arg();
        let pft_timeout = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadpoolWait");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pwa = {:?}, h = {:?}, pft_timeout = {:?}}}",
            pwa,
            h,
            pft_timeout
        );
        let res = api.SetThreadpoolWait(pwa, h, pft_timeout);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetThreadpoolWaitEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let h = call.get_arg();
        let pft_timeout = call.get_arg();
        let reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetThreadpoolWaitEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pwa = {:?}, h = {:?}, pft_timeout = {:?}, reserved = {:?}}}",
            pwa,
            h,
            pft_timeout,
            reserved
        );
        let res = api.SetThreadpoolWaitEx(pwa, h, pft_timeout, reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let callback = call.get_arg();
        let parameter = call.get_arg();
        let due_time = call.get_arg();
        let period = call.get_arg();
        let prefer_io = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetTimerQueueTimer");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{timer_queue = {:?}, callback = {:?}, parameter = {:?}, due_time = {:?}, period = {:?}, prefer_io = {:?}}}" , timer_queue , callback , parameter , due_time , period , prefer_io );
        let res = api.SetTimerQueueTimer(
            timer_queue,
            callback,
            parameter,
            due_time,
            period,
            prefer_io,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetUmsThreadInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ums_thread = call.get_arg();
        let ums_thread_info_class = call.get_arg();
        let ums_thread_information = call.get_arg();
        let ums_thread_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetUmsThreadInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ums_thread = {:?}, ums_thread_info_class = {:?}, ums_thread_information = {:?}, ums_thread_information_length = {:?}}}" , ums_thread , ums_thread_info_class , ums_thread_information , ums_thread_information_length );
        let res = api.SetUmsThreadInformation(
            ums_thread,
            ums_thread_info_class,
            ums_thread_information,
            ums_thread_information_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWaitableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_timer = call.get_arg();
        let lp_due_time = call.get_arg();
        let l_period = call.get_arg();
        let pfn_completion_routine = call.get_arg();
        let lp_arg_to_completion_routine = call.get_arg();
        let f_resume = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWaitableTimer");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_timer = {:?}, lp_due_time = {:?}, l_period = {:?}, pfn_completion_routine = {:?}, lp_arg_to_completion_routine = {:?}, f_resume = {:?}}}" , h_timer , lp_due_time , l_period , pfn_completion_routine , lp_arg_to_completion_routine , f_resume );
        let res = api.SetWaitableTimer(
            h_timer,
            lp_due_time,
            l_period,
            pfn_completion_routine,
            lp_arg_to_completion_routine,
            f_resume,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWaitableTimerEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_timer = call.get_arg();
        let lp_due_time = call.get_arg();
        let l_period = call.get_arg();
        let pfn_completion_routine = call.get_arg();
        let lp_arg_to_completion_routine = call.get_arg();
        let wake_context = call.get_arg();
        let tolerable_delay = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWaitableTimerEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_timer = {:?}, lp_due_time = {:?}, l_period = {:?}, pfn_completion_routine = {:?}, lp_arg_to_completion_routine = {:?}, wake_context = {:?}, tolerable_delay = {:?}}}" , h_timer , lp_due_time , l_period , pfn_completion_routine , lp_arg_to_completion_routine , wake_context , tolerable_delay );
        let res = api.SetWaitableTimerEx(
            h_timer,
            lp_due_time,
            l_period,
            pfn_completion_routine,
            lp_arg_to_completion_routine,
            wake_context,
            tolerable_delay,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Sleep(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("Sleep");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_milliseconds = {:?}}}", dw_milliseconds);
        let res = api.Sleep(dw_milliseconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SleepConditionVariableCS(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let critical_section = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SleepConditionVariableCS");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{condition_variable = {:?}, critical_section = {:?}, dw_milliseconds = {:?}}}" , condition_variable , critical_section , dw_milliseconds );
        let res =
            api.SleepConditionVariableCS(condition_variable, critical_section, dw_milliseconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SleepConditionVariableSRW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let srw_lock = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SleepConditionVariableSRW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{condition_variable = {:?}, srw_lock = {:?}, dw_milliseconds = {:?}, flags = {:?}}}" , condition_variable , srw_lock , dw_milliseconds , flags );
        let res =
            api.SleepConditionVariableSRW(condition_variable, srw_lock, dw_milliseconds, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SleepEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SleepEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_milliseconds = {:?}, b_alertable = {:?}}}",
            dw_milliseconds,
            b_alertable
        );
        let res = api.SleepEx(dw_milliseconds, b_alertable);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_StartThreadpoolIo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("StartThreadpoolIo");
        let _enter = span.enter();
        tracing::trace!("  args = {{pio = {:?}}}", pio);
        let res = api.StartThreadpoolIo(pio);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SubmitThreadpoolWork(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwk = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SubmitThreadpoolWork");
        let _enter = span.enter();
        tracing::trace!("  args = {{pwk = {:?}}}", pwk);
        let res = api.SubmitThreadpoolWork(pwk);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SuspendThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SuspendThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_thread = {:?}}}", h_thread);
        let res = api.SuspendThread(h_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SwitchToFiber(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_fiber = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SwitchToFiber");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_fiber = {:?}}}", lp_fiber);
        let res = api.SwitchToFiber(lp_fiber);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SwitchToThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SwitchToThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.SwitchToThread();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TerminateProcess(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let u_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TerminateProcess");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, u_exit_code = {:?}}}",
            h_process,
            u_exit_code
        );
        let res = api.TerminateProcess(h_process, u_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TerminateThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let dw_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TerminateThread");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_thread = {:?}, dw_exit_code = {:?}}}",
            h_thread,
            dw_exit_code
        );
        let res = api.TerminateThread(h_thread, dw_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsAlloc(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TlsAlloc");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.TlsAlloc();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsFree(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_tls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TlsFree");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_tls_index = {:?}}}", dw_tls_index);
        let res = api.TlsFree(dw_tls_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsGetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_tls_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TlsGetValue");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_tls_index = {:?}}}", dw_tls_index);
        let res = api.TlsGetValue(dw_tls_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TlsSetValue(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_tls_index = call.get_arg();
        let lp_tls_value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TlsSetValue");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_tls_index = {:?}, lp_tls_value = {:?}}}",
            dw_tls_index,
            lp_tls_value
        );
        let res = api.TlsSetValue(dw_tls_index, lp_tls_value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TryAcquireSRWLockExclusive(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TryAcquireSRWLockExclusive");
        let _enter = span.enter();
        tracing::trace!("  args = {{srw_lock = {:?}}}", srw_lock);
        let res = api.TryAcquireSRWLockExclusive(srw_lock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TryAcquireSRWLockShared(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let srw_lock = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TryAcquireSRWLockShared");
        let _enter = span.enter();
        tracing::trace!("  args = {{srw_lock = {:?}}}", srw_lock);
        let res = api.TryAcquireSRWLockShared(srw_lock);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TryEnterCriticalSection(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_critical_section = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TryEnterCriticalSection");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_critical_section = {:?}}}",
            lp_critical_section
        );
        let res = api.TryEnterCriticalSection(lp_critical_section);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TrySubmitThreadpoolCallback(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfns = call.get_arg();
        let pv = call.get_arg();
        let pcbe = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TrySubmitThreadpoolCallback");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pfns = {:?}, pv = {:?}, pcbe = {:?}}}",
            pfns,
            pv,
            pcbe
        );
        let res = api.TrySubmitThreadpoolCallback(pfns, pv, pcbe);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UmsThreadYield(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let scheduler_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UmsThreadYield");
        let _enter = span.enter();
        tracing::trace!("  args = {{scheduler_param = {:?}}}", scheduler_param);
        let res = api.UmsThreadYield(scheduler_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let wait_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnregisterWait");
        let _enter = span.enter();
        tracing::trace!("  args = {{wait_handle = {:?}}}", wait_handle);
        let res = api.UnregisterWait(wait_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterWaitEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let wait_handle = call.get_arg();
        let completion_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnregisterWaitEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{wait_handle = {:?}, completion_event = {:?}}}",
            wait_handle,
            completion_event
        );
        let res = api.UnregisterWaitEx(wait_handle, completion_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UpdateProcThreadAttribute(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_attribute_list = call.get_arg();
        let dw_flags = call.get_arg();
        let attribute = call.get_arg();
        let lp_value = call.get_arg();
        let cb_size = call.get_arg();
        let lp_previous_value = call.get_arg();
        let lp_return_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UpdateProcThreadAttribute");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_attribute_list = {:?}, dw_flags = {:?}, attribute = {:?}, lp_value = {:?}, cb_size = {:?}, lp_previous_value = {:?}, lp_return_size = {:?}}}" , lp_attribute_list , dw_flags , attribute , lp_value , cb_size , lp_previous_value , lp_return_size );
        let res = api.UpdateProcThreadAttribute(
            lp_attribute_list,
            dw_flags,
            attribute,
            lp_value,
            cb_size,
            lp_previous_value,
            lp_return_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForInputIdle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_process = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForInputIdle");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_process = {:?}, dw_milliseconds = {:?}}}",
            h_process,
            dw_milliseconds
        );
        let res = api.WaitForInputIdle(h_process, dw_milliseconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForMultipleObjects(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let lp_handles = call.get_arg();
        let b_wait_all = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForMultipleObjects");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{n_count = {:?}, lp_handles = {:?}, b_wait_all = {:?}, dw_milliseconds = {:?}}}" , n_count , lp_handles , b_wait_all , dw_milliseconds );
        let res = api.WaitForMultipleObjects(n_count, lp_handles, b_wait_all, dw_milliseconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForMultipleObjectsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let lp_handles = call.get_arg();
        let b_wait_all = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForMultipleObjectsEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{n_count = {:?}, lp_handles = {:?}, b_wait_all = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}" , n_count , lp_handles , b_wait_all , dw_milliseconds , b_alertable );
        let res = api.WaitForMultipleObjectsEx(
            n_count,
            lp_handles,
            b_wait_all,
            dw_milliseconds,
            b_alertable,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_handle = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForSingleObject");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_handle = {:?}, dw_milliseconds = {:?}}}",
            h_handle,
            dw_milliseconds
        );
        let res = api.WaitForSingleObject(h_handle, dw_milliseconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForSingleObjectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_handle = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForSingleObjectEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_handle = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}",
            h_handle,
            dw_milliseconds,
            b_alertable
        );
        let res = api.WaitForSingleObjectEx(h_handle, dw_milliseconds, b_alertable);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolIoCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pio = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForThreadpoolIoCallbacks");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pio = {:?}, f_cancel_pending_callbacks = {:?}}}",
            pio,
            f_cancel_pending_callbacks
        );
        let res = api.WaitForThreadpoolIoCallbacks(pio, f_cancel_pending_callbacks);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolTimerCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pti = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForThreadpoolTimerCallbacks");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pti = {:?}, f_cancel_pending_callbacks = {:?}}}",
            pti,
            f_cancel_pending_callbacks
        );
        let res = api.WaitForThreadpoolTimerCallbacks(pti, f_cancel_pending_callbacks);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolWaitCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwa = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForThreadpoolWaitCallbacks");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pwa = {:?}, f_cancel_pending_callbacks = {:?}}}",
            pwa,
            f_cancel_pending_callbacks
        );
        let res = api.WaitForThreadpoolWaitCallbacks(pwa, f_cancel_pending_callbacks);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitForThreadpoolWorkCallbacks(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pwk = call.get_arg();
        let f_cancel_pending_callbacks = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitForThreadpoolWorkCallbacks");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pwk = {:?}, f_cancel_pending_callbacks = {:?}}}",
            pwk,
            f_cancel_pending_callbacks
        );
        let res = api.WaitForThreadpoolWorkCallbacks(pwk, f_cancel_pending_callbacks);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitOnAddress(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let compare_address = call.get_arg();
        let address_size = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitOnAddress");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{address = {:?}, compare_address = {:?}, address_size = {:?}, dw_milliseconds = {:?}}}" , address , compare_address , address_size , dw_milliseconds );
        let res = api.WaitOnAddress(address, compare_address, address_size, dw_milliseconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeAllConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WakeAllConditionVariable");
        let _enter = span.enter();
        tracing::trace!("  args = {{condition_variable = {:?}}}", condition_variable);
        let res = api.WakeAllConditionVariable(condition_variable);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeByAddressAll(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WakeByAddressAll");
        let _enter = span.enter();
        tracing::trace!("  args = {{address = {:?}}}", address);
        let res = api.WakeByAddressAll(address);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeByAddressSingle(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let address = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WakeByAddressSingle");
        let _enter = span.enter();
        tracing::trace!("  args = {{address = {:?}}}", address);
        let res = api.WakeByAddressSingle(address);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WakeConditionVariable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let condition_variable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WakeConditionVariable");
        let _enter = span.enter();
        tracing::trace!("  args = {{condition_variable = {:?}}}", condition_variable);
        let res = api.WakeConditionVariable(condition_variable);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WinExec(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_cmd_line = call.get_arg();
        let u_cmd_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WinExec");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_cmd_line = {:?}, u_cmd_show = {:?}}}",
            lp_cmd_line,
            u_cmd_show
        );
        let res = api.WinExec(lp_cmd_line, u_cmd_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64SetThreadDefaultGuestMachine(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let machine = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("Wow64SetThreadDefaultGuestMachine");
        let _enter = span.enter();
        tracing::trace!("  args = {{machine = {:?}}}", machine);
        let res = api.Wow64SetThreadDefaultGuestMachine(machine);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_Wow64SuspendThread(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::Threading::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_thread = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("Wow64SuspendThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_thread = {:?}}}", h_thread);
        let res = api.Wow64SuspendThread(h_thread);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddDelBackupEntryA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpcsz_file_list = call.get_arg();
        let lpcsz_backup_dir = call.get_arg();
        let lpcsz_base_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddDelBackupEntryA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpcsz_file_list = {:?}, lpcsz_backup_dir = {:?}, lpcsz_base_name = {:?}, dw_flags = {:?}}}" , lpcsz_file_list , lpcsz_backup_dir , lpcsz_base_name , dw_flags );
        let res =
            api.AddDelBackupEntryA(lpcsz_file_list, lpcsz_backup_dir, lpcsz_base_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AddDelBackupEntryW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpcsz_file_list = call.get_arg();
        let lpcsz_backup_dir = call.get_arg();
        let lpcsz_base_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AddDelBackupEntryW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpcsz_file_list = {:?}, lpcsz_backup_dir = {:?}, lpcsz_base_name = {:?}, dw_flags = {:?}}}" , lpcsz_file_list , lpcsz_backup_dir , lpcsz_base_name , dw_flags );
        let res =
            api.AddDelBackupEntryW(lpcsz_file_list, lpcsz_backup_dir, lpcsz_base_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdvInstallFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let lpsz_source_dir = call.get_arg();
        let lpsz_source_file = call.get_arg();
        let lpsz_dest_dir = call.get_arg();
        let lpsz_dest_file = call.get_arg();
        let dw_flags = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AdvInstallFileA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd = {:?}, lpsz_source_dir = {:?}, lpsz_source_file = {:?}, lpsz_dest_dir = {:?}, lpsz_dest_file = {:?}, dw_flags = {:?}, dw_reserved = {:?}}}" , hwnd , lpsz_source_dir , lpsz_source_file , lpsz_dest_dir , lpsz_dest_file , dw_flags , dw_reserved );
        let res = api.AdvInstallFileA(
            hwnd,
            lpsz_source_dir,
            lpsz_source_file,
            lpsz_dest_dir,
            lpsz_dest_file,
            dw_flags,
            dw_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdvInstallFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let lpsz_source_dir = call.get_arg();
        let lpsz_source_file = call.get_arg();
        let lpsz_dest_dir = call.get_arg();
        let lpsz_dest_file = call.get_arg();
        let dw_flags = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AdvInstallFileW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd = {:?}, lpsz_source_dir = {:?}, lpsz_source_file = {:?}, lpsz_dest_dir = {:?}, lpsz_dest_file = {:?}, dw_flags = {:?}, dw_reserved = {:?}}}" , hwnd , lpsz_source_dir , lpsz_source_file , lpsz_dest_dir , lpsz_dest_file , dw_flags , dw_reserved );
        let res = api.AdvInstallFileW(
            hwnd,
            lpsz_source_dir,
            lpsz_source_file,
            lpsz_dest_dir,
            lpsz_dest_file,
            dw_flags,
            dw_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ApphelpCheckShellObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let object_clsid = call.get_arg();
        let b_shim_if_necessary = call.get_arg();
        let pull_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ApphelpCheckShellObject");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{object_clsid = {:?}, b_shim_if_necessary = {:?}, pull_flags = {:?}}}",
            object_clsid,
            b_shim_if_necessary,
            pull_flags
        );
        let res = api.ApphelpCheckShellObject(object_clsid, b_shim_if_necessary, pull_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelDeviceWakeupRequest(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelDeviceWakeupRequest");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_device = {:?}}}", h_device);
        let res = api.CancelDeviceWakeupRequest(h_device);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelTimerQueueTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let timer_queue = call.get_arg();
        let timer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelTimerQueueTimer");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{timer_queue = {:?}, timer = {:?}}}",
            timer_queue,
            timer
        );
        let res = api.CancelTimerQueueTimer(timer_queue, timer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseINFEngine(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inf = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseINFEngine");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_inf = {:?}}}", h_inf);
        let res = api.CloseINFEngine(h_inf);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertAuxiliaryCounterToPerformanceCounter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ull_auxiliary_counter_value = call.get_arg();
        let lp_performance_counter_value = call.get_arg();
        let lp_conversion_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ConvertAuxiliaryCounterToPerformanceCounter");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ull_auxiliary_counter_value = {:?}, lp_performance_counter_value = {:?}, lp_conversion_error = {:?}}}" , ull_auxiliary_counter_value , lp_performance_counter_value , lp_conversion_error );
        let res = api.ConvertAuxiliaryCounterToPerformanceCounter(
            ull_auxiliary_counter_value,
            lp_performance_counter_value,
            lp_conversion_error,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ConvertPerformanceCounterToAuxiliaryCounter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ull_performance_counter_value = call.get_arg();
        let lp_auxiliary_counter_value = call.get_arg();
        let lp_conversion_error = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ConvertPerformanceCounterToAuxiliaryCounter");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{ull_performance_counter_value = {:?}, lp_auxiliary_counter_value = {:?}, lp_conversion_error = {:?}}}" , ull_performance_counter_value , lp_auxiliary_counter_value , lp_conversion_error );
        let res = api.ConvertPerformanceCounterToAuxiliaryCounter(
            ull_performance_counter_value,
            lp_auxiliary_counter_value,
            lp_conversion_error,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DelNodeA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_file_or_dir_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DelNodeA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{psz_file_or_dir_name = {:?}, dw_flags = {:?}}}",
            psz_file_or_dir_name,
            dw_flags
        );
        let res = api.DelNodeA(psz_file_or_dir_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DelNodeRunDLL32W(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DelNodeRunDLL32W");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}",
            hwnd,
            h_instance,
            psz_parms,
            n_show
        );
        let res = api.DelNodeRunDLL32W(hwnd, h_instance, psz_parms, n_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DelNodeW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_file_or_dir_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DelNodeW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{psz_file_or_dir_name = {:?}, dw_flags = {:?}}}",
            psz_file_or_dir_name,
            dw_flags
        );
        let res = api.DelNodeW(psz_file_or_dir_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DnsHostnameToComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hostname = call.get_arg();
        let computer_name = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DnsHostnameToComputerNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hostname = {:?}, computer_name = {:?}, n_size = {:?}}}",
            hostname,
            computer_name,
            n_size
        );
        let res = api.DnsHostnameToComputerNameA(hostname, computer_name, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DnsHostnameToComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hostname = call.get_arg();
        let computer_name = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DnsHostnameToComputerNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hostname = {:?}, computer_name = {:?}, n_size = {:?}}}",
            hostname,
            computer_name,
            n_size
        );
        let res = api.DnsHostnameToComputerNameW(hostname, computer_name, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DosDateTimeToFileTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let w_fat_date = call.get_arg();
        let w_fat_time = call.get_arg();
        let lp_file_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DosDateTimeToFileTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{w_fat_date = {:?}, w_fat_time = {:?}, lp_file_time = {:?}}}",
            w_fat_date,
            w_fat_time,
            lp_file_time
        );
        let res = api.DosDateTimeToFileTime(w_fat_date, w_fat_time, lp_file_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnableProcessOptionalXStateFeatures(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let features = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnableProcessOptionalXStateFeatures");
        let _enter = span.enter();
        tracing::trace!("  args = {{features = {:?}}}", features);
        let res = api.EnableProcessOptionalXStateFeatures(features);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExecuteCabA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let p_cab = call.get_arg();
        let p_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExecuteCabA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, p_cab = {:?}, p_reserved = {:?}}}",
            hwnd,
            p_cab,
            p_reserved
        );
        let res = api.ExecuteCabA(hwnd, p_cab, p_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExecuteCabW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let p_cab = call.get_arg();
        let p_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExecuteCabW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, p_cab = {:?}, p_reserved = {:?}}}",
            hwnd,
            p_cab,
            p_reserved
        );
        let res = api.ExecuteCabW(hwnd, p_cab, p_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExtractFilesA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_cab_name = call.get_arg();
        let psz_expand_dir = call.get_arg();
        let dw_flags = call.get_arg();
        let psz_file_list = call.get_arg();
        let lp_reserved = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExtractFilesA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psz_cab_name = {:?}, psz_expand_dir = {:?}, dw_flags = {:?}, psz_file_list = {:?}, lp_reserved = {:?}, dw_reserved = {:?}}}" , psz_cab_name , psz_expand_dir , dw_flags , psz_file_list , lp_reserved , dw_reserved );
        let res = api.ExtractFilesA(
            psz_cab_name,
            psz_expand_dir,
            dw_flags,
            psz_file_list,
            lp_reserved,
            dw_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ExtractFilesW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_cab_name = call.get_arg();
        let psz_expand_dir = call.get_arg();
        let dw_flags = call.get_arg();
        let psz_file_list = call.get_arg();
        let lp_reserved = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ExtractFilesW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psz_cab_name = {:?}, psz_expand_dir = {:?}, dw_flags = {:?}, psz_file_list = {:?}, lp_reserved = {:?}, dw_reserved = {:?}}}" , psz_cab_name , psz_expand_dir , dw_flags , psz_file_list , lp_reserved , dw_reserved );
        let res = api.ExtractFilesW(
            psz_cab_name,
            psz_expand_dir,
            dw_flags,
            psz_file_list,
            lp_reserved,
            dw_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveMarkNotExistA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_list = call.get_arg();
        let lp_dir = call.get_arg();
        let lp_base_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileSaveMarkNotExistA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_list = {:?}, lp_dir = {:?}, lp_base_name = {:?}}}",
            lp_file_list,
            lp_dir,
            lp_base_name
        );
        let res = api.FileSaveMarkNotExistA(lp_file_list, lp_dir, lp_base_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveMarkNotExistW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_list = call.get_arg();
        let lp_dir = call.get_arg();
        let lp_base_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileSaveMarkNotExistW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_list = {:?}, lp_dir = {:?}, lp_base_name = {:?}}}",
            lp_file_list,
            lp_dir,
            lp_base_name
        );
        let res = api.FileSaveMarkNotExistW(lp_file_list, lp_dir, lp_base_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreOnINFA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let psz_title = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_section = call.get_arg();
        let psz_backup_dir = call.get_arg();
        let psz_base_backup_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileSaveRestoreOnINFA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, psz_title = {:?}, psz_inf = {:?}, psz_section = {:?}, psz_backup_dir = {:?}, psz_base_backup_file = {:?}, dw_flags = {:?}}}" , h_wnd , psz_title , psz_inf , psz_section , psz_backup_dir , psz_base_backup_file , dw_flags );
        let res = api.FileSaveRestoreOnINFA(
            h_wnd,
            psz_title,
            psz_inf,
            psz_section,
            psz_backup_dir,
            psz_base_backup_file,
            dw_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreOnINFW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let psz_title = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_section = call.get_arg();
        let psz_backup_dir = call.get_arg();
        let psz_base_backup_file = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileSaveRestoreOnINFW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, psz_title = {:?}, psz_inf = {:?}, psz_section = {:?}, psz_backup_dir = {:?}, psz_base_backup_file = {:?}, dw_flags = {:?}}}" , h_wnd , psz_title , psz_inf , psz_section , psz_backup_dir , psz_base_backup_file , dw_flags );
        let res = api.FileSaveRestoreOnINFW(
            h_wnd,
            psz_title,
            psz_inf,
            psz_section,
            psz_backup_dir,
            psz_base_backup_file,
            dw_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileSaveRestoreW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_file_list = call.get_arg();
        let lp_dir = call.get_arg();
        let lp_base_name = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileSaveRestoreW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_dlg = {:?}, lp_file_list = {:?}, lp_dir = {:?}, lp_base_name = {:?}, dw_flags = {:?}}}" , h_dlg , lp_file_list , lp_dir , lp_base_name , dw_flags );
        let res = api.FileSaveRestoreW(h_dlg, lp_file_list, lp_dir, lp_base_name, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FileTimeToDosDateTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_time = call.get_arg();
        let lp_fat_date = call.get_arg();
        let lp_fat_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FileTimeToDosDateTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_file_time = {:?}, lp_fat_date = {:?}, lp_fat_time = {:?}}}",
            lp_file_time,
            lp_fat_date,
            lp_fat_time
        );
        let res = api.FileTimeToDosDateTime(lp_file_time, lp_fat_date, lp_fat_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GdiEntry13(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GdiEntry13");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GdiEntry13();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetComputerNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, n_size = {:?}}}",
            lp_buffer,
            n_size
        );
        let res = api.GetComputerNameA(lp_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetComputerNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetComputerNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, n_size = {:?}}}",
            lp_buffer,
            n_size
        );
        let res = api.GetComputerNameW(lp_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentHwProfileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_hw_profile_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentHwProfileA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_hw_profile_info = {:?}}}", lp_hw_profile_info);
        let res = api.GetCurrentHwProfileA(lp_hw_profile_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCurrentHwProfileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_hw_profile_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCurrentHwProfileW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_hw_profile_info = {:?}}}", lp_hw_profile_info);
        let res = api.GetCurrentHwProfileW(lp_hw_profile_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFeatureEnabledState(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let change_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFeatureEnabledState");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{feature_id = {:?}, change_time = {:?}}}",
            feature_id,
            change_time
        );
        let res = api.GetFeatureEnabledState(feature_id, change_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFeatureVariant(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let change_time = call.get_arg();
        let payload_id = call.get_arg();
        let has_notification = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFeatureVariant");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{feature_id = {:?}, change_time = {:?}, payload_id = {:?}, has_notification = {:?}}}" , feature_id , change_time , payload_id , has_notification );
        let res = api.GetFeatureVariant(feature_id, change_time, payload_id, has_notification);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFirmwareEnvironmentVariableA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}}}",
            lp_name,
            lp_guid,
            p_buffer,
            n_size
        );
        let res = api.GetFirmwareEnvironmentVariableA(lp_name, lp_guid, p_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let pdw_attribubutes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFirmwareEnvironmentVariableExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}, pdw_attribubutes = {:?}}}" , lp_name , lp_guid , p_buffer , n_size , pdw_attribubutes );
        let res = api.GetFirmwareEnvironmentVariableExA(
            lp_name,
            lp_guid,
            p_buffer,
            n_size,
            pdw_attribubutes,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let pdw_attribubutes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFirmwareEnvironmentVariableExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}, pdw_attribubutes = {:?}}}" , lp_name , lp_guid , p_buffer , n_size , pdw_attribubutes );
        let res = api.GetFirmwareEnvironmentVariableExW(
            lp_name,
            lp_guid,
            p_buffer,
            n_size,
            pdw_attribubutes,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetFirmwareEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_buffer = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetFirmwareEnvironmentVariableW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_guid = {:?}, p_buffer = {:?}, n_size = {:?}}}",
            lp_name,
            lp_guid,
            p_buffer,
            n_size
        );
        let res = api.GetFirmwareEnvironmentVariableW(lp_name, lp_guid, p_buffer, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileIntA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileIntA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , n_default , lp_file_name );
        let res = api.GetPrivateProfileIntA(lp_app_name, lp_key_name, n_default, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileIntW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileIntW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , n_default , lp_file_name );
        let res = api.GetPrivateProfileIntW(lp_app_name, lp_key_name, n_default, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileSectionA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_returned_string , n_size , lp_file_name );
        let res =
            api.GetPrivateProfileSectionA(lp_app_name, lp_returned_string, n_size, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionNamesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_return_buffer = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileSectionNamesA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_return_buffer = {:?}, n_size = {:?}, lp_file_name = {:?}}}",
            lpsz_return_buffer,
            n_size,
            lp_file_name
        );
        let res = api.GetPrivateProfileSectionNamesA(lpsz_return_buffer, n_size, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionNamesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_return_buffer = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileSectionNamesW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_return_buffer = {:?}, n_size = {:?}, lp_file_name = {:?}}}",
            lpsz_return_buffer,
            n_size,
            lp_file_name
        );
        let res = api.GetPrivateProfileSectionNamesW(lpsz_return_buffer, n_size, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileSectionW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_returned_string , n_size , lp_file_name );
        let res =
            api.GetPrivateProfileSectionW(lp_app_name, lp_returned_string, n_size, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size , lp_file_name );
        let res = api.GetPrivateProfileStringA(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
            lp_file_name,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size , lp_file_name );
        let res = api.GetPrivateProfileStringW(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
            lp_file_name,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStructA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileStructA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file );
        let res =
            api.GetPrivateProfileStructA(lpsz_section, lpsz_key, lp_struct, u_size_struct, sz_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPrivateProfileStructW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPrivateProfileStructW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file );
        let res =
            api.GetPrivateProfileStructW(lpsz_section, lpsz_key, lp_struct, u_size_struct, sz_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileIntA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProfileIntA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}}}",
            lp_app_name,
            lp_key_name,
            n_default
        );
        let res = api.GetProfileIntA(lp_app_name, lp_key_name, n_default);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileIntW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let n_default = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProfileIntW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, n_default = {:?}}}",
            lp_app_name,
            lp_key_name,
            n_default
        );
        let res = api.GetProfileIntW(lp_app_name, lp_key_name, n_default);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProfileSectionA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}}}",
            lp_app_name,
            lp_returned_string,
            n_size
        );
        let res = api.GetProfileSectionA(lp_app_name, lp_returned_string, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProfileSectionW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_returned_string = {:?}, n_size = {:?}}}",
            lp_app_name,
            lp_returned_string,
            n_size
        );
        let res = api.GetProfileSectionW(lp_app_name, lp_returned_string, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProfileStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size );
        let res = api.GetProfileStringA(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_default = call.get_arg();
        let lp_returned_string = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProfileStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_default = {:?}, lp_returned_string = {:?}, n_size = {:?}}}" , lp_app_name , lp_key_name , lp_default , lp_returned_string , n_size );
        let res = api.GetProfileStringW(
            lp_app_name,
            lp_key_name,
            lp_default,
            lp_returned_string,
            n_size,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemRegistryQuota(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pdw_quota_allowed = call.get_arg();
        let pdw_quota_used = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemRegistryQuota");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{pdw_quota_allowed = {:?}, pdw_quota_used = {:?}}}",
            pdw_quota_allowed,
            pdw_quota_used
        );
        let res = api.GetSystemRegistryQuota(pdw_quota_allowed, pdw_quota_used);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetThreadEnabledXStateFeatures(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetThreadEnabledXStateFeatures");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetThreadEnabledXStateFeatures();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserNameA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let pcb_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, pcb_buffer = {:?}}}",
            lp_buffer,
            pcb_buffer
        );
        let res = api.GetUserNameA(lp_buffer, pcb_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetUserNameW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_buffer = call.get_arg();
        let pcb_buffer = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetUserNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_buffer = {:?}, pcb_buffer = {:?}}}",
            lp_buffer,
            pcb_buffer
        );
        let res = api.GetUserNameW(lp_buffer, pcb_buffer);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVersionFromFileA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version );
        let res = api.GetVersionFromFileA(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVersionFromFileExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version );
        let res = api.GetVersionFromFileExA(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVersionFromFileExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version );
        let res = api.GetVersionFromFileExW(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetVersionFromFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_filename = call.get_arg();
        let pdw_ms_ver = call.get_arg();
        let pdw_ls_ver = call.get_arg();
        let b_version = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetVersionFromFileW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_filename = {:?}, pdw_ms_ver = {:?}, pdw_ls_ver = {:?}, b_version = {:?}}}" , lpsz_filename , pdw_ms_ver , pdw_ls_ver , b_version );
        let res = api.GetVersionFromFileW(lpsz_filename, pdw_ms_ver, pdw_ls_ver, b_version);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_min_free = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalCompact");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_min_free = {:?}}}", dw_min_free);
        let res = api.GlobalCompact(dw_min_free);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalFix(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalFix");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalFix(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalUnWire(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalUnWire");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalUnWire(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalUnfix(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalUnfix");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalUnfix(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GlobalWire(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GlobalWire");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_mem = {:?}}}", h_mem);
        let res = api.GlobalWire(h_mem);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPGetIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IMPGetIMEA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.IMPGetIMEA(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPGetIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IMPGetIMEW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.IMPGetIMEW(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPQueryIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IMPQueryIMEA");
        let _enter = span.enter();
        tracing::trace!("  args = {{param_0 = {:?}}}", param_0);
        let res = api.IMPQueryIMEA(param_0);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPQueryIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IMPQueryIMEW");
        let _enter = span.enter();
        tracing::trace!("  args = {{param_0 = {:?}}}", param_0);
        let res = api.IMPQueryIMEW(param_0);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPSetIMEA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IMPSetIMEA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.IMPSetIMEA(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IMPSetIMEW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IMPSetIMEW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.IMPSetIMEW(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsApiSetImplemented(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let contract = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsApiSetImplemented");
        let _enter = span.enter();
        tracing::trace!("  args = {{contract = {:?}}}", contract);
        let res = api.IsApiSetImplemented(contract);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadHugeReadPtr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsBadHugeReadPtr");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp = {:?}, ucb = {:?}}}", lp, ucb);
        let res = api.IsBadHugeReadPtr(lp, ucb);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsBadHugeWritePtr(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp = call.get_arg();
        let ucb = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsBadHugeWritePtr");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp = {:?}, ucb = {:?}}}", lp, ucb);
        let res = api.IsBadHugeWritePtr(lp, ucb);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNTAdmin(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_reserved = call.get_arg();
        let lpdw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsNTAdmin");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_reserved = {:?}, lpdw_reserved = {:?}}}",
            dw_reserved,
            lpdw_reserved
        );
        let res = api.IsNTAdmin(dw_reserved, lpdw_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsNativeVhdBoot(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let native_vhd_boot = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsNativeVhdBoot");
        let _enter = span.enter();
        tracing::trace!("  args = {{native_vhd_boot = {:?}}}", native_vhd_boot);
        let res = api.IsNativeVhdBoot(native_vhd_boot);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsTokenUntrusted(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let token_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsTokenUntrusted");
        let _enter = span.enter();
        tracing::trace!("  args = {{token_handle = {:?}}}", token_handle);
        let res = api.IsTokenUntrusted(token_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LaunchINFSectionExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LaunchINFSectionExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}",
            hwnd,
            h_instance,
            psz_parms,
            n_show
        );
        let res = api.LaunchINFSectionExW(hwnd, h_instance, psz_parms, n_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LaunchINFSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_owner = call.get_arg();
        let h_instance = call.get_arg();
        let psz_params = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LaunchINFSectionW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd_owner = {:?}, h_instance = {:?}, psz_params = {:?}, n_show = {:?}}}",
            hwnd_owner,
            h_instance,
            psz_params,
            n_show
        );
        let res = api.LaunchINFSectionW(hwnd_owner, h_instance, psz_params, n_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalCompact(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_min_free = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalCompact");
        let _enter = span.enter();
        tracing::trace!("  args = {{u_min_free = {:?}}}", u_min_free);
        let res = api.LocalCompact(u_min_free);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LocalShrink(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mem = call.get_arg();
        let cb_new_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LocalShrink");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_mem = {:?}, cb_new_size = {:?}}}",
            h_mem,
            cb_new_size
        );
        let res = api.LocalShrink(h_mem, cb_new_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MulDiv(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_number = call.get_arg();
        let n_numerator = call.get_arg();
        let n_denominator = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MulDiv");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_number = {:?}, n_numerator = {:?}, n_denominator = {:?}}}",
            n_number,
            n_numerator,
            n_denominator
        );
        let res = api.MulDiv(n_number, n_numerator, n_denominator);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedReboot(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_reboot_check = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NeedReboot");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_reboot_check = {:?}}}", dw_reboot_check);
        let res = api.NeedReboot(dw_reboot_check);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NeedRebootInit(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NeedRebootInit");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.NeedRebootInit();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtClose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtClose");
        let _enter = span.enter();
        tracing::trace!("  args = {{handle = {:?}}}", handle);
        let res = api.NtClose(handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtDeviceIoControlFile(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let event = call.get_arg();
        let apc_routine = call.get_arg();
        let apc_context = call.get_arg();
        let io_status_block = call.get_arg();
        let io_control_code = call.get_arg();
        let input_buffer = call.get_arg();
        let input_buffer_length = call.get_arg();
        let output_buffer = call.get_arg();
        let output_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtDeviceIoControlFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_handle = {:?}, event = {:?}, apc_routine = {:?}, apc_context = {:?}, io_status_block = {:?}, io_control_code = {:?}, input_buffer = {:?}, input_buffer_length = {:?}, output_buffer = {:?}, output_buffer_length = {:?}}}" , file_handle , event , apc_routine , apc_context , io_status_block , io_control_code , input_buffer , input_buffer_length , output_buffer , output_buffer_length );
        let res = api.NtDeviceIoControlFile(
            file_handle,
            event,
            apc_routine,
            apc_context,
            io_status_block,
            io_control_code,
            input_buffer,
            input_buffer_length,
            output_buffer,
            output_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtNotifyChangeMultipleKeys(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let master_key_handle = call.get_arg();
        let count = call.get_arg();
        let subordinate_objects = call.get_arg();
        let event = call.get_arg();
        let apc_routine = call.get_arg();
        let apc_context = call.get_arg();
        let io_status_block = call.get_arg();
        let completion_filter = call.get_arg();
        let watch_tree = call.get_arg();
        let buffer = call.get_arg();
        let buffer_size = call.get_arg();
        let asynchronous = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtNotifyChangeMultipleKeys");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{master_key_handle = {:?}, count = {:?}, subordinate_objects = {:?}, event = {:?}, apc_routine = {:?}, apc_context = {:?}, io_status_block = {:?}, completion_filter = {:?}, watch_tree = {:?}, buffer = {:?}, buffer_size = {:?}, asynchronous = {:?}}}" , master_key_handle , count , subordinate_objects , event , apc_routine , apc_context , io_status_block , completion_filter , watch_tree , buffer , buffer_size , asynchronous );
        let res = api.NtNotifyChangeMultipleKeys(
            master_key_handle,
            count,
            subordinate_objects,
            event,
            apc_routine,
            apc_context,
            io_status_block,
            completion_filter,
            watch_tree,
            buffer,
            buffer_size,
            asynchronous,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtOpenFile(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let desired_access = call.get_arg();
        let object_attributes = call.get_arg();
        let io_status_block = call.get_arg();
        let share_access = call.get_arg();
        let open_options = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtOpenFile");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{file_handle = {:?}, desired_access = {:?}, object_attributes = {:?}, io_status_block = {:?}, share_access = {:?}, open_options = {:?}}}" , file_handle , desired_access , object_attributes , io_status_block , share_access , open_options );
        let res = api.NtOpenFile(
            file_handle,
            desired_access,
            object_attributes,
            io_status_block,
            share_access,
            open_options,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryMultipleValueKey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let key_handle = call.get_arg();
        let value_entries = call.get_arg();
        let entry_count = call.get_arg();
        let value_buffer = call.get_arg();
        let buffer_length = call.get_arg();
        let required_buffer_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtQueryMultipleValueKey");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{key_handle = {:?}, value_entries = {:?}, entry_count = {:?}, value_buffer = {:?}, buffer_length = {:?}, required_buffer_length = {:?}}}" , key_handle , value_entries , entry_count , value_buffer , buffer_length , required_buffer_length );
        let res = api.NtQueryMultipleValueKey(
            key_handle,
            value_entries,
            entry_count,
            value_buffer,
            buffer_length,
            required_buffer_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryObject(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let object_information_class = call.get_arg();
        let object_information = call.get_arg();
        let object_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtQueryObject");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{handle = {:?}, object_information_class = {:?}, object_information = {:?}, object_information_length = {:?}, return_length = {:?}}}" , handle , object_information_class , object_information , object_information_length , return_length );
        let res = api.NtQueryObject(
            handle,
            object_information_class,
            object_information,
            object_information_length,
            return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQuerySystemInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let system_information_class = call.get_arg();
        let system_information = call.get_arg();
        let system_information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtQuerySystemInformation");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{system_information_class = {:?}, system_information = {:?}, system_information_length = {:?}, return_length = {:?}}}" , system_information_class , system_information , system_information_length , return_length );
        let res = api.NtQuerySystemInformation(
            system_information_class,
            system_information,
            system_information_length,
            return_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQuerySystemTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtQuerySystemTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{system_time = {:?}}}", system_time);
        let res = api.NtQuerySystemTime(system_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtQueryTimerResolution(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let maximum_time = call.get_arg();
        let minimum_time = call.get_arg();
        let current_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtQueryTimerResolution");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{maximum_time = {:?}, minimum_time = {:?}, current_time = {:?}}}",
            maximum_time,
            minimum_time,
            current_time
        );
        let res = api.NtQueryTimerResolution(maximum_time, minimum_time, current_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtRenameKey(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let key_handle = call.get_arg();
        let new_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtRenameKey");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{key_handle = {:?}, new_name = {:?}}}",
            key_handle,
            new_name
        );
        let res = api.NtRenameKey(key_handle, new_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtSetInformationKey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let key_handle = call.get_arg();
        let key_set_information_class = call.get_arg();
        let key_set_information = call.get_arg();
        let key_set_information_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtSetInformationKey");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{key_handle = {:?}, key_set_information_class = {:?}, key_set_information = {:?}, key_set_information_length = {:?}}}" , key_handle , key_set_information_class , key_set_information , key_set_information_length );
        let res = api.NtSetInformationKey(
            key_handle,
            key_set_information_class,
            key_set_information,
            key_set_information_length,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_NtWaitForSingleObject(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let handle = call.get_arg();
        let alertable = call.get_arg();
        let timeout = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("NtWaitForSingleObject");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{handle = {:?}, alertable = {:?}, timeout = {:?}}}",
            handle,
            alertable,
            timeout
        );
        let res = api.NtWaitForSingleObject(handle, alertable, timeout);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenINFEngineA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let dw_flags = call.get_arg();
        let ph_inf = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenINFEngineA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, dw_flags = {:?}, ph_inf = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , dw_flags , ph_inf , pv_reserved );
        let res = api.OpenINFEngineA(
            psz_inf_filename,
            psz_install_section,
            dw_flags,
            ph_inf,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenINFEngineW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let dw_flags = call.get_arg();
        let ph_inf = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenINFEngineW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, dw_flags = {:?}, ph_inf = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , dw_flags , ph_inf , pv_reserved );
        let res = api.OpenINFEngineW(
            psz_inf_filename,
            psz_install_section,
            dw_flags,
            ph_inf,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenMutexA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenMutexA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenMutexA(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenSemaphoreA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenSemaphoreA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_name
        );
        let res = api.OpenSemaphoreA(dw_desired_access, b_inherit_handle, lp_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenWaitableTimerA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_desired_access = call.get_arg();
        let b_inherit_handle = call.get_arg();
        let lp_timer_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenWaitableTimerA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_desired_access = {:?}, b_inherit_handle = {:?}, lp_timer_name = {:?}}}",
            dw_desired_access,
            b_inherit_handle,
            lp_timer_name
        );
        let res = api.OpenWaitableTimerA(dw_desired_access, b_inherit_handle, lp_timer_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryAuxiliaryCounterFrequency(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_auxiliary_counter_frequency = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryAuxiliaryCounterFrequency");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_auxiliary_counter_frequency = {:?}}}",
            lp_auxiliary_counter_frequency
        );
        let res = api.QueryAuxiliaryCounterFrequency(lp_auxiliary_counter_frequency);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryIdleProcessorCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let buffer_length = call.get_arg();
        let processor_idle_cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryIdleProcessorCycleTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{buffer_length = {:?}, processor_idle_cycle_time = {:?}}}",
            buffer_length,
            processor_idle_cycle_time
        );
        let res = api.QueryIdleProcessorCycleTime(buffer_length, processor_idle_cycle_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryIdleProcessorCycleTimeEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let group = call.get_arg();
        let buffer_length = call.get_arg();
        let processor_idle_cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryIdleProcessorCycleTimeEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{group = {:?}, buffer_length = {:?}, processor_idle_cycle_time = {:?}}}",
            group,
            buffer_length,
            processor_idle_cycle_time
        );
        let res =
            api.QueryIdleProcessorCycleTimeEx(group, buffer_length, processor_idle_cycle_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryInterruptTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_interrupt_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryInterruptTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_interrupt_time = {:?}}}", lp_interrupt_time);
        let res = api.QueryInterruptTime(lp_interrupt_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryInterruptTimePrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_interrupt_time_precise = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryInterruptTimePrecise");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_interrupt_time_precise = {:?}}}",
            lp_interrupt_time_precise
        );
        let res = api.QueryInterruptTimePrecise(lp_interrupt_time_precise);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryProcessCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let process_handle = call.get_arg();
        let cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryProcessCycleTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{process_handle = {:?}, cycle_time = {:?}}}",
            process_handle,
            cycle_time
        );
        let res = api.QueryProcessCycleTime(process_handle, cycle_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryThreadCycleTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let thread_handle = call.get_arg();
        let cycle_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryThreadCycleTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{thread_handle = {:?}, cycle_time = {:?}}}",
            thread_handle,
            cycle_time
        );
        let res = api.QueryThreadCycleTime(thread_handle, cycle_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryUnbiasedInterruptTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unbiased_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryUnbiasedInterruptTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{unbiased_time = {:?}}}", unbiased_time);
        let res = api.QueryUnbiasedInterruptTime(unbiased_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_QueryUnbiasedInterruptTimePrecise(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_unbiased_interrupt_time_precise = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("QueryUnbiasedInterruptTimePrecise");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_unbiased_interrupt_time_precise = {:?}}}",
            lp_unbiased_interrupt_time_precise
        );
        let res = api.QueryUnbiasedInterruptTimePrecise(lp_unbiased_interrupt_time_precise);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RaiseCustomSystemEventTrigger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let custom_system_event_trigger_config = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RaiseCustomSystemEventTrigger");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{custom_system_event_trigger_config = {:?}}}",
            custom_system_event_trigger_config
        );
        let res = api.RaiseCustomSystemEventTrigger(custom_system_event_trigger_config);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RebootCheckOnInstallA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_sec = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RebootCheckOnInstallA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, psz_inf = {:?}, psz_sec = {:?}, dw_reserved = {:?}}}",
            hwnd,
            psz_inf,
            psz_sec,
            dw_reserved
        );
        let res = api.RebootCheckOnInstallA(hwnd, psz_inf, psz_sec, dw_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RebootCheckOnInstallW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_inf = call.get_arg();
        let psz_sec = call.get_arg();
        let dw_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RebootCheckOnInstallW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, psz_inf = {:?}, psz_sec = {:?}, dw_reserved = {:?}}}",
            hwnd,
            psz_inf,
            psz_sec,
            dw_reserved
        );
        let res = api.RebootCheckOnInstallW(hwnd, psz_inf, psz_sec, dw_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecordFeatureError(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let error = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RecordFeatureError");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{feature_id = {:?}, error = {:?}}}",
            feature_id,
            error
        );
        let res = api.RecordFeatureError(feature_id, error);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RecordFeatureUsage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let feature_id = call.get_arg();
        let kind = call.get_arg();
        let addend = call.get_arg();
        let origin_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RecordFeatureUsage");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{feature_id = {:?}, kind = {:?}, addend = {:?}, origin_name = {:?}}}",
            feature_id,
            kind,
            addend,
            origin_name
        );
        let res = api.RecordFeatureUsage(feature_id, kind, addend, origin_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegInstallA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hmod = call.get_arg();
        let psz_section = call.get_arg();
        let pst_table = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RegInstallA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hmod = {:?}, psz_section = {:?}, pst_table = {:?}}}",
            hmod,
            psz_section,
            pst_table
        );
        let res = api.RegInstallA(hmod, psz_section, pst_table);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegInstallW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hmod = call.get_arg();
        let psz_section = call.get_arg();
        let pst_table = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RegInstallW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hmod = {:?}, psz_section = {:?}, pst_table = {:?}}}",
            hmod,
            psz_section,
            pst_table
        );
        let res = api.RegInstallW(hmod, psz_section, pst_table);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplacePartitionUnit(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let target_partition = call.get_arg();
        let spare_partition = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReplacePartitionUnit");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{target_partition = {:?}, spare_partition = {:?}, flags = {:?}}}",
            target_partition,
            spare_partition,
            flags
        );
        let res = api.ReplacePartitionUnit(target_partition, spare_partition, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RequestDeviceWakeup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_device = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RequestDeviceWakeup");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_device = {:?}}}", h_device);
        let res = api.RequestDeviceWakeup(h_device);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlAnsiStringToUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let allocate_destination_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlAnsiStringToUnicodeString");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{destination_string = {:?}, source_string = {:?}, allocate_destination_string = {:?}}}" , destination_string , source_string , allocate_destination_string );
        let res = api.RtlAnsiStringToUnicodeString(
            destination_string,
            source_string,
            allocate_destination_string,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlCharToInteger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let string = call.get_arg();
        let base = call.get_arg();
        let value = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlCharToInteger");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{string = {:?}, base = {:?}, value = {:?}}}",
            string,
            base,
            value
        );
        let res = api.RtlCharToInteger(string, base, value);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFreeAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ansi_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlFreeAnsiString");
        let _enter = span.enter();
        tracing::trace!("  args = {{ansi_string = {:?}}}", ansi_string);
        let res = api.RtlFreeAnsiString(ansi_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFreeOemString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let oem_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlFreeOemString");
        let _enter = span.enter();
        tracing::trace!("  args = {{oem_string = {:?}}}", oem_string);
        let res = api.RtlFreeOemString(oem_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlFreeUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unicode_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlFreeUnicodeString");
        let _enter = span.enter();
        tracing::trace!("  args = {{unicode_string = {:?}}}", unicode_string);
        let res = api.RtlFreeUnicodeString(unicode_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlGetReturnAddressHijackTarget(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlGetReturnAddressHijackTarget");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.RtlGetReturnAddressHijackTarget();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInitAnsiString");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{destination_string = {:?}, source_string = {:?}}}",
            destination_string,
            source_string
        );
        let res = api.RtlInitAnsiString(destination_string, source_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitAnsiStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInitAnsiStringEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{destination_string = {:?}, source_string = {:?}}}",
            destination_string,
            source_string
        );
        let res = api.RtlInitAnsiStringEx(destination_string, source_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitString(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInitString");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{destination_string = {:?}, source_string = {:?}}}",
            destination_string,
            source_string
        );
        let res = api.RtlInitString(destination_string, source_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitStringEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInitStringEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{destination_string = {:?}, source_string = {:?}}}",
            destination_string,
            source_string
        );
        let res = api.RtlInitStringEx(destination_string, source_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlInitUnicodeString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlInitUnicodeString");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{destination_string = {:?}, source_string = {:?}}}",
            destination_string,
            source_string
        );
        let res = api.RtlInitUnicodeString(destination_string, source_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlIsNameLegalDOS8Dot3(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let name = call.get_arg();
        let oem_name = call.get_arg();
        let name_contains_spaces = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlIsNameLegalDOS8Dot3");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{name = {:?}, oem_name = {:?}, name_contains_spaces = {:?}}}",
            name,
            oem_name,
            name_contains_spaces
        );
        let res = api.RtlIsNameLegalDOS8Dot3(name, oem_name, name_contains_spaces);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlLocalTimeToSystemTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let local_time = call.get_arg();
        let system_time = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlLocalTimeToSystemTime");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{local_time = {:?}, system_time = {:?}}}",
            local_time,
            system_time
        );
        let res = api.RtlLocalTimeToSystemTime(local_time, system_time);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlRaiseCustomSystemEventTrigger(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let trigger_config = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlRaiseCustomSystemEventTrigger");
        let _enter = span.enter();
        tracing::trace!("  args = {{trigger_config = {:?}}}", trigger_config);
        let res = api.RtlRaiseCustomSystemEventTrigger(trigger_config);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlTimeToSecondsSince1970(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let time = call.get_arg();
        let elapsed_seconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlTimeToSecondsSince1970");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{time = {:?}, elapsed_seconds = {:?}}}",
            time,
            elapsed_seconds
        );
        let res = api.RtlTimeToSecondsSince1970(time, elapsed_seconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeStringToAnsiString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let allocate_destination_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlUnicodeStringToAnsiString");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{destination_string = {:?}, source_string = {:?}, allocate_destination_string = {:?}}}" , destination_string , source_string , allocate_destination_string );
        let res = api.RtlUnicodeStringToAnsiString(
            destination_string,
            source_string,
            allocate_destination_string,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeStringToOemString(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let destination_string = call.get_arg();
        let source_string = call.get_arg();
        let allocate_destination_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlUnicodeStringToOemString");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{destination_string = {:?}, source_string = {:?}, allocate_destination_string = {:?}}}" , destination_string , source_string , allocate_destination_string );
        let res = api.RtlUnicodeStringToOemString(
            destination_string,
            source_string,
            allocate_destination_string,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUnicodeToMultiByteSize(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let bytes_in_multi_byte_string = call.get_arg();
        let unicode_string = call.get_arg();
        let bytes_in_unicode_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlUnicodeToMultiByteSize");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{bytes_in_multi_byte_string = {:?}, unicode_string = {:?}, bytes_in_unicode_string = {:?}}}" , bytes_in_multi_byte_string , unicode_string , bytes_in_unicode_string );
        let res = api.RtlUnicodeToMultiByteSize(
            bytes_in_multi_byte_string,
            unicode_string,
            bytes_in_unicode_string,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RtlUniform(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let seed = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RtlUniform");
        let _enter = span.enter();
        tracing::trace!("  args = {{seed = {:?}}}", seed);
        let res = api.RtlUniform(seed);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RunSetupCommandA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let sz_cmd_name = call.get_arg();
        let sz_inf_section = call.get_arg();
        let sz_dir = call.get_arg();
        let lpsz_title = call.get_arg();
        let ph_exe = call.get_arg();
        let dw_flags = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RunSetupCommandA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, sz_cmd_name = {:?}, sz_inf_section = {:?}, sz_dir = {:?}, lpsz_title = {:?}, ph_exe = {:?}, dw_flags = {:?}, pv_reserved = {:?}}}" , h_wnd , sz_cmd_name , sz_inf_section , sz_dir , lpsz_title , ph_exe , dw_flags , pv_reserved );
        let res = api.RunSetupCommandA(
            h_wnd,
            sz_cmd_name,
            sz_inf_section,
            sz_dir,
            lpsz_title,
            ph_exe,
            dw_flags,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RunSetupCommandW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let sz_cmd_name = call.get_arg();
        let sz_inf_section = call.get_arg();
        let sz_dir = call.get_arg();
        let lpsz_title = call.get_arg();
        let ph_exe = call.get_arg();
        let dw_flags = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RunSetupCommandW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, sz_cmd_name = {:?}, sz_inf_section = {:?}, sz_dir = {:?}, lpsz_title = {:?}, ph_exe = {:?}, dw_flags = {:?}, pv_reserved = {:?}}}" , h_wnd , sz_cmd_name , sz_inf_section , sz_dir , lpsz_title , ph_exe , dw_flags , pv_reserved );
        let res = api.RunSetupCommandW(
            h_wnd,
            sz_cmd_name,
            sz_inf_section,
            sz_dir,
            lpsz_title,
            ph_exe,
            dw_flags,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendIMEMessageExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendIMEMessageExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.SendIMEMessageExA(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendIMEMessageExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendIMEMessageExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.SendIMEMessageExW(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetEnvironmentStringsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let new_environment = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetEnvironmentStringsA");
        let _enter = span.enter();
        tracing::trace!("  args = {{new_environment = {:?}}}", new_environment);
        let res = api.SetEnvironmentStringsA(new_environment);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFirmwareEnvironmentVariableA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}}}",
            lp_name,
            lp_guid,
            p_value,
            n_size
        );
        let res = api.SetFirmwareEnvironmentVariableA(lp_name, lp_guid, p_value, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let dw_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFirmwareEnvironmentVariableExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}, dw_attributes = {:?}}}" , lp_name , lp_guid , p_value , n_size , dw_attributes );
        let res =
            api.SetFirmwareEnvironmentVariableExA(lp_name, lp_guid, p_value, n_size, dw_attributes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let dw_attributes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFirmwareEnvironmentVariableExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}, dw_attributes = {:?}}}" , lp_name , lp_guid , p_value , n_size , dw_attributes );
        let res =
            api.SetFirmwareEnvironmentVariableExW(lp_name, lp_guid, p_value, n_size, dw_attributes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetFirmwareEnvironmentVariableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_name = call.get_arg();
        let lp_guid = call.get_arg();
        let p_value = call.get_arg();
        let n_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetFirmwareEnvironmentVariableW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_name = {:?}, lp_guid = {:?}, p_value = {:?}, n_size = {:?}}}",
            lp_name,
            lp_guid,
            p_value,
            n_size
        );
        let res = api.SetFirmwareEnvironmentVariableW(lp_name, lp_guid, p_value, n_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetHandleCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_number = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetHandleCount");
        let _enter = span.enter();
        tracing::trace!("  args = {{u_number = {:?}}}", u_number);
        let res = api.SetHandleCount(u_number);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMessageWaitingIndicator(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_msg_indicator = call.get_arg();
        let ul_msg_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetMessageWaitingIndicator");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_msg_indicator = {:?}, ul_msg_count = {:?}}}",
            h_msg_indicator,
            ul_msg_count
        );
        let res = api.SetMessageWaitingIndicator(h_msg_indicator, ul_msg_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPerUserSecValuesA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_per_user = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetPerUserSecValuesA");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_per_user = {:?}}}", p_per_user);
        let res = api.SetPerUserSecValuesA(p_per_user);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPerUserSecValuesW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_per_user = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetPerUserSecValuesW");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_per_user = {:?}}}", p_per_user);
        let res = api.SetPerUserSecValuesW(p_per_user);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SignalObjectAndWait(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_object_to_signal = call.get_arg();
        let h_object_to_wait_on = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let b_alertable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SignalObjectAndWait");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_object_to_signal = {:?}, h_object_to_wait_on = {:?}, dw_milliseconds = {:?}, b_alertable = {:?}}}" , h_object_to_signal , h_object_to_wait_on , dw_milliseconds , b_alertable );
        let res = api.SignalObjectAndWait(
            h_object_to_signal,
            h_object_to_wait_on,
            dw_milliseconds,
            b_alertable,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SubscribeFeatureStateChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let subscription = call.get_arg();
        let callback = call.get_arg();
        let context = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SubscribeFeatureStateChangeNotification");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{subscription = {:?}, callback = {:?}, context = {:?}}}",
            subscription,
            callback,
            context
        );
        let res = api.SubscribeFeatureStateChangeNotification(subscription, callback, context);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let cch_buffer = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateInfStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, cch_buffer = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , psz_translate_section , psz_translate_key , psz_buffer , cch_buffer , pdw_required_size , pv_reserved );
        let res = api.TranslateInfStringA(
            psz_inf_filename,
            psz_install_section,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            cch_buffer,
            pdw_required_size,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inf = call.get_arg();
        let psz_inf_filename = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateInfStringExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_inf = {:?}, psz_inf_filename = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, dw_buffer_size = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , h_inf , psz_inf_filename , psz_translate_section , psz_translate_key , psz_buffer , dw_buffer_size , pdw_required_size , pv_reserved );
        let res = api.TranslateInfStringExA(
            h_inf,
            psz_inf_filename,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            dw_buffer_size,
            pdw_required_size,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inf = call.get_arg();
        let psz_inf_filename = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let dw_buffer_size = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateInfStringExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_inf = {:?}, psz_inf_filename = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, dw_buffer_size = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , h_inf , psz_inf_filename , psz_translate_section , psz_translate_key , psz_buffer , dw_buffer_size , pdw_required_size , pv_reserved );
        let res = api.TranslateInfStringExW(
            h_inf,
            psz_inf_filename,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            dw_buffer_size,
            pdw_required_size,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateInfStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let psz_inf_filename = call.get_arg();
        let psz_install_section = call.get_arg();
        let psz_translate_section = call.get_arg();
        let psz_translate_key = call.get_arg();
        let psz_buffer = call.get_arg();
        let cch_buffer = call.get_arg();
        let pdw_required_size = call.get_arg();
        let pv_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateInfStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{psz_inf_filename = {:?}, psz_install_section = {:?}, psz_translate_section = {:?}, psz_translate_key = {:?}, psz_buffer = {:?}, cch_buffer = {:?}, pdw_required_size = {:?}, pv_reserved = {:?}}}" , psz_inf_filename , psz_install_section , psz_translate_section , psz_translate_key , psz_buffer , cch_buffer , pdw_required_size , pv_reserved );
        let res = api.TranslateInfStringW(
            psz_inf_filename,
            psz_install_section,
            psz_translate_section,
            psz_translate_key,
            psz_buffer,
            cch_buffer,
            pdw_required_size,
            pv_reserved,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnsubscribeFeatureStateChangeNotification(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let subscription = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnsubscribeFeatureStateChangeNotification");
        let _enter = span.enter();
        tracing::trace!("  args = {{subscription = {:?}}}", subscription);
        let res = api.UnsubscribeFeatureStateChangeNotification(subscription);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserInstStubWrapperA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UserInstStubWrapperA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}",
            hwnd,
            h_instance,
            psz_parms,
            n_show
        );
        let res = api.UserInstStubWrapperA(hwnd, h_instance, psz_parms, n_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserInstStubWrapperW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UserInstStubWrapperW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}",
            hwnd,
            h_instance,
            psz_parms,
            n_show
        );
        let res = api.UserInstStubWrapperW(hwnd, h_instance, psz_parms, n_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserUnInstStubWrapperA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UserUnInstStubWrapperA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}",
            hwnd,
            h_instance,
            psz_parms,
            n_show
        );
        let res = api.UserUnInstStubWrapperA(hwnd, h_instance, psz_parms, n_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UserUnInstStubWrapperW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let h_instance = call.get_arg();
        let psz_parms = call.get_arg();
        let n_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UserUnInstStubWrapperW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, h_instance = {:?}, psz_parms = {:?}, n_show = {:?}}}",
            hwnd,
            h_instance,
            psz_parms,
            n_show
        );
        let res = api.UserUnInstStubWrapperW(hwnd, h_instance, psz_parms, n_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WINNLSEnableIME(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WINNLSEnableIME");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.WINNLSEnableIME(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WINNLSGetEnableStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WINNLSGetEnableStatus");
        let _enter = span.enter();
        tracing::trace!("  args = {{param_0 = {:?}}}", param_0);
        let res = api.WINNLSGetEnableStatus(param_0);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WINNLSGetIMEHotkey(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WINNLSGetIMEHotkey");
        let _enter = span.enter();
        tracing::trace!("  args = {{param_0 = {:?}}}", param_0);
        let res = api.WINNLSGetIMEHotkey(param_0);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpGetLockdownPolicy(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let host_information = call.get_arg();
        let lockdown_state = call.get_arg();
        let lockdown_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WldpGetLockdownPolicy");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{host_information = {:?}, lockdown_state = {:?}, lockdown_flags = {:?}}}",
            host_information,
            lockdown_state,
            lockdown_flags
        );
        let res = api.WldpGetLockdownPolicy(host_information, lockdown_state, lockdown_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpIsClassInApprovedList(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let class_id = call.get_arg();
        let host_information = call.get_arg();
        let is_approved = call.get_arg();
        let optional_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WldpIsClassInApprovedList");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{class_id = {:?}, host_information = {:?}, is_approved = {:?}, optional_flags = {:?}}}" , class_id , host_information , is_approved , optional_flags );
        let res =
            api.WldpIsClassInApprovedList(class_id, host_information, is_approved, optional_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpIsDynamicCodePolicyEnabled(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let is_enabled = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WldpIsDynamicCodePolicyEnabled");
        let _enter = span.enter();
        tracing::trace!("  args = {{is_enabled = {:?}}}", is_enabled);
        let res = api.WldpIsDynamicCodePolicyEnabled(is_enabled);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpQueryDeviceSecurityInformation(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let information = call.get_arg();
        let information_length = call.get_arg();
        let return_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WldpQueryDeviceSecurityInformation");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{information = {:?}, information_length = {:?}, return_length = {:?}}}",
            information,
            information_length,
            return_length
        );
        let res =
            api.WldpQueryDeviceSecurityInformation(information, information_length, return_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpQueryDynamicCodeTrust(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let base_image = call.get_arg();
        let image_size = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WldpQueryDynamicCodeTrust");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{file_handle = {:?}, base_image = {:?}, image_size = {:?}}}",
            file_handle,
            base_image,
            image_size
        );
        let res = api.WldpQueryDynamicCodeTrust(file_handle, base_image, image_size);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WldpSetDynamicCodeTrust(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let file_handle = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WldpSetDynamicCodeTrust");
        let _enter = span.enter();
        tracing::trace!("  args = {{file_handle = {:?}}}", file_handle);
        let res = api.WldpSetDynamicCodeTrust(file_handle);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WritePrivateProfileSectionA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}",
            lp_app_name,
            lp_string,
            lp_file_name
        );
        let res = api.WritePrivateProfileSectionA(lp_app_name, lp_string, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WritePrivateProfileSectionW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}",
            lp_app_name,
            lp_string,
            lp_file_name
        );
        let res = api.WritePrivateProfileSectionW(lp_app_name, lp_string, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WritePrivateProfileStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_string , lp_file_name );
        let res = api.WritePrivateProfileStringA(lp_app_name, lp_key_name, lp_string, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WritePrivateProfileStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}, lp_file_name = {:?}}}" , lp_app_name , lp_key_name , lp_string , lp_file_name );
        let res = api.WritePrivateProfileStringW(lp_app_name, lp_key_name, lp_string, lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStructA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WritePrivateProfileStructA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file );
        let res = api.WritePrivateProfileStructA(
            lpsz_section,
            lpsz_key,
            lp_struct,
            u_size_struct,
            sz_file,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WritePrivateProfileStructW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_section = call.get_arg();
        let lpsz_key = call.get_arg();
        let lp_struct = call.get_arg();
        let u_size_struct = call.get_arg();
        let sz_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WritePrivateProfileStructW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lpsz_section = {:?}, lpsz_key = {:?}, lp_struct = {:?}, u_size_struct = {:?}, sz_file = {:?}}}" , lpsz_section , lpsz_key , lp_struct , u_size_struct , sz_file );
        let res = api.WritePrivateProfileStructW(
            lpsz_section,
            lpsz_key,
            lp_struct,
            u_size_struct,
            sz_file,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileSectionA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteProfileSectionA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_string = {:?}}}",
            lp_app_name,
            lp_string
        );
        let res = api.WriteProfileSectionA(lp_app_name, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileSectionW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteProfileSectionW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_string = {:?}}}",
            lp_app_name,
            lp_string
        );
        let res = api.WriteProfileSectionW(lp_app_name, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteProfileStringA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}}}",
            lp_app_name,
            lp_key_name,
            lp_string
        );
        let res = api.WriteProfileStringA(lp_app_name, lp_key_name, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WriteProfileStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_app_name = call.get_arg();
        let lp_key_name = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WriteProfileStringW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_app_name = {:?}, lp_key_name = {:?}, lp_string = {:?}}}",
            lp_app_name,
            lp_key_name,
            lp_string
        );
        let res = api.WriteProfileStringW(lp_app_name, lp_key_name, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__hread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let l_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_hread");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_buffer = {:?}, l_bytes = {:?}}}",
            h_file,
            lp_buffer,
            l_bytes
        );
        let res = api._hread(h_file, lp_buffer, l_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__hwrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let l_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_hwrite");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_buffer = {:?}, l_bytes = {:?}}}",
            h_file,
            lp_buffer,
            l_bytes
        );
        let res = api._hwrite(h_file, lp_buffer, l_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lclose(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_lclose");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_file = {:?}}}", h_file);
        let res = api._lclose(h_file);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lcreat(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let i_attribute = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_lcreat");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_path_name = {:?}, i_attribute = {:?}}}",
            lp_path_name,
            i_attribute
        );
        let res = api._lcreat(lp_path_name, i_attribute);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__llseek(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let l_offset = call.get_arg();
        let i_origin = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_llseek");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, l_offset = {:?}, i_origin = {:?}}}",
            h_file,
            l_offset,
            i_origin
        );
        let res = api._llseek(h_file, l_offset, i_origin);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lopen(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_path_name = call.get_arg();
        let i_read_write = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_lopen");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_path_name = {:?}, i_read_write = {:?}}}",
            lp_path_name,
            i_read_write
        );
        let res = api._lopen(lp_path_name, i_read_write);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let u_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_lread");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_buffer = {:?}, u_bytes = {:?}}}",
            h_file,
            lp_buffer,
            u_bytes
        );
        let res = api._lread(h_file, lp_buffer, u_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk__lwrite(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::System::WindowsProgramming::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_file = call.get_arg();
        let lp_buffer = call.get_arg();
        let u_bytes = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("_lwrite");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_file = {:?}, lp_buffer = {:?}, u_bytes = {:?}}}",
            h_file,
            lp_buffer,
            u_bytes
        );
        let res = api._lwrite(h_file, lp_buffer, u_bytes);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdjustWindowRect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let dw_style = call.get_arg();
        let b_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AdjustWindowRect");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_rect = {:?}, dw_style = {:?}, b_menu = {:?}}}",
            lp_rect,
            dw_style,
            b_menu
        );
        let res = api.AdjustWindowRect(lp_rect, dw_style, b_menu);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AdjustWindowRectEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let dw_style = call.get_arg();
        let b_menu = call.get_arg();
        let dw_ex_style = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AdjustWindowRectEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_rect = {:?}, dw_style = {:?}, b_menu = {:?}, dw_ex_style = {:?}}}",
            lp_rect,
            dw_style,
            b_menu,
            dw_ex_style
        );
        let res = api.AdjustWindowRectEx(lp_rect, dw_style, b_menu, dw_ex_style);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AllowSetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AllowSetForegroundWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_process_id = {:?}}}", dw_process_id);
        let res = api.AllowSetForegroundWindow(dw_process_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AnimateWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let dw_time = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AnimateWindow");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, dw_time = {:?}, dw_flags = {:?}}}",
            h_wnd,
            dw_time,
            dw_flags
        );
        let res = api.AnimateWindow(h_wnd, dw_time, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AnyPopup(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AnyPopup");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.AnyPopup();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AppendMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AppendMenuA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}",
            h_menu,
            u_flags,
            u_id_new_item,
            lp_new_item
        );
        let res = api.AppendMenuA(h_menu, u_flags, u_id_new_item, lp_new_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_AppendMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("AppendMenuW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}",
            h_menu,
            u_flags,
            u_id_new_item,
            lp_new_item
        );
        let res = api.AppendMenuW(h_menu, u_flags, u_id_new_item, lp_new_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ArrangeIconicWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ArrangeIconicWindows");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.ArrangeIconicWindows(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BeginDeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_num_windows = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BeginDeferWindowPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{n_num_windows = {:?}}}", n_num_windows);
        let res = api.BeginDeferWindowPos(n_num_windows);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_BringWindowToTop(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("BringWindowToTop");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.BringWindowToTop(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CalculatePopupWindowPosition(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let anchor_point = call.get_arg();
        let window_size = call.get_arg();
        let flags = call.get_arg();
        let exclude_rect = call.get_arg();
        let popup_window_position = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CalculatePopupWindowPosition");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{anchor_point = {:?}, window_size = {:?}, flags = {:?}, exclude_rect = {:?}, popup_window_position = {:?}}}" , anchor_point , window_size , flags , exclude_rect , popup_window_position );
        let res = api.CalculatePopupWindowPosition(
            anchor_point,
            window_size,
            flags,
            exclude_rect,
            popup_window_position,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallMsgFilterA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let n_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CallMsgFilterA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_msg = {:?}, n_code = {:?}}}", lp_msg, n_code);
        let res = api.CallMsgFilterA(lp_msg, n_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallMsgFilterW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let n_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CallMsgFilterW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_msg = {:?}, n_code = {:?}}}", lp_msg, n_code);
        let res = api.CallMsgFilterW(lp_msg, n_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallNextHookEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hhk = call.get_arg();
        let n_code = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CallNextHookEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hhk = {:?}, n_code = {:?}, w_param = {:?}, l_param = {:?}}}",
            hhk,
            n_code,
            w_param,
            l_param
        );
        let res = api.CallNextHookEx(hhk, n_code, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallWindowProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_prev_wnd_func = call.get_arg();
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CallWindowProcA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_prev_wnd_func = {:?}, h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , lp_prev_wnd_func , h_wnd , msg , w_param , l_param );
        let res = api.CallWindowProcA(lp_prev_wnd_func, h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CallWindowProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_prev_wnd_func = call.get_arg();
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CallWindowProcW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_prev_wnd_func = {:?}, h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , lp_prev_wnd_func , h_wnd , msg , w_param , l_param );
        let res = api.CallWindowProcW(lp_prev_wnd_func, h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CancelShutdown(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CancelShutdown");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.CancelShutdown();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CascadeWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let w_how = call.get_arg();
        let lp_rect = call.get_arg();
        let c_kids = call.get_arg();
        let lp_kids = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CascadeWindows");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd_parent = {:?}, w_how = {:?}, lp_rect = {:?}, c_kids = {:?}, lp_kids = {:?}}}" , hwnd_parent , w_how , lp_rect , c_kids , lp_kids );
        let res = api.CascadeWindows(hwnd_parent, w_how, lp_rect, c_kids, lp_kids);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let cmd = call.get_arg();
        let lpsz_new_item = call.get_arg();
        let cmd_insert = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ChangeMenuA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, cmd = {:?}, lpsz_new_item = {:?}, cmd_insert = {:?}, flags = {:?}}}" , h_menu , cmd , lpsz_new_item , cmd_insert , flags );
        let res = api.ChangeMenuA(h_menu, cmd, lpsz_new_item, cmd_insert, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let cmd = call.get_arg();
        let lpsz_new_item = call.get_arg();
        let cmd_insert = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ChangeMenuW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, cmd = {:?}, lpsz_new_item = {:?}, cmd_insert = {:?}, flags = {:?}}}" , h_menu , cmd , lpsz_new_item , cmd_insert , flags );
        let res = api.ChangeMenuW(h_menu, cmd, lpsz_new_item, cmd_insert, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeWindowMessageFilter(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let message = call.get_arg();
        let dw_flag = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ChangeWindowMessageFilter");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{message = {:?}, dw_flag = {:?}}}",
            message,
            dw_flag
        );
        let res = api.ChangeWindowMessageFilter(message, dw_flag);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChangeWindowMessageFilterEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let message = call.get_arg();
        let action = call.get_arg();
        let p_change_filter_struct = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ChangeWindowMessageFilterEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd = {:?}, message = {:?}, action = {:?}, p_change_filter_struct = {:?}}}" , hwnd , message , action , p_change_filter_struct );
        let res = api.ChangeWindowMessageFilterEx(hwnd, message, action, p_change_filter_struct);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharLowerA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}}}", lpsz);
        let res = api.CharLowerA(lpsz);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharLowerBuffA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz = {:?}, cch_length = {:?}}}",
            lpsz,
            cch_length
        );
        let res = api.CharLowerBuffA(lpsz, cch_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharLowerBuffW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz = {:?}, cch_length = {:?}}}",
            lpsz,
            cch_length
        );
        let res = api.CharLowerBuffW(lpsz, cch_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharLowerW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharLowerW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}}}", lpsz);
        let res = api.CharLowerW(lpsz);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharNextA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharNextA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}}}", lpsz);
        let res = api.CharNextA(lpsz);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharNextExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let lp_current_char = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharNextExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{code_page = {:?}, lp_current_char = {:?}, dw_flags = {:?}}}",
            code_page,
            lp_current_char,
            dw_flags
        );
        let res = api.CharNextExA(code_page, lp_current_char, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharNextW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharNextW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}}}", lpsz);
        let res = api.CharNextW(lpsz);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharPrevA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_start = call.get_arg();
        let lpsz_current = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharPrevA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_start = {:?}, lpsz_current = {:?}}}",
            lpsz_start,
            lpsz_current
        );
        let res = api.CharPrevA(lpsz_start, lpsz_current);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharPrevExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let code_page = call.get_arg();
        let lp_start = call.get_arg();
        let lp_current_char = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharPrevExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{code_page = {:?}, lp_start = {:?}, lp_current_char = {:?}, dw_flags = {:?}}}" , code_page , lp_start , lp_current_char , dw_flags );
        let res = api.CharPrevExA(code_page, lp_start, lp_current_char, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharPrevW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_start = call.get_arg();
        let lpsz_current = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharPrevW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_start = {:?}, lpsz_current = {:?}}}",
            lpsz_start,
            lpsz_current
        );
        let res = api.CharPrevW(lpsz_start, lpsz_current);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharToOemA");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_src = {:?}, p_dst = {:?}}}", p_src, p_dst);
        let res = api.CharToOemA(p_src, p_dst);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharToOemBuffA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}",
            lpsz_src,
            lpsz_dst,
            cch_dst_length
        );
        let res = api.CharToOemBuffA(lpsz_src, lpsz_dst, cch_dst_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharToOemBuffW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}",
            lpsz_src,
            lpsz_dst,
            cch_dst_length
        );
        let res = api.CharToOemBuffW(lpsz_src, lpsz_dst, cch_dst_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharToOemW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharToOemW");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_src = {:?}, p_dst = {:?}}}", p_src, p_dst);
        let res = api.CharToOemW(p_src, p_dst);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharUpperA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}}}", lpsz);
        let res = api.CharUpperA(lpsz);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharUpperBuffA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz = {:?}, cch_length = {:?}}}",
            lpsz,
            cch_length
        );
        let res = api.CharUpperBuffA(lpsz, cch_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let cch_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharUpperBuffW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz = {:?}, cch_length = {:?}}}",
            lpsz,
            cch_length
        );
        let res = api.CharUpperBuffW(lpsz, cch_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CharUpperW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CharUpperW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lpsz = {:?}}}", lpsz);
        let res = api.CharUpperW(lpsz);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckMenuItem(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_check_item = call.get_arg();
        let u_check = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CheckMenuItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_id_check_item = {:?}, u_check = {:?}}}",
            h_menu,
            u_id_check_item,
            u_check
        );
        let res = api.CheckMenuItem(h_menu, u_id_check_item, u_check);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CheckMenuRadioItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hmenu = call.get_arg();
        let first = call.get_arg();
        let last = call.get_arg();
        let check = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CheckMenuRadioItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hmenu = {:?}, first = {:?}, last = {:?}, check = {:?}, flags = {:?}}}",
            hmenu,
            first,
            last,
            check,
            flags
        );
        let res = api.CheckMenuRadioItem(hmenu, first, last, check, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChildWindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ChildWindowFromPoint");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd_parent = {:?}, point = {:?}}}",
            h_wnd_parent,
            point
        );
        let res = api.ChildWindowFromPoint(h_wnd_parent, point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ChildWindowFromPointEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pt = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ChildWindowFromPointEx");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, pt = {:?}, flags = {:?}}}",
            hwnd,
            pt,
            flags
        );
        let res = api.ChildWindowFromPointEx(hwnd, pt, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ClipCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ClipCursor");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_rect = {:?}}}", lp_rect);
        let res = api.ClipCursor(lp_rect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CloseWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CloseWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.CloseWindow(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyAcceleratorTableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_accel_src = call.get_arg();
        let lp_accel_dst = call.get_arg();
        let c_accel_entries = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyAcceleratorTableA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_accel_src = {:?}, lp_accel_dst = {:?}, c_accel_entries = {:?}}}",
            h_accel_src,
            lp_accel_dst,
            c_accel_entries
        );
        let res = api.CopyAcceleratorTableA(h_accel_src, lp_accel_dst, c_accel_entries);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyAcceleratorTableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_accel_src = call.get_arg();
        let lp_accel_dst = call.get_arg();
        let c_accel_entries = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyAcceleratorTableW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_accel_src = {:?}, lp_accel_dst = {:?}, c_accel_entries = {:?}}}",
            h_accel_src,
            lp_accel_dst,
            c_accel_entries
        );
        let res = api.CopyAcceleratorTableW(h_accel_src, lp_accel_dst, c_accel_entries);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_icon = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyIcon");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_icon = {:?}}}", h_icon);
        let res = api.CopyIcon(h_icon);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CopyImage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h = call.get_arg();
        let r#type = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CopyImage");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h = {:?}, r#type = {:?}, cx = {:?}, cy = {:?}, flags = {:?}}}",
            h,
            r#type,
            cx,
            cy,
            flags
        );
        let res = api.CopyImage(h, r#type, cx, cy, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateAcceleratorTableA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let paccel = call.get_arg();
        let c_accel = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateAcceleratorTableA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{paccel = {:?}, c_accel = {:?}}}",
            paccel,
            c_accel
        );
        let res = api.CreateAcceleratorTableA(paccel, c_accel);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateAcceleratorTableW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let paccel = call.get_arg();
        let c_accel = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateAcceleratorTableW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{paccel = {:?}, c_accel = {:?}}}",
            paccel,
            c_accel
        );
        let res = api.CreateAcceleratorTableW(paccel, c_accel);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inst = call.get_arg();
        let x_hot_spot = call.get_arg();
        let y_hot_spot = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let pv_and_plane = call.get_arg();
        let pv_xor_plane = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateCursor");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_inst = {:?}, x_hot_spot = {:?}, y_hot_spot = {:?}, n_width = {:?}, n_height = {:?}, pv_and_plane = {:?}, pv_xor_plane = {:?}}}" , h_inst , x_hot_spot , y_hot_spot , n_width , n_height , pv_and_plane , pv_xor_plane );
        let res = api.CreateCursor(
            h_inst,
            x_hot_spot,
            y_hot_spot,
            n_width,
            n_height,
            pv_and_plane,
            pv_xor_plane,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogIndirectParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateDialogIndirectParamA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, lp_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.CreateDialogIndirectParamA(
            h_instance,
            lp_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogIndirectParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateDialogIndirectParamW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, lp_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.CreateDialogIndirectParamW(
            h_instance,
            lp_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateDialogParamA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.CreateDialogParamA(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateDialogParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateDialogParamW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.CreateDialogParamW(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let c_planes = call.get_arg();
        let c_bits_pixel = call.get_arg();
        let lpb_an_dbits = call.get_arg();
        let lpb_xo_rbits = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateIcon");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, n_width = {:?}, n_height = {:?}, c_planes = {:?}, c_bits_pixel = {:?}, lpb_an_dbits = {:?}, lpb_xo_rbits = {:?}}}" , h_instance , n_width , n_height , c_planes , c_bits_pixel , lpb_an_dbits , lpb_xo_rbits );
        let res = api.CreateIcon(
            h_instance,
            n_width,
            n_height,
            c_planes,
            c_bits_pixel,
            lpb_an_dbits,
            lpb_xo_rbits,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIconFromResource(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let dw_res_size = call.get_arg();
        let f_icon = call.get_arg();
        let dw_ver = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateIconFromResource");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{presbits = {:?}, dw_res_size = {:?}, f_icon = {:?}, dw_ver = {:?}}}",
            presbits,
            dw_res_size,
            f_icon,
            dw_ver
        );
        let res = api.CreateIconFromResource(presbits, dw_res_size, f_icon, dw_ver);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateIconFromResourceEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let dw_res_size = call.get_arg();
        let f_icon = call.get_arg();
        let dw_ver = call.get_arg();
        let cx_desired = call.get_arg();
        let cy_desired = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateIconFromResourceEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{presbits = {:?}, dw_res_size = {:?}, f_icon = {:?}, dw_ver = {:?}, cx_desired = {:?}, cy_desired = {:?}, flags = {:?}}}" , presbits , dw_res_size , f_icon , dw_ver , cx_desired , cy_desired , flags );
        let res = api.CreateIconFromResourceEx(
            presbits,
            dw_res_size,
            f_icon,
            dw_ver,
            cx_desired,
            cy_desired,
            flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMDIWindowA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_instance = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateMDIWindowA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_instance = {:?}, l_param = {:?}}}" , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_instance , l_param );
        let res = api.CreateMDIWindowA(
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_instance,
            l_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMDIWindowW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_instance = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateMDIWindowW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_instance = {:?}, l_param = {:?}}}" , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_instance , l_param );
        let res = api.CreateMDIWindowW(
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_instance,
            l_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.CreateMenu();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreatePopupMenu(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreatePopupMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.CreatePopupMenu();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateWindowExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_ex_style = call.get_arg();
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_menu = call.get_arg();
        let h_instance = call.get_arg();
        let lp_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateWindowExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_ex_style = {:?}, lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_menu = {:?}, h_instance = {:?}, lp_param = {:?}}}" , dw_ex_style , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_menu , h_instance , lp_param );
        let res = api.CreateWindowExA(
            dw_ex_style,
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_menu,
            h_instance,
            lp_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_CreateWindowExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_ex_style = call.get_arg();
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let dw_style = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let h_menu = call.get_arg();
        let h_instance = call.get_arg();
        let lp_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("CreateWindowExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{dw_ex_style = {:?}, lp_class_name = {:?}, lp_window_name = {:?}, dw_style = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, h_wnd_parent = {:?}, h_menu = {:?}, h_instance = {:?}, lp_param = {:?}}}" , dw_ex_style , lp_class_name , lp_window_name , dw_style , x , y , n_width , n_height , h_wnd_parent , h_menu , h_instance , lp_param );
        let res = api.CreateWindowExW(
            dw_ex_style,
            lp_class_name,
            lp_window_name,
            dw_style,
            x,
            y,
            n_width,
            n_height,
            h_wnd_parent,
            h_menu,
            h_instance,
            lp_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefDlgProcA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefDlgProcA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_dlg,
            msg,
            w_param,
            l_param
        );
        let res = api.DefDlgProcA(h_dlg, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefDlgProcW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefDlgProcW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_dlg,
            msg,
            w_param,
            l_param
        );
        let res = api.DefDlgProcW(h_dlg, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefFrameProcA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_wnd_mdi_client = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefFrameProcA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, h_wnd_mdi_client = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , h_wnd_mdi_client , u_msg , w_param , l_param );
        let res = api.DefFrameProcA(h_wnd, h_wnd_mdi_client, u_msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefFrameProcW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_wnd_mdi_client = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefFrameProcW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, h_wnd_mdi_client = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_wnd , h_wnd_mdi_client , u_msg , w_param , l_param );
        let res = api.DefFrameProcW(h_wnd, h_wnd_mdi_client, u_msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefMDIChildProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefMDIChildProcA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            u_msg,
            w_param,
            l_param
        );
        let res = api.DefMDIChildProcA(h_wnd, u_msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefMDIChildProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefMDIChildProcW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, u_msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            u_msg,
            w_param,
            l_param
        );
        let res = api.DefMDIChildProcW(h_wnd, u_msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefWindowProcA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefWindowProcA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.DefWindowProcA(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DefWindowProcW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DefWindowProcW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.DefWindowProcW(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_win_pos_info = call.get_arg();
        let h_wnd = call.get_arg();
        let h_wnd_insert_after = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeferWindowPos");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_win_pos_info = {:?}, h_wnd = {:?}, h_wnd_insert_after = {:?}, x = {:?}, y = {:?}, cx = {:?}, cy = {:?}, u_flags = {:?}}}" , h_win_pos_info , h_wnd , h_wnd_insert_after , x , y , cx , cy , u_flags );
        let res = api.DeferWindowPos(
            h_win_pos_info,
            h_wnd,
            h_wnd_insert_after,
            x,
            y,
            cx,
            cy,
            u_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeleteMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeleteMenu");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}}}",
            h_menu,
            u_position,
            u_flags
        );
        let res = api.DeleteMenu(h_menu, u_position, u_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DeregisterShellHookWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DeregisterShellHookWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{hwnd = {:?}}}", hwnd);
        let res = api.DeregisterShellHookWindow(hwnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyAcceleratorTable(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_accel = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DestroyAcceleratorTable");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_accel = {:?}}}", h_accel);
        let res = api.DestroyAcceleratorTable(h_accel);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DestroyCaret");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.DestroyCaret();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_cursor = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DestroyCursor");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_cursor = {:?}}}", h_cursor);
        let res = api.DestroyCursor(h_cursor);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_icon = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DestroyIcon");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_icon = {:?}}}", h_icon);
        let res = api.DestroyIcon(h_icon);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DestroyMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_menu = {:?}}}", h_menu);
        let res = api.DestroyMenu(h_menu);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DestroyWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DestroyWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.DestroyWindow(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxIndirectParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let h_dialog_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DialogBoxIndirectParamA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, h_dialog_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , h_dialog_template , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.DialogBoxIndirectParamA(
            h_instance,
            h_dialog_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxIndirectParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let h_dialog_template = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DialogBoxIndirectParamW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, h_dialog_template = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , h_dialog_template , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.DialogBoxIndirectParamW(
            h_instance,
            h_dialog_template,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxParamA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DialogBoxParamA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.DialogBoxParamA(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DialogBoxParamW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_template_name = call.get_arg();
        let h_wnd_parent = call.get_arg();
        let lp_dialog_func = call.get_arg();
        let dw_init_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DialogBoxParamW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_instance = {:?}, lp_template_name = {:?}, h_wnd_parent = {:?}, lp_dialog_func = {:?}, dw_init_param = {:?}}}" , h_instance , lp_template_name , h_wnd_parent , lp_dialog_func , dw_init_param );
        let res = api.DialogBoxParamW(
            h_instance,
            lp_template_name,
            h_wnd_parent,
            lp_dialog_func,
            dw_init_param,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DisableProcessWindowsGhosting(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DisableProcessWindowsGhosting");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.DisableProcessWindowsGhosting();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DispatchMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DispatchMessageA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_msg = {:?}}}", lp_msg);
        let res = api.DispatchMessageA(lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DispatchMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DispatchMessageW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_msg = {:?}}}", lp_msg);
        let res = api.DispatchMessageW(lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DragObject(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let hwnd_from = call.get_arg();
        let fmt = call.get_arg();
        let data = call.get_arg();
        let hcur = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DragObject");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd_parent = {:?}, hwnd_from = {:?}, fmt = {:?}, data = {:?}, hcur = {:?}}}" , hwnd_parent , hwnd_from , fmt , data , hcur );
        let res = api.DragObject(hwnd_parent, hwnd_from, fmt, data, hcur);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_DrawMenuBar(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("DrawMenuBar");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.DrawMenuBar(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnableMenuItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_enable_item = call.get_arg();
        let u_enable = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnableMenuItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_id_enable_item = {:?}, u_enable = {:?}}}",
            h_menu,
            u_id_enable_item,
            u_enable
        );
        let res = api.EnableMenuItem(h_menu, u_id_enable_item, u_enable);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndDeferWindowPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_win_pos_info = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EndDeferWindowPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_win_pos_info = {:?}}}", h_win_pos_info);
        let res = api.EndDeferWindowPos(h_win_pos_info);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndDialog(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EndDialog");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, n_result = {:?}}}",
            h_dlg,
            n_result
        );
        let res = api.EndDialog(h_dlg, n_result);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EndMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EndMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.EndMenu();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumChildWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumChildWindows");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd_parent = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
            h_wnd_parent,
            lp_enum_func,
            l_param
        );
        let res = api.EnumChildWindows(h_wnd_parent, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumPropsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_enum_func = {:?}}}",
            h_wnd,
            lp_enum_func
        );
        let res = api.EnumPropsA(h_wnd, lp_enum_func);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumPropsExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
            h_wnd,
            lp_enum_func,
            l_param
        );
        let res = api.EnumPropsExA(h_wnd, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumPropsExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_enum_func = {:?}, l_param = {:?}}}",
            h_wnd,
            lp_enum_func,
            l_param
        );
        let res = api.EnumPropsExW(h_wnd, lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumPropsW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_enum_func = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumPropsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_enum_func = {:?}}}",
            h_wnd,
            lp_enum_func
        );
        let res = api.EnumPropsW(h_wnd, lp_enum_func);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumThreadWindows(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_thread_id = call.get_arg();
        let lpfn = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumThreadWindows");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{dw_thread_id = {:?}, lpfn = {:?}, l_param = {:?}}}",
            dw_thread_id,
            lpfn,
            l_param
        );
        let res = api.EnumThreadWindows(dw_thread_id, lpfn, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_EnumWindows(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_enum_func = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("EnumWindows");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_enum_func = {:?}, l_param = {:?}}}",
            lp_enum_func,
            l_param
        );
        let res = api.EnumWindows(lp_enum_func, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindWindowA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_class_name = {:?}, lp_window_name = {:?}}}",
            lp_class_name,
            lp_window_name
        );
        let res = api.FindWindowA(lp_class_name, lp_window_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let h_wnd_child_after = call.get_arg();
        let lpsz_class = call.get_arg();
        let lpsz_window = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindWindowExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd_parent = {:?}, h_wnd_child_after = {:?}, lpsz_class = {:?}, lpsz_window = {:?}}}" , h_wnd_parent , h_wnd_child_after , lpsz_class , lpsz_window );
        let res = api.FindWindowExA(h_wnd_parent, h_wnd_child_after, lpsz_class, lpsz_window);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let h_wnd_child_after = call.get_arg();
        let lpsz_class = call.get_arg();
        let lpsz_window = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindWindowExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd_parent = {:?}, h_wnd_child_after = {:?}, lpsz_class = {:?}, lpsz_window = {:?}}}" , h_wnd_parent , h_wnd_child_after , lpsz_class , lpsz_window );
        let res = api.FindWindowExW(h_wnd_parent, h_wnd_child_after, lpsz_class, lpsz_window);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FindWindowW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let lp_window_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FindWindowW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_class_name = {:?}, lp_window_name = {:?}}}",
            lp_class_name,
            lp_window_name
        );
        let res = api.FindWindowW(lp_class_name, lp_window_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlashWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let b_invert = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlashWindow");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, b_invert = {:?}}}",
            h_wnd,
            b_invert
        );
        let res = api.FlashWindow(h_wnd, b_invert);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_FlashWindowEx(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pfwi = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("FlashWindowEx");
        let _enter = span.enter();
        tracing::trace!("  args = {{pfwi = {:?}}}", pfwi);
        let res = api.FlashWindowEx(pfwi);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetAltTabInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let i_item = call.get_arg();
        let pati = call.get_arg();
        let psz_item_text = call.get_arg();
        let cch_item_text = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetAltTabInfoA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd = {:?}, i_item = {:?}, pati = {:?}, psz_item_text = {:?}, cch_item_text = {:?}}}" , hwnd , i_item , pati , psz_item_text , cch_item_text );
        let res = api.GetAltTabInfoA(hwnd, i_item, pati, psz_item_text, cch_item_text);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetAltTabInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let i_item = call.get_arg();
        let pati = call.get_arg();
        let psz_item_text = call.get_arg();
        let cch_item_text = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetAltTabInfoW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd = {:?}, i_item = {:?}, pati = {:?}, psz_item_text = {:?}, cch_item_text = {:?}}}" , hwnd , i_item , pati , psz_item_text , cch_item_text );
        let res = api.GetAltTabInfoW(hwnd, i_item, pati, psz_item_text, cch_item_text);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetAncestor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let ga_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetAncestor");
        let _enter = span.enter();
        tracing::trace!("  args = {{hwnd = {:?}, ga_flags = {:?}}}", hwnd, ga_flags);
        let res = api.GetAncestor(hwnd, ga_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCaretBlinkTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCaretBlinkTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCaretBlinkTime();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCaretPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCaretPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_point = {:?}}}", lp_point);
        let res = api.GetCaretPos(lp_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassLongA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetClassLongA");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, n_index = {:?}}}", h_wnd, n_index);
        let res = api.GetClassLongA(h_wnd, n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassLongW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetClassLongW");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, n_index = {:?}}}", h_wnd, n_index);
        let res = api.GetClassLongW(h_wnd, n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassNameA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_class_name = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetClassNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_class_name = {:?}, n_max_count = {:?}}}",
            h_wnd,
            lp_class_name,
            n_max_count
        );
        let res = api.GetClassNameA(h_wnd, lp_class_name, n_max_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassNameW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_class_name = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetClassNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_class_name = {:?}, n_max_count = {:?}}}",
            h_wnd,
            lp_class_name,
            n_max_count
        );
        let res = api.GetClassNameW(h_wnd, lp_class_name, n_max_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClassWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetClassWord");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, n_index = {:?}}}", h_wnd, n_index);
        let res = api.GetClassWord(h_wnd, n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClientRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetClientRect");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, lp_rect = {:?}}}", h_wnd, lp_rect);
        let res = api.GetClientRect(h_wnd, lp_rect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetClipCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetClipCursor");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_rect = {:?}}}", lp_rect);
        let res = api.GetClipCursor(lp_rect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCursor");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetCursor();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCursorInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pci = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCursorInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{pci = {:?}}}", pci);
        let res = api.GetCursorInfo(pci);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetCursorPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetCursorPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_point = {:?}}}", lp_point);
        let res = api.GetCursorPos(lp_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDesktopWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDesktopWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetDesktopWindow();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDialogBaseUnits(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDialogBaseUnits");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetDialogBaseUnits();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgCtrlID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDlgCtrlID");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.GetDlgCtrlID(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItem(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDlgItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}}}",
            h_dlg,
            n_id_dlg_item
        );
        let res = api.GetDlgItem(h_dlg, n_id_dlg_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemInt(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_translated = call.get_arg();
        let b_signed = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDlgItemInt");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_translated = {:?}, b_signed = {:?}}}" , h_dlg , n_id_dlg_item , lp_translated , b_signed );
        let res = api.GetDlgItemInt(h_dlg, n_id_dlg_item, lp_translated, b_signed);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDlgItemTextA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}, cch_max = {:?}}}",
            h_dlg,
            n_id_dlg_item,
            lp_string,
            cch_max
        );
        let res = api.GetDlgItemTextA(h_dlg, n_id_dlg_item, lp_string, cch_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetDlgItemTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetDlgItemTextW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}, cch_max = {:?}}}",
            h_dlg,
            n_id_dlg_item,
            lp_string,
            cch_max
        );
        let res = api.GetDlgItemTextW(h_dlg, n_id_dlg_item, lp_string, cch_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetForegroundWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetForegroundWindow();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetGUIThreadInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_thread = call.get_arg();
        let pgui = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetGUIThreadInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{id_thread = {:?}, pgui = {:?}}}",
            id_thread,
            pgui
        );
        let res = api.GetGUIThreadInfo(id_thread, pgui);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetInputState(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetInputState");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetInputState();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLastActivePopup(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLastActivePopup");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.GetLastActivePopup(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetLayeredWindowAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pcr_key = call.get_arg();
        let pb_alpha = call.get_arg();
        let pdw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetLayeredWindowAttributes");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, pcr_key = {:?}, pb_alpha = {:?}, pdw_flags = {:?}}}",
            hwnd,
            pcr_key,
            pb_alpha,
            pdw_flags
        );
        let res = api.GetLayeredWindowAttributes(hwnd, pcr_key, pb_alpha, pdw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.GetMenu(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let id_object = call.get_arg();
        let id_item = call.get_arg();
        let pmbi = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuBarInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, id_object = {:?}, id_item = {:?}, pmbi = {:?}}}",
            hwnd,
            id_object,
            id_item,
            pmbi
        );
        let res = api.GetMenuBarInfo(hwnd, id_object, id_item, pmbi);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuCheckMarkDimensions(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuCheckMarkDimensions");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetMenuCheckMarkDimensions();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuDefaultItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let f_by_pos = call.get_arg();
        let gmdi_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuDefaultItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, f_by_pos = {:?}, gmdi_flags = {:?}}}",
            h_menu,
            f_by_pos,
            gmdi_flags
        );
        let res = api.GetMenuDefaultItem(h_menu, f_by_pos, gmdi_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemCount(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuItemCount");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_menu = {:?}}}", h_menu);
        let res = api.GetMenuItemCount(h_menu);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemID(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let n_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuItemID");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_menu = {:?}, n_pos = {:?}}}", h_menu, n_pos);
        let res = api.GetMenuItemID(h_menu, n_pos);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuItemRect(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let u_item = call.get_arg();
        let lprc_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuItemRect");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, h_menu = {:?}, u_item = {:?}, lprc_item = {:?}}}",
            h_wnd,
            h_menu,
            u_item,
            lprc_item
        );
        let res = api.GetMenuItemRect(h_wnd, h_menu, u_item, lprc_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuState(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuState");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_id = {:?}, u_flags = {:?}}}",
            h_menu,
            u_id,
            u_flags
        );
        let res = api.GetMenuState(h_menu, u_id, u_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuStringA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuStringA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, u_id_item = {:?}, lp_string = {:?}, cch_max = {:?}, flags = {:?}}}" , h_menu , u_id_item , lp_string , cch_max , flags );
        let res = api.GetMenuStringA(h_menu, u_id_item, lp_string, cch_max, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMenuStringW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_id_item = call.get_arg();
        let lp_string = call.get_arg();
        let cch_max = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMenuStringW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, u_id_item = {:?}, lp_string = {:?}, cch_max = {:?}, flags = {:?}}}" , h_menu , u_id_item , lp_string , cch_max , flags );
        let res = api.GetMenuStringW(h_menu, u_id_item, lp_string, cch_max, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMessageA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max );
        let res = api.GetMessageA(lp_msg, h_wnd, w_msg_filter_min, w_msg_filter_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageExtraInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMessageExtraInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetMessageExtraInfo();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessagePos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMessagePos");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetMessagePos();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMessageTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetMessageTime();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetMessageW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max );
        let res = api.GetMessageW(lp_msg, h_wnd, w_msg_filter_min, w_msg_filter_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNextDlgGroupItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let h_ctl = call.get_arg();
        let b_previous = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNextDlgGroupItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, h_ctl = {:?}, b_previous = {:?}}}",
            h_dlg,
            h_ctl,
            b_previous
        );
        let res = api.GetNextDlgGroupItem(h_dlg, h_ctl, b_previous);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetNextDlgTabItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let h_ctl = call.get_arg();
        let b_previous = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetNextDlgTabItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, h_ctl = {:?}, b_previous = {:?}}}",
            h_dlg,
            h_ctl,
            b_previous
        );
        let res = api.GetNextDlgTabItem(h_dlg, h_ctl, b_previous);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetParent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetParent");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.GetParent(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPhysicalCursorPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPhysicalCursorPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_point = {:?}}}", lp_point);
        let res = api.GetPhysicalCursorPos(lp_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetProcessDefaultLayout(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let pdw_default_layout = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetProcessDefaultLayout");
        let _enter = span.enter();
        tracing::trace!("  args = {{pdw_default_layout = {:?}}}", pdw_default_layout);
        let res = api.GetProcessDefaultLayout(pdw_default_layout);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPropA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}}}",
            h_wnd,
            lp_string
        );
        let res = api.GetPropA(h_wnd, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetPropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetPropW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}}}",
            h_wnd,
            lp_string
        );
        let res = api.GetPropW(h_wnd, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetQueueStatus(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetQueueStatus");
        let _enter = span.enter();
        tracing::trace!("  args = {{flags = {:?}}}", flags);
        let res = api.GetQueueStatus(flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let id_object = call.get_arg();
        let psbi = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetScrollBarInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, id_object = {:?}, psbi = {:?}}}",
            hwnd,
            id_object,
            psbi
        );
        let res = api.GetScrollBarInfo(hwnd, id_object, psbi);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let n_bar = call.get_arg();
        let lpsi = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetScrollInfo");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, n_bar = {:?}, lpsi = {:?}}}",
            hwnd,
            n_bar,
            lpsi
        );
        let res = api.GetScrollInfo(hwnd, n_bar, lpsi);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_bar = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetScrollPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, n_bar = {:?}}}", h_wnd, n_bar);
        let res = api.GetScrollPos(h_wnd, n_bar);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetScrollRange(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_bar = call.get_arg();
        let lp_min_pos = call.get_arg();
        let lp_max_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetScrollRange");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_bar = {:?}, lp_min_pos = {:?}, lp_max_pos = {:?}}}",
            h_wnd,
            n_bar,
            lp_min_pos,
            lp_max_pos
        );
        let res = api.GetScrollRange(h_wnd, n_bar, lp_min_pos, lp_max_pos);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetShellWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetShellWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.GetShellWindow();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSubMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let n_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSubMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_menu = {:?}, n_pos = {:?}}}", h_menu, n_pos);
        let res = api.GetSubMenu(h_menu, n_pos);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSysColor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSysColor");
        let _enter = span.enter();
        tracing::trace!("  args = {{n_index = {:?}}}", n_index);
        let res = api.GetSysColor(n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let b_revert = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemMenu");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, b_revert = {:?}}}",
            h_wnd,
            b_revert
        );
        let res = api.GetSystemMenu(h_wnd, b_revert);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetSystemMetrics(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetSystemMetrics");
        let _enter = span.enter();
        tracing::trace!("  args = {{n_index = {:?}}}", n_index);
        let res = api.GetSystemMetrics(n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTitleBarInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pti = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTitleBarInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{hwnd = {:?}, pti = {:?}}}", hwnd, pti);
        let res = api.GetTitleBarInfo(hwnd, pti);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetTopWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetTopWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.GetTopWindow(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_cmd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, u_cmd = {:?}}}", h_wnd, u_cmd);
        let res = api.GetWindow(h_wnd, u_cmd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowDisplayAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let pdw_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowDisplayAffinity");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, pdw_affinity = {:?}}}",
            h_wnd,
            pdw_affinity
        );
        let res = api.GetWindowDisplayAffinity(h_wnd, pdw_affinity);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowInfo(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let pwi = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{hwnd = {:?}, pwi = {:?}}}", hwnd, pwi);
        let res = api.GetWindowInfo(hwnd, pwi);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowLongA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowLongA");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, n_index = {:?}}}", h_wnd, n_index);
        let res = api.GetWindowLongA(h_wnd, n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowLongW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowLongW");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, n_index = {:?}}}", h_wnd, n_index);
        let res = api.GetWindowLongW(h_wnd, n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowModuleFileNameA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_file_name = call.get_arg();
        let cch_file_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowModuleFileNameA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, psz_file_name = {:?}, cch_file_name_max = {:?}}}",
            hwnd,
            psz_file_name,
            cch_file_name_max
        );
        let res = api.GetWindowModuleFileNameA(hwnd, psz_file_name, cch_file_name_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowModuleFileNameW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let psz_file_name = call.get_arg();
        let cch_file_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowModuleFileNameW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, psz_file_name = {:?}, cch_file_name_max = {:?}}}",
            hwnd,
            psz_file_name,
            cch_file_name_max
        );
        let res = api.GetWindowModuleFileNameW(hwnd, psz_file_name, cch_file_name_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowPlacement(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lpwndpl = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowPlacement");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, lpwndpl = {:?}}}", h_wnd, lpwndpl);
        let res = api.GetWindowPlacement(h_wnd, lpwndpl);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowRect");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, lp_rect = {:?}}}", h_wnd, lp_rect);
        let res = api.GetWindowRect(h_wnd, lp_rect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowTextA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}, n_max_count = {:?}}}",
            h_wnd,
            lp_string,
            n_max_count
        );
        let res = api.GetWindowTextA(h_wnd, lp_string, n_max_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextLengthA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowTextLengthA");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.GetWindowTextLengthA(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextLengthW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowTextLengthW");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.GetWindowTextLengthW(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let n_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowTextW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}, n_max_count = {:?}}}",
            h_wnd,
            lp_string,
            n_max_count
        );
        let res = api.GetWindowTextW(h_wnd, lp_string, n_max_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowThreadProcessId(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lpdw_process_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowThreadProcessId");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lpdw_process_id = {:?}}}",
            h_wnd,
            lpdw_process_id
        );
        let res = api.GetWindowThreadProcessId(h_wnd, lpdw_process_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_GetWindowWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("GetWindowWord");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, n_index = {:?}}}", h_wnd, n_index);
        let res = api.GetWindowWord(h_wnd, n_index);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HideCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HideCaret");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.HideCaret(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_HiliteMenuItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let u_id_hilite_item = call.get_arg();
        let u_hilite = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("HiliteMenuItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, h_menu = {:?}, u_id_hilite_item = {:?}, u_hilite = {:?}}}",
            h_wnd,
            h_menu,
            u_id_hilite_item,
            u_hilite
        );
        let res = api.HiliteMenuItem(h_wnd, h_menu, u_id_hilite_item, u_hilite);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InSendMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InSendMessage");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.InSendMessage();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InSendMessageEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_reserved = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InSendMessageEx");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_reserved = {:?}}}", lp_reserved);
        let res = api.InSendMessageEx(lp_reserved);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InheritWindowMonitor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let hwnd_inherit = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InheritWindowMonitor");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, hwnd_inherit = {:?}}}",
            hwnd,
            hwnd_inherit
        );
        let res = api.InheritWindowMonitor(hwnd, hwnd_inherit);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InsertMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InsertMenuA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_menu , u_position , u_flags , u_id_new_item , lp_new_item );
        let res = api.InsertMenuA(h_menu, u_position, u_flags, u_id_new_item, lp_new_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InsertMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InsertMenuW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_menu , u_position , u_flags , u_id_new_item , lp_new_item );
        let res = api.InsertMenuW(h_menu, u_position, u_flags, u_id_new_item, lp_new_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_InternalGetWindowText(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let p_string = call.get_arg();
        let cch_max_count = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("InternalGetWindowText");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, p_string = {:?}, cch_max_count = {:?}}}",
            h_wnd,
            p_string,
            cch_max_count
        );
        let res = api.InternalGetWindowText(h_wnd, p_string, cch_max_count);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsCharAlphaA");
        let _enter = span.enter();
        tracing::trace!("  args = {{ch = {:?}}}", ch);
        let res = api.IsCharAlphaA(ch);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaNumericA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsCharAlphaNumericA");
        let _enter = span.enter();
        tracing::trace!("  args = {{ch = {:?}}}", ch);
        let res = api.IsCharAlphaNumericA(ch);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaNumericW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsCharAlphaNumericW");
        let _enter = span.enter();
        tracing::trace!("  args = {{ch = {:?}}}", ch);
        let res = api.IsCharAlphaNumericW(ch);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharAlphaW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsCharAlphaW");
        let _enter = span.enter();
        tracing::trace!("  args = {{ch = {:?}}}", ch);
        let res = api.IsCharAlphaW(ch);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharLowerA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsCharLowerA");
        let _enter = span.enter();
        tracing::trace!("  args = {{ch = {:?}}}", ch);
        let res = api.IsCharLowerA(ch);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharUpperA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsCharUpperA");
        let _enter = span.enter();
        tracing::trace!("  args = {{ch = {:?}}}", ch);
        let res = api.IsCharUpperA(ch);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsCharUpperW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ch = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsCharUpperW");
        let _enter = span.enter();
        tracing::trace!("  args = {{ch = {:?}}}", ch);
        let res = api.IsCharUpperW(ch);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsChild(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_parent = call.get_arg();
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsChild");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd_parent = {:?}, h_wnd = {:?}}}",
            h_wnd_parent,
            h_wnd
        );
        let res = api.IsChild(h_wnd_parent, h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDialogMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsDialogMessageA");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_dlg = {:?}, lp_msg = {:?}}}", h_dlg, lp_msg);
        let res = api.IsDialogMessageA(h_dlg, lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsDialogMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsDialogMessageW");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_dlg = {:?}, lp_msg = {:?}}}", h_dlg, lp_msg);
        let res = api.IsDialogMessageW(h_dlg, lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsGUIThread(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let b_convert = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsGUIThread");
        let _enter = span.enter();
        tracing::trace!("  args = {{b_convert = {:?}}}", b_convert);
        let res = api.IsGUIThread(b_convert);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsHungAppWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsHungAppWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{hwnd = {:?}}}", hwnd);
        let res = api.IsHungAppWindow(hwnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsIconic(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsIconic");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.IsIconic(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_menu = {:?}}}", h_menu);
        let res = api.IsMenu(h_menu);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsProcessDPIAware(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsProcessDPIAware");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.IsProcessDPIAware();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.IsWindow(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWindowUnicode(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsWindowUnicode");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.IsWindowUnicode(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWindowVisible(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsWindowVisible");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.IsWindowVisible(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsWow64Message(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsWow64Message");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.IsWow64Message();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_IsZoomed(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("IsZoomed");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.IsZoomed(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_KillTimer(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let u_id_event = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("KillTimer");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, u_id_event = {:?}}}",
            h_wnd,
            u_id_event
        );
        let res = api.KillTimer(h_wnd, u_id_event);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadAcceleratorsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_table_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadAcceleratorsA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_table_name = {:?}}}",
            h_instance,
            lp_table_name
        );
        let res = api.LoadAcceleratorsA(h_instance, lp_table_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadAcceleratorsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_table_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadAcceleratorsW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_table_name = {:?}}}",
            h_instance,
            lp_table_name
        );
        let res = api.LoadAcceleratorsW(h_instance, lp_table_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_cursor_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadCursorA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_cursor_name = {:?}}}",
            h_instance,
            lp_cursor_name
        );
        let res = api.LoadCursorA(h_instance, lp_cursor_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorFromFileA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadCursorFromFileA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.LoadCursorFromFileA(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorFromFileW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_file_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadCursorFromFileW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_file_name = {:?}}}", lp_file_name);
        let res = api.LoadCursorFromFileW(lp_file_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadCursorW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_cursor_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadCursorW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_cursor_name = {:?}}}",
            h_instance,
            lp_cursor_name
        );
        let res = api.LoadCursorW(h_instance, lp_cursor_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadIconA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_icon_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadIconA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_icon_name = {:?}}}",
            h_instance,
            lp_icon_name
        );
        let res = api.LoadIconA(h_instance, lp_icon_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadIconW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_icon_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadIconW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_icon_name = {:?}}}",
            h_instance,
            lp_icon_name
        );
        let res = api.LoadIconW(h_instance, lp_icon_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadImageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inst = call.get_arg();
        let name = call.get_arg();
        let r#type = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let fu_load = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadImageA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_inst = {:?}, name = {:?}, r#type = {:?}, cx = {:?}, cy = {:?}, fu_load = {:?}}}" , h_inst , name , r#type , cx , cy , fu_load );
        let res = api.LoadImageA(h_inst, name, r#type, cx, cy, fu_load);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadImageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_inst = call.get_arg();
        let name = call.get_arg();
        let r#type = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let fu_load = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadImageW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_inst = {:?}, name = {:?}, r#type = {:?}, cx = {:?}, cy = {:?}, fu_load = {:?}}}" , h_inst , name , r#type , cx , cy , fu_load );
        let res = api.LoadImageW(h_inst, name, r#type, cx, cy, fu_load);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_menu_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadMenuA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_menu_name = {:?}}}",
            h_instance,
            lp_menu_name
        );
        let res = api.LoadMenuA(h_instance, lp_menu_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuIndirectA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_menu_template = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadMenuIndirectA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_menu_template = {:?}}}", lp_menu_template);
        let res = api.LoadMenuIndirectA(lp_menu_template);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuIndirectW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_menu_template = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadMenuIndirectW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_menu_template = {:?}}}", lp_menu_template);
        let res = api.LoadMenuIndirectW(lp_menu_template);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let lp_menu_name = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadMenuW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, lp_menu_name = {:?}}}",
            h_instance,
            lp_menu_name
        );
        let res = api.LoadMenuW(h_instance, lp_menu_name);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadStringA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let u_id = call.get_arg();
        let lp_buffer = call.get_arg();
        let cch_buffer_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadStringA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, u_id = {:?}, lp_buffer = {:?}, cch_buffer_max = {:?}}}",
            h_instance,
            u_id,
            lp_buffer,
            cch_buffer_max
        );
        let res = api.LoadStringA(h_instance, u_id, lp_buffer, cch_buffer_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LoadStringW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_instance = call.get_arg();
        let u_id = call.get_arg();
        let lp_buffer = call.get_arg();
        let cch_buffer_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LoadStringW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_instance = {:?}, u_id = {:?}, lp_buffer = {:?}, cch_buffer_max = {:?}}}",
            h_instance,
            u_id,
            lp_buffer,
            cch_buffer_max
        );
        let res = api.LoadStringW(h_instance, u_id, lp_buffer, cch_buffer_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LockSetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_lock_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LockSetForegroundWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{u_lock_code = {:?}}}", u_lock_code);
        let res = api.LockSetForegroundWindow(u_lock_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LogicalToPhysicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LogicalToPhysicalPoint");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_point = {:?}}}",
            h_wnd,
            lp_point
        );
        let res = api.LogicalToPhysicalPoint(h_wnd, lp_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LookupIconIdFromDirectory(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let f_icon = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LookupIconIdFromDirectory");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{presbits = {:?}, f_icon = {:?}}}",
            presbits,
            f_icon
        );
        let res = api.LookupIconIdFromDirectory(presbits, f_icon);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_LookupIconIdFromDirectoryEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let presbits = call.get_arg();
        let f_icon = call.get_arg();
        let cx_desired = call.get_arg();
        let cy_desired = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("LookupIconIdFromDirectoryEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{presbits = {:?}, f_icon = {:?}, cx_desired = {:?}, cy_desired = {:?}, flags = {:?}}}" , presbits , f_icon , cx_desired , cy_desired , flags );
        let res = api.LookupIconIdFromDirectoryEx(presbits, f_icon, cx_desired, cy_desired, flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MapDialogRect(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let lp_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MapDialogRect");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_dlg = {:?}, lp_rect = {:?}}}", h_dlg, lp_rect);
        let res = api.MapDialogRect(h_dlg, lp_rect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MenuItemFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let pt_screen = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MenuItemFromPoint");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, h_menu = {:?}, pt_screen = {:?}}}",
            h_wnd,
            h_menu,
            pt_screen
        );
        let res = api.MenuItemFromPoint(h_wnd, h_menu, pt_screen);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MessageBoxA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}}}",
            h_wnd,
            lp_text,
            lp_caption,
            u_type
        );
        let res = api.MessageBoxA(h_wnd, lp_text, lp_caption, u_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxExA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let w_language_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MessageBoxExA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}, w_language_id = {:?}}}" , h_wnd , lp_text , lp_caption , u_type , w_language_id );
        let res = api.MessageBoxExA(h_wnd, lp_text, lp_caption, u_type, w_language_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxExW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let w_language_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MessageBoxExW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}, w_language_id = {:?}}}" , h_wnd , lp_text , lp_caption , u_type , w_language_id );
        let res = api.MessageBoxExW(h_wnd, lp_text, lp_caption, u_type, w_language_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MessageBoxW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_text = call.get_arg();
        let lp_caption = call.get_arg();
        let u_type = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MessageBoxW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_text = {:?}, lp_caption = {:?}, u_type = {:?}}}",
            h_wnd,
            lp_text,
            lp_caption,
            u_type
        );
        let res = api.MessageBoxW(h_wnd, lp_text, lp_caption, u_type);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ModifyMenuA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mnu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ModifyMenuA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_mnu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_mnu , u_position , u_flags , u_id_new_item , lp_new_item );
        let res = api.ModifyMenuA(h_mnu, u_position, u_flags, u_id_new_item, lp_new_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ModifyMenuW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_mnu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let u_id_new_item = call.get_arg();
        let lp_new_item = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ModifyMenuW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_mnu = {:?}, u_position = {:?}, u_flags = {:?}, u_id_new_item = {:?}, lp_new_item = {:?}}}" , h_mnu , u_position , u_flags , u_id_new_item , lp_new_item );
        let res = api.ModifyMenuW(h_mnu, u_position, u_flags, u_id_new_item, lp_new_item);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MoveWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_width = call.get_arg();
        let n_height = call.get_arg();
        let b_repaint = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MoveWindow");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, x = {:?}, y = {:?}, n_width = {:?}, n_height = {:?}, b_repaint = {:?}}}" , h_wnd , x , y , n_width , n_height , b_repaint );
        let res = api.MoveWindow(h_wnd, x, y, n_width, n_height, b_repaint);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MsgWaitForMultipleObjects(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let p_handles = call.get_arg();
        let f_wait_all = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let dw_wake_mask = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MsgWaitForMultipleObjects");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{n_count = {:?}, p_handles = {:?}, f_wait_all = {:?}, dw_milliseconds = {:?}, dw_wake_mask = {:?}}}" , n_count , p_handles , f_wait_all , dw_milliseconds , dw_wake_mask );
        let res = api.MsgWaitForMultipleObjects(
            n_count,
            p_handles,
            f_wait_all,
            dw_milliseconds,
            dw_wake_mask,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_MsgWaitForMultipleObjectsEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_count = call.get_arg();
        let p_handles = call.get_arg();
        let dw_milliseconds = call.get_arg();
        let dw_wake_mask = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("MsgWaitForMultipleObjectsEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{n_count = {:?}, p_handles = {:?}, dw_milliseconds = {:?}, dw_wake_mask = {:?}, dw_flags = {:?}}}" , n_count , p_handles , dw_milliseconds , dw_wake_mask , dw_flags );
        let res = api.MsgWaitForMultipleObjectsEx(
            n_count,
            p_handles,
            dw_milliseconds,
            dw_wake_mask,
            dw_flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OemToCharA");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_src = {:?}, p_dst = {:?}}}", p_src, p_dst);
        let res = api.OemToCharA(p_src, p_dst);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharBuffA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OemToCharBuffA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}",
            lpsz_src,
            lpsz_dst,
            cch_dst_length
        );
        let res = api.OemToCharBuffA(lpsz_src, lpsz_dst, cch_dst_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharBuffW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lpsz_src = call.get_arg();
        let lpsz_dst = call.get_arg();
        let cch_dst_length = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OemToCharBuffW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lpsz_src = {:?}, lpsz_dst = {:?}, cch_dst_length = {:?}}}",
            lpsz_src,
            lpsz_dst,
            cch_dst_length
        );
        let res = api.OemToCharBuffW(lpsz_src, lpsz_dst, cch_dst_length);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OemToCharW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let p_src = call.get_arg();
        let p_dst = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OemToCharW");
        let _enter = span.enter();
        tracing::trace!("  args = {{p_src = {:?}, p_dst = {:?}}}", p_src, p_dst);
        let res = api.OemToCharW(p_src, p_dst);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_OpenIcon(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("OpenIcon");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.OpenIcon(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let w_remove_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PeekMessageA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}, w_remove_msg = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max , w_remove_msg );
        let res = api.PeekMessageA(
            lp_msg,
            h_wnd,
            w_msg_filter_min,
            w_msg_filter_max,
            w_remove_msg,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PeekMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let h_wnd = call.get_arg();
        let w_msg_filter_min = call.get_arg();
        let w_msg_filter_max = call.get_arg();
        let w_remove_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PeekMessageW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{lp_msg = {:?}, h_wnd = {:?}, w_msg_filter_min = {:?}, w_msg_filter_max = {:?}, w_remove_msg = {:?}}}" , lp_msg , h_wnd , w_msg_filter_min , w_msg_filter_max , w_remove_msg );
        let res = api.PeekMessageW(
            lp_msg,
            h_wnd,
            w_msg_filter_min,
            w_msg_filter_max,
            w_remove_msg,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PhysicalToLogicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PhysicalToLogicalPoint");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_point = {:?}}}",
            h_wnd,
            lp_point
        );
        let res = api.PhysicalToLogicalPoint(h_wnd, lp_point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PostMessageA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.PostMessageA(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PostMessageW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.PostMessageW(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostQuitMessage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_exit_code = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PostQuitMessage");
        let _enter = span.enter();
        tracing::trace!("  args = {{n_exit_code = {:?}}}", n_exit_code);
        let res = api.PostQuitMessage(n_exit_code);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostThreadMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_thread = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PostThreadMessageA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{id_thread = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            id_thread,
            msg,
            w_param,
            l_param
        );
        let res = api.PostThreadMessageA(id_thread, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PostThreadMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_thread = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PostThreadMessageW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{id_thread = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            id_thread,
            msg,
            w_param,
            l_param
        );
        let res = api.PostThreadMessageW(id_thread, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrivateExtractIconsA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let sz_file_name = call.get_arg();
        let n_icon_index = call.get_arg();
        let cx_icon = call.get_arg();
        let cy_icon = call.get_arg();
        let phicon = call.get_arg();
        let piconid = call.get_arg();
        let n_icons = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrivateExtractIconsA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{sz_file_name = {:?}, n_icon_index = {:?}, cx_icon = {:?}, cy_icon = {:?}, phicon = {:?}, piconid = {:?}, n_icons = {:?}, flags = {:?}}}" , sz_file_name , n_icon_index , cx_icon , cy_icon , phicon , piconid , n_icons , flags );
        let res = api.PrivateExtractIconsA(
            sz_file_name,
            n_icon_index,
            cx_icon,
            cy_icon,
            phicon,
            piconid,
            n_icons,
            flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_PrivateExtractIconsW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let sz_file_name = call.get_arg();
        let n_icon_index = call.get_arg();
        let cx_icon = call.get_arg();
        let cy_icon = call.get_arg();
        let phicon = call.get_arg();
        let piconid = call.get_arg();
        let n_icons = call.get_arg();
        let flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("PrivateExtractIconsW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{sz_file_name = {:?}, n_icon_index = {:?}, cx_icon = {:?}, cy_icon = {:?}, phicon = {:?}, piconid = {:?}, n_icons = {:?}, flags = {:?}}}" , sz_file_name , n_icon_index , cx_icon , cy_icon , phicon , piconid , n_icons , flags );
        let res = api.PrivateExtractIconsW(
            sz_file_name,
            n_icon_index,
            cx_icon,
            cy_icon,
            phicon,
            piconid,
            n_icons,
            flags,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RealChildWindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let pt_parent_client_coords = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RealChildWindowFromPoint");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd_parent = {:?}, pt_parent_client_coords = {:?}}}",
            hwnd_parent,
            pt_parent_client_coords
        );
        let res = api.RealChildWindowFromPoint(hwnd_parent, pt_parent_client_coords);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RealGetWindowClassA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let ptsz_class_name = call.get_arg();
        let cch_class_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RealGetWindowClassA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, ptsz_class_name = {:?}, cch_class_name_max = {:?}}}",
            hwnd,
            ptsz_class_name,
            cch_class_name_max
        );
        let res = api.RealGetWindowClassA(hwnd, ptsz_class_name, cch_class_name_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RealGetWindowClassW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let ptsz_class_name = call.get_arg();
        let cch_class_name_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RealGetWindowClassW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, ptsz_class_name = {:?}, cch_class_name_max = {:?}}}",
            hwnd,
            ptsz_class_name,
            cch_class_name_max
        );
        let res = api.RealGetWindowClassW(hwnd, ptsz_class_name, cch_class_name_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterShellHookWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RegisterShellHookWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{hwnd = {:?}}}", hwnd);
        let res = api.RegisterShellHookWindow(hwnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterWindowMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RegisterWindowMessageA");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_string = {:?}}}", lp_string);
        let res = api.RegisterWindowMessageA(lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RegisterWindowMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RegisterWindowMessageW");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_string = {:?}}}", lp_string);
        let res = api.RegisterWindowMessageW(lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemoveMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_position = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemoveMenu");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_position = {:?}, u_flags = {:?}}}",
            h_menu,
            u_position,
            u_flags
        );
        let res = api.RemoveMenu(h_menu, u_position, u_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemovePropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemovePropA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}}}",
            h_wnd,
            lp_string
        );
        let res = api.RemovePropA(h_wnd, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_RemovePropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("RemovePropW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}}}",
            h_wnd,
            lp_string
        );
        let res = api.RemovePropW(h_wnd, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ReplyMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let l_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ReplyMessage");
        let _enter = span.enter();
        tracing::trace!("  args = {{l_result = {:?}}}", l_result);
        let res = api.ReplyMessage(l_result);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ScrollWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let x_amount = call.get_arg();
        let y_amount = call.get_arg();
        let lp_rect = call.get_arg();
        let lp_clip_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ScrollWindow");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, x_amount = {:?}, y_amount = {:?}, lp_rect = {:?}, lp_clip_rect = {:?}}}" , h_wnd , x_amount , y_amount , lp_rect , lp_clip_rect );
        let res = api.ScrollWindow(h_wnd, x_amount, y_amount, lp_rect, lp_clip_rect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendDlgItemMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendDlgItemMessageA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_dlg , n_id_dlg_item , msg , w_param , l_param );
        let res = api.SendDlgItemMessageA(h_dlg, n_id_dlg_item, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendDlgItemMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendDlgItemMessageW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}" , h_dlg , n_id_dlg_item , msg , w_param , l_param );
        let res = api.SendDlgItemMessageW(h_dlg, n_id_dlg_item, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendMessageA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.SendMessageA(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageCallbackA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let lp_result_call_back = call.get_arg();
        let dw_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendMessageCallbackA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, lp_result_call_back = {:?}, dw_data = {:?}}}" , h_wnd , msg , w_param , l_param , lp_result_call_back , dw_data );
        let res =
            api.SendMessageCallbackA(h_wnd, msg, w_param, l_param, lp_result_call_back, dw_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageCallbackW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let lp_result_call_back = call.get_arg();
        let dw_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendMessageCallbackW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, lp_result_call_back = {:?}, dw_data = {:?}}}" , h_wnd , msg , w_param , l_param , lp_result_call_back , dw_data );
        let res =
            api.SendMessageCallbackW(h_wnd, msg, w_param, l_param, lp_result_call_back, dw_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageTimeoutA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let fu_flags = call.get_arg();
        let u_timeout = call.get_arg();
        let lpdw_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendMessageTimeoutA");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, fu_flags = {:?}, u_timeout = {:?}, lpdw_result = {:?}}}" , h_wnd , msg , w_param , l_param , fu_flags , u_timeout , lpdw_result );
        let res = api.SendMessageTimeoutA(
            h_wnd,
            msg,
            w_param,
            l_param,
            fu_flags,
            u_timeout,
            lpdw_result,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageTimeoutW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let fu_flags = call.get_arg();
        let u_timeout = call.get_arg();
        let lpdw_result = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendMessageTimeoutW");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}, fu_flags = {:?}, u_timeout = {:?}, lpdw_result = {:?}}}" , h_wnd , msg , w_param , l_param , fu_flags , u_timeout , lpdw_result );
        let res = api.SendMessageTimeoutW(
            h_wnd,
            msg,
            w_param,
            l_param,
            fu_flags,
            u_timeout,
            lpdw_result,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendMessageW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendMessageW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.SendMessageW(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendNotifyMessageA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendNotifyMessageA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.SendNotifyMessageA(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SendNotifyMessageW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let msg = call.get_arg();
        let w_param = call.get_arg();
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SendNotifyMessageW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, msg = {:?}, w_param = {:?}, l_param = {:?}}}",
            h_wnd,
            msg,
            w_param,
            l_param
        );
        let res = api.SendNotifyMessageW(h_wnd, msg, w_param, l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCaretBlinkTime(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let u_m_seconds = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCaretBlinkTime");
        let _enter = span.enter();
        tracing::trace!("  args = {{u_m_seconds = {:?}}}", u_m_seconds);
        let res = api.SetCaretBlinkTime(u_m_seconds);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCaretPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let x = call.get_arg();
        let y = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCaretPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{x = {:?}, y = {:?}}}", x, y);
        let res = api.SetCaretPos(x, y);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetClassLongA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetClassLongA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
            h_wnd,
            n_index,
            dw_new_long
        );
        let res = api.SetClassLongA(h_wnd, n_index, dw_new_long);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetClassLongW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetClassLongW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
            h_wnd,
            n_index,
            dw_new_long
        );
        let res = api.SetClassLongW(h_wnd, n_index, dw_new_long);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetClassWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let w_new_word = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetClassWord");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_index = {:?}, w_new_word = {:?}}}",
            h_wnd,
            n_index,
            w_new_word
        );
        let res = api.SetClassWord(h_wnd, n_index, w_new_word);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCoalescableTimer(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_id_event = call.get_arg();
        let u_elapse = call.get_arg();
        let lp_timer_func = call.get_arg();
        let u_tolerance_delay = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCoalescableTimer");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, n_id_event = {:?}, u_elapse = {:?}, lp_timer_func = {:?}, u_tolerance_delay = {:?}}}" , h_wnd , n_id_event , u_elapse , lp_timer_func , u_tolerance_delay );
        let res = api.SetCoalescableTimer(
            h_wnd,
            n_id_event,
            u_elapse,
            lp_timer_func,
            u_tolerance_delay,
        );
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_cursor = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCursor");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_cursor = {:?}}}", h_cursor);
        let res = api.SetCursor(h_cursor);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetCursorPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let x = call.get_arg();
        let y = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetCursorPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{x = {:?}, y = {:?}}}", x, y);
        let res = api.SetCursorPos(x, y);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDebugErrorLevel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_level = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetDebugErrorLevel");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_level = {:?}}}", dw_level);
        let res = api.SetDebugErrorLevel(dw_level);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemInt(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let u_value = call.get_arg();
        let b_signed = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetDlgItemInt");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, u_value = {:?}, b_signed = {:?}}}",
            h_dlg,
            n_id_dlg_item,
            u_value,
            b_signed
        );
        let res = api.SetDlgItemInt(h_dlg, n_id_dlg_item, u_value, b_signed);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetDlgItemTextA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}}}",
            h_dlg,
            n_id_dlg_item,
            lp_string
        );
        let res = api.SetDlgItemTextA(h_dlg, n_id_dlg_item, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetDlgItemTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_dlg = call.get_arg();
        let n_id_dlg_item = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetDlgItemTextW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_dlg = {:?}, n_id_dlg_item = {:?}, lp_string = {:?}}}",
            h_dlg,
            n_id_dlg_item,
            lp_string
        );
        let res = api.SetDlgItemTextW(h_dlg, n_id_dlg_item, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetForegroundWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetForegroundWindow");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.SetForegroundWindow(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetLayeredWindowAttributes(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let cr_key = call.get_arg();
        let b_alpha = call.get_arg();
        let dw_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetLayeredWindowAttributes");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, cr_key = {:?}, b_alpha = {:?}, dw_flags = {:?}}}",
            hwnd,
            cr_key,
            b_alpha,
            dw_flags
        );
        let res = api.SetLayeredWindowAttributes(hwnd, cr_key, b_alpha, dw_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMenu(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_menu = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetMenu");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, h_menu = {:?}}}", h_wnd, h_menu);
        let res = api.SetMenu(h_wnd, h_menu);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMenuDefaultItem(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_item = call.get_arg();
        let f_by_pos = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetMenuDefaultItem");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_menu = {:?}, u_item = {:?}, f_by_pos = {:?}}}",
            h_menu,
            u_item,
            f_by_pos
        );
        let res = api.SetMenuDefaultItem(h_menu, u_item, f_by_pos);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMessageExtraInfo(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let l_param = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetMessageExtraInfo");
        let _enter = span.enter();
        tracing::trace!("  args = {{l_param = {:?}}}", l_param);
        let res = api.SetMessageExtraInfo(l_param);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetMessageQueue(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let c_messages_max = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetMessageQueue");
        let _enter = span.enter();
        tracing::trace!("  args = {{c_messages_max = {:?}}}", c_messages_max);
        let res = api.SetMessageQueue(c_messages_max);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetParent(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_child = call.get_arg();
        let h_wnd_new_parent = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetParent");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd_child = {:?}, h_wnd_new_parent = {:?}}}",
            h_wnd_child,
            h_wnd_new_parent
        );
        let res = api.SetParent(h_wnd_child, h_wnd_new_parent);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPhysicalCursorPos(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let x = call.get_arg();
        let y = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetPhysicalCursorPos");
        let _enter = span.enter();
        tracing::trace!("  args = {{x = {:?}, y = {:?}}}", x, y);
        let res = api.SetPhysicalCursorPos(x, y);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDPIAware(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessDPIAware");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.SetProcessDPIAware();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetProcessDefaultLayout(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let dw_default_layout = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetProcessDefaultLayout");
        let _enter = span.enter();
        tracing::trace!("  args = {{dw_default_layout = {:?}}}", dw_default_layout);
        let res = api.SetProcessDefaultLayout(dw_default_layout);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPropA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let h_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetPropA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}, h_data = {:?}}}",
            h_wnd,
            lp_string,
            h_data
        );
        let res = api.SetPropA(h_wnd, lp_string, h_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetPropW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let h_data = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetPropW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}, h_data = {:?}}}",
            h_wnd,
            lp_string,
            h_data
        );
        let res = api.SetPropW(h_wnd, lp_string, h_data);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSysColors(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let c_elements = call.get_arg();
        let lpa_elements = call.get_arg();
        let lpa_rgb_values = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetSysColors");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{c_elements = {:?}, lpa_elements = {:?}, lpa_rgb_values = {:?}}}",
            c_elements,
            lpa_elements,
            lpa_rgb_values
        );
        let res = api.SetSysColors(c_elements, lpa_elements, lpa_rgb_values);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetSystemCursor(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hcur = call.get_arg();
        let id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetSystemCursor");
        let _enter = span.enter();
        tracing::trace!("  args = {{hcur = {:?}, id = {:?}}}", hcur, id);
        let res = api.SetSystemCursor(hcur, id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetTimer(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_id_event = call.get_arg();
        let u_elapse = call.get_arg();
        let lp_timer_func = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetTimer");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_id_event = {:?}, u_elapse = {:?}, lp_timer_func = {:?}}}",
            h_wnd,
            n_id_event,
            u_elapse,
            lp_timer_func
        );
        let res = api.SetTimer(h_wnd, n_id_event, u_elapse, lp_timer_func);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowDisplayAffinity(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let dw_affinity = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowDisplayAffinity");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, dw_affinity = {:?}}}",
            h_wnd,
            dw_affinity
        );
        let res = api.SetWindowDisplayAffinity(h_wnd, dw_affinity);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowLongA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowLongA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
            h_wnd,
            n_index,
            dw_new_long
        );
        let res = api.SetWindowLongA(h_wnd, n_index, dw_new_long);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowLongW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let dw_new_long = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowLongW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_index = {:?}, dw_new_long = {:?}}}",
            h_wnd,
            n_index,
            dw_new_long
        );
        let res = api.SetWindowLongW(h_wnd, n_index, dw_new_long);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowPlacement(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lpwndpl = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowPlacement");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, lpwndpl = {:?}}}", h_wnd, lpwndpl);
        let res = api.SetWindowPlacement(h_wnd, lpwndpl);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowPos(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_wnd_insert_after = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let cx = call.get_arg();
        let cy = call.get_arg();
        let u_flags = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowPos");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_wnd = {:?}, h_wnd_insert_after = {:?}, x = {:?}, y = {:?}, cx = {:?}, cy = {:?}, u_flags = {:?}}}" , h_wnd , h_wnd_insert_after , x , y , cx , cy , u_flags );
        let res = api.SetWindowPos(h_wnd, h_wnd_insert_after, x, y, cx, cy, u_flags);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowTextA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowTextA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}}}",
            h_wnd,
            lp_string
        );
        let res = api.SetWindowTextA(h_wnd, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowTextW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let lp_string = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowTextW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, lp_string = {:?}}}",
            h_wnd,
            lp_string
        );
        let res = api.SetWindowTextW(h_wnd, lp_string);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowWord(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_index = call.get_arg();
        let w_new_word = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowWord");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_index = {:?}, w_new_word = {:?}}}",
            h_wnd,
            n_index,
            w_new_word
        );
        let res = api.SetWindowWord(h_wnd, n_index, w_new_word);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_filter_type = call.get_arg();
        let pfn_filter_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowsHookA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_filter_type = {:?}, pfn_filter_proc = {:?}}}",
            n_filter_type,
            pfn_filter_proc
        );
        let res = api.SetWindowsHookA(n_filter_type, pfn_filter_proc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookExA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_hook = call.get_arg();
        let lpfn = call.get_arg();
        let hmod = call.get_arg();
        let dw_thread_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowsHookExA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{id_hook = {:?}, lpfn = {:?}, hmod = {:?}, dw_thread_id = {:?}}}",
            id_hook,
            lpfn,
            hmod,
            dw_thread_id
        );
        let res = api.SetWindowsHookExA(id_hook, lpfn, hmod, dw_thread_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookExW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let id_hook = call.get_arg();
        let lpfn = call.get_arg();
        let hmod = call.get_arg();
        let dw_thread_id = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowsHookExW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{id_hook = {:?}, lpfn = {:?}, hmod = {:?}, dw_thread_id = {:?}}}",
            id_hook,
            lpfn,
            hmod,
            dw_thread_id
        );
        let res = api.SetWindowsHookExW(id_hook, lpfn, hmod, dw_thread_id);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SetWindowsHookW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_filter_type = call.get_arg();
        let pfn_filter_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SetWindowsHookW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_filter_type = {:?}, pfn_filter_proc = {:?}}}",
            n_filter_type,
            pfn_filter_proc
        );
        let res = api.SetWindowsHookW(n_filter_type, pfn_filter_proc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowCaret(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ShowCaret");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}}}", h_wnd);
        let res = api.ShowCaret(h_wnd);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowCursor(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let b_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ShowCursor");
        let _enter = span.enter();
        tracing::trace!("  args = {{b_show = {:?}}}", b_show);
        let res = api.ShowCursor(b_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowOwnedPopups(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let f_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ShowOwnedPopups");
        let _enter = span.enter();
        tracing::trace!("  args = {{h_wnd = {:?}, f_show = {:?}}}", h_wnd, f_show);
        let res = api.ShowOwnedPopups(h_wnd, f_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowWindow(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_cmd_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ShowWindow");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_cmd_show = {:?}}}",
            h_wnd,
            n_cmd_show
        );
        let res = api.ShowWindow(h_wnd, n_cmd_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_ShowWindowAsync(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let n_cmd_show = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("ShowWindowAsync");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, n_cmd_show = {:?}}}",
            h_wnd,
            n_cmd_show
        );
        let res = api.ShowWindowAsync(h_wnd, n_cmd_show);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SoundSentry(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SoundSentry");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.SoundSentry();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SwitchToThisWindow(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd = call.get_arg();
        let f_unknown = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SwitchToThisWindow");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{hwnd = {:?}, f_unknown = {:?}}}",
            hwnd,
            f_unknown
        );
        let res = api.SwitchToThisWindow(hwnd, f_unknown);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SystemParametersInfoA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ui_action = call.get_arg();
        let ui_param = call.get_arg();
        let pv_param = call.get_arg();
        let f_win_ini = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SystemParametersInfoA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ui_action = {:?}, ui_param = {:?}, pv_param = {:?}, f_win_ini = {:?}}}",
            ui_action,
            ui_param,
            pv_param,
            f_win_ini
        );
        let res = api.SystemParametersInfoA(ui_action, ui_param, pv_param, f_win_ini);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_SystemParametersInfoW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let ui_action = call.get_arg();
        let ui_param = call.get_arg();
        let pv_param = call.get_arg();
        let f_win_ini = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("SystemParametersInfoW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{ui_action = {:?}, ui_param = {:?}, pv_param = {:?}, f_win_ini = {:?}}}",
            ui_action,
            ui_param,
            pv_param,
            f_win_ini
        );
        let res = api.SystemParametersInfoW(ui_action, ui_param, pv_param, f_win_ini);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TileWindows(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hwnd_parent = call.get_arg();
        let w_how = call.get_arg();
        let lp_rect = call.get_arg();
        let c_kids = call.get_arg();
        let lp_kids = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TileWindows");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{hwnd_parent = {:?}, w_how = {:?}, lp_rect = {:?}, c_kids = {:?}, lp_kids = {:?}}}" , hwnd_parent , w_how , lp_rect , c_kids , lp_kids );
        let res = api.TileWindows(hwnd_parent, w_how, lp_rect, c_kids, lp_kids);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TrackPopupMenu(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let n_reserved = call.get_arg();
        let h_wnd = call.get_arg();
        let prc_rect = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TrackPopupMenu");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, u_flags = {:?}, x = {:?}, y = {:?}, n_reserved = {:?}, h_wnd = {:?}, prc_rect = {:?}}}" , h_menu , u_flags , x , y , n_reserved , h_wnd , prc_rect );
        let res = api.TrackPopupMenu(h_menu, u_flags, x, y, n_reserved, h_wnd, prc_rect);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TrackPopupMenuEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_menu = call.get_arg();
        let u_flags = call.get_arg();
        let x = call.get_arg();
        let y = call.get_arg();
        let hwnd = call.get_arg();
        let lptpm = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TrackPopupMenuEx");
        let _enter = span.enter();
        tracing :: trace ! ( "  args = {{h_menu = {:?}, u_flags = {:?}, x = {:?}, y = {:?}, hwnd = {:?}, lptpm = {:?}}}" , h_menu , u_flags , x , y , hwnd , lptpm );
        let res = api.TrackPopupMenuEx(h_menu, u_flags, x, y, hwnd, lptpm);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateAcceleratorA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_acc_table = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateAcceleratorA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, h_acc_table = {:?}, lp_msg = {:?}}}",
            h_wnd,
            h_acc_table,
            lp_msg
        );
        let res = api.TranslateAcceleratorA(h_wnd, h_acc_table, lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateAcceleratorW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd = call.get_arg();
        let h_acc_table = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateAcceleratorW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd = {:?}, h_acc_table = {:?}, lp_msg = {:?}}}",
            h_wnd,
            h_acc_table,
            lp_msg
        );
        let res = api.TranslateAcceleratorW(h_wnd, h_acc_table, lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateMDISysAccel(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let h_wnd_client = call.get_arg();
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateMDISysAccel");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{h_wnd_client = {:?}, lp_msg = {:?}}}",
            h_wnd_client,
            lp_msg
        );
        let res = api.TranslateMDISysAccel(h_wnd_client, lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_TranslateMessage(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_msg = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("TranslateMessage");
        let _enter = span.enter();
        tracing::trace!("  args = {{lp_msg = {:?}}}", lp_msg);
        let res = api.TranslateMessage(lp_msg);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnhookWindowsHook(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let n_code = call.get_arg();
        let pfn_filter_proc = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnhookWindowsHook");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{n_code = {:?}, pfn_filter_proc = {:?}}}",
            n_code,
            pfn_filter_proc
        );
        let res = api.UnhookWindowsHook(n_code, pfn_filter_proc);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnhookWindowsHookEx(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let hhk = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnhookWindowsHookEx");
        let _enter = span.enter();
        tracing::trace!("  args = {{hhk = {:?}}}", hhk);
        let res = api.UnhookWindowsHookEx(hhk);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterClassA(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let h_instance = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnregisterClassA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_class_name = {:?}, h_instance = {:?}}}",
            lp_class_name,
            h_instance
        );
        let res = api.UnregisterClassA(lp_class_name, h_instance);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_UnregisterClassW(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let lp_class_name = call.get_arg();
        let h_instance = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("UnregisterClassW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{lp_class_name = {:?}, h_instance = {:?}}}",
            lp_class_name,
            h_instance
        );
        let res = api.UnregisterClassW(lp_class_name, h_instance);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WaitMessage(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WaitMessage");
        let _enter = span.enter();
        tracing::trace!("  args = {{}}",);
        let res = api.WaitMessage();
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WindowFromPhysicalPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WindowFromPhysicalPoint");
        let _enter = span.enter();
        tracing::trace!("  args = {{point = {:?}}}", point);
        let res = api.WindowFromPhysicalPoint(point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_WindowFromPoint(
    context: &mut ExtendedContext,
    memory: FlatMemoryCtx,
) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let point = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("WindowFromPoint");
        let _enter = span.enter();
        tracing::trace!("  args = {{point = {:?}}}", point);
        let res = api.WindowFromPoint(point);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wsprintfA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("wsprintfA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.wsprintfA(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wsprintfW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("wsprintfW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}}}",
            param_0,
            param_1
        );
        let res = api.wsprintfW(param_0, param_1);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wvsprintfA(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let arglist = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("wvsprintfA");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}, arglist = {:?}}}",
            param_0,
            param_1,
            arglist
        );
        let res = api.wvsprintfA(param_0, param_1, arglist);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
#[no_mangle]
extern "C" fn thunk_wvsprintfW(context: &mut ExtendedContext, memory: FlatMemoryCtx) -> PtrRepr {
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let api = win32::Win32::UI::WindowsAndMessaging::get_api(&context.win32);
        let mut call = StdCallHelper::new(memory, &mut context.cpu, &mut context.unwind_reason);
        let param_0 = call.get_arg();
        let param_1 = call.get_arg();
        let arglist = call.get_arg();
        let unwind_token = call.unwind_token();
        let span = tracing::trace_span!("wvsprintfW");
        let _enter = span.enter();
        tracing::trace!(
            "  args = {{param_0 = {:?}, param_1 = {:?}, arglist = {:?}}}",
            param_0,
            param_1,
            arglist
        );
        let res = api.wvsprintfW(param_0, param_1, arglist);
        tracing::trace!("result = {:?}", res);
        call.finish(res)
    }));
    match result {
        Ok(ret) => ret,
        Err(_) => {
            eprintln!("Caught a panic in native code. Whoops, aborting..");
            std::process::abort();
        }
    }
}
