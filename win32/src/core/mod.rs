pub mod prelude;

#[allow(unused)]
use prelude::*;

/// An error code value returned by most COM functions.
#[derive(Copy, Clone, Default, Debug, Eq, PartialEq)]
#[must_use]
#[allow(non_camel_case_types)]
pub struct HRESULT(pub i32);

// TODO: stubs for pointers
#[derive(Copy, Clone, Default, Debug, Eq, PartialEq)]
pub struct PSTR(pub u32);
#[derive(Copy, Clone, Default, Debug, Eq, PartialEq)]
pub struct PCSTR(pub u32);
#[derive(Copy, Clone, Default, Debug, Eq, PartialEq)]
pub struct PWSTR(pub u32);
#[derive(Copy, Clone, Default, Debug, Eq, PartialEq)]
pub struct PCWSTR(pub u32);

#[derive(Clone, Copy, Default, PartialEq, Eq, Hash)]
pub struct GUID {
    pub data1: u32,
    pub data2: u16,
    pub data3: u16,
    pub data4: [u8; 8],
}

impl GUID {
    /// Creates a `GUID` represented by the all-zero byte-pattern.
    pub const fn zeroed() -> Self {
        Self {
            data1: 0,
            data2: 0,
            data3: 0,
            data4: [0, 0, 0, 0, 0, 0, 0, 0],
        }
    }

    /// Creates a `GUID` with the given constant values.
    pub const fn from_values(data1: u32, data2: u16, data3: u16, data4: [u8; 8]) -> Self {
        Self {
            data1,
            data2,
            data3,
            data4,
        }
    }

    /// Creates a `GUID` from a `u128` value.
    pub const fn from_u128(uuid: u128) -> Self {
        Self {
            data1: (uuid >> 96) as u32,
            data2: (uuid >> 80 & 0xffff) as u16,
            data3: (uuid >> 64 & 0xffff) as u16,
            data4: (uuid as u64).to_be_bytes(),
        }
    }
}
