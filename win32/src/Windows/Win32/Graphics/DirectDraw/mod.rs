#![allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clashing_extern_declarations,
    unused_assignments,
    clippy::all
)]
#[allow(unused)]
use win32::core::prelude::*;
pub struct ACCESSRECTLIST {
    pub lpLink: MutPtr<ACCESSRECTLIST>,
    pub rDest: super::super::Foundation::RECT,
    pub lpOwner: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpSurfaceData: MutPtr<::core::ffi::c_void>,
    pub dwFlags: u32,
    pub lpHeapAliasInfo: MutPtr<HEAPALIASINFO>,
}
impl ::core::marker::Copy for ACCESSRECTLIST {}
impl ::core::clone::Clone for ACCESSRECTLIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ACCESSRECTLIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ACCESSRECTLIST")
            .field("lpLink", &self.lpLink)
            .field("rDest", &self.rDest)
            .field("lpOwner", &self.lpOwner)
            .field("lpSurfaceData", &self.lpSurfaceData)
            .field("dwFlags", &self.dwFlags)
            .field("lpHeapAliasInfo", &self.lpHeapAliasInfo)
            .finish()
    }
}
impl ::core::cmp::PartialEq for ACCESSRECTLIST {
    fn eq(&self, other: &Self) -> bool {
        self.lpLink == other.lpLink
            && self.rDest == other.rDest
            && self.lpOwner == other.lpOwner
            && self.lpSurfaceData == other.lpSurfaceData
            && self.dwFlags == other.dwFlags
            && self.lpHeapAliasInfo == other.lpHeapAliasInfo
    }
}
impl ::core::cmp::Eq for ACCESSRECTLIST {}
impl FromIntoMemory for ACCESSRECTLIST {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_lpLink = <MutPtr<ACCESSRECTLIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_rDest =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        let f_lpOwner =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpSurfaceData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_lpHeapAliasInfo =
            <MutPtr<HEAPALIASINFO> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            lpLink: f_lpLink,
            rDest: f_rDest,
            lpOwner: f_lpOwner,
            lpSurfaceData: f_lpSurfaceData,
            dwFlags: f_dwFlags,
            lpHeapAliasInfo: f_lpHeapAliasInfo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.rDest, &mut into[4..4 + 16]);
        FromIntoMemory::into_bytes(self.lpOwner, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfaceData, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpHeapAliasInfo, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub const ACCESSRECT_BROKEN: i32 = 4i32;
pub const ACCESSRECT_NOTHOLDINGWIN16LOCK: i32 = 2i32;
pub const ACCESSRECT_VRAMSTYLE: i32 = 1i32;
pub struct ATTACHLIST {
    pub dwFlags: u32,
    pub lpLink: MutPtr<ATTACHLIST>,
    pub lpAttached: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpIAttached: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
}
impl ::core::marker::Copy for ATTACHLIST {}
impl ::core::clone::Clone for ATTACHLIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ATTACHLIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ATTACHLIST")
            .field("dwFlags", &self.dwFlags)
            .field("lpLink", &self.lpLink)
            .field("lpAttached", &self.lpAttached)
            .field("lpIAttached", &self.lpIAttached)
            .finish()
    }
}
impl ::core::cmp::PartialEq for ATTACHLIST {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.lpLink == other.lpLink
            && self.lpAttached == other.lpAttached
            && self.lpIAttached == other.lpIAttached
    }
}
impl ::core::cmp::Eq for ATTACHLIST {}
impl FromIntoMemory for ATTACHLIST {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpLink = <MutPtr<ATTACHLIST> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpAttached =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpIAttached =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwFlags: f_dwFlags,
            lpLink: f_lpLink,
            lpAttached: f_lpAttached,
            lpIAttached: f_lpIAttached,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpAttached, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpIAttached, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const CCHDEVICENAME: u32 = 32u32;
pub const CLSID_DirectDraw: crate::core::GUID =
    crate::core::GUID::from_u128(0xd7b70ee0_4340_11cf_b063_0020afc2cd35);
pub const CLSID_DirectDraw7: crate::core::GUID =
    crate::core::GUID::from_u128(0x3c305196_50db_11d3_9cfe_00c04fd930c5);
pub const CLSID_DirectDrawClipper: crate::core::GUID =
    crate::core::GUID::from_u128(0x593817a0_7db3_11cf_a2de_00aa00b93356);
pub const D3DFMT_INTERNAL_D15S1: u32 = 73u32;
pub const D3DFMT_INTERNAL_D24S8: u32 = 75u32;
pub const D3DFMT_INTERNAL_D24X8: u32 = 77u32;
pub const D3DFMT_INTERNAL_D32: u32 = 71u32;
pub const D3DFMT_INTERNAL_S1D15: u32 = 72u32;
pub const D3DFMT_INTERNAL_S8D24: u32 = 74u32;
pub const D3DFMT_INTERNAL_X8D24: u32 = 76u32;
pub const D3DFORMAT_MEMBEROFGROUP_ARGB: i32 = 524288i32;
pub const D3DFORMAT_OP_3DACCELERATION: i32 = 2048i32;
pub const D3DFORMAT_OP_AUTOGENMIPMAP: i32 = 4194304i32;
pub const D3DFORMAT_OP_BUMPMAP: i32 = 65536i32;
pub const D3DFORMAT_OP_CONVERT_TO_ARGB: i32 = 8192i32;
pub const D3DFORMAT_OP_CUBETEXTURE: i32 = 4i32;
pub const D3DFORMAT_OP_DISPLAYMODE: i32 = 1024i32;
pub const D3DFORMAT_OP_DMAP: i32 = 131072i32;
pub const D3DFORMAT_OP_NOALPHABLEND: i32 = 2097152i32;
pub const D3DFORMAT_OP_NOFILTER: i32 = 262144i32;
pub const D3DFORMAT_OP_NOTEXCOORDWRAPNORMIP: i32 = 16777216i32;
pub const D3DFORMAT_OP_OFFSCREENPLAIN: i32 = 16384i32;
pub const D3DFORMAT_OP_OFFSCREEN_RENDERTARGET: i32 = 8i32;
pub const D3DFORMAT_OP_PIXELSIZE: i32 = 4096i32;
pub const D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET: i32 = 16i32;
pub const D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET: i32 = 256i32;
pub const D3DFORMAT_OP_SRGBREAD: i32 = 32768i32;
pub const D3DFORMAT_OP_SRGBWRITE: i32 = 1048576i32;
pub const D3DFORMAT_OP_TEXTURE: i32 = 1i32;
pub const D3DFORMAT_OP_VERTEXTEXTURE: i32 = 8388608i32;
pub const D3DFORMAT_OP_VOLUMETEXTURE: i32 = 2i32;
pub const D3DFORMAT_OP_ZSTENCIL: i32 = 64i32;
pub const D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH: i32 = 128i32;
pub struct DBLNODE {
    pub next: MutPtr<DBLNODE>,
    pub prev: MutPtr<DBLNODE>,
    pub object: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub object_int: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
}
impl ::core::marker::Copy for DBLNODE {}
impl ::core::clone::Clone for DBLNODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DBLNODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DBLNODE")
            .field("next", &self.next)
            .field("prev", &self.prev)
            .field("object", &self.object)
            .field("object_int", &self.object_int)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DBLNODE {
    fn eq(&self, other: &Self) -> bool {
        self.next == other.next
            && self.prev == other.prev
            && self.object == other.object
            && self.object_int == other.object_int
    }
}
impl ::core::cmp::Eq for DBLNODE {}
impl FromIntoMemory for DBLNODE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_next = <MutPtr<DBLNODE> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_prev = <MutPtr<DBLNODE> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_object =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_object_int =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            next: f_next,
            prev: f_prev,
            object: f_object,
            object_int: f_object_int,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.next, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.prev, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.object, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.object_int, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const DCICOMMAND: u32 = 3075u32;
pub struct DD32BITDRIVERDATA {
    pub szName: [super::super::Foundation::CHAR; 260],
    pub szEntryPoint: [super::super::Foundation::CHAR; 64],
    pub dwContext: u32,
}
impl ::core::marker::Copy for DD32BITDRIVERDATA {}
impl ::core::clone::Clone for DD32BITDRIVERDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD32BITDRIVERDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD32BITDRIVERDATA")
            .field("szName", &self.szName)
            .field("szEntryPoint", &self.szEntryPoint)
            .field("dwContext", &self.dwContext)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD32BITDRIVERDATA {
    fn eq(&self, other: &Self) -> bool {
        self.szName == other.szName
            && self.szEntryPoint == other.szEntryPoint
            && self.dwContext == other.dwContext
    }
}
impl ::core::cmp::Eq for DD32BITDRIVERDATA {}
impl FromIntoMemory for DD32BITDRIVERDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 328);
        let f_szName = <[super::super::Foundation::CHAR; 260] as FromIntoMemory>::from_bytes(
            &from[0..0 + 260],
        );
        let f_szEntryPoint = <[super::super::Foundation::CHAR; 64] as FromIntoMemory>::from_bytes(
            &from[260..260 + 64],
        );
        let f_dwContext = <u32 as FromIntoMemory>::from_bytes(&from[324..324 + 4]);
        Self {
            szName: f_szName,
            szEntryPoint: f_szEntryPoint,
            dwContext: f_dwContext,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 328);
        FromIntoMemory::into_bytes(self.szName, &mut into[0..0 + 260]);
        FromIntoMemory::into_bytes(self.szEntryPoint, &mut into[260..260 + 64]);
        FromIntoMemory::into_bytes(self.dwContext, &mut into[324..324 + 4]);
    }
    fn size() -> usize {
        328
    }
}
pub const DDABLT_SRCOVERDEST: i32 = 1i32;
pub const DDAL_IMPLICIT: i32 = 1i32;
pub struct DDARGB {
    pub blue: u8,
    pub green: u8,
    pub red: u8,
    pub alpha: u8,
}
impl ::core::marker::Copy for DDARGB {}
impl ::core::clone::Clone for DDARGB {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDARGB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDARGB")
            .field("blue", &self.blue)
            .field("green", &self.green)
            .field("red", &self.red)
            .field("alpha", &self.alpha)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDARGB {
    fn eq(&self, other: &Self) -> bool {
        self.blue == other.blue
            && self.green == other.green
            && self.red == other.red
            && self.alpha == other.alpha
    }
}
impl ::core::cmp::Eq for DDARGB {}
impl FromIntoMemory for DDARGB {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_blue = <u8 as FromIntoMemory>::from_bytes(&from[0..0 + 1]);
        let f_green = <u8 as FromIntoMemory>::from_bytes(&from[1..1 + 1]);
        let f_red = <u8 as FromIntoMemory>::from_bytes(&from[2..2 + 1]);
        let f_alpha = <u8 as FromIntoMemory>::from_bytes(&from[3..3 + 1]);
        Self {
            blue: f_blue,
            green: f_green,
            red: f_red,
            alpha: f_alpha,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.blue, &mut into[0..0 + 1]);
        FromIntoMemory::into_bytes(self.green, &mut into[1..1 + 1]);
        FromIntoMemory::into_bytes(self.red, &mut into[2..2 + 1]);
        FromIntoMemory::into_bytes(self.alpha, &mut into[3..3 + 1]);
    }
    fn size() -> usize {
        4
    }
}
pub const DDBD_1: i32 = 16384i32;
pub const DDBD_16: i32 = 1024i32;
pub const DDBD_2: i32 = 8192i32;
pub const DDBD_24: i32 = 512i32;
pub const DDBD_32: i32 = 256i32;
pub const DDBD_4: i32 = 4096i32;
pub const DDBD_8: i32 = 2048i32;
pub struct DDBLTBATCH {
    pub lprDest: MutPtr<super::super::Foundation::RECT>,
    pub lpDDSSrc: IDirectDrawSurface,
    pub lprSrc: MutPtr<super::super::Foundation::RECT>,
    pub dwFlags: u32,
    pub lpDDBltFx: MutPtr<DDBLTFX>,
}
impl ::core::marker::Copy for DDBLTBATCH {}
impl ::core::clone::Clone for DDBLTBATCH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDBLTBATCH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDBLTBATCH")
            .field("lprDest", &self.lprDest)
            .field("lpDDSSrc", &self.lpDDSSrc)
            .field("lprSrc", &self.lprSrc)
            .field("dwFlags", &self.dwFlags)
            .field("lpDDBltFx", &self.lpDDBltFx)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDBLTBATCH {
    fn eq(&self, other: &Self) -> bool {
        self.lprDest == other.lprDest
            && self.lpDDSSrc == other.lpDDSSrc
            && self.lprSrc == other.lprSrc
            && self.dwFlags == other.dwFlags
            && self.lpDDBltFx == other.lpDDBltFx
    }
}
impl ::core::cmp::Eq for DDBLTBATCH {}
impl FromIntoMemory for DDBLTBATCH {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lprDest =
            <MutPtr<super::super::Foundation::RECT> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSSrc = <IDirectDrawSurface as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lprSrc =
            <MutPtr<super::super::Foundation::RECT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpDDBltFx = <MutPtr<DDBLTFX> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lprDest: f_lprDest,
            lpDDSSrc: f_lpDDSSrc,
            lprSrc: f_lprSrc,
            dwFlags: f_dwFlags,
            lpDDBltFx: f_lpDDBltFx,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lprDest, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSSrc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lprSrc, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpDDBltFx, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub const DDBLTFAST_DESTCOLORKEY: u32 = 2u32;
pub const DDBLTFAST_DONOTWAIT: u32 = 32u32;
pub const DDBLTFAST_NOCOLORKEY: u32 = 0u32;
pub const DDBLTFAST_SRCCOLORKEY: u32 = 1u32;
pub const DDBLTFAST_WAIT: u32 = 16u32;
pub struct DDBLTFX {
    pub dwSize: u32,
    pub dwDDFX: u32,
    pub dwROP: u32,
    pub dwDDROP: u32,
    pub dwRotationAngle: u32,
    pub dwZBufferOpCode: u32,
    pub dwZBufferLow: u32,
    pub dwZBufferHigh: u32,
    pub dwZBufferBaseDest: u32,
    pub dwZDestConstBitDepth: u32,
    pub Anonymous1: DDBLTFX_0,
    pub dwZSrcConstBitDepth: u32,
    pub Anonymous2: DDBLTFX_1,
    pub dwAlphaEdgeBlendBitDepth: u32,
    pub dwAlphaEdgeBlend: u32,
    pub dwReserved: u32,
    pub dwAlphaDestConstBitDepth: u32,
    pub Anonymous3: DDBLTFX_2,
    pub dwAlphaSrcConstBitDepth: u32,
    pub Anonymous4: DDBLTFX_3,
    pub Anonymous5: DDBLTFX_4,
    pub ddckDestColorkey: DDCOLORKEY,
    pub ddckSrcColorkey: DDCOLORKEY,
}
impl ::core::marker::Copy for DDBLTFX {}
impl ::core::clone::Clone for DDBLTFX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDBLTFX {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwDDFX == other.dwDDFX
            && self.dwROP == other.dwROP
            && self.dwDDROP == other.dwDDROP
            && self.dwRotationAngle == other.dwRotationAngle
            && self.dwZBufferOpCode == other.dwZBufferOpCode
            && self.dwZBufferLow == other.dwZBufferLow
            && self.dwZBufferHigh == other.dwZBufferHigh
            && self.dwZBufferBaseDest == other.dwZBufferBaseDest
            && self.dwZDestConstBitDepth == other.dwZDestConstBitDepth
            && self.Anonymous1 == other.Anonymous1
            && self.dwZSrcConstBitDepth == other.dwZSrcConstBitDepth
            && self.Anonymous2 == other.Anonymous2
            && self.dwAlphaEdgeBlendBitDepth == other.dwAlphaEdgeBlendBitDepth
            && self.dwAlphaEdgeBlend == other.dwAlphaEdgeBlend
            && self.dwReserved == other.dwReserved
            && self.dwAlphaDestConstBitDepth == other.dwAlphaDestConstBitDepth
            && self.Anonymous3 == other.Anonymous3
            && self.dwAlphaSrcConstBitDepth == other.dwAlphaSrcConstBitDepth
            && self.Anonymous4 == other.Anonymous4
            && self.Anonymous5 == other.Anonymous5
            && self.ddckDestColorkey == other.ddckDestColorkey
            && self.ddckSrcColorkey == other.ddckSrcColorkey
    }
}
impl ::core::cmp::Eq for DDBLTFX {}
impl FromIntoMemory for DDBLTFX {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 100);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwDDFX = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwROP = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwDDROP = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwRotationAngle = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwZBufferOpCode = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwZBufferLow = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwZBufferHigh = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwZBufferBaseDest = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwZDestConstBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_Anonymous1 = <DDBLTFX_0 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwZSrcConstBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_Anonymous2 = <DDBLTFX_1 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaEdgeBlendBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwAlphaEdgeBlend = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwAlphaDestConstBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_Anonymous3 = <DDBLTFX_2 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwAlphaSrcConstBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_Anonymous4 = <DDBLTFX_3 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_Anonymous5 = <DDBLTFX_4 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_ddckDestColorkey = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[84..84 + 8]);
        let f_ddckSrcColorkey = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[92..92 + 8]);
        Self {
            dwSize: f_dwSize,
            dwDDFX: f_dwDDFX,
            dwROP: f_dwROP,
            dwDDROP: f_dwDDROP,
            dwRotationAngle: f_dwRotationAngle,
            dwZBufferOpCode: f_dwZBufferOpCode,
            dwZBufferLow: f_dwZBufferLow,
            dwZBufferHigh: f_dwZBufferHigh,
            dwZBufferBaseDest: f_dwZBufferBaseDest,
            dwZDestConstBitDepth: f_dwZDestConstBitDepth,
            Anonymous1: f_Anonymous1,
            dwZSrcConstBitDepth: f_dwZSrcConstBitDepth,
            Anonymous2: f_Anonymous2,
            dwAlphaEdgeBlendBitDepth: f_dwAlphaEdgeBlendBitDepth,
            dwAlphaEdgeBlend: f_dwAlphaEdgeBlend,
            dwReserved: f_dwReserved,
            dwAlphaDestConstBitDepth: f_dwAlphaDestConstBitDepth,
            Anonymous3: f_Anonymous3,
            dwAlphaSrcConstBitDepth: f_dwAlphaSrcConstBitDepth,
            Anonymous4: f_Anonymous4,
            Anonymous5: f_Anonymous5,
            ddckDestColorkey: f_ddckDestColorkey,
            ddckSrcColorkey: f_ddckSrcColorkey,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 100);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwDDFX, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwROP, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwDDROP, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwRotationAngle, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferOpCode, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferLow, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferHigh, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBaseDest, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwZDestConstBitDepth, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwZSrcConstBitDepth, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaEdgeBlendBitDepth, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaEdgeBlend, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaDestConstBitDepth, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous3, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaSrcConstBitDepth, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous4, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous5, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.ddckDestColorkey, &mut into[84..84 + 8]);
        FromIntoMemory::into_bytes(self.ddckSrcColorkey, &mut into[92..92 + 8]);
    }
    fn size() -> usize {
        100
    }
}
pub struct DDBLTFX_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDBLTFX_0 {}
impl ::core::clone::Clone for DDBLTFX_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDBLTFX_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDBLTFX_0 {}
impl FromIntoMemory for DDBLTFX_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDBLTFX_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDBLTFX_1 {}
impl ::core::clone::Clone for DDBLTFX_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDBLTFX_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDBLTFX_1 {}
impl FromIntoMemory for DDBLTFX_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDBLTFX_2 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDBLTFX_2 {}
impl ::core::clone::Clone for DDBLTFX_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDBLTFX_2 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDBLTFX_2 {}
impl FromIntoMemory for DDBLTFX_2 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDBLTFX_3 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDBLTFX_3 {}
impl ::core::clone::Clone for DDBLTFX_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDBLTFX_3 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDBLTFX_3 {}
impl FromIntoMemory for DDBLTFX_3 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDBLTFX_4 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDBLTFX_4 {}
impl ::core::clone::Clone for DDBLTFX_4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDBLTFX_4 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDBLTFX_4 {}
impl FromIntoMemory for DDBLTFX_4 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub const DDBLTFX_ARITHSTRETCHY: i32 = 1i32;
pub const DDBLTFX_MIRRORLEFTRIGHT: i32 = 2i32;
pub const DDBLTFX_MIRRORUPDOWN: i32 = 4i32;
pub const DDBLTFX_NOTEARING: i32 = 8i32;
pub const DDBLTFX_ROTATE180: i32 = 16i32;
pub const DDBLTFX_ROTATE270: i32 = 32i32;
pub const DDBLTFX_ROTATE90: i32 = 64i32;
pub const DDBLTFX_ZBUFFERBASEDEST: i32 = 256i32;
pub const DDBLTFX_ZBUFFERRANGE: i32 = 128i32;
pub const DDBLT_AFLAGS: i32 = -2147483648i32;
pub const DDBLT_ALPHADEST: i32 = 1i32;
pub const DDBLT_ALPHADESTCONSTOVERRIDE: i32 = 2i32;
pub const DDBLT_ALPHADESTNEG: i32 = 4i32;
pub const DDBLT_ALPHADESTSURFACEOVERRIDE: i32 = 8i32;
pub const DDBLT_ALPHAEDGEBLEND: i32 = 16i32;
pub const DDBLT_ALPHASRC: i32 = 32i32;
pub const DDBLT_ALPHASRCCONSTOVERRIDE: i32 = 64i32;
pub const DDBLT_ALPHASRCNEG: i32 = 128i32;
pub const DDBLT_ALPHASRCSURFACEOVERRIDE: i32 = 256i32;
pub const DDBLT_ASYNC: i32 = 512i32;
pub const DDBLT_COLORFILL: i32 = 1024i32;
pub const DDBLT_DDFX: i32 = 2048i32;
pub const DDBLT_DDROPS: i32 = 4096i32;
pub const DDBLT_DEPTHFILL: i32 = 33554432i32;
pub const DDBLT_DONOTWAIT: i32 = 134217728i32;
pub const DDBLT_EXTENDED_FLAGS: i32 = 1073741824i32;
pub const DDBLT_EXTENDED_LINEAR_CONTENT: i32 = 4i32;
pub const DDBLT_KEYDEST: i32 = 8192i32;
pub const DDBLT_KEYDESTOVERRIDE: i32 = 16384i32;
pub const DDBLT_KEYSRC: i32 = 32768i32;
pub const DDBLT_KEYSRCOVERRIDE: i32 = 65536i32;
pub const DDBLT_LAST_PRESENTATION: i32 = 536870912i32;
pub const DDBLT_PRESENTATION: i32 = 268435456i32;
pub const DDBLT_ROP: i32 = 131072i32;
pub const DDBLT_ROTATIONANGLE: i32 = 262144i32;
pub const DDBLT_WAIT: i32 = 16777216i32;
pub const DDBLT_ZBUFFER: i32 = 524288i32;
pub const DDBLT_ZBUFFERDESTCONSTOVERRIDE: i32 = 1048576i32;
pub const DDBLT_ZBUFFERDESTOVERRIDE: i32 = 2097152i32;
pub const DDBLT_ZBUFFERSRCCONSTOVERRIDE: i32 = 4194304i32;
pub const DDBLT_ZBUFFERSRCOVERRIDE: i32 = 8388608i32;
pub struct DDBOBNEXTFIELDINFO {
    pub lpSurface: MutPtr<DDSURFACEDATA>,
}
impl ::core::marker::Copy for DDBOBNEXTFIELDINFO {}
impl ::core::clone::Clone for DDBOBNEXTFIELDINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDBOBNEXTFIELDINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDBOBNEXTFIELDINFO")
            .field("lpSurface", &self.lpSurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDBOBNEXTFIELDINFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpSurface == other.lpSurface
    }
}
impl ::core::cmp::Eq for DDBOBNEXTFIELDINFO {}
impl FromIntoMemory for DDBOBNEXTFIELDINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_lpSurface = <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            lpSurface: f_lpSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.lpSurface, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub const DDCAPS2_AUTOFLIPOVERLAY: i32 = 8i32;
pub const DDCAPS2_CANAUTOGENMIPMAP: i32 = 1073741824i32;
pub const DDCAPS2_CANBOBHARDWARE: i32 = 16384i32;
pub const DDCAPS2_CANBOBINTERLEAVED: i32 = 16i32;
pub const DDCAPS2_CANBOBNONINTERLEAVED: i32 = 32i32;
pub const DDCAPS2_CANCALIBRATEGAMMA: i32 = 1048576i32;
pub const DDCAPS2_CANDROPZ16BIT: i32 = 256i32;
pub const DDCAPS2_CANFLIPODDEVEN: i32 = 8192i32;
pub const DDCAPS2_CANMANAGERESOURCE: i32 = 268435456i32;
pub const DDCAPS2_CANMANAGETEXTURE: i32 = 8388608i32;
pub const DDCAPS2_CANRENDERWINDOWED: i32 = 524288i32;
pub const DDCAPS2_CANSHARERESOURCE: i32 = -2147483648i32;
pub const DDCAPS2_CERTIFIED: i32 = 1i32;
pub const DDCAPS2_COLORCONTROLOVERLAY: i32 = 64i32;
pub const DDCAPS2_COLORCONTROLPRIMARY: i32 = 128i32;
pub const DDCAPS2_COPYFOURCC: i32 = 32768i32;
pub const DDCAPS2_DYNAMICTEXTURES: i32 = 536870912i32;
pub const DDCAPS2_FLIPINTERVAL: i32 = 2097152i32;
pub const DDCAPS2_FLIPNOVSYNC: i32 = 4194304i32;
pub const DDCAPS2_NO2DDURING3DSCENE: i32 = 2i32;
pub const DDCAPS2_NONLOCALVIDMEM: i32 = 512i32;
pub const DDCAPS2_NONLOCALVIDMEMCAPS: i32 = 1024i32;
pub const DDCAPS2_NOPAGELOCKREQUIRED: i32 = 2048i32;
pub const DDCAPS2_PRIMARYGAMMA: i32 = 131072i32;
pub const DDCAPS2_RESERVED1: i32 = 134217728i32;
pub const DDCAPS2_STEREO: i32 = 33554432i32;
pub const DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL: i32 = 67108864i32;
pub const DDCAPS2_TEXMANINNONLOCALVIDMEM: i32 = 16777216i32;
pub const DDCAPS2_VIDEOPORT: i32 = 4i32;
pub const DDCAPS2_WIDESURFACES: i32 = 4096i32;
pub const DDCAPS_3D: i32 = 1i32;
pub const DDCAPS_ALIGNBOUNDARYDEST: i32 = 2i32;
pub const DDCAPS_ALIGNBOUNDARYSRC: i32 = 8i32;
pub const DDCAPS_ALIGNSIZEDEST: i32 = 4i32;
pub const DDCAPS_ALIGNSIZESRC: i32 = 16i32;
pub const DDCAPS_ALIGNSTRIDE: i32 = 32i32;
pub const DDCAPS_ALPHA: i32 = 8388608i32;
pub const DDCAPS_BANKSWITCHED: i32 = 134217728i32;
pub const DDCAPS_BLT: i32 = 64i32;
pub const DDCAPS_BLTCOLORFILL: i32 = 67108864i32;
pub const DDCAPS_BLTDEPTHFILL: i32 = 268435456i32;
pub const DDCAPS_BLTFOURCC: i32 = 256i32;
pub const DDCAPS_BLTQUEUE: i32 = 128i32;
pub const DDCAPS_BLTSTRETCH: i32 = 512i32;
pub const DDCAPS_CANBLTSYSMEM: i32 = -2147483648i32;
pub const DDCAPS_CANCLIP: i32 = 536870912i32;
pub const DDCAPS_CANCLIPSTRETCHED: i32 = 1073741824i32;
pub const DDCAPS_COLORKEY: i32 = 4194304i32;
pub const DDCAPS_COLORKEYHWASSIST: i32 = 16777216i32;
pub struct DDCAPS_DX1 {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCKeyCaps: u32,
    pub dwFXCaps: u32,
    pub dwFXAlphaCaps: u32,
    pub dwPalCaps: u32,
    pub dwSVCaps: u32,
    pub dwAlphaBltConstBitDepths: u32,
    pub dwAlphaBltPixelBitDepths: u32,
    pub dwAlphaBltSurfaceBitDepths: u32,
    pub dwAlphaOverlayConstBitDepths: u32,
    pub dwAlphaOverlayPixelBitDepths: u32,
    pub dwAlphaOverlaySurfaceBitDepths: u32,
    pub dwZBufferBitDepths: u32,
    pub dwVidMemTotal: u32,
    pub dwVidMemFree: u32,
    pub dwMaxVisibleOverlays: u32,
    pub dwCurrVisibleOverlays: u32,
    pub dwNumFourCCCodes: u32,
    pub dwAlignBoundarySrc: u32,
    pub dwAlignSizeSrc: u32,
    pub dwAlignBoundaryDest: u32,
    pub dwAlignSizeDest: u32,
    pub dwAlignStrideAlign: u32,
    pub dwRops: [u32; 8],
    pub ddsCaps: DDSCAPS,
    pub dwMinOverlayStretch: u32,
    pub dwMaxOverlayStretch: u32,
    pub dwMinLiveVideoStretch: u32,
    pub dwMaxLiveVideoStretch: u32,
    pub dwMinHwCodecStretch: u32,
    pub dwMaxHwCodecStretch: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
}
impl ::core::marker::Copy for DDCAPS_DX1 {}
impl ::core::clone::Clone for DDCAPS_DX1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDCAPS_DX1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDCAPS_DX1")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwCaps2", &self.dwCaps2)
            .field("dwCKeyCaps", &self.dwCKeyCaps)
            .field("dwFXCaps", &self.dwFXCaps)
            .field("dwFXAlphaCaps", &self.dwFXAlphaCaps)
            .field("dwPalCaps", &self.dwPalCaps)
            .field("dwSVCaps", &self.dwSVCaps)
            .field("dwAlphaBltConstBitDepths", &self.dwAlphaBltConstBitDepths)
            .field("dwAlphaBltPixelBitDepths", &self.dwAlphaBltPixelBitDepths)
            .field(
                "dwAlphaBltSurfaceBitDepths",
                &self.dwAlphaBltSurfaceBitDepths,
            )
            .field(
                "dwAlphaOverlayConstBitDepths",
                &self.dwAlphaOverlayConstBitDepths,
            )
            .field(
                "dwAlphaOverlayPixelBitDepths",
                &self.dwAlphaOverlayPixelBitDepths,
            )
            .field(
                "dwAlphaOverlaySurfaceBitDepths",
                &self.dwAlphaOverlaySurfaceBitDepths,
            )
            .field("dwZBufferBitDepths", &self.dwZBufferBitDepths)
            .field("dwVidMemTotal", &self.dwVidMemTotal)
            .field("dwVidMemFree", &self.dwVidMemFree)
            .field("dwMaxVisibleOverlays", &self.dwMaxVisibleOverlays)
            .field("dwCurrVisibleOverlays", &self.dwCurrVisibleOverlays)
            .field("dwNumFourCCCodes", &self.dwNumFourCCCodes)
            .field("dwAlignBoundarySrc", &self.dwAlignBoundarySrc)
            .field("dwAlignSizeSrc", &self.dwAlignSizeSrc)
            .field("dwAlignBoundaryDest", &self.dwAlignBoundaryDest)
            .field("dwAlignSizeDest", &self.dwAlignSizeDest)
            .field("dwAlignStrideAlign", &self.dwAlignStrideAlign)
            .field("dwRops", &self.dwRops)
            .field("ddsCaps", &self.ddsCaps)
            .field("dwMinOverlayStretch", &self.dwMinOverlayStretch)
            .field("dwMaxOverlayStretch", &self.dwMaxOverlayStretch)
            .field("dwMinLiveVideoStretch", &self.dwMinLiveVideoStretch)
            .field("dwMaxLiveVideoStretch", &self.dwMaxLiveVideoStretch)
            .field("dwMinHwCodecStretch", &self.dwMinHwCodecStretch)
            .field("dwMaxHwCodecStretch", &self.dwMaxHwCodecStretch)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDCAPS_DX1 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCKeyCaps == other.dwCKeyCaps
            && self.dwFXCaps == other.dwFXCaps
            && self.dwFXAlphaCaps == other.dwFXAlphaCaps
            && self.dwPalCaps == other.dwPalCaps
            && self.dwSVCaps == other.dwSVCaps
            && self.dwAlphaBltConstBitDepths == other.dwAlphaBltConstBitDepths
            && self.dwAlphaBltPixelBitDepths == other.dwAlphaBltPixelBitDepths
            && self.dwAlphaBltSurfaceBitDepths == other.dwAlphaBltSurfaceBitDepths
            && self.dwAlphaOverlayConstBitDepths == other.dwAlphaOverlayConstBitDepths
            && self.dwAlphaOverlayPixelBitDepths == other.dwAlphaOverlayPixelBitDepths
            && self.dwAlphaOverlaySurfaceBitDepths == other.dwAlphaOverlaySurfaceBitDepths
            && self.dwZBufferBitDepths == other.dwZBufferBitDepths
            && self.dwVidMemTotal == other.dwVidMemTotal
            && self.dwVidMemFree == other.dwVidMemFree
            && self.dwMaxVisibleOverlays == other.dwMaxVisibleOverlays
            && self.dwCurrVisibleOverlays == other.dwCurrVisibleOverlays
            && self.dwNumFourCCCodes == other.dwNumFourCCCodes
            && self.dwAlignBoundarySrc == other.dwAlignBoundarySrc
            && self.dwAlignSizeSrc == other.dwAlignSizeSrc
            && self.dwAlignBoundaryDest == other.dwAlignBoundaryDest
            && self.dwAlignSizeDest == other.dwAlignSizeDest
            && self.dwAlignStrideAlign == other.dwAlignStrideAlign
            && self.dwRops == other.dwRops
            && self.ddsCaps == other.ddsCaps
            && self.dwMinOverlayStretch == other.dwMinOverlayStretch
            && self.dwMaxOverlayStretch == other.dwMaxOverlayStretch
            && self.dwMinLiveVideoStretch == other.dwMinLiveVideoStretch
            && self.dwMaxLiveVideoStretch == other.dwMaxLiveVideoStretch
            && self.dwMinHwCodecStretch == other.dwMinHwCodecStretch
            && self.dwMaxHwCodecStretch == other.dwMaxHwCodecStretch
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
    }
}
impl ::core::cmp::Eq for DDCAPS_DX1 {}
impl FromIntoMemory for DDCAPS_DX1 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 172);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFXAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwPalCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwSVCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBltConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlphaBltPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlphaBltSurfaceBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlphaOverlayConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlphaOverlayPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaOverlaySurfaceBitDepths =
            <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwZBufferBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwVidMemTotal = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwVidMemFree = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwMaxVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwCurrVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwNumFourCCCodes = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwAlignBoundarySrc = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwAlignSizeSrc = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwAlignBoundaryDest = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_dwAlignSizeDest = <u32 as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dwAlignStrideAlign = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[100..100 + 32]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        let f_dwMinOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[136..136 + 4]);
        let f_dwMaxOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_dwMinLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwMaxLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwMinHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwMaxHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCKeyCaps: f_dwCKeyCaps,
            dwFXCaps: f_dwFXCaps,
            dwFXAlphaCaps: f_dwFXAlphaCaps,
            dwPalCaps: f_dwPalCaps,
            dwSVCaps: f_dwSVCaps,
            dwAlphaBltConstBitDepths: f_dwAlphaBltConstBitDepths,
            dwAlphaBltPixelBitDepths: f_dwAlphaBltPixelBitDepths,
            dwAlphaBltSurfaceBitDepths: f_dwAlphaBltSurfaceBitDepths,
            dwAlphaOverlayConstBitDepths: f_dwAlphaOverlayConstBitDepths,
            dwAlphaOverlayPixelBitDepths: f_dwAlphaOverlayPixelBitDepths,
            dwAlphaOverlaySurfaceBitDepths: f_dwAlphaOverlaySurfaceBitDepths,
            dwZBufferBitDepths: f_dwZBufferBitDepths,
            dwVidMemTotal: f_dwVidMemTotal,
            dwVidMemFree: f_dwVidMemFree,
            dwMaxVisibleOverlays: f_dwMaxVisibleOverlays,
            dwCurrVisibleOverlays: f_dwCurrVisibleOverlays,
            dwNumFourCCCodes: f_dwNumFourCCCodes,
            dwAlignBoundarySrc: f_dwAlignBoundarySrc,
            dwAlignSizeSrc: f_dwAlignSizeSrc,
            dwAlignBoundaryDest: f_dwAlignBoundaryDest,
            dwAlignSizeDest: f_dwAlignSizeDest,
            dwAlignStrideAlign: f_dwAlignStrideAlign,
            dwRops: f_dwRops,
            ddsCaps: f_ddsCaps,
            dwMinOverlayStretch: f_dwMinOverlayStretch,
            dwMaxOverlayStretch: f_dwMaxOverlayStretch,
            dwMinLiveVideoStretch: f_dwMinLiveVideoStretch,
            dwMaxLiveVideoStretch: f_dwMaxLiveVideoStretch,
            dwMinHwCodecStretch: f_dwMinHwCodecStretch,
            dwMaxHwCodecStretch: f_dwMaxHwCodecStretch,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 172);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFXAlphaCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwPalCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwSVCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltConstBitDepths, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltPixelBitDepths, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltSurfaceBitDepths, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayConstBitDepths, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayPixelBitDepths, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlaySurfaceBitDepths, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBitDepths, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemTotal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemFree, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVisibleOverlays, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVisibleOverlays, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCCCodes, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundarySrc, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeSrc, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundaryDest, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeDest, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignStrideAlign, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwRops, &mut into[100..100 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[132..132 + 4]);
        FromIntoMemory::into_bytes(self.dwMinOverlayStretch, &mut into[136..136 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlayStretch, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.dwMinLiveVideoStretch, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxLiveVideoStretch, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwMinHwCodecStretch, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHwCodecStretch, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[168..168 + 4]);
    }
    fn size() -> usize {
        172
    }
}
pub struct DDCAPS_DX3 {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCKeyCaps: u32,
    pub dwFXCaps: u32,
    pub dwFXAlphaCaps: u32,
    pub dwPalCaps: u32,
    pub dwSVCaps: u32,
    pub dwAlphaBltConstBitDepths: u32,
    pub dwAlphaBltPixelBitDepths: u32,
    pub dwAlphaBltSurfaceBitDepths: u32,
    pub dwAlphaOverlayConstBitDepths: u32,
    pub dwAlphaOverlayPixelBitDepths: u32,
    pub dwAlphaOverlaySurfaceBitDepths: u32,
    pub dwZBufferBitDepths: u32,
    pub dwVidMemTotal: u32,
    pub dwVidMemFree: u32,
    pub dwMaxVisibleOverlays: u32,
    pub dwCurrVisibleOverlays: u32,
    pub dwNumFourCCCodes: u32,
    pub dwAlignBoundarySrc: u32,
    pub dwAlignSizeSrc: u32,
    pub dwAlignBoundaryDest: u32,
    pub dwAlignSizeDest: u32,
    pub dwAlignStrideAlign: u32,
    pub dwRops: [u32; 8],
    pub ddsCaps: DDSCAPS,
    pub dwMinOverlayStretch: u32,
    pub dwMaxOverlayStretch: u32,
    pub dwMinLiveVideoStretch: u32,
    pub dwMaxLiveVideoStretch: u32,
    pub dwMinHwCodecStretch: u32,
    pub dwMaxHwCodecStretch: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwSVBCaps: u32,
    pub dwSVBCKeyCaps: u32,
    pub dwSVBFXCaps: u32,
    pub dwSVBRops: [u32; 8],
    pub dwVSBCaps: u32,
    pub dwVSBCKeyCaps: u32,
    pub dwVSBFXCaps: u32,
    pub dwVSBRops: [u32; 8],
    pub dwSSBCaps: u32,
    pub dwSSBCKeyCaps: u32,
    pub dwSSBFXCaps: u32,
    pub dwSSBRops: [u32; 8],
    pub dwReserved4: u32,
    pub dwReserved5: u32,
    pub dwReserved6: u32,
}
impl ::core::marker::Copy for DDCAPS_DX3 {}
impl ::core::clone::Clone for DDCAPS_DX3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDCAPS_DX3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDCAPS_DX3")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwCaps2", &self.dwCaps2)
            .field("dwCKeyCaps", &self.dwCKeyCaps)
            .field("dwFXCaps", &self.dwFXCaps)
            .field("dwFXAlphaCaps", &self.dwFXAlphaCaps)
            .field("dwPalCaps", &self.dwPalCaps)
            .field("dwSVCaps", &self.dwSVCaps)
            .field("dwAlphaBltConstBitDepths", &self.dwAlphaBltConstBitDepths)
            .field("dwAlphaBltPixelBitDepths", &self.dwAlphaBltPixelBitDepths)
            .field(
                "dwAlphaBltSurfaceBitDepths",
                &self.dwAlphaBltSurfaceBitDepths,
            )
            .field(
                "dwAlphaOverlayConstBitDepths",
                &self.dwAlphaOverlayConstBitDepths,
            )
            .field(
                "dwAlphaOverlayPixelBitDepths",
                &self.dwAlphaOverlayPixelBitDepths,
            )
            .field(
                "dwAlphaOverlaySurfaceBitDepths",
                &self.dwAlphaOverlaySurfaceBitDepths,
            )
            .field("dwZBufferBitDepths", &self.dwZBufferBitDepths)
            .field("dwVidMemTotal", &self.dwVidMemTotal)
            .field("dwVidMemFree", &self.dwVidMemFree)
            .field("dwMaxVisibleOverlays", &self.dwMaxVisibleOverlays)
            .field("dwCurrVisibleOverlays", &self.dwCurrVisibleOverlays)
            .field("dwNumFourCCCodes", &self.dwNumFourCCCodes)
            .field("dwAlignBoundarySrc", &self.dwAlignBoundarySrc)
            .field("dwAlignSizeSrc", &self.dwAlignSizeSrc)
            .field("dwAlignBoundaryDest", &self.dwAlignBoundaryDest)
            .field("dwAlignSizeDest", &self.dwAlignSizeDest)
            .field("dwAlignStrideAlign", &self.dwAlignStrideAlign)
            .field("dwRops", &self.dwRops)
            .field("ddsCaps", &self.ddsCaps)
            .field("dwMinOverlayStretch", &self.dwMinOverlayStretch)
            .field("dwMaxOverlayStretch", &self.dwMaxOverlayStretch)
            .field("dwMinLiveVideoStretch", &self.dwMinLiveVideoStretch)
            .field("dwMaxLiveVideoStretch", &self.dwMaxLiveVideoStretch)
            .field("dwMinHwCodecStretch", &self.dwMinHwCodecStretch)
            .field("dwMaxHwCodecStretch", &self.dwMaxHwCodecStretch)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwSVBCaps", &self.dwSVBCaps)
            .field("dwSVBCKeyCaps", &self.dwSVBCKeyCaps)
            .field("dwSVBFXCaps", &self.dwSVBFXCaps)
            .field("dwSVBRops", &self.dwSVBRops)
            .field("dwVSBCaps", &self.dwVSBCaps)
            .field("dwVSBCKeyCaps", &self.dwVSBCKeyCaps)
            .field("dwVSBFXCaps", &self.dwVSBFXCaps)
            .field("dwVSBRops", &self.dwVSBRops)
            .field("dwSSBCaps", &self.dwSSBCaps)
            .field("dwSSBCKeyCaps", &self.dwSSBCKeyCaps)
            .field("dwSSBFXCaps", &self.dwSSBFXCaps)
            .field("dwSSBRops", &self.dwSSBRops)
            .field("dwReserved4", &self.dwReserved4)
            .field("dwReserved5", &self.dwReserved5)
            .field("dwReserved6", &self.dwReserved6)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDCAPS_DX3 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCKeyCaps == other.dwCKeyCaps
            && self.dwFXCaps == other.dwFXCaps
            && self.dwFXAlphaCaps == other.dwFXAlphaCaps
            && self.dwPalCaps == other.dwPalCaps
            && self.dwSVCaps == other.dwSVCaps
            && self.dwAlphaBltConstBitDepths == other.dwAlphaBltConstBitDepths
            && self.dwAlphaBltPixelBitDepths == other.dwAlphaBltPixelBitDepths
            && self.dwAlphaBltSurfaceBitDepths == other.dwAlphaBltSurfaceBitDepths
            && self.dwAlphaOverlayConstBitDepths == other.dwAlphaOverlayConstBitDepths
            && self.dwAlphaOverlayPixelBitDepths == other.dwAlphaOverlayPixelBitDepths
            && self.dwAlphaOverlaySurfaceBitDepths == other.dwAlphaOverlaySurfaceBitDepths
            && self.dwZBufferBitDepths == other.dwZBufferBitDepths
            && self.dwVidMemTotal == other.dwVidMemTotal
            && self.dwVidMemFree == other.dwVidMemFree
            && self.dwMaxVisibleOverlays == other.dwMaxVisibleOverlays
            && self.dwCurrVisibleOverlays == other.dwCurrVisibleOverlays
            && self.dwNumFourCCCodes == other.dwNumFourCCCodes
            && self.dwAlignBoundarySrc == other.dwAlignBoundarySrc
            && self.dwAlignSizeSrc == other.dwAlignSizeSrc
            && self.dwAlignBoundaryDest == other.dwAlignBoundaryDest
            && self.dwAlignSizeDest == other.dwAlignSizeDest
            && self.dwAlignStrideAlign == other.dwAlignStrideAlign
            && self.dwRops == other.dwRops
            && self.ddsCaps == other.ddsCaps
            && self.dwMinOverlayStretch == other.dwMinOverlayStretch
            && self.dwMaxOverlayStretch == other.dwMaxOverlayStretch
            && self.dwMinLiveVideoStretch == other.dwMinLiveVideoStretch
            && self.dwMaxLiveVideoStretch == other.dwMaxLiveVideoStretch
            && self.dwMinHwCodecStretch == other.dwMinHwCodecStretch
            && self.dwMaxHwCodecStretch == other.dwMaxHwCodecStretch
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwSVBCaps == other.dwSVBCaps
            && self.dwSVBCKeyCaps == other.dwSVBCKeyCaps
            && self.dwSVBFXCaps == other.dwSVBFXCaps
            && self.dwSVBRops == other.dwSVBRops
            && self.dwVSBCaps == other.dwVSBCaps
            && self.dwVSBCKeyCaps == other.dwVSBCKeyCaps
            && self.dwVSBFXCaps == other.dwVSBFXCaps
            && self.dwVSBRops == other.dwVSBRops
            && self.dwSSBCaps == other.dwSSBCaps
            && self.dwSSBCKeyCaps == other.dwSSBCKeyCaps
            && self.dwSSBFXCaps == other.dwSSBFXCaps
            && self.dwSSBRops == other.dwSSBRops
            && self.dwReserved4 == other.dwReserved4
            && self.dwReserved5 == other.dwReserved5
            && self.dwReserved6 == other.dwReserved6
    }
}
impl ::core::cmp::Eq for DDCAPS_DX3 {}
impl FromIntoMemory for DDCAPS_DX3 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 316);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFXAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwPalCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwSVCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBltConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlphaBltPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlphaBltSurfaceBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlphaOverlayConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlphaOverlayPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaOverlaySurfaceBitDepths =
            <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwZBufferBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwVidMemTotal = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwVidMemFree = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwMaxVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwCurrVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwNumFourCCCodes = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwAlignBoundarySrc = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwAlignSizeSrc = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwAlignBoundaryDest = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_dwAlignSizeDest = <u32 as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dwAlignStrideAlign = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[100..100 + 32]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        let f_dwMinOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[136..136 + 4]);
        let f_dwMaxOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_dwMinLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwMaxLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwMinHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwMaxHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        let f_dwSVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[172..172 + 4]);
        let f_dwSVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[176..176 + 4]);
        let f_dwSVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[180..180 + 4]);
        let f_dwSVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[184..184 + 32]);
        let f_dwVSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[216..216 + 4]);
        let f_dwVSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[220..220 + 4]);
        let f_dwVSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[224..224 + 4]);
        let f_dwVSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[228..228 + 32]);
        let f_dwSSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[260..260 + 4]);
        let f_dwSSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[264..264 + 4]);
        let f_dwSSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[268..268 + 4]);
        let f_dwSSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[272..272 + 32]);
        let f_dwReserved4 = <u32 as FromIntoMemory>::from_bytes(&from[304..304 + 4]);
        let f_dwReserved5 = <u32 as FromIntoMemory>::from_bytes(&from[308..308 + 4]);
        let f_dwReserved6 = <u32 as FromIntoMemory>::from_bytes(&from[312..312 + 4]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCKeyCaps: f_dwCKeyCaps,
            dwFXCaps: f_dwFXCaps,
            dwFXAlphaCaps: f_dwFXAlphaCaps,
            dwPalCaps: f_dwPalCaps,
            dwSVCaps: f_dwSVCaps,
            dwAlphaBltConstBitDepths: f_dwAlphaBltConstBitDepths,
            dwAlphaBltPixelBitDepths: f_dwAlphaBltPixelBitDepths,
            dwAlphaBltSurfaceBitDepths: f_dwAlphaBltSurfaceBitDepths,
            dwAlphaOverlayConstBitDepths: f_dwAlphaOverlayConstBitDepths,
            dwAlphaOverlayPixelBitDepths: f_dwAlphaOverlayPixelBitDepths,
            dwAlphaOverlaySurfaceBitDepths: f_dwAlphaOverlaySurfaceBitDepths,
            dwZBufferBitDepths: f_dwZBufferBitDepths,
            dwVidMemTotal: f_dwVidMemTotal,
            dwVidMemFree: f_dwVidMemFree,
            dwMaxVisibleOverlays: f_dwMaxVisibleOverlays,
            dwCurrVisibleOverlays: f_dwCurrVisibleOverlays,
            dwNumFourCCCodes: f_dwNumFourCCCodes,
            dwAlignBoundarySrc: f_dwAlignBoundarySrc,
            dwAlignSizeSrc: f_dwAlignSizeSrc,
            dwAlignBoundaryDest: f_dwAlignBoundaryDest,
            dwAlignSizeDest: f_dwAlignSizeDest,
            dwAlignStrideAlign: f_dwAlignStrideAlign,
            dwRops: f_dwRops,
            ddsCaps: f_ddsCaps,
            dwMinOverlayStretch: f_dwMinOverlayStretch,
            dwMaxOverlayStretch: f_dwMaxOverlayStretch,
            dwMinLiveVideoStretch: f_dwMinLiveVideoStretch,
            dwMaxLiveVideoStretch: f_dwMaxLiveVideoStretch,
            dwMinHwCodecStretch: f_dwMinHwCodecStretch,
            dwMaxHwCodecStretch: f_dwMaxHwCodecStretch,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
            dwSVBCaps: f_dwSVBCaps,
            dwSVBCKeyCaps: f_dwSVBCKeyCaps,
            dwSVBFXCaps: f_dwSVBFXCaps,
            dwSVBRops: f_dwSVBRops,
            dwVSBCaps: f_dwVSBCaps,
            dwVSBCKeyCaps: f_dwVSBCKeyCaps,
            dwVSBFXCaps: f_dwVSBFXCaps,
            dwVSBRops: f_dwVSBRops,
            dwSSBCaps: f_dwSSBCaps,
            dwSSBCKeyCaps: f_dwSSBCKeyCaps,
            dwSSBFXCaps: f_dwSSBFXCaps,
            dwSSBRops: f_dwSSBRops,
            dwReserved4: f_dwReserved4,
            dwReserved5: f_dwReserved5,
            dwReserved6: f_dwReserved6,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 316);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFXAlphaCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwPalCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwSVCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltConstBitDepths, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltPixelBitDepths, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltSurfaceBitDepths, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayConstBitDepths, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayPixelBitDepths, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlaySurfaceBitDepths, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBitDepths, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemTotal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemFree, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVisibleOverlays, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVisibleOverlays, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCCCodes, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundarySrc, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeSrc, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundaryDest, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeDest, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignStrideAlign, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwRops, &mut into[100..100 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[132..132 + 4]);
        FromIntoMemory::into_bytes(self.dwMinOverlayStretch, &mut into[136..136 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlayStretch, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.dwMinLiveVideoStretch, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxLiveVideoStretch, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwMinHwCodecStretch, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHwCodecStretch, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[168..168 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps, &mut into[172..172 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCKeyCaps, &mut into[176..176 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBFXCaps, &mut into[180..180 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBRops, &mut into[184..184 + 32]);
        FromIntoMemory::into_bytes(self.dwVSBCaps, &mut into[216..216 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBCKeyCaps, &mut into[220..220 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBFXCaps, &mut into[224..224 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBRops, &mut into[228..228 + 32]);
        FromIntoMemory::into_bytes(self.dwSSBCaps, &mut into[260..260 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBCKeyCaps, &mut into[264..264 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBFXCaps, &mut into[268..268 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBRops, &mut into[272..272 + 32]);
        FromIntoMemory::into_bytes(self.dwReserved4, &mut into[304..304 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved5, &mut into[308..308 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved6, &mut into[312..312 + 4]);
    }
    fn size() -> usize {
        316
    }
}
pub struct DDCAPS_DX5 {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCKeyCaps: u32,
    pub dwFXCaps: u32,
    pub dwFXAlphaCaps: u32,
    pub dwPalCaps: u32,
    pub dwSVCaps: u32,
    pub dwAlphaBltConstBitDepths: u32,
    pub dwAlphaBltPixelBitDepths: u32,
    pub dwAlphaBltSurfaceBitDepths: u32,
    pub dwAlphaOverlayConstBitDepths: u32,
    pub dwAlphaOverlayPixelBitDepths: u32,
    pub dwAlphaOverlaySurfaceBitDepths: u32,
    pub dwZBufferBitDepths: u32,
    pub dwVidMemTotal: u32,
    pub dwVidMemFree: u32,
    pub dwMaxVisibleOverlays: u32,
    pub dwCurrVisibleOverlays: u32,
    pub dwNumFourCCCodes: u32,
    pub dwAlignBoundarySrc: u32,
    pub dwAlignSizeSrc: u32,
    pub dwAlignBoundaryDest: u32,
    pub dwAlignSizeDest: u32,
    pub dwAlignStrideAlign: u32,
    pub dwRops: [u32; 8],
    pub ddsCaps: DDSCAPS,
    pub dwMinOverlayStretch: u32,
    pub dwMaxOverlayStretch: u32,
    pub dwMinLiveVideoStretch: u32,
    pub dwMaxLiveVideoStretch: u32,
    pub dwMinHwCodecStretch: u32,
    pub dwMaxHwCodecStretch: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwSVBCaps: u32,
    pub dwSVBCKeyCaps: u32,
    pub dwSVBFXCaps: u32,
    pub dwSVBRops: [u32; 8],
    pub dwVSBCaps: u32,
    pub dwVSBCKeyCaps: u32,
    pub dwVSBFXCaps: u32,
    pub dwVSBRops: [u32; 8],
    pub dwSSBCaps: u32,
    pub dwSSBCKeyCaps: u32,
    pub dwSSBFXCaps: u32,
    pub dwSSBRops: [u32; 8],
    pub dwMaxVideoPorts: u32,
    pub dwCurrVideoPorts: u32,
    pub dwSVBCaps2: u32,
    pub dwNLVBCaps: u32,
    pub dwNLVBCaps2: u32,
    pub dwNLVBCKeyCaps: u32,
    pub dwNLVBFXCaps: u32,
    pub dwNLVBRops: [u32; 8],
}
impl ::core::marker::Copy for DDCAPS_DX5 {}
impl ::core::clone::Clone for DDCAPS_DX5 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDCAPS_DX5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDCAPS_DX5")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwCaps2", &self.dwCaps2)
            .field("dwCKeyCaps", &self.dwCKeyCaps)
            .field("dwFXCaps", &self.dwFXCaps)
            .field("dwFXAlphaCaps", &self.dwFXAlphaCaps)
            .field("dwPalCaps", &self.dwPalCaps)
            .field("dwSVCaps", &self.dwSVCaps)
            .field("dwAlphaBltConstBitDepths", &self.dwAlphaBltConstBitDepths)
            .field("dwAlphaBltPixelBitDepths", &self.dwAlphaBltPixelBitDepths)
            .field(
                "dwAlphaBltSurfaceBitDepths",
                &self.dwAlphaBltSurfaceBitDepths,
            )
            .field(
                "dwAlphaOverlayConstBitDepths",
                &self.dwAlphaOverlayConstBitDepths,
            )
            .field(
                "dwAlphaOverlayPixelBitDepths",
                &self.dwAlphaOverlayPixelBitDepths,
            )
            .field(
                "dwAlphaOverlaySurfaceBitDepths",
                &self.dwAlphaOverlaySurfaceBitDepths,
            )
            .field("dwZBufferBitDepths", &self.dwZBufferBitDepths)
            .field("dwVidMemTotal", &self.dwVidMemTotal)
            .field("dwVidMemFree", &self.dwVidMemFree)
            .field("dwMaxVisibleOverlays", &self.dwMaxVisibleOverlays)
            .field("dwCurrVisibleOverlays", &self.dwCurrVisibleOverlays)
            .field("dwNumFourCCCodes", &self.dwNumFourCCCodes)
            .field("dwAlignBoundarySrc", &self.dwAlignBoundarySrc)
            .field("dwAlignSizeSrc", &self.dwAlignSizeSrc)
            .field("dwAlignBoundaryDest", &self.dwAlignBoundaryDest)
            .field("dwAlignSizeDest", &self.dwAlignSizeDest)
            .field("dwAlignStrideAlign", &self.dwAlignStrideAlign)
            .field("dwRops", &self.dwRops)
            .field("ddsCaps", &self.ddsCaps)
            .field("dwMinOverlayStretch", &self.dwMinOverlayStretch)
            .field("dwMaxOverlayStretch", &self.dwMaxOverlayStretch)
            .field("dwMinLiveVideoStretch", &self.dwMinLiveVideoStretch)
            .field("dwMaxLiveVideoStretch", &self.dwMaxLiveVideoStretch)
            .field("dwMinHwCodecStretch", &self.dwMinHwCodecStretch)
            .field("dwMaxHwCodecStretch", &self.dwMaxHwCodecStretch)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwSVBCaps", &self.dwSVBCaps)
            .field("dwSVBCKeyCaps", &self.dwSVBCKeyCaps)
            .field("dwSVBFXCaps", &self.dwSVBFXCaps)
            .field("dwSVBRops", &self.dwSVBRops)
            .field("dwVSBCaps", &self.dwVSBCaps)
            .field("dwVSBCKeyCaps", &self.dwVSBCKeyCaps)
            .field("dwVSBFXCaps", &self.dwVSBFXCaps)
            .field("dwVSBRops", &self.dwVSBRops)
            .field("dwSSBCaps", &self.dwSSBCaps)
            .field("dwSSBCKeyCaps", &self.dwSSBCKeyCaps)
            .field("dwSSBFXCaps", &self.dwSSBFXCaps)
            .field("dwSSBRops", &self.dwSSBRops)
            .field("dwMaxVideoPorts", &self.dwMaxVideoPorts)
            .field("dwCurrVideoPorts", &self.dwCurrVideoPorts)
            .field("dwSVBCaps2", &self.dwSVBCaps2)
            .field("dwNLVBCaps", &self.dwNLVBCaps)
            .field("dwNLVBCaps2", &self.dwNLVBCaps2)
            .field("dwNLVBCKeyCaps", &self.dwNLVBCKeyCaps)
            .field("dwNLVBFXCaps", &self.dwNLVBFXCaps)
            .field("dwNLVBRops", &self.dwNLVBRops)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDCAPS_DX5 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCKeyCaps == other.dwCKeyCaps
            && self.dwFXCaps == other.dwFXCaps
            && self.dwFXAlphaCaps == other.dwFXAlphaCaps
            && self.dwPalCaps == other.dwPalCaps
            && self.dwSVCaps == other.dwSVCaps
            && self.dwAlphaBltConstBitDepths == other.dwAlphaBltConstBitDepths
            && self.dwAlphaBltPixelBitDepths == other.dwAlphaBltPixelBitDepths
            && self.dwAlphaBltSurfaceBitDepths == other.dwAlphaBltSurfaceBitDepths
            && self.dwAlphaOverlayConstBitDepths == other.dwAlphaOverlayConstBitDepths
            && self.dwAlphaOverlayPixelBitDepths == other.dwAlphaOverlayPixelBitDepths
            && self.dwAlphaOverlaySurfaceBitDepths == other.dwAlphaOverlaySurfaceBitDepths
            && self.dwZBufferBitDepths == other.dwZBufferBitDepths
            && self.dwVidMemTotal == other.dwVidMemTotal
            && self.dwVidMemFree == other.dwVidMemFree
            && self.dwMaxVisibleOverlays == other.dwMaxVisibleOverlays
            && self.dwCurrVisibleOverlays == other.dwCurrVisibleOverlays
            && self.dwNumFourCCCodes == other.dwNumFourCCCodes
            && self.dwAlignBoundarySrc == other.dwAlignBoundarySrc
            && self.dwAlignSizeSrc == other.dwAlignSizeSrc
            && self.dwAlignBoundaryDest == other.dwAlignBoundaryDest
            && self.dwAlignSizeDest == other.dwAlignSizeDest
            && self.dwAlignStrideAlign == other.dwAlignStrideAlign
            && self.dwRops == other.dwRops
            && self.ddsCaps == other.ddsCaps
            && self.dwMinOverlayStretch == other.dwMinOverlayStretch
            && self.dwMaxOverlayStretch == other.dwMaxOverlayStretch
            && self.dwMinLiveVideoStretch == other.dwMinLiveVideoStretch
            && self.dwMaxLiveVideoStretch == other.dwMaxLiveVideoStretch
            && self.dwMinHwCodecStretch == other.dwMinHwCodecStretch
            && self.dwMaxHwCodecStretch == other.dwMaxHwCodecStretch
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwSVBCaps == other.dwSVBCaps
            && self.dwSVBCKeyCaps == other.dwSVBCKeyCaps
            && self.dwSVBFXCaps == other.dwSVBFXCaps
            && self.dwSVBRops == other.dwSVBRops
            && self.dwVSBCaps == other.dwVSBCaps
            && self.dwVSBCKeyCaps == other.dwVSBCKeyCaps
            && self.dwVSBFXCaps == other.dwVSBFXCaps
            && self.dwVSBRops == other.dwVSBRops
            && self.dwSSBCaps == other.dwSSBCaps
            && self.dwSSBCKeyCaps == other.dwSSBCKeyCaps
            && self.dwSSBFXCaps == other.dwSSBFXCaps
            && self.dwSSBRops == other.dwSSBRops
            && self.dwMaxVideoPorts == other.dwMaxVideoPorts
            && self.dwCurrVideoPorts == other.dwCurrVideoPorts
            && self.dwSVBCaps2 == other.dwSVBCaps2
            && self.dwNLVBCaps == other.dwNLVBCaps
            && self.dwNLVBCaps2 == other.dwNLVBCaps2
            && self.dwNLVBCKeyCaps == other.dwNLVBCKeyCaps
            && self.dwNLVBFXCaps == other.dwNLVBFXCaps
            && self.dwNLVBRops == other.dwNLVBRops
    }
}
impl ::core::cmp::Eq for DDCAPS_DX5 {}
impl FromIntoMemory for DDCAPS_DX5 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 364);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFXAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwPalCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwSVCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBltConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlphaBltPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlphaBltSurfaceBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlphaOverlayConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlphaOverlayPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaOverlaySurfaceBitDepths =
            <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwZBufferBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwVidMemTotal = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwVidMemFree = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwMaxVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwCurrVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwNumFourCCCodes = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwAlignBoundarySrc = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwAlignSizeSrc = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwAlignBoundaryDest = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_dwAlignSizeDest = <u32 as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dwAlignStrideAlign = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[100..100 + 32]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        let f_dwMinOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[136..136 + 4]);
        let f_dwMaxOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_dwMinLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwMaxLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwMinHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwMaxHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        let f_dwSVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[172..172 + 4]);
        let f_dwSVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[176..176 + 4]);
        let f_dwSVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[180..180 + 4]);
        let f_dwSVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[184..184 + 32]);
        let f_dwVSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[216..216 + 4]);
        let f_dwVSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[220..220 + 4]);
        let f_dwVSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[224..224 + 4]);
        let f_dwVSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[228..228 + 32]);
        let f_dwSSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[260..260 + 4]);
        let f_dwSSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[264..264 + 4]);
        let f_dwSSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[268..268 + 4]);
        let f_dwSSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[272..272 + 32]);
        let f_dwMaxVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[304..304 + 4]);
        let f_dwCurrVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[308..308 + 4]);
        let f_dwSVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[312..312 + 4]);
        let f_dwNLVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[316..316 + 4]);
        let f_dwNLVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[320..320 + 4]);
        let f_dwNLVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[324..324 + 4]);
        let f_dwNLVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[328..328 + 4]);
        let f_dwNLVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[332..332 + 32]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCKeyCaps: f_dwCKeyCaps,
            dwFXCaps: f_dwFXCaps,
            dwFXAlphaCaps: f_dwFXAlphaCaps,
            dwPalCaps: f_dwPalCaps,
            dwSVCaps: f_dwSVCaps,
            dwAlphaBltConstBitDepths: f_dwAlphaBltConstBitDepths,
            dwAlphaBltPixelBitDepths: f_dwAlphaBltPixelBitDepths,
            dwAlphaBltSurfaceBitDepths: f_dwAlphaBltSurfaceBitDepths,
            dwAlphaOverlayConstBitDepths: f_dwAlphaOverlayConstBitDepths,
            dwAlphaOverlayPixelBitDepths: f_dwAlphaOverlayPixelBitDepths,
            dwAlphaOverlaySurfaceBitDepths: f_dwAlphaOverlaySurfaceBitDepths,
            dwZBufferBitDepths: f_dwZBufferBitDepths,
            dwVidMemTotal: f_dwVidMemTotal,
            dwVidMemFree: f_dwVidMemFree,
            dwMaxVisibleOverlays: f_dwMaxVisibleOverlays,
            dwCurrVisibleOverlays: f_dwCurrVisibleOverlays,
            dwNumFourCCCodes: f_dwNumFourCCCodes,
            dwAlignBoundarySrc: f_dwAlignBoundarySrc,
            dwAlignSizeSrc: f_dwAlignSizeSrc,
            dwAlignBoundaryDest: f_dwAlignBoundaryDest,
            dwAlignSizeDest: f_dwAlignSizeDest,
            dwAlignStrideAlign: f_dwAlignStrideAlign,
            dwRops: f_dwRops,
            ddsCaps: f_ddsCaps,
            dwMinOverlayStretch: f_dwMinOverlayStretch,
            dwMaxOverlayStretch: f_dwMaxOverlayStretch,
            dwMinLiveVideoStretch: f_dwMinLiveVideoStretch,
            dwMaxLiveVideoStretch: f_dwMaxLiveVideoStretch,
            dwMinHwCodecStretch: f_dwMinHwCodecStretch,
            dwMaxHwCodecStretch: f_dwMaxHwCodecStretch,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
            dwSVBCaps: f_dwSVBCaps,
            dwSVBCKeyCaps: f_dwSVBCKeyCaps,
            dwSVBFXCaps: f_dwSVBFXCaps,
            dwSVBRops: f_dwSVBRops,
            dwVSBCaps: f_dwVSBCaps,
            dwVSBCKeyCaps: f_dwVSBCKeyCaps,
            dwVSBFXCaps: f_dwVSBFXCaps,
            dwVSBRops: f_dwVSBRops,
            dwSSBCaps: f_dwSSBCaps,
            dwSSBCKeyCaps: f_dwSSBCKeyCaps,
            dwSSBFXCaps: f_dwSSBFXCaps,
            dwSSBRops: f_dwSSBRops,
            dwMaxVideoPorts: f_dwMaxVideoPorts,
            dwCurrVideoPorts: f_dwCurrVideoPorts,
            dwSVBCaps2: f_dwSVBCaps2,
            dwNLVBCaps: f_dwNLVBCaps,
            dwNLVBCaps2: f_dwNLVBCaps2,
            dwNLVBCKeyCaps: f_dwNLVBCKeyCaps,
            dwNLVBFXCaps: f_dwNLVBFXCaps,
            dwNLVBRops: f_dwNLVBRops,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 364);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFXAlphaCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwPalCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwSVCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltConstBitDepths, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltPixelBitDepths, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltSurfaceBitDepths, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayConstBitDepths, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayPixelBitDepths, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlaySurfaceBitDepths, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBitDepths, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemTotal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemFree, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVisibleOverlays, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVisibleOverlays, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCCCodes, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundarySrc, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeSrc, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundaryDest, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeDest, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignStrideAlign, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwRops, &mut into[100..100 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[132..132 + 4]);
        FromIntoMemory::into_bytes(self.dwMinOverlayStretch, &mut into[136..136 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlayStretch, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.dwMinLiveVideoStretch, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxLiveVideoStretch, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwMinHwCodecStretch, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHwCodecStretch, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[168..168 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps, &mut into[172..172 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCKeyCaps, &mut into[176..176 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBFXCaps, &mut into[180..180 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBRops, &mut into[184..184 + 32]);
        FromIntoMemory::into_bytes(self.dwVSBCaps, &mut into[216..216 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBCKeyCaps, &mut into[220..220 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBFXCaps, &mut into[224..224 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBRops, &mut into[228..228 + 32]);
        FromIntoMemory::into_bytes(self.dwSSBCaps, &mut into[260..260 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBCKeyCaps, &mut into[264..264 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBFXCaps, &mut into[268..268 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBRops, &mut into[272..272 + 32]);
        FromIntoMemory::into_bytes(self.dwMaxVideoPorts, &mut into[304..304 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVideoPorts, &mut into[308..308 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps2, &mut into[312..312 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps, &mut into[316..316 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps2, &mut into[320..320 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCKeyCaps, &mut into[324..324 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBFXCaps, &mut into[328..328 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBRops, &mut into[332..332 + 32]);
    }
    fn size() -> usize {
        364
    }
}
pub struct DDCAPS_DX6 {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCKeyCaps: u32,
    pub dwFXCaps: u32,
    pub dwFXAlphaCaps: u32,
    pub dwPalCaps: u32,
    pub dwSVCaps: u32,
    pub dwAlphaBltConstBitDepths: u32,
    pub dwAlphaBltPixelBitDepths: u32,
    pub dwAlphaBltSurfaceBitDepths: u32,
    pub dwAlphaOverlayConstBitDepths: u32,
    pub dwAlphaOverlayPixelBitDepths: u32,
    pub dwAlphaOverlaySurfaceBitDepths: u32,
    pub dwZBufferBitDepths: u32,
    pub dwVidMemTotal: u32,
    pub dwVidMemFree: u32,
    pub dwMaxVisibleOverlays: u32,
    pub dwCurrVisibleOverlays: u32,
    pub dwNumFourCCCodes: u32,
    pub dwAlignBoundarySrc: u32,
    pub dwAlignSizeSrc: u32,
    pub dwAlignBoundaryDest: u32,
    pub dwAlignSizeDest: u32,
    pub dwAlignStrideAlign: u32,
    pub dwRops: [u32; 8],
    pub ddsOldCaps: DDSCAPS,
    pub dwMinOverlayStretch: u32,
    pub dwMaxOverlayStretch: u32,
    pub dwMinLiveVideoStretch: u32,
    pub dwMaxLiveVideoStretch: u32,
    pub dwMinHwCodecStretch: u32,
    pub dwMaxHwCodecStretch: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwSVBCaps: u32,
    pub dwSVBCKeyCaps: u32,
    pub dwSVBFXCaps: u32,
    pub dwSVBRops: [u32; 8],
    pub dwVSBCaps: u32,
    pub dwVSBCKeyCaps: u32,
    pub dwVSBFXCaps: u32,
    pub dwVSBRops: [u32; 8],
    pub dwSSBCaps: u32,
    pub dwSSBCKeyCaps: u32,
    pub dwSSBFXCaps: u32,
    pub dwSSBRops: [u32; 8],
    pub dwMaxVideoPorts: u32,
    pub dwCurrVideoPorts: u32,
    pub dwSVBCaps2: u32,
    pub dwNLVBCaps: u32,
    pub dwNLVBCaps2: u32,
    pub dwNLVBCKeyCaps: u32,
    pub dwNLVBFXCaps: u32,
    pub dwNLVBRops: [u32; 8],
    pub ddsCaps: DDSCAPS2,
}
impl ::core::marker::Copy for DDCAPS_DX6 {}
impl ::core::clone::Clone for DDCAPS_DX6 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDCAPS_DX6 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCKeyCaps == other.dwCKeyCaps
            && self.dwFXCaps == other.dwFXCaps
            && self.dwFXAlphaCaps == other.dwFXAlphaCaps
            && self.dwPalCaps == other.dwPalCaps
            && self.dwSVCaps == other.dwSVCaps
            && self.dwAlphaBltConstBitDepths == other.dwAlphaBltConstBitDepths
            && self.dwAlphaBltPixelBitDepths == other.dwAlphaBltPixelBitDepths
            && self.dwAlphaBltSurfaceBitDepths == other.dwAlphaBltSurfaceBitDepths
            && self.dwAlphaOverlayConstBitDepths == other.dwAlphaOverlayConstBitDepths
            && self.dwAlphaOverlayPixelBitDepths == other.dwAlphaOverlayPixelBitDepths
            && self.dwAlphaOverlaySurfaceBitDepths == other.dwAlphaOverlaySurfaceBitDepths
            && self.dwZBufferBitDepths == other.dwZBufferBitDepths
            && self.dwVidMemTotal == other.dwVidMemTotal
            && self.dwVidMemFree == other.dwVidMemFree
            && self.dwMaxVisibleOverlays == other.dwMaxVisibleOverlays
            && self.dwCurrVisibleOverlays == other.dwCurrVisibleOverlays
            && self.dwNumFourCCCodes == other.dwNumFourCCCodes
            && self.dwAlignBoundarySrc == other.dwAlignBoundarySrc
            && self.dwAlignSizeSrc == other.dwAlignSizeSrc
            && self.dwAlignBoundaryDest == other.dwAlignBoundaryDest
            && self.dwAlignSizeDest == other.dwAlignSizeDest
            && self.dwAlignStrideAlign == other.dwAlignStrideAlign
            && self.dwRops == other.dwRops
            && self.ddsOldCaps == other.ddsOldCaps
            && self.dwMinOverlayStretch == other.dwMinOverlayStretch
            && self.dwMaxOverlayStretch == other.dwMaxOverlayStretch
            && self.dwMinLiveVideoStretch == other.dwMinLiveVideoStretch
            && self.dwMaxLiveVideoStretch == other.dwMaxLiveVideoStretch
            && self.dwMinHwCodecStretch == other.dwMinHwCodecStretch
            && self.dwMaxHwCodecStretch == other.dwMaxHwCodecStretch
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwSVBCaps == other.dwSVBCaps
            && self.dwSVBCKeyCaps == other.dwSVBCKeyCaps
            && self.dwSVBFXCaps == other.dwSVBFXCaps
            && self.dwSVBRops == other.dwSVBRops
            && self.dwVSBCaps == other.dwVSBCaps
            && self.dwVSBCKeyCaps == other.dwVSBCKeyCaps
            && self.dwVSBFXCaps == other.dwVSBFXCaps
            && self.dwVSBRops == other.dwVSBRops
            && self.dwSSBCaps == other.dwSSBCaps
            && self.dwSSBCKeyCaps == other.dwSSBCKeyCaps
            && self.dwSSBFXCaps == other.dwSSBFXCaps
            && self.dwSSBRops == other.dwSSBRops
            && self.dwMaxVideoPorts == other.dwMaxVideoPorts
            && self.dwCurrVideoPorts == other.dwCurrVideoPorts
            && self.dwSVBCaps2 == other.dwSVBCaps2
            && self.dwNLVBCaps == other.dwNLVBCaps
            && self.dwNLVBCaps2 == other.dwNLVBCaps2
            && self.dwNLVBCKeyCaps == other.dwNLVBCKeyCaps
            && self.dwNLVBFXCaps == other.dwNLVBFXCaps
            && self.dwNLVBRops == other.dwNLVBRops
            && self.ddsCaps == other.ddsCaps
    }
}
impl ::core::cmp::Eq for DDCAPS_DX6 {}
impl FromIntoMemory for DDCAPS_DX6 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 380);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFXAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwPalCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwSVCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBltConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlphaBltPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlphaBltSurfaceBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlphaOverlayConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlphaOverlayPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaOverlaySurfaceBitDepths =
            <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwZBufferBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwVidMemTotal = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwVidMemFree = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwMaxVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwCurrVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwNumFourCCCodes = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwAlignBoundarySrc = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwAlignSizeSrc = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwAlignBoundaryDest = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_dwAlignSizeDest = <u32 as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dwAlignStrideAlign = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[100..100 + 32]);
        let f_ddsOldCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        let f_dwMinOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[136..136 + 4]);
        let f_dwMaxOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_dwMinLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwMaxLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwMinHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwMaxHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        let f_dwSVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[172..172 + 4]);
        let f_dwSVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[176..176 + 4]);
        let f_dwSVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[180..180 + 4]);
        let f_dwSVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[184..184 + 32]);
        let f_dwVSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[216..216 + 4]);
        let f_dwVSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[220..220 + 4]);
        let f_dwVSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[224..224 + 4]);
        let f_dwVSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[228..228 + 32]);
        let f_dwSSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[260..260 + 4]);
        let f_dwSSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[264..264 + 4]);
        let f_dwSSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[268..268 + 4]);
        let f_dwSSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[272..272 + 32]);
        let f_dwMaxVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[304..304 + 4]);
        let f_dwCurrVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[308..308 + 4]);
        let f_dwSVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[312..312 + 4]);
        let f_dwNLVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[316..316 + 4]);
        let f_dwNLVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[320..320 + 4]);
        let f_dwNLVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[324..324 + 4]);
        let f_dwNLVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[328..328 + 4]);
        let f_dwNLVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[332..332 + 32]);
        let f_ddsCaps = <DDSCAPS2 as FromIntoMemory>::from_bytes(&from[364..364 + 16]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCKeyCaps: f_dwCKeyCaps,
            dwFXCaps: f_dwFXCaps,
            dwFXAlphaCaps: f_dwFXAlphaCaps,
            dwPalCaps: f_dwPalCaps,
            dwSVCaps: f_dwSVCaps,
            dwAlphaBltConstBitDepths: f_dwAlphaBltConstBitDepths,
            dwAlphaBltPixelBitDepths: f_dwAlphaBltPixelBitDepths,
            dwAlphaBltSurfaceBitDepths: f_dwAlphaBltSurfaceBitDepths,
            dwAlphaOverlayConstBitDepths: f_dwAlphaOverlayConstBitDepths,
            dwAlphaOverlayPixelBitDepths: f_dwAlphaOverlayPixelBitDepths,
            dwAlphaOverlaySurfaceBitDepths: f_dwAlphaOverlaySurfaceBitDepths,
            dwZBufferBitDepths: f_dwZBufferBitDepths,
            dwVidMemTotal: f_dwVidMemTotal,
            dwVidMemFree: f_dwVidMemFree,
            dwMaxVisibleOverlays: f_dwMaxVisibleOverlays,
            dwCurrVisibleOverlays: f_dwCurrVisibleOverlays,
            dwNumFourCCCodes: f_dwNumFourCCCodes,
            dwAlignBoundarySrc: f_dwAlignBoundarySrc,
            dwAlignSizeSrc: f_dwAlignSizeSrc,
            dwAlignBoundaryDest: f_dwAlignBoundaryDest,
            dwAlignSizeDest: f_dwAlignSizeDest,
            dwAlignStrideAlign: f_dwAlignStrideAlign,
            dwRops: f_dwRops,
            ddsOldCaps: f_ddsOldCaps,
            dwMinOverlayStretch: f_dwMinOverlayStretch,
            dwMaxOverlayStretch: f_dwMaxOverlayStretch,
            dwMinLiveVideoStretch: f_dwMinLiveVideoStretch,
            dwMaxLiveVideoStretch: f_dwMaxLiveVideoStretch,
            dwMinHwCodecStretch: f_dwMinHwCodecStretch,
            dwMaxHwCodecStretch: f_dwMaxHwCodecStretch,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
            dwSVBCaps: f_dwSVBCaps,
            dwSVBCKeyCaps: f_dwSVBCKeyCaps,
            dwSVBFXCaps: f_dwSVBFXCaps,
            dwSVBRops: f_dwSVBRops,
            dwVSBCaps: f_dwVSBCaps,
            dwVSBCKeyCaps: f_dwVSBCKeyCaps,
            dwVSBFXCaps: f_dwVSBFXCaps,
            dwVSBRops: f_dwVSBRops,
            dwSSBCaps: f_dwSSBCaps,
            dwSSBCKeyCaps: f_dwSSBCKeyCaps,
            dwSSBFXCaps: f_dwSSBFXCaps,
            dwSSBRops: f_dwSSBRops,
            dwMaxVideoPorts: f_dwMaxVideoPorts,
            dwCurrVideoPorts: f_dwCurrVideoPorts,
            dwSVBCaps2: f_dwSVBCaps2,
            dwNLVBCaps: f_dwNLVBCaps,
            dwNLVBCaps2: f_dwNLVBCaps2,
            dwNLVBCKeyCaps: f_dwNLVBCKeyCaps,
            dwNLVBFXCaps: f_dwNLVBFXCaps,
            dwNLVBRops: f_dwNLVBRops,
            ddsCaps: f_ddsCaps,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 380);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFXAlphaCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwPalCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwSVCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltConstBitDepths, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltPixelBitDepths, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltSurfaceBitDepths, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayConstBitDepths, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayPixelBitDepths, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlaySurfaceBitDepths, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBitDepths, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemTotal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemFree, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVisibleOverlays, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVisibleOverlays, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCCCodes, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundarySrc, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeSrc, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundaryDest, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeDest, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignStrideAlign, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwRops, &mut into[100..100 + 32]);
        FromIntoMemory::into_bytes(self.ddsOldCaps, &mut into[132..132 + 4]);
        FromIntoMemory::into_bytes(self.dwMinOverlayStretch, &mut into[136..136 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlayStretch, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.dwMinLiveVideoStretch, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxLiveVideoStretch, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwMinHwCodecStretch, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHwCodecStretch, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[168..168 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps, &mut into[172..172 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCKeyCaps, &mut into[176..176 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBFXCaps, &mut into[180..180 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBRops, &mut into[184..184 + 32]);
        FromIntoMemory::into_bytes(self.dwVSBCaps, &mut into[216..216 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBCKeyCaps, &mut into[220..220 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBFXCaps, &mut into[224..224 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBRops, &mut into[228..228 + 32]);
        FromIntoMemory::into_bytes(self.dwSSBCaps, &mut into[260..260 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBCKeyCaps, &mut into[264..264 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBFXCaps, &mut into[268..268 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBRops, &mut into[272..272 + 32]);
        FromIntoMemory::into_bytes(self.dwMaxVideoPorts, &mut into[304..304 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVideoPorts, &mut into[308..308 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps2, &mut into[312..312 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps, &mut into[316..316 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps2, &mut into[320..320 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCKeyCaps, &mut into[324..324 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBFXCaps, &mut into[328..328 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBRops, &mut into[332..332 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[364..364 + 16]);
    }
    fn size() -> usize {
        380
    }
}
pub struct DDCAPS_DX7 {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCKeyCaps: u32,
    pub dwFXCaps: u32,
    pub dwFXAlphaCaps: u32,
    pub dwPalCaps: u32,
    pub dwSVCaps: u32,
    pub dwAlphaBltConstBitDepths: u32,
    pub dwAlphaBltPixelBitDepths: u32,
    pub dwAlphaBltSurfaceBitDepths: u32,
    pub dwAlphaOverlayConstBitDepths: u32,
    pub dwAlphaOverlayPixelBitDepths: u32,
    pub dwAlphaOverlaySurfaceBitDepths: u32,
    pub dwZBufferBitDepths: u32,
    pub dwVidMemTotal: u32,
    pub dwVidMemFree: u32,
    pub dwMaxVisibleOverlays: u32,
    pub dwCurrVisibleOverlays: u32,
    pub dwNumFourCCCodes: u32,
    pub dwAlignBoundarySrc: u32,
    pub dwAlignSizeSrc: u32,
    pub dwAlignBoundaryDest: u32,
    pub dwAlignSizeDest: u32,
    pub dwAlignStrideAlign: u32,
    pub dwRops: [u32; 8],
    pub ddsOldCaps: DDSCAPS,
    pub dwMinOverlayStretch: u32,
    pub dwMaxOverlayStretch: u32,
    pub dwMinLiveVideoStretch: u32,
    pub dwMaxLiveVideoStretch: u32,
    pub dwMinHwCodecStretch: u32,
    pub dwMaxHwCodecStretch: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwSVBCaps: u32,
    pub dwSVBCKeyCaps: u32,
    pub dwSVBFXCaps: u32,
    pub dwSVBRops: [u32; 8],
    pub dwVSBCaps: u32,
    pub dwVSBCKeyCaps: u32,
    pub dwVSBFXCaps: u32,
    pub dwVSBRops: [u32; 8],
    pub dwSSBCaps: u32,
    pub dwSSBCKeyCaps: u32,
    pub dwSSBFXCaps: u32,
    pub dwSSBRops: [u32; 8],
    pub dwMaxVideoPorts: u32,
    pub dwCurrVideoPorts: u32,
    pub dwSVBCaps2: u32,
    pub dwNLVBCaps: u32,
    pub dwNLVBCaps2: u32,
    pub dwNLVBCKeyCaps: u32,
    pub dwNLVBFXCaps: u32,
    pub dwNLVBRops: [u32; 8],
    pub ddsCaps: DDSCAPS2,
}
impl ::core::marker::Copy for DDCAPS_DX7 {}
impl ::core::clone::Clone for DDCAPS_DX7 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDCAPS_DX7 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCKeyCaps == other.dwCKeyCaps
            && self.dwFXCaps == other.dwFXCaps
            && self.dwFXAlphaCaps == other.dwFXAlphaCaps
            && self.dwPalCaps == other.dwPalCaps
            && self.dwSVCaps == other.dwSVCaps
            && self.dwAlphaBltConstBitDepths == other.dwAlphaBltConstBitDepths
            && self.dwAlphaBltPixelBitDepths == other.dwAlphaBltPixelBitDepths
            && self.dwAlphaBltSurfaceBitDepths == other.dwAlphaBltSurfaceBitDepths
            && self.dwAlphaOverlayConstBitDepths == other.dwAlphaOverlayConstBitDepths
            && self.dwAlphaOverlayPixelBitDepths == other.dwAlphaOverlayPixelBitDepths
            && self.dwAlphaOverlaySurfaceBitDepths == other.dwAlphaOverlaySurfaceBitDepths
            && self.dwZBufferBitDepths == other.dwZBufferBitDepths
            && self.dwVidMemTotal == other.dwVidMemTotal
            && self.dwVidMemFree == other.dwVidMemFree
            && self.dwMaxVisibleOverlays == other.dwMaxVisibleOverlays
            && self.dwCurrVisibleOverlays == other.dwCurrVisibleOverlays
            && self.dwNumFourCCCodes == other.dwNumFourCCCodes
            && self.dwAlignBoundarySrc == other.dwAlignBoundarySrc
            && self.dwAlignSizeSrc == other.dwAlignSizeSrc
            && self.dwAlignBoundaryDest == other.dwAlignBoundaryDest
            && self.dwAlignSizeDest == other.dwAlignSizeDest
            && self.dwAlignStrideAlign == other.dwAlignStrideAlign
            && self.dwRops == other.dwRops
            && self.ddsOldCaps == other.ddsOldCaps
            && self.dwMinOverlayStretch == other.dwMinOverlayStretch
            && self.dwMaxOverlayStretch == other.dwMaxOverlayStretch
            && self.dwMinLiveVideoStretch == other.dwMinLiveVideoStretch
            && self.dwMaxLiveVideoStretch == other.dwMaxLiveVideoStretch
            && self.dwMinHwCodecStretch == other.dwMinHwCodecStretch
            && self.dwMaxHwCodecStretch == other.dwMaxHwCodecStretch
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwSVBCaps == other.dwSVBCaps
            && self.dwSVBCKeyCaps == other.dwSVBCKeyCaps
            && self.dwSVBFXCaps == other.dwSVBFXCaps
            && self.dwSVBRops == other.dwSVBRops
            && self.dwVSBCaps == other.dwVSBCaps
            && self.dwVSBCKeyCaps == other.dwVSBCKeyCaps
            && self.dwVSBFXCaps == other.dwVSBFXCaps
            && self.dwVSBRops == other.dwVSBRops
            && self.dwSSBCaps == other.dwSSBCaps
            && self.dwSSBCKeyCaps == other.dwSSBCKeyCaps
            && self.dwSSBFXCaps == other.dwSSBFXCaps
            && self.dwSSBRops == other.dwSSBRops
            && self.dwMaxVideoPorts == other.dwMaxVideoPorts
            && self.dwCurrVideoPorts == other.dwCurrVideoPorts
            && self.dwSVBCaps2 == other.dwSVBCaps2
            && self.dwNLVBCaps == other.dwNLVBCaps
            && self.dwNLVBCaps2 == other.dwNLVBCaps2
            && self.dwNLVBCKeyCaps == other.dwNLVBCKeyCaps
            && self.dwNLVBFXCaps == other.dwNLVBFXCaps
            && self.dwNLVBRops == other.dwNLVBRops
            && self.ddsCaps == other.ddsCaps
    }
}
impl ::core::cmp::Eq for DDCAPS_DX7 {}
impl FromIntoMemory for DDCAPS_DX7 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 380);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFXAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwPalCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwSVCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBltConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlphaBltPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlphaBltSurfaceBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlphaOverlayConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlphaOverlayPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaOverlaySurfaceBitDepths =
            <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwZBufferBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwVidMemTotal = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwVidMemFree = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwMaxVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwCurrVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwNumFourCCCodes = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwAlignBoundarySrc = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwAlignSizeSrc = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwAlignBoundaryDest = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_dwAlignSizeDest = <u32 as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dwAlignStrideAlign = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[100..100 + 32]);
        let f_ddsOldCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        let f_dwMinOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[136..136 + 4]);
        let f_dwMaxOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_dwMinLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwMaxLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwMinHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwMaxHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        let f_dwSVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[172..172 + 4]);
        let f_dwSVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[176..176 + 4]);
        let f_dwSVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[180..180 + 4]);
        let f_dwSVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[184..184 + 32]);
        let f_dwVSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[216..216 + 4]);
        let f_dwVSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[220..220 + 4]);
        let f_dwVSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[224..224 + 4]);
        let f_dwVSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[228..228 + 32]);
        let f_dwSSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[260..260 + 4]);
        let f_dwSSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[264..264 + 4]);
        let f_dwSSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[268..268 + 4]);
        let f_dwSSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[272..272 + 32]);
        let f_dwMaxVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[304..304 + 4]);
        let f_dwCurrVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[308..308 + 4]);
        let f_dwSVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[312..312 + 4]);
        let f_dwNLVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[316..316 + 4]);
        let f_dwNLVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[320..320 + 4]);
        let f_dwNLVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[324..324 + 4]);
        let f_dwNLVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[328..328 + 4]);
        let f_dwNLVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[332..332 + 32]);
        let f_ddsCaps = <DDSCAPS2 as FromIntoMemory>::from_bytes(&from[364..364 + 16]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCKeyCaps: f_dwCKeyCaps,
            dwFXCaps: f_dwFXCaps,
            dwFXAlphaCaps: f_dwFXAlphaCaps,
            dwPalCaps: f_dwPalCaps,
            dwSVCaps: f_dwSVCaps,
            dwAlphaBltConstBitDepths: f_dwAlphaBltConstBitDepths,
            dwAlphaBltPixelBitDepths: f_dwAlphaBltPixelBitDepths,
            dwAlphaBltSurfaceBitDepths: f_dwAlphaBltSurfaceBitDepths,
            dwAlphaOverlayConstBitDepths: f_dwAlphaOverlayConstBitDepths,
            dwAlphaOverlayPixelBitDepths: f_dwAlphaOverlayPixelBitDepths,
            dwAlphaOverlaySurfaceBitDepths: f_dwAlphaOverlaySurfaceBitDepths,
            dwZBufferBitDepths: f_dwZBufferBitDepths,
            dwVidMemTotal: f_dwVidMemTotal,
            dwVidMemFree: f_dwVidMemFree,
            dwMaxVisibleOverlays: f_dwMaxVisibleOverlays,
            dwCurrVisibleOverlays: f_dwCurrVisibleOverlays,
            dwNumFourCCCodes: f_dwNumFourCCCodes,
            dwAlignBoundarySrc: f_dwAlignBoundarySrc,
            dwAlignSizeSrc: f_dwAlignSizeSrc,
            dwAlignBoundaryDest: f_dwAlignBoundaryDest,
            dwAlignSizeDest: f_dwAlignSizeDest,
            dwAlignStrideAlign: f_dwAlignStrideAlign,
            dwRops: f_dwRops,
            ddsOldCaps: f_ddsOldCaps,
            dwMinOverlayStretch: f_dwMinOverlayStretch,
            dwMaxOverlayStretch: f_dwMaxOverlayStretch,
            dwMinLiveVideoStretch: f_dwMinLiveVideoStretch,
            dwMaxLiveVideoStretch: f_dwMaxLiveVideoStretch,
            dwMinHwCodecStretch: f_dwMinHwCodecStretch,
            dwMaxHwCodecStretch: f_dwMaxHwCodecStretch,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
            dwSVBCaps: f_dwSVBCaps,
            dwSVBCKeyCaps: f_dwSVBCKeyCaps,
            dwSVBFXCaps: f_dwSVBFXCaps,
            dwSVBRops: f_dwSVBRops,
            dwVSBCaps: f_dwVSBCaps,
            dwVSBCKeyCaps: f_dwVSBCKeyCaps,
            dwVSBFXCaps: f_dwVSBFXCaps,
            dwVSBRops: f_dwVSBRops,
            dwSSBCaps: f_dwSSBCaps,
            dwSSBCKeyCaps: f_dwSSBCKeyCaps,
            dwSSBFXCaps: f_dwSSBFXCaps,
            dwSSBRops: f_dwSSBRops,
            dwMaxVideoPorts: f_dwMaxVideoPorts,
            dwCurrVideoPorts: f_dwCurrVideoPorts,
            dwSVBCaps2: f_dwSVBCaps2,
            dwNLVBCaps: f_dwNLVBCaps,
            dwNLVBCaps2: f_dwNLVBCaps2,
            dwNLVBCKeyCaps: f_dwNLVBCKeyCaps,
            dwNLVBFXCaps: f_dwNLVBFXCaps,
            dwNLVBRops: f_dwNLVBRops,
            ddsCaps: f_ddsCaps,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 380);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFXAlphaCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwPalCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwSVCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltConstBitDepths, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltPixelBitDepths, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltSurfaceBitDepths, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayConstBitDepths, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayPixelBitDepths, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlaySurfaceBitDepths, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBitDepths, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemTotal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemFree, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVisibleOverlays, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVisibleOverlays, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCCCodes, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundarySrc, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeSrc, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundaryDest, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeDest, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignStrideAlign, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwRops, &mut into[100..100 + 32]);
        FromIntoMemory::into_bytes(self.ddsOldCaps, &mut into[132..132 + 4]);
        FromIntoMemory::into_bytes(self.dwMinOverlayStretch, &mut into[136..136 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlayStretch, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.dwMinLiveVideoStretch, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxLiveVideoStretch, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwMinHwCodecStretch, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHwCodecStretch, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[168..168 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps, &mut into[172..172 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCKeyCaps, &mut into[176..176 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBFXCaps, &mut into[180..180 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBRops, &mut into[184..184 + 32]);
        FromIntoMemory::into_bytes(self.dwVSBCaps, &mut into[216..216 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBCKeyCaps, &mut into[220..220 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBFXCaps, &mut into[224..224 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBRops, &mut into[228..228 + 32]);
        FromIntoMemory::into_bytes(self.dwSSBCaps, &mut into[260..260 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBCKeyCaps, &mut into[264..264 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBFXCaps, &mut into[268..268 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBRops, &mut into[272..272 + 32]);
        FromIntoMemory::into_bytes(self.dwMaxVideoPorts, &mut into[304..304 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVideoPorts, &mut into[308..308 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps2, &mut into[312..312 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps, &mut into[316..316 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps2, &mut into[320..320 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCKeyCaps, &mut into[324..324 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBFXCaps, &mut into[328..328 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBRops, &mut into[332..332 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[364..364 + 16]);
    }
    fn size() -> usize {
        380
    }
}
pub const DDCAPS_GDI: i32 = 1024i32;
pub const DDCAPS_NOHARDWARE: i32 = 33554432i32;
pub const DDCAPS_OVERLAY: i32 = 2048i32;
pub const DDCAPS_OVERLAYCANTCLIP: i32 = 4096i32;
pub const DDCAPS_OVERLAYFOURCC: i32 = 8192i32;
pub const DDCAPS_OVERLAYSTRETCH: i32 = 16384i32;
pub const DDCAPS_PALETTE: i32 = 32768i32;
pub const DDCAPS_PALETTEVSYNC: i32 = 65536i32;
pub const DDCAPS_READSCANLINE: i32 = 131072i32;
pub const DDCAPS_RESERVED1: i32 = 262144i32;
pub const DDCAPS_VBI: i32 = 524288i32;
pub const DDCAPS_ZBLTS: i32 = 1048576i32;
pub const DDCAPS_ZOVERLAYS: i32 = 2097152i32;
pub const DDCKEYCAPS_DESTBLT: i32 = 1i32;
pub const DDCKEYCAPS_DESTBLTCLRSPACE: i32 = 2i32;
pub const DDCKEYCAPS_DESTBLTCLRSPACEYUV: i32 = 4i32;
pub const DDCKEYCAPS_DESTBLTYUV: i32 = 8i32;
pub const DDCKEYCAPS_DESTOVERLAY: i32 = 16i32;
pub const DDCKEYCAPS_DESTOVERLAYCLRSPACE: i32 = 32i32;
pub const DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV: i32 = 64i32;
pub const DDCKEYCAPS_DESTOVERLAYONEACTIVE: i32 = 128i32;
pub const DDCKEYCAPS_DESTOVERLAYYUV: i32 = 256i32;
pub const DDCKEYCAPS_NOCOSTOVERLAY: i32 = 262144i32;
pub const DDCKEYCAPS_SRCBLT: i32 = 512i32;
pub const DDCKEYCAPS_SRCBLTCLRSPACE: i32 = 1024i32;
pub const DDCKEYCAPS_SRCBLTCLRSPACEYUV: i32 = 2048i32;
pub const DDCKEYCAPS_SRCBLTYUV: i32 = 4096i32;
pub const DDCKEYCAPS_SRCOVERLAY: i32 = 8192i32;
pub const DDCKEYCAPS_SRCOVERLAYCLRSPACE: i32 = 16384i32;
pub const DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV: i32 = 32768i32;
pub const DDCKEYCAPS_SRCOVERLAYONEACTIVE: i32 = 65536i32;
pub const DDCKEYCAPS_SRCOVERLAYYUV: i32 = 131072i32;
pub const DDCKEY_COLORSPACE: i32 = 1i32;
pub const DDCKEY_DESTBLT: i32 = 2i32;
pub const DDCKEY_DESTOVERLAY: i32 = 4i32;
pub const DDCKEY_SRCBLT: i32 = 8i32;
pub const DDCKEY_SRCOVERLAY: i32 = 16i32;
pub struct DDCOLORCONTROL {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub lBrightness: i32,
    pub lContrast: i32,
    pub lHue: i32,
    pub lSaturation: i32,
    pub lSharpness: i32,
    pub lGamma: i32,
    pub lColorEnable: i32,
    pub dwReserved1: u32,
}
impl ::core::marker::Copy for DDCOLORCONTROL {}
impl ::core::clone::Clone for DDCOLORCONTROL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDCOLORCONTROL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDCOLORCONTROL")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("lBrightness", &self.lBrightness)
            .field("lContrast", &self.lContrast)
            .field("lHue", &self.lHue)
            .field("lSaturation", &self.lSaturation)
            .field("lSharpness", &self.lSharpness)
            .field("lGamma", &self.lGamma)
            .field("lColorEnable", &self.lColorEnable)
            .field("dwReserved1", &self.dwReserved1)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDCOLORCONTROL {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.lBrightness == other.lBrightness
            && self.lContrast == other.lContrast
            && self.lHue == other.lHue
            && self.lSaturation == other.lSaturation
            && self.lSharpness == other.lSharpness
            && self.lGamma == other.lGamma
            && self.lColorEnable == other.lColorEnable
            && self.dwReserved1 == other.dwReserved1
    }
}
impl ::core::cmp::Eq for DDCOLORCONTROL {}
impl FromIntoMemory for DDCOLORCONTROL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lBrightness = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lContrast = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lHue = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lSaturation = <i32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lSharpness = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lGamma = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_lColorEnable = <i32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            lBrightness: f_lBrightness,
            lContrast: f_lContrast,
            lHue: f_lHue,
            lSaturation: f_lSaturation,
            lSharpness: f_lSharpness,
            lGamma: f_lGamma,
            lColorEnable: f_lColorEnable,
            dwReserved1: f_dwReserved1,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lBrightness, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lContrast, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lHue, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lSaturation, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lSharpness, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lGamma, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lColorEnable, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[36..36 + 4]);
    }
    fn size() -> usize {
        40
    }
}
pub struct DDCOLORKEY {
    pub dwColorSpaceLowValue: u32,
    pub dwColorSpaceHighValue: u32,
}
impl ::core::marker::Copy for DDCOLORKEY {}
impl ::core::clone::Clone for DDCOLORKEY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDCOLORKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDCOLORKEY")
            .field("dwColorSpaceLowValue", &self.dwColorSpaceLowValue)
            .field("dwColorSpaceHighValue", &self.dwColorSpaceHighValue)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDCOLORKEY {
    fn eq(&self, other: &Self) -> bool {
        self.dwColorSpaceLowValue == other.dwColorSpaceLowValue
            && self.dwColorSpaceHighValue == other.dwColorSpaceHighValue
    }
}
impl ::core::cmp::Eq for DDCOLORKEY {}
impl FromIntoMemory for DDCOLORKEY {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_dwColorSpaceLowValue = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwColorSpaceHighValue = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            dwColorSpaceLowValue: f_dwColorSpaceLowValue,
            dwColorSpaceHighValue: f_dwColorSpaceHighValue,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.dwColorSpaceLowValue, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwColorSpaceHighValue, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub const DDCOLOR_BRIGHTNESS: i32 = 1i32;
pub const DDCOLOR_COLORENABLE: i32 = 64i32;
pub const DDCOLOR_CONTRAST: i32 = 2i32;
pub const DDCOLOR_GAMMA: i32 = 32i32;
pub const DDCOLOR_HUE: i32 = 4i32;
pub const DDCOLOR_SATURATION: i32 = 8i32;
pub const DDCOLOR_SHARPNESS: i32 = 16i32;
pub struct DDCOMPBUFFERINFO {
    pub dwSize: u32,
    pub dwNumCompBuffers: u32,
    pub dwWidthToCreate: u32,
    pub dwHeightToCreate: u32,
    pub dwBytesToAllocate: u32,
    pub ddCompCaps: DDSCAPS2,
    pub ddPixelFormat: DDPIXELFORMAT,
}
impl ::core::marker::Copy for DDCOMPBUFFERINFO {}
impl ::core::clone::Clone for DDCOMPBUFFERINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDCOMPBUFFERINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwNumCompBuffers == other.dwNumCompBuffers
            && self.dwWidthToCreate == other.dwWidthToCreate
            && self.dwHeightToCreate == other.dwHeightToCreate
            && self.dwBytesToAllocate == other.dwBytesToAllocate
            && self.ddCompCaps == other.ddCompCaps
            && self.ddPixelFormat == other.ddPixelFormat
    }
}
impl ::core::cmp::Eq for DDCOMPBUFFERINFO {}
impl FromIntoMemory for DDCOMPBUFFERINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 68);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwNumCompBuffers = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidthToCreate = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeightToCreate = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwBytesToAllocate = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddCompCaps = <DDSCAPS2 as FromIntoMemory>::from_bytes(&from[20..20 + 16]);
        let f_ddPixelFormat = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[36..36 + 32]);
        Self {
            dwSize: f_dwSize,
            dwNumCompBuffers: f_dwNumCompBuffers,
            dwWidthToCreate: f_dwWidthToCreate,
            dwHeightToCreate: f_dwHeightToCreate,
            dwBytesToAllocate: f_dwBytesToAllocate,
            ddCompCaps: f_ddCompCaps,
            ddPixelFormat: f_ddPixelFormat,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 68);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwNumCompBuffers, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidthToCreate, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeightToCreate, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwBytesToAllocate, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddCompCaps, &mut into[20..20 + 16]);
        FromIntoMemory::into_bytes(self.ddPixelFormat, &mut into[36..36 + 32]);
    }
    fn size() -> usize {
        68
    }
}
pub struct DDCORECAPS {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCKeyCaps: u32,
    pub dwFXCaps: u32,
    pub dwFXAlphaCaps: u32,
    pub dwPalCaps: u32,
    pub dwSVCaps: u32,
    pub dwAlphaBltConstBitDepths: u32,
    pub dwAlphaBltPixelBitDepths: u32,
    pub dwAlphaBltSurfaceBitDepths: u32,
    pub dwAlphaOverlayConstBitDepths: u32,
    pub dwAlphaOverlayPixelBitDepths: u32,
    pub dwAlphaOverlaySurfaceBitDepths: u32,
    pub dwZBufferBitDepths: u32,
    pub dwVidMemTotal: u32,
    pub dwVidMemFree: u32,
    pub dwMaxVisibleOverlays: u32,
    pub dwCurrVisibleOverlays: u32,
    pub dwNumFourCCCodes: u32,
    pub dwAlignBoundarySrc: u32,
    pub dwAlignSizeSrc: u32,
    pub dwAlignBoundaryDest: u32,
    pub dwAlignSizeDest: u32,
    pub dwAlignStrideAlign: u32,
    pub dwRops: [u32; 8],
    pub ddsCaps: DDSCAPS,
    pub dwMinOverlayStretch: u32,
    pub dwMaxOverlayStretch: u32,
    pub dwMinLiveVideoStretch: u32,
    pub dwMaxLiveVideoStretch: u32,
    pub dwMinHwCodecStretch: u32,
    pub dwMaxHwCodecStretch: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwSVBCaps: u32,
    pub dwSVBCKeyCaps: u32,
    pub dwSVBFXCaps: u32,
    pub dwSVBRops: [u32; 8],
    pub dwVSBCaps: u32,
    pub dwVSBCKeyCaps: u32,
    pub dwVSBFXCaps: u32,
    pub dwVSBRops: [u32; 8],
    pub dwSSBCaps: u32,
    pub dwSSBCKeyCaps: u32,
    pub dwSSBFXCaps: u32,
    pub dwSSBRops: [u32; 8],
    pub dwMaxVideoPorts: u32,
    pub dwCurrVideoPorts: u32,
    pub dwSVBCaps2: u32,
}
impl ::core::marker::Copy for DDCORECAPS {}
impl ::core::clone::Clone for DDCORECAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDCORECAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDCORECAPS")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwCaps2", &self.dwCaps2)
            .field("dwCKeyCaps", &self.dwCKeyCaps)
            .field("dwFXCaps", &self.dwFXCaps)
            .field("dwFXAlphaCaps", &self.dwFXAlphaCaps)
            .field("dwPalCaps", &self.dwPalCaps)
            .field("dwSVCaps", &self.dwSVCaps)
            .field("dwAlphaBltConstBitDepths", &self.dwAlphaBltConstBitDepths)
            .field("dwAlphaBltPixelBitDepths", &self.dwAlphaBltPixelBitDepths)
            .field(
                "dwAlphaBltSurfaceBitDepths",
                &self.dwAlphaBltSurfaceBitDepths,
            )
            .field(
                "dwAlphaOverlayConstBitDepths",
                &self.dwAlphaOverlayConstBitDepths,
            )
            .field(
                "dwAlphaOverlayPixelBitDepths",
                &self.dwAlphaOverlayPixelBitDepths,
            )
            .field(
                "dwAlphaOverlaySurfaceBitDepths",
                &self.dwAlphaOverlaySurfaceBitDepths,
            )
            .field("dwZBufferBitDepths", &self.dwZBufferBitDepths)
            .field("dwVidMemTotal", &self.dwVidMemTotal)
            .field("dwVidMemFree", &self.dwVidMemFree)
            .field("dwMaxVisibleOverlays", &self.dwMaxVisibleOverlays)
            .field("dwCurrVisibleOverlays", &self.dwCurrVisibleOverlays)
            .field("dwNumFourCCCodes", &self.dwNumFourCCCodes)
            .field("dwAlignBoundarySrc", &self.dwAlignBoundarySrc)
            .field("dwAlignSizeSrc", &self.dwAlignSizeSrc)
            .field("dwAlignBoundaryDest", &self.dwAlignBoundaryDest)
            .field("dwAlignSizeDest", &self.dwAlignSizeDest)
            .field("dwAlignStrideAlign", &self.dwAlignStrideAlign)
            .field("dwRops", &self.dwRops)
            .field("ddsCaps", &self.ddsCaps)
            .field("dwMinOverlayStretch", &self.dwMinOverlayStretch)
            .field("dwMaxOverlayStretch", &self.dwMaxOverlayStretch)
            .field("dwMinLiveVideoStretch", &self.dwMinLiveVideoStretch)
            .field("dwMaxLiveVideoStretch", &self.dwMaxLiveVideoStretch)
            .field("dwMinHwCodecStretch", &self.dwMinHwCodecStretch)
            .field("dwMaxHwCodecStretch", &self.dwMaxHwCodecStretch)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwSVBCaps", &self.dwSVBCaps)
            .field("dwSVBCKeyCaps", &self.dwSVBCKeyCaps)
            .field("dwSVBFXCaps", &self.dwSVBFXCaps)
            .field("dwSVBRops", &self.dwSVBRops)
            .field("dwVSBCaps", &self.dwVSBCaps)
            .field("dwVSBCKeyCaps", &self.dwVSBCKeyCaps)
            .field("dwVSBFXCaps", &self.dwVSBFXCaps)
            .field("dwVSBRops", &self.dwVSBRops)
            .field("dwSSBCaps", &self.dwSSBCaps)
            .field("dwSSBCKeyCaps", &self.dwSSBCKeyCaps)
            .field("dwSSBFXCaps", &self.dwSSBFXCaps)
            .field("dwSSBRops", &self.dwSSBRops)
            .field("dwMaxVideoPorts", &self.dwMaxVideoPorts)
            .field("dwCurrVideoPorts", &self.dwCurrVideoPorts)
            .field("dwSVBCaps2", &self.dwSVBCaps2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDCORECAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCKeyCaps == other.dwCKeyCaps
            && self.dwFXCaps == other.dwFXCaps
            && self.dwFXAlphaCaps == other.dwFXAlphaCaps
            && self.dwPalCaps == other.dwPalCaps
            && self.dwSVCaps == other.dwSVCaps
            && self.dwAlphaBltConstBitDepths == other.dwAlphaBltConstBitDepths
            && self.dwAlphaBltPixelBitDepths == other.dwAlphaBltPixelBitDepths
            && self.dwAlphaBltSurfaceBitDepths == other.dwAlphaBltSurfaceBitDepths
            && self.dwAlphaOverlayConstBitDepths == other.dwAlphaOverlayConstBitDepths
            && self.dwAlphaOverlayPixelBitDepths == other.dwAlphaOverlayPixelBitDepths
            && self.dwAlphaOverlaySurfaceBitDepths == other.dwAlphaOverlaySurfaceBitDepths
            && self.dwZBufferBitDepths == other.dwZBufferBitDepths
            && self.dwVidMemTotal == other.dwVidMemTotal
            && self.dwVidMemFree == other.dwVidMemFree
            && self.dwMaxVisibleOverlays == other.dwMaxVisibleOverlays
            && self.dwCurrVisibleOverlays == other.dwCurrVisibleOverlays
            && self.dwNumFourCCCodes == other.dwNumFourCCCodes
            && self.dwAlignBoundarySrc == other.dwAlignBoundarySrc
            && self.dwAlignSizeSrc == other.dwAlignSizeSrc
            && self.dwAlignBoundaryDest == other.dwAlignBoundaryDest
            && self.dwAlignSizeDest == other.dwAlignSizeDest
            && self.dwAlignStrideAlign == other.dwAlignStrideAlign
            && self.dwRops == other.dwRops
            && self.ddsCaps == other.ddsCaps
            && self.dwMinOverlayStretch == other.dwMinOverlayStretch
            && self.dwMaxOverlayStretch == other.dwMaxOverlayStretch
            && self.dwMinLiveVideoStretch == other.dwMinLiveVideoStretch
            && self.dwMaxLiveVideoStretch == other.dwMaxLiveVideoStretch
            && self.dwMinHwCodecStretch == other.dwMinHwCodecStretch
            && self.dwMaxHwCodecStretch == other.dwMaxHwCodecStretch
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwSVBCaps == other.dwSVBCaps
            && self.dwSVBCKeyCaps == other.dwSVBCKeyCaps
            && self.dwSVBFXCaps == other.dwSVBFXCaps
            && self.dwSVBRops == other.dwSVBRops
            && self.dwVSBCaps == other.dwVSBCaps
            && self.dwVSBCKeyCaps == other.dwVSBCKeyCaps
            && self.dwVSBFXCaps == other.dwVSBFXCaps
            && self.dwVSBRops == other.dwVSBRops
            && self.dwSSBCaps == other.dwSSBCaps
            && self.dwSSBCKeyCaps == other.dwSSBCKeyCaps
            && self.dwSSBFXCaps == other.dwSSBFXCaps
            && self.dwSSBRops == other.dwSSBRops
            && self.dwMaxVideoPorts == other.dwMaxVideoPorts
            && self.dwCurrVideoPorts == other.dwCurrVideoPorts
            && self.dwSVBCaps2 == other.dwSVBCaps2
    }
}
impl ::core::cmp::Eq for DDCORECAPS {}
impl FromIntoMemory for DDCORECAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 316);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFXAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwPalCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwSVCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBltConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlphaBltPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlphaBltSurfaceBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlphaOverlayConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlphaOverlayPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaOverlaySurfaceBitDepths =
            <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwZBufferBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwVidMemTotal = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwVidMemFree = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwMaxVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwCurrVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwNumFourCCCodes = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwAlignBoundarySrc = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwAlignSizeSrc = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwAlignBoundaryDest = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_dwAlignSizeDest = <u32 as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dwAlignStrideAlign = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[100..100 + 32]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        let f_dwMinOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[136..136 + 4]);
        let f_dwMaxOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_dwMinLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwMaxLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwMinHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwMaxHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        let f_dwSVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[172..172 + 4]);
        let f_dwSVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[176..176 + 4]);
        let f_dwSVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[180..180 + 4]);
        let f_dwSVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[184..184 + 32]);
        let f_dwVSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[216..216 + 4]);
        let f_dwVSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[220..220 + 4]);
        let f_dwVSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[224..224 + 4]);
        let f_dwVSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[228..228 + 32]);
        let f_dwSSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[260..260 + 4]);
        let f_dwSSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[264..264 + 4]);
        let f_dwSSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[268..268 + 4]);
        let f_dwSSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[272..272 + 32]);
        let f_dwMaxVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[304..304 + 4]);
        let f_dwCurrVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[308..308 + 4]);
        let f_dwSVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[312..312 + 4]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCKeyCaps: f_dwCKeyCaps,
            dwFXCaps: f_dwFXCaps,
            dwFXAlphaCaps: f_dwFXAlphaCaps,
            dwPalCaps: f_dwPalCaps,
            dwSVCaps: f_dwSVCaps,
            dwAlphaBltConstBitDepths: f_dwAlphaBltConstBitDepths,
            dwAlphaBltPixelBitDepths: f_dwAlphaBltPixelBitDepths,
            dwAlphaBltSurfaceBitDepths: f_dwAlphaBltSurfaceBitDepths,
            dwAlphaOverlayConstBitDepths: f_dwAlphaOverlayConstBitDepths,
            dwAlphaOverlayPixelBitDepths: f_dwAlphaOverlayPixelBitDepths,
            dwAlphaOverlaySurfaceBitDepths: f_dwAlphaOverlaySurfaceBitDepths,
            dwZBufferBitDepths: f_dwZBufferBitDepths,
            dwVidMemTotal: f_dwVidMemTotal,
            dwVidMemFree: f_dwVidMemFree,
            dwMaxVisibleOverlays: f_dwMaxVisibleOverlays,
            dwCurrVisibleOverlays: f_dwCurrVisibleOverlays,
            dwNumFourCCCodes: f_dwNumFourCCCodes,
            dwAlignBoundarySrc: f_dwAlignBoundarySrc,
            dwAlignSizeSrc: f_dwAlignSizeSrc,
            dwAlignBoundaryDest: f_dwAlignBoundaryDest,
            dwAlignSizeDest: f_dwAlignSizeDest,
            dwAlignStrideAlign: f_dwAlignStrideAlign,
            dwRops: f_dwRops,
            ddsCaps: f_ddsCaps,
            dwMinOverlayStretch: f_dwMinOverlayStretch,
            dwMaxOverlayStretch: f_dwMaxOverlayStretch,
            dwMinLiveVideoStretch: f_dwMinLiveVideoStretch,
            dwMaxLiveVideoStretch: f_dwMaxLiveVideoStretch,
            dwMinHwCodecStretch: f_dwMinHwCodecStretch,
            dwMaxHwCodecStretch: f_dwMaxHwCodecStretch,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
            dwSVBCaps: f_dwSVBCaps,
            dwSVBCKeyCaps: f_dwSVBCKeyCaps,
            dwSVBFXCaps: f_dwSVBFXCaps,
            dwSVBRops: f_dwSVBRops,
            dwVSBCaps: f_dwVSBCaps,
            dwVSBCKeyCaps: f_dwVSBCKeyCaps,
            dwVSBFXCaps: f_dwVSBFXCaps,
            dwVSBRops: f_dwVSBRops,
            dwSSBCaps: f_dwSSBCaps,
            dwSSBCKeyCaps: f_dwSSBCKeyCaps,
            dwSSBFXCaps: f_dwSSBFXCaps,
            dwSSBRops: f_dwSSBRops,
            dwMaxVideoPorts: f_dwMaxVideoPorts,
            dwCurrVideoPorts: f_dwCurrVideoPorts,
            dwSVBCaps2: f_dwSVBCaps2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 316);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFXAlphaCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwPalCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwSVCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltConstBitDepths, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltPixelBitDepths, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltSurfaceBitDepths, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayConstBitDepths, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayPixelBitDepths, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlaySurfaceBitDepths, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBitDepths, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemTotal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemFree, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVisibleOverlays, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVisibleOverlays, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCCCodes, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundarySrc, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeSrc, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundaryDest, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeDest, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignStrideAlign, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwRops, &mut into[100..100 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[132..132 + 4]);
        FromIntoMemory::into_bytes(self.dwMinOverlayStretch, &mut into[136..136 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlayStretch, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.dwMinLiveVideoStretch, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxLiveVideoStretch, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwMinHwCodecStretch, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHwCodecStretch, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[168..168 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps, &mut into[172..172 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCKeyCaps, &mut into[176..176 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBFXCaps, &mut into[180..180 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBRops, &mut into[184..184 + 32]);
        FromIntoMemory::into_bytes(self.dwVSBCaps, &mut into[216..216 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBCKeyCaps, &mut into[220..220 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBFXCaps, &mut into[224..224 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBRops, &mut into[228..228 + 32]);
        FromIntoMemory::into_bytes(self.dwSSBCaps, &mut into[260..260 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBCKeyCaps, &mut into[264..264 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBFXCaps, &mut into[268..268 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBRops, &mut into[272..272 + 32]);
        FromIntoMemory::into_bytes(self.dwMaxVideoPorts, &mut into[304..304 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVideoPorts, &mut into[308..308 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps2, &mut into[312..312 + 4]);
    }
    fn size() -> usize {
        316
    }
}
pub const DDCREATEDRIVEROBJECT: u32 = 10u32;
pub const DDCREATE_EMULATIONONLY: i32 = 2i32;
pub const DDCREATE_HARDWAREONLY: i32 = 1i32;
pub struct DDDEVICEIDENTIFIER {
    pub szDriver: [super::super::Foundation::CHAR; 512],
    pub szDescription: [super::super::Foundation::CHAR; 512],
    pub liDriverVersion: i64,
    pub dwVendorId: u32,
    pub dwDeviceId: u32,
    pub dwSubSysId: u32,
    pub dwRevision: u32,
    pub guidDeviceIdentifier: crate::core::GUID,
}
impl ::core::marker::Copy for DDDEVICEIDENTIFIER {}
impl ::core::clone::Clone for DDDEVICEIDENTIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDDEVICEIDENTIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDDEVICEIDENTIFIER")
            .field("szDriver", &self.szDriver)
            .field("szDescription", &self.szDescription)
            .field("liDriverVersion", &self.liDriverVersion)
            .field("dwVendorId", &self.dwVendorId)
            .field("dwDeviceId", &self.dwDeviceId)
            .field("dwSubSysId", &self.dwSubSysId)
            .field("dwRevision", &self.dwRevision)
            .field("guidDeviceIdentifier", &self.guidDeviceIdentifier)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDDEVICEIDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.szDriver == other.szDriver
            && self.szDescription == other.szDescription
            && self.liDriverVersion == other.liDriverVersion
            && self.dwVendorId == other.dwVendorId
            && self.dwDeviceId == other.dwDeviceId
            && self.dwSubSysId == other.dwSubSysId
            && self.dwRevision == other.dwRevision
            && self.guidDeviceIdentifier == other.guidDeviceIdentifier
    }
}
impl ::core::cmp::Eq for DDDEVICEIDENTIFIER {}
impl FromIntoMemory for DDDEVICEIDENTIFIER {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 1064);
        let f_szDriver = <[super::super::Foundation::CHAR; 512] as FromIntoMemory>::from_bytes(
            &from[0..0 + 512],
        );
        let f_szDescription = <[super::super::Foundation::CHAR; 512] as FromIntoMemory>::from_bytes(
            &from[512..512 + 512],
        );
        let f_liDriverVersion = <i64 as FromIntoMemory>::from_bytes(&from[1024..1024 + 8]);
        let f_dwVendorId = <u32 as FromIntoMemory>::from_bytes(&from[1032..1032 + 4]);
        let f_dwDeviceId = <u32 as FromIntoMemory>::from_bytes(&from[1036..1036 + 4]);
        let f_dwSubSysId = <u32 as FromIntoMemory>::from_bytes(&from[1040..1040 + 4]);
        let f_dwRevision = <u32 as FromIntoMemory>::from_bytes(&from[1044..1044 + 4]);
        let f_guidDeviceIdentifier =
            <crate::core::GUID as FromIntoMemory>::from_bytes(&from[1048..1048 + 16]);
        Self {
            szDriver: f_szDriver,
            szDescription: f_szDescription,
            liDriverVersion: f_liDriverVersion,
            dwVendorId: f_dwVendorId,
            dwDeviceId: f_dwDeviceId,
            dwSubSysId: f_dwSubSysId,
            dwRevision: f_dwRevision,
            guidDeviceIdentifier: f_guidDeviceIdentifier,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 1064);
        FromIntoMemory::into_bytes(self.szDriver, &mut into[0..0 + 512]);
        FromIntoMemory::into_bytes(self.szDescription, &mut into[512..512 + 512]);
        FromIntoMemory::into_bytes(self.liDriverVersion, &mut into[1024..1024 + 8]);
        FromIntoMemory::into_bytes(self.dwVendorId, &mut into[1032..1032 + 4]);
        FromIntoMemory::into_bytes(self.dwDeviceId, &mut into[1036..1036 + 4]);
        FromIntoMemory::into_bytes(self.dwSubSysId, &mut into[1040..1040 + 4]);
        FromIntoMemory::into_bytes(self.dwRevision, &mut into[1044..1044 + 4]);
        FromIntoMemory::into_bytes(self.guidDeviceIdentifier, &mut into[1048..1048 + 16]);
    }
    fn size() -> usize {
        1064
    }
}
pub struct DDDEVICEIDENTIFIER2 {
    pub szDriver: [super::super::Foundation::CHAR; 512],
    pub szDescription: [super::super::Foundation::CHAR; 512],
    pub liDriverVersion: i64,
    pub dwVendorId: u32,
    pub dwDeviceId: u32,
    pub dwSubSysId: u32,
    pub dwRevision: u32,
    pub guidDeviceIdentifier: crate::core::GUID,
    pub dwWHQLLevel: u32,
}
impl ::core::marker::Copy for DDDEVICEIDENTIFIER2 {}
impl ::core::clone::Clone for DDDEVICEIDENTIFIER2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDDEVICEIDENTIFIER2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDDEVICEIDENTIFIER2")
            .field("szDriver", &self.szDriver)
            .field("szDescription", &self.szDescription)
            .field("liDriverVersion", &self.liDriverVersion)
            .field("dwVendorId", &self.dwVendorId)
            .field("dwDeviceId", &self.dwDeviceId)
            .field("dwSubSysId", &self.dwSubSysId)
            .field("dwRevision", &self.dwRevision)
            .field("guidDeviceIdentifier", &self.guidDeviceIdentifier)
            .field("dwWHQLLevel", &self.dwWHQLLevel)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDDEVICEIDENTIFIER2 {
    fn eq(&self, other: &Self) -> bool {
        self.szDriver == other.szDriver
            && self.szDescription == other.szDescription
            && self.liDriverVersion == other.liDriverVersion
            && self.dwVendorId == other.dwVendorId
            && self.dwDeviceId == other.dwDeviceId
            && self.dwSubSysId == other.dwSubSysId
            && self.dwRevision == other.dwRevision
            && self.guidDeviceIdentifier == other.guidDeviceIdentifier
            && self.dwWHQLLevel == other.dwWHQLLevel
    }
}
impl ::core::cmp::Eq for DDDEVICEIDENTIFIER2 {}
impl FromIntoMemory for DDDEVICEIDENTIFIER2 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 1072);
        let f_szDriver = <[super::super::Foundation::CHAR; 512] as FromIntoMemory>::from_bytes(
            &from[0..0 + 512],
        );
        let f_szDescription = <[super::super::Foundation::CHAR; 512] as FromIntoMemory>::from_bytes(
            &from[512..512 + 512],
        );
        let f_liDriverVersion = <i64 as FromIntoMemory>::from_bytes(&from[1024..1024 + 8]);
        let f_dwVendorId = <u32 as FromIntoMemory>::from_bytes(&from[1032..1032 + 4]);
        let f_dwDeviceId = <u32 as FromIntoMemory>::from_bytes(&from[1036..1036 + 4]);
        let f_dwSubSysId = <u32 as FromIntoMemory>::from_bytes(&from[1040..1040 + 4]);
        let f_dwRevision = <u32 as FromIntoMemory>::from_bytes(&from[1044..1044 + 4]);
        let f_guidDeviceIdentifier =
            <crate::core::GUID as FromIntoMemory>::from_bytes(&from[1048..1048 + 16]);
        let f_dwWHQLLevel = <u32 as FromIntoMemory>::from_bytes(&from[1064..1064 + 4]);
        Self {
            szDriver: f_szDriver,
            szDescription: f_szDescription,
            liDriverVersion: f_liDriverVersion,
            dwVendorId: f_dwVendorId,
            dwDeviceId: f_dwDeviceId,
            dwSubSysId: f_dwSubSysId,
            dwRevision: f_dwRevision,
            guidDeviceIdentifier: f_guidDeviceIdentifier,
            dwWHQLLevel: f_dwWHQLLevel,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 1072);
        FromIntoMemory::into_bytes(self.szDriver, &mut into[0..0 + 512]);
        FromIntoMemory::into_bytes(self.szDescription, &mut into[512..512 + 512]);
        FromIntoMemory::into_bytes(self.liDriverVersion, &mut into[1024..1024 + 8]);
        FromIntoMemory::into_bytes(self.dwVendorId, &mut into[1032..1032 + 4]);
        FromIntoMemory::into_bytes(self.dwDeviceId, &mut into[1036..1036 + 4]);
        FromIntoMemory::into_bytes(self.dwSubSysId, &mut into[1040..1040 + 4]);
        FromIntoMemory::into_bytes(self.dwRevision, &mut into[1044..1044 + 4]);
        FromIntoMemory::into_bytes(self.guidDeviceIdentifier, &mut into[1048..1048 + 16]);
        FromIntoMemory::into_bytes(self.dwWHQLLevel, &mut into[1064..1064 + 4]);
    }
    fn size() -> usize {
        1072
    }
}
pub const DDEDM_REFRESHRATES: i32 = 1i32;
pub const DDEDM_STANDARDVGAMODES: i32 = 2i32;
pub const DDEM_MODEFAILED: i32 = 2i32;
pub const DDEM_MODEPASSED: i32 = 1i32;
pub struct DDENABLEIRQINFO {
    pub dwIRQSources: u32,
    pub dwLine: u32,
    pub IRQCallback: PDX_IRQCALLBACK,
    pub lpIRQData: MutPtr<DX_IRQDATA>,
}
impl ::core::marker::Copy for DDENABLEIRQINFO {}
impl ::core::clone::Clone for DDENABLEIRQINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDENABLEIRQINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDENABLEIRQINFO")
            .field("dwIRQSources", &self.dwIRQSources)
            .field("dwLine", &self.dwLine)
            .field("IRQCallback", &self.IRQCallback)
            .field("lpIRQData", &self.lpIRQData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDENABLEIRQINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwIRQSources == other.dwIRQSources
            && self.dwLine == other.dwLine
            && self.IRQCallback == other.IRQCallback
            && self.lpIRQData == other.lpIRQData
    }
}
impl ::core::cmp::Eq for DDENABLEIRQINFO {}
impl FromIntoMemory for DDENABLEIRQINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwIRQSources = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwLine = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_IRQCallback = <PDX_IRQCALLBACK as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpIRQData = <MutPtr<DX_IRQDATA> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwIRQSources: f_dwIRQSources,
            dwLine: f_dwLine,
            IRQCallback: f_IRQCallback,
            lpIRQData: f_lpIRQData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwIRQSources, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwLine, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.IRQCallback, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpIRQData, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const DDENUMOVERLAYZ_BACKTOFRONT: i32 = 0i32;
pub const DDENUMOVERLAYZ_FRONTTOBACK: i32 = 1i32;
pub const DDENUMRET_CANCEL: u32 = 0u32;
pub const DDENUMRET_OK: u32 = 1u32;
pub const DDENUMSURFACES_ALL: i32 = 1i32;
pub const DDENUMSURFACES_CANBECREATED: i32 = 8i32;
pub const DDENUMSURFACES_DOESEXIST: i32 = 16i32;
pub const DDENUMSURFACES_MATCH: i32 = 2i32;
pub const DDENUMSURFACES_NOMATCH: i32 = 4i32;
pub const DDENUM_ATTACHEDSECONDARYDEVICES: i32 = 1i32;
pub const DDENUM_DETACHEDSECONDARYDEVICES: i32 = 2i32;
pub const DDENUM_NONDISPLAYDEVICES: i32 = 4i32;
pub const DDERR_NOTINITIALIZED: i32 = -2147221008i32;
pub struct DDFLIPOVERLAYINFO {
    pub lpCurrentSurface: MutPtr<DDSURFACEDATA>,
    pub lpTargetSurface: MutPtr<DDSURFACEDATA>,
    pub dwFlags: u32,
}
impl ::core::marker::Copy for DDFLIPOVERLAYINFO {}
impl ::core::clone::Clone for DDFLIPOVERLAYINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDFLIPOVERLAYINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDFLIPOVERLAYINFO")
            .field("lpCurrentSurface", &self.lpCurrentSurface)
            .field("lpTargetSurface", &self.lpTargetSurface)
            .field("dwFlags", &self.dwFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDFLIPOVERLAYINFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpCurrentSurface == other.lpCurrentSurface
            && self.lpTargetSurface == other.lpTargetSurface
            && self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for DDFLIPOVERLAYINFO {}
impl FromIntoMemory for DDFLIPOVERLAYINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_lpCurrentSurface =
            <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpTargetSurface =
            <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            lpCurrentSurface: f_lpCurrentSurface,
            lpTargetSurface: f_lpTargetSurface,
            dwFlags: f_dwFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.lpCurrentSurface, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpTargetSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DDFLIPVIDEOPORTINFO {
    pub lpVideoPortData: MutPtr<DDVIDEOPORTDATA>,
    pub lpCurrentSurface: MutPtr<DDSURFACEDATA>,
    pub lpTargetSurface: MutPtr<DDSURFACEDATA>,
    pub dwFlipVPFlags: u32,
}
impl ::core::marker::Copy for DDFLIPVIDEOPORTINFO {}
impl ::core::clone::Clone for DDFLIPVIDEOPORTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDFLIPVIDEOPORTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDFLIPVIDEOPORTINFO")
            .field("lpVideoPortData", &self.lpVideoPortData)
            .field("lpCurrentSurface", &self.lpCurrentSurface)
            .field("lpTargetSurface", &self.lpTargetSurface)
            .field("dwFlipVPFlags", &self.dwFlipVPFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDFLIPVIDEOPORTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpVideoPortData == other.lpVideoPortData
            && self.lpCurrentSurface == other.lpCurrentSurface
            && self.lpTargetSurface == other.lpTargetSurface
            && self.dwFlipVPFlags == other.dwFlipVPFlags
    }
}
impl ::core::cmp::Eq for DDFLIPVIDEOPORTINFO {}
impl FromIntoMemory for DDFLIPVIDEOPORTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpVideoPortData =
            <MutPtr<DDVIDEOPORTDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpCurrentSurface =
            <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpTargetSurface =
            <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlipVPFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpVideoPortData: f_lpVideoPortData,
            lpCurrentSurface: f_lpCurrentSurface,
            lpTargetSurface: f_lpTargetSurface,
            dwFlipVPFlags: f_dwFlipVPFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpVideoPortData, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpCurrentSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpTargetSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlipVPFlags, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const DDFLIP_DONOTWAIT: i32 = 32i32;
pub const DDFLIP_EVEN: i32 = 2i32;
pub const DDFLIP_INTERVAL2: i32 = 33554432i32;
pub const DDFLIP_INTERVAL3: i32 = 50331648i32;
pub const DDFLIP_INTERVAL4: i32 = 67108864i32;
pub const DDFLIP_NOVSYNC: i32 = 8i32;
pub const DDFLIP_ODD: i32 = 4i32;
pub const DDFLIP_STEREO: i32 = 16i32;
pub const DDFLIP_WAIT: i32 = 1i32;
pub const DDFXALPHACAPS_BLTALPHAEDGEBLEND: i32 = 1i32;
pub const DDFXALPHACAPS_BLTALPHAPIXELS: i32 = 2i32;
pub const DDFXALPHACAPS_BLTALPHAPIXELSNEG: i32 = 4i32;
pub const DDFXALPHACAPS_BLTALPHASURFACES: i32 = 8i32;
pub const DDFXALPHACAPS_BLTALPHASURFACESNEG: i32 = 16i32;
pub const DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND: i32 = 32i32;
pub const DDFXALPHACAPS_OVERLAYALPHAPIXELS: i32 = 64i32;
pub const DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG: i32 = 128i32;
pub const DDFXALPHACAPS_OVERLAYALPHASURFACES: i32 = 256i32;
pub const DDFXALPHACAPS_OVERLAYALPHASURFACESNEG: i32 = 512i32;
pub const DDFXCAPS_BLTALPHA: i32 = 1i32;
pub const DDFXCAPS_BLTARITHSTRETCHY: i32 = 32i32;
pub const DDFXCAPS_BLTARITHSTRETCHYN: i32 = 16i32;
pub const DDFXCAPS_BLTFILTER: i32 = 32i32;
pub const DDFXCAPS_BLTMIRRORLEFTRIGHT: i32 = 64i32;
pub const DDFXCAPS_BLTMIRRORUPDOWN: i32 = 128i32;
pub const DDFXCAPS_BLTROTATION: i32 = 256i32;
pub const DDFXCAPS_BLTROTATION90: i32 = 512i32;
pub const DDFXCAPS_BLTSHRINKX: i32 = 1024i32;
pub const DDFXCAPS_BLTSHRINKXN: i32 = 2048i32;
pub const DDFXCAPS_BLTSHRINKY: i32 = 4096i32;
pub const DDFXCAPS_BLTSHRINKYN: i32 = 8192i32;
pub const DDFXCAPS_BLTSTRETCHX: i32 = 16384i32;
pub const DDFXCAPS_BLTSTRETCHXN: i32 = 32768i32;
pub const DDFXCAPS_BLTSTRETCHY: i32 = 65536i32;
pub const DDFXCAPS_BLTSTRETCHYN: i32 = 131072i32;
pub const DDFXCAPS_OVERLAYALPHA: i32 = 4i32;
pub const DDFXCAPS_OVERLAYARITHSTRETCHY: i32 = 262144i32;
pub const DDFXCAPS_OVERLAYARITHSTRETCHYN: i32 = 8i32;
pub const DDFXCAPS_OVERLAYDEINTERLACE: i32 = 536870912i32;
pub const DDFXCAPS_OVERLAYFILTER: i32 = 262144i32;
pub const DDFXCAPS_OVERLAYMIRRORLEFTRIGHT: i32 = 134217728i32;
pub const DDFXCAPS_OVERLAYMIRRORUPDOWN: i32 = 268435456i32;
pub const DDFXCAPS_OVERLAYSHRINKX: i32 = 524288i32;
pub const DDFXCAPS_OVERLAYSHRINKXN: i32 = 1048576i32;
pub const DDFXCAPS_OVERLAYSHRINKY: i32 = 2097152i32;
pub const DDFXCAPS_OVERLAYSHRINKYN: i32 = 4194304i32;
pub const DDFXCAPS_OVERLAYSTRETCHX: i32 = 8388608i32;
pub const DDFXCAPS_OVERLAYSTRETCHXN: i32 = 16777216i32;
pub const DDFXCAPS_OVERLAYSTRETCHY: i32 = 33554432i32;
pub const DDFXCAPS_OVERLAYSTRETCHYN: i32 = 67108864i32;
pub struct DDGAMMARAMP {
    pub red: [u16; 256],
    pub green: [u16; 256],
    pub blue: [u16; 256],
}
impl ::core::marker::Copy for DDGAMMARAMP {}
impl ::core::clone::Clone for DDGAMMARAMP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGAMMARAMP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGAMMARAMP")
            .field("red", &self.red)
            .field("green", &self.green)
            .field("blue", &self.blue)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGAMMARAMP {
    fn eq(&self, other: &Self) -> bool {
        self.red == other.red && self.green == other.green && self.blue == other.blue
    }
}
impl ::core::cmp::Eq for DDGAMMARAMP {}
impl FromIntoMemory for DDGAMMARAMP {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 1536);
        let f_red = <[u16; 256] as FromIntoMemory>::from_bytes(&from[0..0 + 512]);
        let f_green = <[u16; 256] as FromIntoMemory>::from_bytes(&from[512..512 + 512]);
        let f_blue = <[u16; 256] as FromIntoMemory>::from_bytes(&from[1024..1024 + 512]);
        Self {
            red: f_red,
            green: f_green,
            blue: f_blue,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 1536);
        FromIntoMemory::into_bytes(self.red, &mut into[0..0 + 512]);
        FromIntoMemory::into_bytes(self.green, &mut into[512..512 + 512]);
        FromIntoMemory::into_bytes(self.blue, &mut into[1024..1024 + 512]);
    }
    fn size() -> usize {
        1536
    }
}
pub const DDGBS_CANBLT: i32 = 1i32;
pub const DDGBS_ISBLTDONE: i32 = 2i32;
pub const DDGDI_GETHOSTIDENTIFIER: i32 = 1i32;
pub const DDGET32BITDRIVERNAME: u32 = 11u32;
pub struct DDGETCURRENTAUTOFLIPININFO {
    pub lpVideoPortData: MutPtr<DDVIDEOPORTDATA>,
}
impl ::core::marker::Copy for DDGETCURRENTAUTOFLIPININFO {}
impl ::core::clone::Clone for DDGETCURRENTAUTOFLIPININFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETCURRENTAUTOFLIPININFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETCURRENTAUTOFLIPININFO")
            .field("lpVideoPortData", &self.lpVideoPortData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETCURRENTAUTOFLIPININFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpVideoPortData == other.lpVideoPortData
    }
}
impl ::core::cmp::Eq for DDGETCURRENTAUTOFLIPININFO {}
impl FromIntoMemory for DDGETCURRENTAUTOFLIPININFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_lpVideoPortData =
            <MutPtr<DDVIDEOPORTDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            lpVideoPortData: f_lpVideoPortData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.lpVideoPortData, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDGETCURRENTAUTOFLIPOUTINFO {
    pub dwSurfaceIndex: u32,
    pub dwVBISurfaceIndex: u32,
}
impl ::core::marker::Copy for DDGETCURRENTAUTOFLIPOUTINFO {}
impl ::core::clone::Clone for DDGETCURRENTAUTOFLIPOUTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETCURRENTAUTOFLIPOUTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETCURRENTAUTOFLIPOUTINFO")
            .field("dwSurfaceIndex", &self.dwSurfaceIndex)
            .field("dwVBISurfaceIndex", &self.dwVBISurfaceIndex)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETCURRENTAUTOFLIPOUTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSurfaceIndex == other.dwSurfaceIndex
            && self.dwVBISurfaceIndex == other.dwVBISurfaceIndex
    }
}
impl ::core::cmp::Eq for DDGETCURRENTAUTOFLIPOUTINFO {}
impl FromIntoMemory for DDGETCURRENTAUTOFLIPOUTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_dwSurfaceIndex = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwVBISurfaceIndex = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            dwSurfaceIndex: f_dwSurfaceIndex,
            dwVBISurfaceIndex: f_dwVBISurfaceIndex,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.dwSurfaceIndex, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwVBISurfaceIndex, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub struct DDGETIRQINFO {
    pub dwFlags: u32,
}
impl ::core::marker::Copy for DDGETIRQINFO {}
impl ::core::clone::Clone for DDGETIRQINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETIRQINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETIRQINFO")
            .field("dwFlags", &self.dwFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETIRQINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for DDGETIRQINFO {}
impl FromIntoMemory for DDGETIRQINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self { dwFlags: f_dwFlags }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDGETPOLARITYININFO {
    pub lpVideoPortData: MutPtr<DDVIDEOPORTDATA>,
}
impl ::core::marker::Copy for DDGETPOLARITYININFO {}
impl ::core::clone::Clone for DDGETPOLARITYININFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETPOLARITYININFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETPOLARITYININFO")
            .field("lpVideoPortData", &self.lpVideoPortData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETPOLARITYININFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpVideoPortData == other.lpVideoPortData
    }
}
impl ::core::cmp::Eq for DDGETPOLARITYININFO {}
impl FromIntoMemory for DDGETPOLARITYININFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_lpVideoPortData =
            <MutPtr<DDVIDEOPORTDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            lpVideoPortData: f_lpVideoPortData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.lpVideoPortData, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDGETPOLARITYOUTINFO {
    pub bPolarity: u32,
}
impl ::core::marker::Copy for DDGETPOLARITYOUTINFO {}
impl ::core::clone::Clone for DDGETPOLARITYOUTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETPOLARITYOUTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETPOLARITYOUTINFO")
            .field("bPolarity", &self.bPolarity)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETPOLARITYOUTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.bPolarity == other.bPolarity
    }
}
impl ::core::cmp::Eq for DDGETPOLARITYOUTINFO {}
impl FromIntoMemory for DDGETPOLARITYOUTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_bPolarity = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            bPolarity: f_bPolarity,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.bPolarity, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDGETPREVIOUSAUTOFLIPININFO {
    pub lpVideoPortData: MutPtr<DDVIDEOPORTDATA>,
}
impl ::core::marker::Copy for DDGETPREVIOUSAUTOFLIPININFO {}
impl ::core::clone::Clone for DDGETPREVIOUSAUTOFLIPININFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETPREVIOUSAUTOFLIPININFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETPREVIOUSAUTOFLIPININFO")
            .field("lpVideoPortData", &self.lpVideoPortData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETPREVIOUSAUTOFLIPININFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpVideoPortData == other.lpVideoPortData
    }
}
impl ::core::cmp::Eq for DDGETPREVIOUSAUTOFLIPININFO {}
impl FromIntoMemory for DDGETPREVIOUSAUTOFLIPININFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_lpVideoPortData =
            <MutPtr<DDVIDEOPORTDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            lpVideoPortData: f_lpVideoPortData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.lpVideoPortData, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDGETPREVIOUSAUTOFLIPOUTINFO {
    pub dwSurfaceIndex: u32,
    pub dwVBISurfaceIndex: u32,
}
impl ::core::marker::Copy for DDGETPREVIOUSAUTOFLIPOUTINFO {}
impl ::core::clone::Clone for DDGETPREVIOUSAUTOFLIPOUTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETPREVIOUSAUTOFLIPOUTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETPREVIOUSAUTOFLIPOUTINFO")
            .field("dwSurfaceIndex", &self.dwSurfaceIndex)
            .field("dwVBISurfaceIndex", &self.dwVBISurfaceIndex)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETPREVIOUSAUTOFLIPOUTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSurfaceIndex == other.dwSurfaceIndex
            && self.dwVBISurfaceIndex == other.dwVBISurfaceIndex
    }
}
impl ::core::cmp::Eq for DDGETPREVIOUSAUTOFLIPOUTINFO {}
impl FromIntoMemory for DDGETPREVIOUSAUTOFLIPOUTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_dwSurfaceIndex = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwVBISurfaceIndex = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            dwSurfaceIndex: f_dwSurfaceIndex,
            dwVBISurfaceIndex: f_dwVBISurfaceIndex,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.dwSurfaceIndex, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwVBISurfaceIndex, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub struct DDGETTRANSFERSTATUSOUTINFO {
    pub dwTransferID: PtrRepr,
}
impl ::core::marker::Copy for DDGETTRANSFERSTATUSOUTINFO {}
impl ::core::clone::Clone for DDGETTRANSFERSTATUSOUTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDGETTRANSFERSTATUSOUTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDGETTRANSFERSTATUSOUTINFO")
            .field("dwTransferID", &self.dwTransferID)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDGETTRANSFERSTATUSOUTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwTransferID == other.dwTransferID
    }
}
impl ::core::cmp::Eq for DDGETTRANSFERSTATUSOUTINFO {}
impl FromIntoMemory for DDGETTRANSFERSTATUSOUTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwTransferID = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            dwTransferID: f_dwTransferID,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwTransferID, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub const DDGFS_CANFLIP: i32 = 1i32;
pub const DDGFS_ISFLIPDONE: i32 = 2i32;
pub struct DDHALDDRAWFNS {
    pub dwSize: u32,
    pub lpSetInfo: LPDDHAL_SETINFO,
    pub lpVidMemAlloc: LPDDHAL_VIDMEMALLOC,
    pub lpVidMemFree: LPDDHAL_VIDMEMFREE,
}
impl ::core::marker::Copy for DDHALDDRAWFNS {}
impl ::core::clone::Clone for DDHALDDRAWFNS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHALDDRAWFNS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHALDDRAWFNS")
            .field("dwSize", &self.dwSize)
            .field("lpSetInfo", &self.lpSetInfo)
            .field("lpVidMemAlloc", &self.lpVidMemAlloc)
            .field("lpVidMemFree", &self.lpVidMemFree)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHALDDRAWFNS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpSetInfo == other.lpSetInfo
            && self.lpVidMemAlloc == other.lpVidMemAlloc
            && self.lpVidMemFree == other.lpVidMemFree
    }
}
impl ::core::cmp::Eq for DDHALDDRAWFNS {}
impl FromIntoMemory for DDHALDDRAWFNS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpSetInfo = <LPDDHAL_SETINFO as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpVidMemAlloc = <LPDDHAL_VIDMEMALLOC as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVidMemFree = <LPDDHAL_VIDMEMFREE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwSize: f_dwSize,
            lpSetInfo: f_lpSetInfo,
            lpVidMemAlloc: f_lpVidMemAlloc,
            lpVidMemFree: f_lpVidMemFree,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpSetInfo, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpVidMemAlloc, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVidMemFree, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHALINFO {
    pub dwSize: u32,
    pub lpDDCallbacks: MutPtr<DDHAL_DDCALLBACKS>,
    pub lpDDSurfaceCallbacks: MutPtr<DDHAL_DDSURFACECALLBACKS>,
    pub lpDDPaletteCallbacks: MutPtr<DDHAL_DDPALETTECALLBACKS>,
    pub vmiData: VIDMEMINFO,
    pub ddCaps: DDCORECAPS,
    pub dwMonitorFrequency: u32,
    pub GetDriverInfo: LPDDHAL_GETDRIVERINFO,
    pub dwModeIndex: u32,
    pub lpdwFourCC: MutPtr<u32>,
    pub dwNumModes: u32,
    pub lpModeInfo: MutPtr<DDHALMODEINFO>,
    pub dwFlags: u32,
    pub lpPDevice: MutPtr<::core::ffi::c_void>,
    pub hInstance: u32,
    pub lpD3DGlobalDriverData: PtrRepr,
    pub lpD3DHALCallbacks: PtrRepr,
    pub lpDDExeBufCallbacks: MutPtr<DDHAL_DDEXEBUFCALLBACKS>,
}
impl ::core::marker::Copy for DDHALINFO {}
impl ::core::clone::Clone for DDHALINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHALINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpDDCallbacks == other.lpDDCallbacks
            && self.lpDDSurfaceCallbacks == other.lpDDSurfaceCallbacks
            && self.lpDDPaletteCallbacks == other.lpDDPaletteCallbacks
            && self.vmiData == other.vmiData
            && self.ddCaps == other.ddCaps
            && self.dwMonitorFrequency == other.dwMonitorFrequency
            && self.GetDriverInfo == other.GetDriverInfo
            && self.dwModeIndex == other.dwModeIndex
            && self.lpdwFourCC == other.lpdwFourCC
            && self.dwNumModes == other.dwNumModes
            && self.lpModeInfo == other.lpModeInfo
            && self.dwFlags == other.dwFlags
            && self.lpPDevice == other.lpPDevice
            && self.hInstance == other.hInstance
            && self.lpD3DGlobalDriverData == other.lpD3DGlobalDriverData
            && self.lpD3DHALCallbacks == other.lpD3DHALCallbacks
            && self.lpDDExeBufCallbacks == other.lpDDExeBufCallbacks
    }
}
impl ::core::cmp::Eq for DDHALINFO {}
impl FromIntoMemory for DDHALINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 460);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDCallbacks =
            <MutPtr<DDHAL_DDCALLBACKS> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDSurfaceCallbacks =
            <MutPtr<DDHAL_DDSURFACECALLBACKS> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpDDPaletteCallbacks =
            <MutPtr<DDHAL_DDPALETTECALLBACKS> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_vmiData = <VIDMEMINFO as FromIntoMemory>::from_bytes(&from[16..16 + 80]);
        let f_ddCaps = <DDCORECAPS as FromIntoMemory>::from_bytes(&from[96..96 + 316]);
        let f_dwMonitorFrequency = <u32 as FromIntoMemory>::from_bytes(&from[412..412 + 4]);
        let f_GetDriverInfo =
            <LPDDHAL_GETDRIVERINFO as FromIntoMemory>::from_bytes(&from[416..416 + 4]);
        let f_dwModeIndex = <u32 as FromIntoMemory>::from_bytes(&from[420..420 + 4]);
        let f_lpdwFourCC = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[424..424 + 4]);
        let f_dwNumModes = <u32 as FromIntoMemory>::from_bytes(&from[428..428 + 4]);
        let f_lpModeInfo =
            <MutPtr<DDHALMODEINFO> as FromIntoMemory>::from_bytes(&from[432..432 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[436..436 + 4]);
        let f_lpPDevice =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[440..440 + 4]);
        let f_hInstance = <u32 as FromIntoMemory>::from_bytes(&from[444..444 + 4]);
        let f_lpD3DGlobalDriverData = <PtrRepr as FromIntoMemory>::from_bytes(&from[448..448 + 4]);
        let f_lpD3DHALCallbacks = <PtrRepr as FromIntoMemory>::from_bytes(&from[452..452 + 4]);
        let f_lpDDExeBufCallbacks =
            <MutPtr<DDHAL_DDEXEBUFCALLBACKS> as FromIntoMemory>::from_bytes(&from[456..456 + 4]);
        Self {
            dwSize: f_dwSize,
            lpDDCallbacks: f_lpDDCallbacks,
            lpDDSurfaceCallbacks: f_lpDDSurfaceCallbacks,
            lpDDPaletteCallbacks: f_lpDDPaletteCallbacks,
            vmiData: f_vmiData,
            ddCaps: f_ddCaps,
            dwMonitorFrequency: f_dwMonitorFrequency,
            GetDriverInfo: f_GetDriverInfo,
            dwModeIndex: f_dwModeIndex,
            lpdwFourCC: f_lpdwFourCC,
            dwNumModes: f_dwNumModes,
            lpModeInfo: f_lpModeInfo,
            dwFlags: f_dwFlags,
            lpPDevice: f_lpPDevice,
            hInstance: f_hInstance,
            lpD3DGlobalDriverData: f_lpD3DGlobalDriverData,
            lpD3DHALCallbacks: f_lpD3DHALCallbacks,
            lpDDExeBufCallbacks: f_lpDDExeBufCallbacks,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 460);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDCallbacks, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurfaceCallbacks, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPaletteCallbacks, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.vmiData, &mut into[16..16 + 80]);
        FromIntoMemory::into_bytes(self.ddCaps, &mut into[96..96 + 316]);
        FromIntoMemory::into_bytes(self.dwMonitorFrequency, &mut into[412..412 + 4]);
        FromIntoMemory::into_bytes(self.GetDriverInfo, &mut into[416..416 + 4]);
        FromIntoMemory::into_bytes(self.dwModeIndex, &mut into[420..420 + 4]);
        FromIntoMemory::into_bytes(self.lpdwFourCC, &mut into[424..424 + 4]);
        FromIntoMemory::into_bytes(self.dwNumModes, &mut into[428..428 + 4]);
        FromIntoMemory::into_bytes(self.lpModeInfo, &mut into[432..432 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[436..436 + 4]);
        FromIntoMemory::into_bytes(self.lpPDevice, &mut into[440..440 + 4]);
        FromIntoMemory::into_bytes(self.hInstance, &mut into[444..444 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DGlobalDriverData, &mut into[448..448 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DHALCallbacks, &mut into[452..452 + 4]);
        FromIntoMemory::into_bytes(self.lpDDExeBufCallbacks, &mut into[456..456 + 4]);
    }
    fn size() -> usize {
        460
    }
}
pub const DDHALINFO_GETDRIVERINFO2: i32 = 8i32;
pub const DDHALINFO_GETDRIVERINFOSET: i32 = 4i32;
pub const DDHALINFO_ISPRIMARYDISPLAY: i32 = 1i32;
pub const DDHALINFO_MODEXILLEGAL: i32 = 2i32;
pub struct DDHALMODEINFO {
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub lPitch: i32,
    pub dwBPP: u32,
    pub wFlags: u16,
    pub wRefreshRate: u16,
    pub dwRBitMask: u32,
    pub dwGBitMask: u32,
    pub dwBBitMask: u32,
    pub dwAlphaBitMask: u32,
}
impl ::core::marker::Copy for DDHALMODEINFO {}
impl ::core::clone::Clone for DDHALMODEINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHALMODEINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHALMODEINFO")
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("lPitch", &self.lPitch)
            .field("dwBPP", &self.dwBPP)
            .field("wFlags", &self.wFlags)
            .field("wRefreshRate", &self.wRefreshRate)
            .field("dwRBitMask", &self.dwRBitMask)
            .field("dwGBitMask", &self.dwGBitMask)
            .field("dwBBitMask", &self.dwBBitMask)
            .field("dwAlphaBitMask", &self.dwAlphaBitMask)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHALMODEINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.lPitch == other.lPitch
            && self.dwBPP == other.dwBPP
            && self.wFlags == other.wFlags
            && self.wRefreshRate == other.wRefreshRate
            && self.dwRBitMask == other.dwRBitMask
            && self.dwGBitMask == other.dwGBitMask
            && self.dwBBitMask == other.dwBBitMask
            && self.dwAlphaBitMask == other.dwAlphaBitMask
    }
}
impl ::core::cmp::Eq for DDHALMODEINFO {}
impl FromIntoMemory for DDHALMODEINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lPitch = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwBPP = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_wFlags = <u16 as FromIntoMemory>::from_bytes(&from[16..16 + 2]);
        let f_wRefreshRate = <u16 as FromIntoMemory>::from_bytes(&from[18..18 + 2]);
        let f_dwRBitMask = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwGBitMask = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwBBitMask = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBitMask = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            lPitch: f_lPitch,
            dwBPP: f_dwBPP,
            wFlags: f_wFlags,
            wRefreshRate: f_wRefreshRate,
            dwRBitMask: f_dwRBitMask,
            dwGBitMask: f_dwGBitMask,
            dwBBitMask: f_dwBBitMask,
            dwAlphaBitMask: f_dwAlphaBitMask,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lPitch, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwBPP, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.wFlags, &mut into[16..16 + 2]);
        FromIntoMemory::into_bytes(self.wRefreshRate, &mut into[18..18 + 2]);
        FromIntoMemory::into_bytes(self.dwRBitMask, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwGBitMask, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwBBitMask, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBitMask, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct DDHAL_ADDATTACHEDSURFACEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpSurfAttached: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub AddAttachedSurface: LPDDHALSURFCB_ADDATTACHEDSURFACE,
}
impl ::core::marker::Copy for DDHAL_ADDATTACHEDSURFACEDATA {}
impl ::core::clone::Clone for DDHAL_ADDATTACHEDSURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_ADDATTACHEDSURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_ADDATTACHEDSURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("lpSurfAttached", &self.lpSurfAttached)
            .field("ddRVal", &self.ddRVal)
            .field("AddAttachedSurface", &self.AddAttachedSurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_ADDATTACHEDSURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.lpSurfAttached == other.lpSurfAttached
            && self.ddRVal == other.ddRVal
            && self.AddAttachedSurface == other.AddAttachedSurface
    }
}
impl ::core::cmp::Eq for DDHAL_ADDATTACHEDSURFACEDATA {}
impl FromIntoMemory for DDHAL_ADDATTACHEDSURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurfAttached =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_AddAttachedSurface =
            <LPDDHALSURFCB_ADDATTACHEDSURFACE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            lpSurfAttached: f_lpSurfAttached,
            ddRVal: f_ddRVal,
            AddAttachedSurface: f_AddAttachedSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfAttached, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.AddAttachedSurface, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub const DDHAL_APP_DLLNAME: &'static str = "DDRAW.DLL";
pub struct DDHAL_BEGINMOCOMPFRAMEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpMoComp: MutPtr<DDRAWI_DDMOTIONCOMP_LCL>,
    pub lpDestSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwInputDataSize: u32,
    pub lpInputData: MutPtr<::core::ffi::c_void>,
    pub dwOutputDataSize: u32,
    pub lpOutputData: MutPtr<::core::ffi::c_void>,
    pub ddRVal: crate::core::HRESULT,
    pub BeginMoCompFrame: LPDDHALMOCOMPCB_BEGINFRAME,
}
impl ::core::marker::Copy for DDHAL_BEGINMOCOMPFRAMEDATA {}
impl ::core::clone::Clone for DDHAL_BEGINMOCOMPFRAMEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_BEGINMOCOMPFRAMEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_BEGINMOCOMPFRAMEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("lpDestSurface", &self.lpDestSurface)
            .field("dwInputDataSize", &self.dwInputDataSize)
            .field("lpInputData", &self.lpInputData)
            .field("dwOutputDataSize", &self.dwOutputDataSize)
            .field("lpOutputData", &self.lpOutputData)
            .field("ddRVal", &self.ddRVal)
            .field("BeginMoCompFrame", &self.BeginMoCompFrame)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_BEGINMOCOMPFRAMEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpDestSurface == other.lpDestSurface
            && self.dwInputDataSize == other.dwInputDataSize
            && self.lpInputData == other.lpInputData
            && self.dwOutputDataSize == other.dwOutputDataSize
            && self.lpOutputData == other.lpOutputData
            && self.ddRVal == other.ddRVal
            && self.BeginMoCompFrame == other.BeginMoCompFrame
    }
}
impl ::core::cmp::Eq for DDHAL_BEGINMOCOMPFRAMEDATA {}
impl FromIntoMemory for DDHAL_BEGINMOCOMPFRAMEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DDRAWI_DDMOTIONCOMP_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDestSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwInputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpInputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwOutputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpOutputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_BeginMoCompFrame =
            <LPDDHALMOCOMPCB_BEGINFRAME as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpDestSurface: f_lpDestSurface,
            dwInputDataSize: f_dwInputDataSize,
            lpInputData: f_lpInputData,
            dwOutputDataSize: f_dwOutputDataSize,
            lpOutputData: f_lpOutputData,
            ddRVal: f_ddRVal,
            BeginMoCompFrame: f_BeginMoCompFrame,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDestSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwInputDataSize, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpInputData, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwOutputDataSize, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpOutputData, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.BeginMoCompFrame, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct DDHAL_BLTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDDestSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub rDest: super::super::Foundation::RECTL,
    pub lpDDSrcSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub rSrc: super::super::Foundation::RECTL,
    pub dwFlags: u32,
    pub dwROPFlags: u32,
    pub bltFX: DDBLTFX,
    pub ddRVal: crate::core::HRESULT,
    pub Blt: LPDDHALSURFCB_BLT,
    pub IsClipped: super::super::Foundation::BOOL,
    pub rOrigDest: super::super::Foundation::RECTL,
    pub rOrigSrc: super::super::Foundation::RECTL,
    pub dwRectCnt: u32,
    pub prDestRects: MutPtr<super::super::Foundation::RECT>,
}
impl ::core::marker::Copy for DDHAL_BLTDATA {}
impl ::core::clone::Clone for DDHAL_BLTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_BLTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDDestSurface == other.lpDDDestSurface
            && self.rDest == other.rDest
            && self.lpDDSrcSurface == other.lpDDSrcSurface
            && self.rSrc == other.rSrc
            && self.dwFlags == other.dwFlags
            && self.dwROPFlags == other.dwROPFlags
            && self.bltFX == other.bltFX
            && self.ddRVal == other.ddRVal
            && self.Blt == other.Blt
            && self.IsClipped == other.IsClipped
            && self.rOrigDest == other.rOrigDest
            && self.rOrigSrc == other.rOrigSrc
            && self.dwRectCnt == other.dwRectCnt
            && self.prDestRects == other.prDestRects
    }
}
impl ::core::cmp::Eq for DDHAL_BLTDATA {}
impl FromIntoMemory for DDHAL_BLTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 204);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDDestSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_rDest =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_lpDDSrcSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_rSrc =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[28..28 + 16]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwROPFlags = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_bltFX = <DDBLTFX as FromIntoMemory>::from_bytes(&from[52..52 + 100]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_Blt = <LPDDHALSURFCB_BLT as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_IsClipped =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_rOrigDest =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[164..164 + 16]);
        let f_rOrigSrc =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[180..180 + 16]);
        let f_dwRectCnt = <u32 as FromIntoMemory>::from_bytes(&from[196..196 + 4]);
        let f_prDestRects = <MutPtr<super::super::Foundation::RECT> as FromIntoMemory>::from_bytes(
            &from[200..200 + 4],
        );
        Self {
            lpDD: f_lpDD,
            lpDDDestSurface: f_lpDDDestSurface,
            rDest: f_rDest,
            lpDDSrcSurface: f_lpDDSrcSurface,
            rSrc: f_rSrc,
            dwFlags: f_dwFlags,
            dwROPFlags: f_dwROPFlags,
            bltFX: f_bltFX,
            ddRVal: f_ddRVal,
            Blt: f_Blt,
            IsClipped: f_IsClipped,
            rOrigDest: f_rOrigDest,
            rOrigSrc: f_rOrigSrc,
            dwRectCnt: f_dwRectCnt,
            prDestRects: f_prDestRects,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 204);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDDestSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.rDest, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.lpDDSrcSurface, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.rSrc, &mut into[28..28 + 16]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwROPFlags, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.bltFX, &mut into[52..52 + 100]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.Blt, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.IsClipped, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.rOrigDest, &mut into[164..164 + 16]);
        FromIntoMemory::into_bytes(self.rOrigSrc, &mut into[180..180 + 16]);
        FromIntoMemory::into_bytes(self.dwRectCnt, &mut into[196..196 + 4]);
        FromIntoMemory::into_bytes(self.prDestRects, &mut into[200..200 + 4]);
    }
    fn size() -> usize {
        204
    }
}
pub struct DDHAL_CALLBACKS {
    pub cbDDCallbacks: DDHAL_DDCALLBACKS,
    pub cbDDSurfaceCallbacks: DDHAL_DDSURFACECALLBACKS,
    pub cbDDPaletteCallbacks: DDHAL_DDPALETTECALLBACKS,
    pub HALDD: DDHAL_DDCALLBACKS,
    pub HALDDSurface: DDHAL_DDSURFACECALLBACKS,
    pub HALDDPalette: DDHAL_DDPALETTECALLBACKS,
    pub HELDD: DDHAL_DDCALLBACKS,
    pub HELDDSurface: DDHAL_DDSURFACECALLBACKS,
    pub HELDDPalette: DDHAL_DDPALETTECALLBACKS,
    pub cbDDExeBufCallbacks: DDHAL_DDEXEBUFCALLBACKS,
    pub HALDDExeBuf: DDHAL_DDEXEBUFCALLBACKS,
    pub HELDDExeBuf: DDHAL_DDEXEBUFCALLBACKS,
    pub cbDDVideoPortCallbacks: DDHAL_DDVIDEOPORTCALLBACKS,
    pub HALDDVideoPort: DDHAL_DDVIDEOPORTCALLBACKS,
    pub cbDDColorControlCallbacks: DDHAL_DDCOLORCONTROLCALLBACKS,
    pub HALDDColorControl: DDHAL_DDCOLORCONTROLCALLBACKS,
    pub cbDDMiscellaneousCallbacks: DDHAL_DDMISCELLANEOUSCALLBACKS,
    pub HALDDMiscellaneous: DDHAL_DDMISCELLANEOUSCALLBACKS,
    pub cbDDKernelCallbacks: DDHAL_DDKERNELCALLBACKS,
    pub HALDDKernel: DDHAL_DDKERNELCALLBACKS,
    pub cbDDMotionCompCallbacks: DDHAL_DDMOTIONCOMPCALLBACKS,
    pub HALDDMotionComp: DDHAL_DDMOTIONCOMPCALLBACKS,
}
impl ::core::marker::Copy for DDHAL_CALLBACKS {}
impl ::core::clone::Clone for DDHAL_CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_CALLBACKS")
            .field("cbDDCallbacks", &self.cbDDCallbacks)
            .field("cbDDSurfaceCallbacks", &self.cbDDSurfaceCallbacks)
            .field("cbDDPaletteCallbacks", &self.cbDDPaletteCallbacks)
            .field("HALDD", &self.HALDD)
            .field("HALDDSurface", &self.HALDDSurface)
            .field("HALDDPalette", &self.HALDDPalette)
            .field("HELDD", &self.HELDD)
            .field("HELDDSurface", &self.HELDDSurface)
            .field("HELDDPalette", &self.HELDDPalette)
            .field("cbDDExeBufCallbacks", &self.cbDDExeBufCallbacks)
            .field("HALDDExeBuf", &self.HALDDExeBuf)
            .field("HELDDExeBuf", &self.HELDDExeBuf)
            .field("cbDDVideoPortCallbacks", &self.cbDDVideoPortCallbacks)
            .field("HALDDVideoPort", &self.HALDDVideoPort)
            .field("cbDDColorControlCallbacks", &self.cbDDColorControlCallbacks)
            .field("HALDDColorControl", &self.HALDDColorControl)
            .field(
                "cbDDMiscellaneousCallbacks",
                &self.cbDDMiscellaneousCallbacks,
            )
            .field("HALDDMiscellaneous", &self.HALDDMiscellaneous)
            .field("cbDDKernelCallbacks", &self.cbDDKernelCallbacks)
            .field("HALDDKernel", &self.HALDDKernel)
            .field("cbDDMotionCompCallbacks", &self.cbDDMotionCompCallbacks)
            .field("HALDDMotionComp", &self.HALDDMotionComp)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_CALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.cbDDCallbacks == other.cbDDCallbacks
            && self.cbDDSurfaceCallbacks == other.cbDDSurfaceCallbacks
            && self.cbDDPaletteCallbacks == other.cbDDPaletteCallbacks
            && self.HALDD == other.HALDD
            && self.HALDDSurface == other.HALDDSurface
            && self.HALDDPalette == other.HALDDPalette
            && self.HELDD == other.HELDD
            && self.HELDDSurface == other.HELDDSurface
            && self.HELDDPalette == other.HELDDPalette
            && self.cbDDExeBufCallbacks == other.cbDDExeBufCallbacks
            && self.HALDDExeBuf == other.HALDDExeBuf
            && self.HELDDExeBuf == other.HELDDExeBuf
            && self.cbDDVideoPortCallbacks == other.cbDDVideoPortCallbacks
            && self.HALDDVideoPort == other.HALDDVideoPort
            && self.cbDDColorControlCallbacks == other.cbDDColorControlCallbacks
            && self.HALDDColorControl == other.HALDDColorControl
            && self.cbDDMiscellaneousCallbacks == other.cbDDMiscellaneousCallbacks
            && self.HALDDMiscellaneous == other.HALDDMiscellaneous
            && self.cbDDKernelCallbacks == other.cbDDKernelCallbacks
            && self.HALDDKernel == other.HALDDKernel
            && self.cbDDMotionCompCallbacks == other.cbDDMotionCompCallbacks
            && self.HALDDMotionComp == other.HALDDMotionComp
    }
}
impl ::core::cmp::Eq for DDHAL_CALLBACKS {}
impl FromIntoMemory for DDHAL_CALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 812);
        let f_cbDDCallbacks = <DDHAL_DDCALLBACKS as FromIntoMemory>::from_bytes(&from[0..0 + 48]);
        let f_cbDDSurfaceCallbacks =
            <DDHAL_DDSURFACECALLBACKS as FromIntoMemory>::from_bytes(&from[48..48 + 64]);
        let f_cbDDPaletteCallbacks =
            <DDHAL_DDPALETTECALLBACKS as FromIntoMemory>::from_bytes(&from[112..112 + 16]);
        let f_HALDD = <DDHAL_DDCALLBACKS as FromIntoMemory>::from_bytes(&from[128..128 + 48]);
        let f_HALDDSurface =
            <DDHAL_DDSURFACECALLBACKS as FromIntoMemory>::from_bytes(&from[176..176 + 64]);
        let f_HALDDPalette =
            <DDHAL_DDPALETTECALLBACKS as FromIntoMemory>::from_bytes(&from[240..240 + 16]);
        let f_HELDD = <DDHAL_DDCALLBACKS as FromIntoMemory>::from_bytes(&from[256..256 + 48]);
        let f_HELDDSurface =
            <DDHAL_DDSURFACECALLBACKS as FromIntoMemory>::from_bytes(&from[304..304 + 64]);
        let f_HELDDPalette =
            <DDHAL_DDPALETTECALLBACKS as FromIntoMemory>::from_bytes(&from[368..368 + 16]);
        let f_cbDDExeBufCallbacks =
            <DDHAL_DDEXEBUFCALLBACKS as FromIntoMemory>::from_bytes(&from[384..384 + 28]);
        let f_HALDDExeBuf =
            <DDHAL_DDEXEBUFCALLBACKS as FromIntoMemory>::from_bytes(&from[412..412 + 28]);
        let f_HELDDExeBuf =
            <DDHAL_DDEXEBUFCALLBACKS as FromIntoMemory>::from_bytes(&from[440..440 + 28]);
        let f_cbDDVideoPortCallbacks =
            <DDHAL_DDVIDEOPORTCALLBACKS as FromIntoMemory>::from_bytes(&from[468..468 + 72]);
        let f_HALDDVideoPort =
            <DDHAL_DDVIDEOPORTCALLBACKS as FromIntoMemory>::from_bytes(&from[540..540 + 72]);
        let f_cbDDColorControlCallbacks =
            <DDHAL_DDCOLORCONTROLCALLBACKS as FromIntoMemory>::from_bytes(&from[612..612 + 12]);
        let f_HALDDColorControl =
            <DDHAL_DDCOLORCONTROLCALLBACKS as FromIntoMemory>::from_bytes(&from[624..624 + 12]);
        let f_cbDDMiscellaneousCallbacks =
            <DDHAL_DDMISCELLANEOUSCALLBACKS as FromIntoMemory>::from_bytes(&from[636..636 + 24]);
        let f_HALDDMiscellaneous =
            <DDHAL_DDMISCELLANEOUSCALLBACKS as FromIntoMemory>::from_bytes(&from[660..660 + 24]);
        let f_cbDDKernelCallbacks =
            <DDHAL_DDKERNELCALLBACKS as FromIntoMemory>::from_bytes(&from[684..684 + 16]);
        let f_HALDDKernel =
            <DDHAL_DDKERNELCALLBACKS as FromIntoMemory>::from_bytes(&from[700..700 + 16]);
        let f_cbDDMotionCompCallbacks =
            <DDHAL_DDMOTIONCOMPCALLBACKS as FromIntoMemory>::from_bytes(&from[716..716 + 48]);
        let f_HALDDMotionComp =
            <DDHAL_DDMOTIONCOMPCALLBACKS as FromIntoMemory>::from_bytes(&from[764..764 + 48]);
        Self {
            cbDDCallbacks: f_cbDDCallbacks,
            cbDDSurfaceCallbacks: f_cbDDSurfaceCallbacks,
            cbDDPaletteCallbacks: f_cbDDPaletteCallbacks,
            HALDD: f_HALDD,
            HALDDSurface: f_HALDDSurface,
            HALDDPalette: f_HALDDPalette,
            HELDD: f_HELDD,
            HELDDSurface: f_HELDDSurface,
            HELDDPalette: f_HELDDPalette,
            cbDDExeBufCallbacks: f_cbDDExeBufCallbacks,
            HALDDExeBuf: f_HALDDExeBuf,
            HELDDExeBuf: f_HELDDExeBuf,
            cbDDVideoPortCallbacks: f_cbDDVideoPortCallbacks,
            HALDDVideoPort: f_HALDDVideoPort,
            cbDDColorControlCallbacks: f_cbDDColorControlCallbacks,
            HALDDColorControl: f_HALDDColorControl,
            cbDDMiscellaneousCallbacks: f_cbDDMiscellaneousCallbacks,
            HALDDMiscellaneous: f_HALDDMiscellaneous,
            cbDDKernelCallbacks: f_cbDDKernelCallbacks,
            HALDDKernel: f_HALDDKernel,
            cbDDMotionCompCallbacks: f_cbDDMotionCompCallbacks,
            HALDDMotionComp: f_HALDDMotionComp,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 812);
        FromIntoMemory::into_bytes(self.cbDDCallbacks, &mut into[0..0 + 48]);
        FromIntoMemory::into_bytes(self.cbDDSurfaceCallbacks, &mut into[48..48 + 64]);
        FromIntoMemory::into_bytes(self.cbDDPaletteCallbacks, &mut into[112..112 + 16]);
        FromIntoMemory::into_bytes(self.HALDD, &mut into[128..128 + 48]);
        FromIntoMemory::into_bytes(self.HALDDSurface, &mut into[176..176 + 64]);
        FromIntoMemory::into_bytes(self.HALDDPalette, &mut into[240..240 + 16]);
        FromIntoMemory::into_bytes(self.HELDD, &mut into[256..256 + 48]);
        FromIntoMemory::into_bytes(self.HELDDSurface, &mut into[304..304 + 64]);
        FromIntoMemory::into_bytes(self.HELDDPalette, &mut into[368..368 + 16]);
        FromIntoMemory::into_bytes(self.cbDDExeBufCallbacks, &mut into[384..384 + 28]);
        FromIntoMemory::into_bytes(self.HALDDExeBuf, &mut into[412..412 + 28]);
        FromIntoMemory::into_bytes(self.HELDDExeBuf, &mut into[440..440 + 28]);
        FromIntoMemory::into_bytes(self.cbDDVideoPortCallbacks, &mut into[468..468 + 72]);
        FromIntoMemory::into_bytes(self.HALDDVideoPort, &mut into[540..540 + 72]);
        FromIntoMemory::into_bytes(self.cbDDColorControlCallbacks, &mut into[612..612 + 12]);
        FromIntoMemory::into_bytes(self.HALDDColorControl, &mut into[624..624 + 12]);
        FromIntoMemory::into_bytes(self.cbDDMiscellaneousCallbacks, &mut into[636..636 + 24]);
        FromIntoMemory::into_bytes(self.HALDDMiscellaneous, &mut into[660..660 + 24]);
        FromIntoMemory::into_bytes(self.cbDDKernelCallbacks, &mut into[684..684 + 16]);
        FromIntoMemory::into_bytes(self.HALDDKernel, &mut into[700..700 + 16]);
        FromIntoMemory::into_bytes(self.cbDDMotionCompCallbacks, &mut into[716..716 + 48]);
        FromIntoMemory::into_bytes(self.HALDDMotionComp, &mut into[764..764 + 48]);
    }
    fn size() -> usize {
        812
    }
}
pub struct DDHAL_CANCREATESURFACEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurfaceDesc: MutPtr<DDSURFACEDESC>,
    pub bIsDifferentPixelFormat: u32,
    pub ddRVal: crate::core::HRESULT,
    pub CanCreateSurface: LPDDHAL_CANCREATESURFACE,
}
impl ::core::marker::Copy for DDHAL_CANCREATESURFACEDATA {}
impl ::core::clone::Clone for DDHAL_CANCREATESURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_CANCREATESURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_CANCREATESURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurfaceDesc", &self.lpDDSurfaceDesc)
            .field("bIsDifferentPixelFormat", &self.bIsDifferentPixelFormat)
            .field("ddRVal", &self.ddRVal)
            .field("CanCreateSurface", &self.CanCreateSurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_CANCREATESURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurfaceDesc == other.lpDDSurfaceDesc
            && self.bIsDifferentPixelFormat == other.bIsDifferentPixelFormat
            && self.ddRVal == other.ddRVal
            && self.CanCreateSurface == other.CanCreateSurface
    }
}
impl ::core::cmp::Eq for DDHAL_CANCREATESURFACEDATA {}
impl FromIntoMemory for DDHAL_CANCREATESURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurfaceDesc =
            <MutPtr<DDSURFACEDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bIsDifferentPixelFormat = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CanCreateSurface =
            <LPDDHAL_CANCREATESURFACE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurfaceDesc: f_lpDDSurfaceDesc,
            bIsDifferentPixelFormat: f_bIsDifferentPixelFormat,
            ddRVal: f_ddRVal,
            CanCreateSurface: f_CanCreateSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurfaceDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bIsDifferentPixelFormat, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateSurface, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_CANCREATEVPORTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpDDVideoPortDesc: MutPtr<DDVIDEOPORTDESC>,
    pub ddRVal: crate::core::HRESULT,
    pub CanCreateVideoPort: LPDDHALVPORTCB_CANCREATEVIDEOPORT,
}
impl ::core::marker::Copy for DDHAL_CANCREATEVPORTDATA {}
impl ::core::clone::Clone for DDHAL_CANCREATEVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_CANCREATEVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_CANCREATEVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDVideoPortDesc", &self.lpDDVideoPortDesc)
            .field("ddRVal", &self.ddRVal)
            .field("CanCreateVideoPort", &self.CanCreateVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_CANCREATEVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDVideoPortDesc == other.lpDDVideoPortDesc
            && self.ddRVal == other.ddRVal
            && self.CanCreateVideoPort == other.CanCreateVideoPort
    }
}
impl ::core::cmp::Eq for DDHAL_CANCREATEVPORTDATA {}
impl FromIntoMemory for DDHAL_CANCREATEVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDVideoPortDesc =
            <MutPtr<DDVIDEOPORTDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CanCreateVideoPort =
            <LPDDHALVPORTCB_CANCREATEVIDEOPORT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDVideoPortDesc: f_lpDDVideoPortDesc,
            ddRVal: f_ddRVal,
            CanCreateVideoPort: f_CanCreateVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDVideoPortDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateVideoPort, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const DDHAL_CB32_CANCREATESURFACE: i32 = 32i32;
pub const DDHAL_CB32_CREATEPALETTE: i32 = 64i32;
pub const DDHAL_CB32_CREATESURFACE: i32 = 2i32;
pub const DDHAL_CB32_DESTROYDRIVER: i32 = 1i32;
pub const DDHAL_CB32_FLIPTOGDISURFACE: i32 = 512i32;
pub const DDHAL_CB32_GETSCANLINE: i32 = 128i32;
pub const DDHAL_CB32_MAPMEMORY: i32 = -2147483648i32;
pub const DDHAL_CB32_SETCOLORKEY: i32 = 4i32;
pub const DDHAL_CB32_SETEXCLUSIVEMODE: i32 = 256i32;
pub const DDHAL_CB32_SETMODE: i32 = 8i32;
pub const DDHAL_CB32_WAITFORVERTICALBLANK: i32 = 16i32;
pub struct DDHAL_COLORCONTROLDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpColorData: MutPtr<DDCOLORCONTROL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub ColorControl: LPDDHALCOLORCB_COLORCONTROL,
}
impl ::core::marker::Copy for DDHAL_COLORCONTROLDATA {}
impl ::core::clone::Clone for DDHAL_COLORCONTROLDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_COLORCONTROLDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_COLORCONTROLDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("lpColorData", &self.lpColorData)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_COLORCONTROLDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.lpColorData == other.lpColorData
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DDHAL_COLORCONTROLDATA {}
impl FromIntoMemory for DDHAL_COLORCONTROLDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpColorData = <MutPtr<DDCOLORCONTROL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ColorControl =
            <LPDDHALCOLORCB_COLORCONTROL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            lpColorData: f_lpColorData,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpColorData, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub const DDHAL_COLOR_COLORCONTROL: i32 = 1i32;
pub struct DDHAL_CREATEMOCOMPDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpMoComp: MutPtr<DDRAWI_DDMOTIONCOMP_LCL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwUncompWidth: u32,
    pub dwUncompHeight: u32,
    pub ddUncompPixelFormat: DDPIXELFORMAT,
    pub lpData: MutPtr<::core::ffi::c_void>,
    pub dwDataSize: u32,
    pub ddRVal: crate::core::HRESULT,
    pub CreateMoComp: LPDDHALMOCOMPCB_CREATE,
}
impl ::core::marker::Copy for DDHAL_CREATEMOCOMPDATA {}
impl ::core::clone::Clone for DDHAL_CREATEMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_CREATEMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpGuid == other.lpGuid
            && self.dwUncompWidth == other.dwUncompWidth
            && self.dwUncompHeight == other.dwUncompHeight
            && self.ddUncompPixelFormat == other.ddUncompPixelFormat
            && self.lpData == other.lpData
            && self.dwDataSize == other.dwDataSize
            && self.ddRVal == other.ddRVal
            && self.CreateMoComp == other.CreateMoComp
    }
}
impl ::core::cmp::Eq for DDHAL_CREATEMOCOMPDATA {}
impl FromIntoMemory for DDHAL_CREATEMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 68);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DDRAWI_DDMOTIONCOMP_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwUncompWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwUncompHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddUncompPixelFormat =
            <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[20..20 + 32]);
        let f_lpData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwDataSize = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_CreateMoComp =
            <LPDDHALMOCOMPCB_CREATE as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpGuid: f_lpGuid,
            dwUncompWidth: f_dwUncompWidth,
            dwUncompHeight: f_dwUncompHeight,
            ddUncompPixelFormat: f_ddUncompPixelFormat,
            lpData: f_lpData,
            dwDataSize: f_dwDataSize,
            ddRVal: f_ddRVal,
            CreateMoComp: f_CreateMoComp,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 68);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwUncompWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwUncompHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddUncompPixelFormat, &mut into[20..20 + 32]);
        FromIntoMemory::into_bytes(self.lpData, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwDataSize, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.CreateMoComp, &mut into[64..64 + 4]);
    }
    fn size() -> usize {
        68
    }
}
pub struct DDHAL_CREATEPALETTEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDPalette: MutPtr<DDRAWI_DDRAWPALETTE_GBL>,
    pub lpColorTable: MutPtr<super::Gdi::PALETTEENTRY>,
    pub ddRVal: crate::core::HRESULT,
    pub CreatePalette: LPDDHAL_CREATEPALETTE,
    pub is_excl: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DDHAL_CREATEPALETTEDATA {}
impl ::core::clone::Clone for DDHAL_CREATEPALETTEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_CREATEPALETTEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_CREATEPALETTEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("lpColorTable", &self.lpColorTable)
            .field("ddRVal", &self.ddRVal)
            .field("CreatePalette", &self.CreatePalette)
            .field("is_excl", &self.is_excl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_CREATEPALETTEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDPalette == other.lpDDPalette
            && self.lpColorTable == other.lpColorTable
            && self.ddRVal == other.ddRVal
            && self.CreatePalette == other.CreatePalette
            && self.is_excl == other.is_excl
    }
}
impl ::core::cmp::Eq for DDHAL_CREATEPALETTEDATA {}
impl FromIntoMemory for DDHAL_CREATEPALETTEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDPalette =
            <MutPtr<DDRAWI_DDRAWPALETTE_GBL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpColorTable =
            <MutPtr<super::Gdi::PALETTEENTRY> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CreatePalette =
            <LPDDHAL_CREATEPALETTE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_is_excl =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDPalette: f_lpDDPalette,
            lpColorTable: f_lpColorTable,
            ddRVal: f_ddRVal,
            CreatePalette: f_CreatePalette,
            is_excl: f_is_excl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpColorTable, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CreatePalette, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.is_excl, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_CREATESURFACEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurfaceDesc: MutPtr<DDSURFACEDESC>,
    pub lplpSList: MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_LCL>>,
    pub dwSCnt: u32,
    pub ddRVal: crate::core::HRESULT,
    pub CreateSurface: LPDDHAL_CREATESURFACE,
}
impl ::core::marker::Copy for DDHAL_CREATESURFACEDATA {}
impl ::core::clone::Clone for DDHAL_CREATESURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_CREATESURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_CREATESURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurfaceDesc", &self.lpDDSurfaceDesc)
            .field("lplpSList", &self.lplpSList)
            .field("dwSCnt", &self.dwSCnt)
            .field("ddRVal", &self.ddRVal)
            .field("CreateSurface", &self.CreateSurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_CREATESURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurfaceDesc == other.lpDDSurfaceDesc
            && self.lplpSList == other.lplpSList
            && self.dwSCnt == other.dwSCnt
            && self.ddRVal == other.ddRVal
            && self.CreateSurface == other.CreateSurface
    }
}
impl ::core::cmp::Eq for DDHAL_CREATESURFACEDATA {}
impl FromIntoMemory for DDHAL_CREATESURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurfaceDesc =
            <MutPtr<DDSURFACEDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lplpSList = <MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_LCL>> as FromIntoMemory>::from_bytes(
            &from[8..8 + 4],
        );
        let f_dwSCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_CreateSurface =
            <LPDDHAL_CREATESURFACE as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurfaceDesc: f_lpDDSurfaceDesc,
            lplpSList: f_lplpSList,
            dwSCnt: f_dwSCnt,
            ddRVal: f_ddRVal,
            CreateSurface: f_CreateSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurfaceDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lplpSList, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwSCnt, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.CreateSurface, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_CREATESURFACEEXDATA {
    pub dwFlags: u32,
    pub lpDDLcl: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpDDSLcl: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DDHAL_CREATESURFACEEXDATA {}
impl ::core::clone::Clone for DDHAL_CREATESURFACEEXDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_CREATESURFACEEXDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_CREATESURFACEEXDATA")
            .field("dwFlags", &self.dwFlags)
            .field("lpDDLcl", &self.lpDDLcl)
            .field("lpDDSLcl", &self.lpDDSLcl)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_CREATESURFACEEXDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.lpDDLcl == other.lpDDLcl
            && self.lpDDSLcl == other.lpDDSLcl
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DDHAL_CREATESURFACEEXDATA {}
impl FromIntoMemory for DDHAL_CREATESURFACEEXDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDLcl =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDSLcl =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwFlags: f_dwFlags,
            lpDDLcl: f_lpDDLcl,
            lpDDSLcl: f_lpDDSLcl,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSLcl, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const DDHAL_CREATESURFACEEX_SWAPHANDLES: i32 = 1i32;
pub struct DDHAL_CREATEVPORTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpDDVideoPortDesc: MutPtr<DDVIDEOPORTDESC>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub CreateVideoPort: LPDDHALVPORTCB_CREATEVIDEOPORT,
}
impl ::core::marker::Copy for DDHAL_CREATEVPORTDATA {}
impl ::core::clone::Clone for DDHAL_CREATEVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_CREATEVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_CREATEVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDVideoPortDesc", &self.lpDDVideoPortDesc)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("ddRVal", &self.ddRVal)
            .field("CreateVideoPort", &self.CreateVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_CREATEVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDVideoPortDesc == other.lpDDVideoPortDesc
            && self.lpVideoPort == other.lpVideoPort
            && self.ddRVal == other.ddRVal
            && self.CreateVideoPort == other.CreateVideoPort
    }
}
impl ::core::cmp::Eq for DDHAL_CREATEVPORTDATA {}
impl FromIntoMemory for DDHAL_CREATEVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDVideoPortDesc =
            <MutPtr<DDVIDEOPORTDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CreateVideoPort =
            <LPDDHALVPORTCB_CREATEVIDEOPORT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDVideoPortDesc: f_lpDDVideoPortDesc,
            lpVideoPort: f_lpVideoPort,
            ddRVal: f_ddRVal,
            CreateVideoPort: f_CreateVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDVideoPortDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CreateVideoPort, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub const DDHAL_D3DBUFCB32_CANCREATED3DBUF: i32 = 1i32;
pub const DDHAL_D3DBUFCB32_CREATED3DBUF: i32 = 2i32;
pub const DDHAL_D3DBUFCB32_DESTROYD3DBUF: i32 = 4i32;
pub const DDHAL_D3DBUFCB32_LOCKD3DBUF: i32 = 8i32;
pub const DDHAL_D3DBUFCB32_UNLOCKD3DBUF: i32 = 16i32;
pub struct DDHAL_DDCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub DestroyDriver: LPDDHAL_DESTROYDRIVER,
    pub CreateSurface: LPDDHAL_CREATESURFACE,
    pub SetColorKey: LPDDHAL_SETCOLORKEY,
    pub SetMode: LPDDHAL_SETMODE,
    pub WaitForVerticalBlank: LPDDHAL_WAITFORVERTICALBLANK,
    pub CanCreateSurface: LPDDHAL_CANCREATESURFACE,
    pub CreatePalette: LPDDHAL_CREATEPALETTE,
    pub GetScanLine: LPDDHAL_GETSCANLINE,
    pub SetExclusiveMode: LPDDHAL_SETEXCLUSIVEMODE,
    pub FlipToGDISurface: LPDDHAL_FLIPTOGDISURFACE,
}
impl ::core::marker::Copy for DDHAL_DDCALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("DestroyDriver", &self.DestroyDriver)
            .field("CreateSurface", &self.CreateSurface)
            .field("SetColorKey", &self.SetColorKey)
            .field("SetMode", &self.SetMode)
            .field("WaitForVerticalBlank", &self.WaitForVerticalBlank)
            .field("CanCreateSurface", &self.CanCreateSurface)
            .field("CreatePalette", &self.CreatePalette)
            .field("GetScanLine", &self.GetScanLine)
            .field("SetExclusiveMode", &self.SetExclusiveMode)
            .field("FlipToGDISurface", &self.FlipToGDISurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.DestroyDriver == other.DestroyDriver
            && self.CreateSurface == other.CreateSurface
            && self.SetColorKey == other.SetColorKey
            && self.SetMode == other.SetMode
            && self.WaitForVerticalBlank == other.WaitForVerticalBlank
            && self.CanCreateSurface == other.CanCreateSurface
            && self.CreatePalette == other.CreatePalette
            && self.GetScanLine == other.GetScanLine
            && self.SetExclusiveMode == other.SetExclusiveMode
            && self.FlipToGDISurface == other.FlipToGDISurface
    }
}
impl ::core::cmp::Eq for DDHAL_DDCALLBACKS {}
impl FromIntoMemory for DDHAL_DDCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 48);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DestroyDriver =
            <LPDDHAL_DESTROYDRIVER as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateSurface =
            <LPDDHAL_CREATESURFACE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetColorKey = <LPDDHAL_SETCOLORKEY as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_SetMode = <LPDDHAL_SETMODE as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_WaitForVerticalBlank =
            <LPDDHAL_WAITFORVERTICALBLANK as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_CanCreateSurface =
            <LPDDHAL_CANCREATESURFACE as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_CreatePalette =
            <LPDDHAL_CREATEPALETTE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_GetScanLine = <LPDDHAL_GETSCANLINE as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_SetExclusiveMode =
            <LPDDHAL_SETEXCLUSIVEMODE as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_FlipToGDISurface =
            <LPDDHAL_FLIPTOGDISURFACE as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            DestroyDriver: f_DestroyDriver,
            CreateSurface: f_CreateSurface,
            SetColorKey: f_SetColorKey,
            SetMode: f_SetMode,
            WaitForVerticalBlank: f_WaitForVerticalBlank,
            CanCreateSurface: f_CanCreateSurface,
            CreatePalette: f_CreatePalette,
            GetScanLine: f_GetScanLine,
            SetExclusiveMode: f_SetExclusiveMode,
            FlipToGDISurface: f_FlipToGDISurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 48);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DestroyDriver, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateSurface, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.SetMode, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.WaitForVerticalBlank, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateSurface, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.CreatePalette, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.GetScanLine, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.SetExclusiveMode, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.FlipToGDISurface, &mut into[44..44 + 4]);
    }
    fn size() -> usize {
        48
    }
}
pub struct DDHAL_DDCOLORCONTROLCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub ColorControl: LPDDHALCOLORCB_COLORCONTROL,
}
impl ::core::marker::Copy for DDHAL_DDCOLORCONTROLCALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDCOLORCONTROLCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDCOLORCONTROLCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDCOLORCONTROLCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDCOLORCONTROLCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DDHAL_DDCOLORCONTROLCALLBACKS {}
impl FromIntoMemory for DDHAL_DDCOLORCONTROLCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ColorControl =
            <LPDDHALCOLORCB_COLORCONTROL as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DDHAL_DDEXEBUFCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub CanCreateExecuteBuffer: LPDDHALEXEBUFCB_CANCREATEEXEBUF,
    pub CreateExecuteBuffer: LPDDHALEXEBUFCB_CREATEEXEBUF,
    pub DestroyExecuteBuffer: LPDDHALEXEBUFCB_DESTROYEXEBUF,
    pub LockExecuteBuffer: LPDDHALEXEBUFCB_LOCKEXEBUF,
    pub UnlockExecuteBuffer: LPDDHALEXEBUFCB_UNLOCKEXEBUF,
}
impl ::core::marker::Copy for DDHAL_DDEXEBUFCALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDEXEBUFCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDEXEBUFCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDEXEBUFCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("CanCreateExecuteBuffer", &self.CanCreateExecuteBuffer)
            .field("CreateExecuteBuffer", &self.CreateExecuteBuffer)
            .field("DestroyExecuteBuffer", &self.DestroyExecuteBuffer)
            .field("LockExecuteBuffer", &self.LockExecuteBuffer)
            .field("UnlockExecuteBuffer", &self.UnlockExecuteBuffer)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDEXEBUFCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.CanCreateExecuteBuffer == other.CanCreateExecuteBuffer
            && self.CreateExecuteBuffer == other.CreateExecuteBuffer
            && self.DestroyExecuteBuffer == other.DestroyExecuteBuffer
            && self.LockExecuteBuffer == other.LockExecuteBuffer
            && self.UnlockExecuteBuffer == other.UnlockExecuteBuffer
    }
}
impl ::core::cmp::Eq for DDHAL_DDEXEBUFCALLBACKS {}
impl FromIntoMemory for DDHAL_DDEXEBUFCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_CanCreateExecuteBuffer =
            <LPDDHALEXEBUFCB_CANCREATEEXEBUF as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateExecuteBuffer =
            <LPDDHALEXEBUFCB_CREATEEXEBUF as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_DestroyExecuteBuffer =
            <LPDDHALEXEBUFCB_DESTROYEXEBUF as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_LockExecuteBuffer =
            <LPDDHALEXEBUFCB_LOCKEXEBUF as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_UnlockExecuteBuffer =
            <LPDDHALEXEBUFCB_UNLOCKEXEBUF as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            CanCreateExecuteBuffer: f_CanCreateExecuteBuffer,
            CreateExecuteBuffer: f_CreateExecuteBuffer,
            DestroyExecuteBuffer: f_DestroyExecuteBuffer,
            LockExecuteBuffer: f_LockExecuteBuffer,
            UnlockExecuteBuffer: f_UnlockExecuteBuffer,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateExecuteBuffer, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateExecuteBuffer, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.DestroyExecuteBuffer, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.LockExecuteBuffer, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.UnlockExecuteBuffer, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DDHAL_DDKERNELCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub SyncSurfaceData: LPDDHALKERNELCB_SYNCSURFACE,
    pub SyncVideoPortData: LPDDHALKERNELCB_SYNCVIDEOPORT,
}
impl ::core::marker::Copy for DDHAL_DDKERNELCALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDKERNELCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDKERNELCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDKERNELCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("SyncSurfaceData", &self.SyncSurfaceData)
            .field("SyncVideoPortData", &self.SyncVideoPortData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDKERNELCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.SyncSurfaceData == other.SyncSurfaceData
            && self.SyncVideoPortData == other.SyncVideoPortData
    }
}
impl ::core::cmp::Eq for DDHAL_DDKERNELCALLBACKS {}
impl FromIntoMemory for DDHAL_DDKERNELCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_SyncSurfaceData =
            <LPDDHALKERNELCB_SYNCSURFACE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SyncVideoPortData =
            <LPDDHALKERNELCB_SYNCVIDEOPORT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            SyncSurfaceData: f_SyncSurfaceData,
            SyncVideoPortData: f_SyncVideoPortData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.SyncSurfaceData, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SyncVideoPortData, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_DDMISCELLANEOUS2CALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub Reserved: MutPtr<::core::ffi::c_void>,
    pub CreateSurfaceEx: LPDDHAL_CREATESURFACEEX,
    pub GetDriverState: LPDDHAL_GETDRIVERSTATE,
    pub DestroyDDLocal: LPDDHAL_DESTROYDDLOCAL,
}
impl ::core::marker::Copy for DDHAL_DDMISCELLANEOUS2CALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDMISCELLANEOUS2CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDMISCELLANEOUS2CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDMISCELLANEOUS2CALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("Reserved", &self.Reserved)
            .field("CreateSurfaceEx", &self.CreateSurfaceEx)
            .field("GetDriverState", &self.GetDriverState)
            .field("DestroyDDLocal", &self.DestroyDDLocal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDMISCELLANEOUS2CALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.Reserved == other.Reserved
            && self.CreateSurfaceEx == other.CreateSurfaceEx
            && self.GetDriverState == other.GetDriverState
            && self.DestroyDDLocal == other.DestroyDDLocal
    }
}
impl ::core::cmp::Eq for DDHAL_DDMISCELLANEOUS2CALLBACKS {}
impl FromIntoMemory for DDHAL_DDMISCELLANEOUS2CALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_Reserved =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateSurfaceEx =
            <LPDDHAL_CREATESURFACEEX as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetDriverState =
            <LPDDHAL_GETDRIVERSTATE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_DestroyDDLocal =
            <LPDDHAL_DESTROYDDLOCAL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            Reserved: f_Reserved,
            CreateSurfaceEx: f_CreateSurfaceEx,
            GetDriverState: f_GetDriverState,
            DestroyDDLocal: f_DestroyDDLocal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.Reserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateSurfaceEx, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetDriverState, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.DestroyDDLocal, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_DDMISCELLANEOUSCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub GetAvailDriverMemory: LPDDHAL_GETAVAILDRIVERMEMORY,
    pub UpdateNonLocalHeap: LPDDHAL_UPDATENONLOCALHEAP,
    pub GetHeapAlignment: LPDDHAL_GETHEAPALIGNMENT,
    pub GetSysmemBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
}
impl ::core::marker::Copy for DDHAL_DDMISCELLANEOUSCALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDMISCELLANEOUSCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDMISCELLANEOUSCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDMISCELLANEOUSCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("GetAvailDriverMemory", &self.GetAvailDriverMemory)
            .field("UpdateNonLocalHeap", &self.UpdateNonLocalHeap)
            .field("GetHeapAlignment", &self.GetHeapAlignment)
            .field("GetSysmemBltStatus", &self.GetSysmemBltStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDMISCELLANEOUSCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.GetAvailDriverMemory == other.GetAvailDriverMemory
            && self.UpdateNonLocalHeap == other.UpdateNonLocalHeap
            && self.GetHeapAlignment == other.GetHeapAlignment
            && self.GetSysmemBltStatus == other.GetSysmemBltStatus
    }
}
impl ::core::cmp::Eq for DDHAL_DDMISCELLANEOUSCALLBACKS {}
impl FromIntoMemory for DDHAL_DDMISCELLANEOUSCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_GetAvailDriverMemory =
            <LPDDHAL_GETAVAILDRIVERMEMORY as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_UpdateNonLocalHeap =
            <LPDDHAL_UPDATENONLOCALHEAP as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetHeapAlignment =
            <LPDDHAL_GETHEAPALIGNMENT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetSysmemBltStatus =
            <LPDDHALSURFCB_GETBLTSTATUS as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            GetAvailDriverMemory: f_GetAvailDriverMemory,
            UpdateNonLocalHeap: f_UpdateNonLocalHeap,
            GetHeapAlignment: f_GetHeapAlignment,
            GetSysmemBltStatus: f_GetSysmemBltStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.GetAvailDriverMemory, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.UpdateNonLocalHeap, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetHeapAlignment, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetSysmemBltStatus, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_DDMOTIONCOMPCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub GetMoCompGuids: LPDDHALMOCOMPCB_GETGUIDS,
    pub GetMoCompFormats: LPDDHALMOCOMPCB_GETFORMATS,
    pub CreateMoComp: LPDDHALMOCOMPCB_CREATE,
    pub GetMoCompBuffInfo: LPDDHALMOCOMPCB_GETCOMPBUFFINFO,
    pub GetInternalMoCompInfo: LPDDHALMOCOMPCB_GETINTERNALINFO,
    pub BeginMoCompFrame: LPDDHALMOCOMPCB_BEGINFRAME,
    pub EndMoCompFrame: LPDDHALMOCOMPCB_ENDFRAME,
    pub RenderMoComp: LPDDHALMOCOMPCB_RENDER,
    pub QueryMoCompStatus: LPDDHALMOCOMPCB_QUERYSTATUS,
    pub DestroyMoComp: LPDDHALMOCOMPCB_DESTROY,
}
impl ::core::marker::Copy for DDHAL_DDMOTIONCOMPCALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDMOTIONCOMPCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDMOTIONCOMPCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDMOTIONCOMPCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("GetMoCompGuids", &self.GetMoCompGuids)
            .field("GetMoCompFormats", &self.GetMoCompFormats)
            .field("CreateMoComp", &self.CreateMoComp)
            .field("GetMoCompBuffInfo", &self.GetMoCompBuffInfo)
            .field("GetInternalMoCompInfo", &self.GetInternalMoCompInfo)
            .field("BeginMoCompFrame", &self.BeginMoCompFrame)
            .field("EndMoCompFrame", &self.EndMoCompFrame)
            .field("RenderMoComp", &self.RenderMoComp)
            .field("QueryMoCompStatus", &self.QueryMoCompStatus)
            .field("DestroyMoComp", &self.DestroyMoComp)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDMOTIONCOMPCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.GetMoCompGuids == other.GetMoCompGuids
            && self.GetMoCompFormats == other.GetMoCompFormats
            && self.CreateMoComp == other.CreateMoComp
            && self.GetMoCompBuffInfo == other.GetMoCompBuffInfo
            && self.GetInternalMoCompInfo == other.GetInternalMoCompInfo
            && self.BeginMoCompFrame == other.BeginMoCompFrame
            && self.EndMoCompFrame == other.EndMoCompFrame
            && self.RenderMoComp == other.RenderMoComp
            && self.QueryMoCompStatus == other.QueryMoCompStatus
            && self.DestroyMoComp == other.DestroyMoComp
    }
}
impl ::core::cmp::Eq for DDHAL_DDMOTIONCOMPCALLBACKS {}
impl FromIntoMemory for DDHAL_DDMOTIONCOMPCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 48);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_GetMoCompGuids =
            <LPDDHALMOCOMPCB_GETGUIDS as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetMoCompFormats =
            <LPDDHALMOCOMPCB_GETFORMATS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CreateMoComp =
            <LPDDHALMOCOMPCB_CREATE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetMoCompBuffInfo =
            <LPDDHALMOCOMPCB_GETCOMPBUFFINFO as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_GetInternalMoCompInfo =
            <LPDDHALMOCOMPCB_GETINTERNALINFO as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_BeginMoCompFrame =
            <LPDDHALMOCOMPCB_BEGINFRAME as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_EndMoCompFrame =
            <LPDDHALMOCOMPCB_ENDFRAME as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_RenderMoComp =
            <LPDDHALMOCOMPCB_RENDER as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_QueryMoCompStatus =
            <LPDDHALMOCOMPCB_QUERYSTATUS as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_DestroyMoComp =
            <LPDDHALMOCOMPCB_DESTROY as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            GetMoCompGuids: f_GetMoCompGuids,
            GetMoCompFormats: f_GetMoCompFormats,
            CreateMoComp: f_CreateMoComp,
            GetMoCompBuffInfo: f_GetMoCompBuffInfo,
            GetInternalMoCompInfo: f_GetInternalMoCompInfo,
            BeginMoCompFrame: f_BeginMoCompFrame,
            EndMoCompFrame: f_EndMoCompFrame,
            RenderMoComp: f_RenderMoComp,
            QueryMoCompStatus: f_QueryMoCompStatus,
            DestroyMoComp: f_DestroyMoComp,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 48);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompGuids, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompFormats, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CreateMoComp, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompBuffInfo, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.GetInternalMoCompInfo, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.BeginMoCompFrame, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.EndMoCompFrame, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.RenderMoComp, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.QueryMoCompStatus, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.DestroyMoComp, &mut into[44..44 + 4]);
    }
    fn size() -> usize {
        48
    }
}
pub struct DDHAL_DDPALETTECALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub DestroyPalette: LPDDHALPALCB_DESTROYPALETTE,
    pub SetEntries: LPDDHALPALCB_SETENTRIES,
}
impl ::core::marker::Copy for DDHAL_DDPALETTECALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDPALETTECALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDPALETTECALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDPALETTECALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("DestroyPalette", &self.DestroyPalette)
            .field("SetEntries", &self.SetEntries)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDPALETTECALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.DestroyPalette == other.DestroyPalette
            && self.SetEntries == other.SetEntries
    }
}
impl ::core::cmp::Eq for DDHAL_DDPALETTECALLBACKS {}
impl FromIntoMemory for DDHAL_DDPALETTECALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DestroyPalette =
            <LPDDHALPALCB_DESTROYPALETTE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SetEntries =
            <LPDDHALPALCB_SETENTRIES as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            DestroyPalette: f_DestroyPalette,
            SetEntries: f_SetEntries,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DestroyPalette, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SetEntries, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_DDSURFACECALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub DestroySurface: LPDDHALSURFCB_DESTROYSURFACE,
    pub Flip: LPDDHALSURFCB_FLIP,
    pub SetClipList: LPDDHALSURFCB_SETCLIPLIST,
    pub Lock: LPDDHALSURFCB_LOCK,
    pub Unlock: LPDDHALSURFCB_UNLOCK,
    pub Blt: LPDDHALSURFCB_BLT,
    pub SetColorKey: LPDDHALSURFCB_SETCOLORKEY,
    pub AddAttachedSurface: LPDDHALSURFCB_ADDATTACHEDSURFACE,
    pub GetBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
    pub GetFlipStatus: LPDDHALSURFCB_GETFLIPSTATUS,
    pub UpdateOverlay: LPDDHALSURFCB_UPDATEOVERLAY,
    pub SetOverlayPosition: LPDDHALSURFCB_SETOVERLAYPOSITION,
    pub reserved4: MutPtr<::core::ffi::c_void>,
    pub SetPalette: LPDDHALSURFCB_SETPALETTE,
}
impl ::core::marker::Copy for DDHAL_DDSURFACECALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDSURFACECALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDSURFACECALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDSURFACECALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("DestroySurface", &self.DestroySurface)
            .field("Flip", &self.Flip)
            .field("SetClipList", &self.SetClipList)
            .field("Lock", &self.Lock)
            .field("Unlock", &self.Unlock)
            .field("Blt", &self.Blt)
            .field("SetColorKey", &self.SetColorKey)
            .field("AddAttachedSurface", &self.AddAttachedSurface)
            .field("GetBltStatus", &self.GetBltStatus)
            .field("GetFlipStatus", &self.GetFlipStatus)
            .field("UpdateOverlay", &self.UpdateOverlay)
            .field("SetOverlayPosition", &self.SetOverlayPosition)
            .field("reserved4", &self.reserved4)
            .field("SetPalette", &self.SetPalette)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDSURFACECALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.DestroySurface == other.DestroySurface
            && self.Flip == other.Flip
            && self.SetClipList == other.SetClipList
            && self.Lock == other.Lock
            && self.Unlock == other.Unlock
            && self.Blt == other.Blt
            && self.SetColorKey == other.SetColorKey
            && self.AddAttachedSurface == other.AddAttachedSurface
            && self.GetBltStatus == other.GetBltStatus
            && self.GetFlipStatus == other.GetFlipStatus
            && self.UpdateOverlay == other.UpdateOverlay
            && self.SetOverlayPosition == other.SetOverlayPosition
            && self.reserved4 == other.reserved4
            && self.SetPalette == other.SetPalette
    }
}
impl ::core::cmp::Eq for DDHAL_DDSURFACECALLBACKS {}
impl FromIntoMemory for DDHAL_DDSURFACECALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 64);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DestroySurface =
            <LPDDHALSURFCB_DESTROYSURFACE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Flip = <LPDDHALSURFCB_FLIP as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetClipList =
            <LPDDHALSURFCB_SETCLIPLIST as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Lock = <LPDDHALSURFCB_LOCK as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_Unlock = <LPDDHALSURFCB_UNLOCK as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_Blt = <LPDDHALSURFCB_BLT as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_SetColorKey =
            <LPDDHALSURFCB_SETCOLORKEY as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_AddAttachedSurface =
            <LPDDHALSURFCB_ADDATTACHEDSURFACE as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_GetBltStatus =
            <LPDDHALSURFCB_GETBLTSTATUS as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_GetFlipStatus =
            <LPDDHALSURFCB_GETFLIPSTATUS as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_UpdateOverlay =
            <LPDDHALSURFCB_UPDATEOVERLAY as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_SetOverlayPosition =
            <LPDDHALSURFCB_SETOVERLAYPOSITION as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_reserved4 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_SetPalette =
            <LPDDHALSURFCB_SETPALETTE as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            DestroySurface: f_DestroySurface,
            Flip: f_Flip,
            SetClipList: f_SetClipList,
            Lock: f_Lock,
            Unlock: f_Unlock,
            Blt: f_Blt,
            SetColorKey: f_SetColorKey,
            AddAttachedSurface: f_AddAttachedSurface,
            GetBltStatus: f_GetBltStatus,
            GetFlipStatus: f_GetFlipStatus,
            UpdateOverlay: f_UpdateOverlay,
            SetOverlayPosition: f_SetOverlayPosition,
            reserved4: f_reserved4,
            SetPalette: f_SetPalette,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 64);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DestroySurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Flip, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetClipList, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Lock, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.Unlock, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.Blt, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.AddAttachedSurface, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.GetBltStatus, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.GetFlipStatus, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.UpdateOverlay, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.SetOverlayPosition, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.reserved4, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.SetPalette, &mut into[60..60 + 4]);
    }
    fn size() -> usize {
        64
    }
}
pub struct DDHAL_DDVIDEOPORTCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub CanCreateVideoPort: LPDDHALVPORTCB_CANCREATEVIDEOPORT,
    pub CreateVideoPort: LPDDHALVPORTCB_CREATEVIDEOPORT,
    pub FlipVideoPort: LPDDHALVPORTCB_FLIP,
    pub GetVideoPortBandwidth: LPDDHALVPORTCB_GETBANDWIDTH,
    pub GetVideoPortInputFormats: LPDDHALVPORTCB_GETINPUTFORMATS,
    pub GetVideoPortOutputFormats: LPDDHALVPORTCB_GETOUTPUTFORMATS,
    pub lpReserved1: MutPtr<::core::ffi::c_void>,
    pub GetVideoPortField: LPDDHALVPORTCB_GETFIELD,
    pub GetVideoPortLine: LPDDHALVPORTCB_GETLINE,
    pub GetVideoPortConnectInfo: LPDDHALVPORTCB_GETVPORTCONNECT,
    pub DestroyVideoPort: LPDDHALVPORTCB_DESTROYVPORT,
    pub GetVideoPortFlipStatus: LPDDHALVPORTCB_GETFLIPSTATUS,
    pub UpdateVideoPort: LPDDHALVPORTCB_UPDATE,
    pub WaitForVideoPortSync: LPDDHALVPORTCB_WAITFORSYNC,
    pub GetVideoSignalStatus: LPDDHALVPORTCB_GETSIGNALSTATUS,
    pub ColorControl: LPDDHALVPORTCB_COLORCONTROL,
}
impl ::core::marker::Copy for DDHAL_DDVIDEOPORTCALLBACKS {}
impl ::core::clone::Clone for DDHAL_DDVIDEOPORTCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DDVIDEOPORTCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DDVIDEOPORTCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("CanCreateVideoPort", &self.CanCreateVideoPort)
            .field("CreateVideoPort", &self.CreateVideoPort)
            .field("FlipVideoPort", &self.FlipVideoPort)
            .field("GetVideoPortBandwidth", &self.GetVideoPortBandwidth)
            .field("GetVideoPortInputFormats", &self.GetVideoPortInputFormats)
            .field("GetVideoPortOutputFormats", &self.GetVideoPortOutputFormats)
            .field("lpReserved1", &self.lpReserved1)
            .field("GetVideoPortField", &self.GetVideoPortField)
            .field("GetVideoPortLine", &self.GetVideoPortLine)
            .field("GetVideoPortConnectInfo", &self.GetVideoPortConnectInfo)
            .field("DestroyVideoPort", &self.DestroyVideoPort)
            .field("GetVideoPortFlipStatus", &self.GetVideoPortFlipStatus)
            .field("UpdateVideoPort", &self.UpdateVideoPort)
            .field("WaitForVideoPortSync", &self.WaitForVideoPortSync)
            .field("GetVideoSignalStatus", &self.GetVideoSignalStatus)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DDVIDEOPORTCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.CanCreateVideoPort == other.CanCreateVideoPort
            && self.CreateVideoPort == other.CreateVideoPort
            && self.FlipVideoPort == other.FlipVideoPort
            && self.GetVideoPortBandwidth == other.GetVideoPortBandwidth
            && self.GetVideoPortInputFormats == other.GetVideoPortInputFormats
            && self.GetVideoPortOutputFormats == other.GetVideoPortOutputFormats
            && self.lpReserved1 == other.lpReserved1
            && self.GetVideoPortField == other.GetVideoPortField
            && self.GetVideoPortLine == other.GetVideoPortLine
            && self.GetVideoPortConnectInfo == other.GetVideoPortConnectInfo
            && self.DestroyVideoPort == other.DestroyVideoPort
            && self.GetVideoPortFlipStatus == other.GetVideoPortFlipStatus
            && self.UpdateVideoPort == other.UpdateVideoPort
            && self.WaitForVideoPortSync == other.WaitForVideoPortSync
            && self.GetVideoSignalStatus == other.GetVideoSignalStatus
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DDHAL_DDVIDEOPORTCALLBACKS {}
impl FromIntoMemory for DDHAL_DDVIDEOPORTCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 72);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_CanCreateVideoPort =
            <LPDDHALVPORTCB_CANCREATEVIDEOPORT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateVideoPort =
            <LPDDHALVPORTCB_CREATEVIDEOPORT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_FlipVideoPort =
            <LPDDHALVPORTCB_FLIP as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetVideoPortBandwidth =
            <LPDDHALVPORTCB_GETBANDWIDTH as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_GetVideoPortInputFormats =
            <LPDDHALVPORTCB_GETINPUTFORMATS as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_GetVideoPortOutputFormats =
            <LPDDHALVPORTCB_GETOUTPUTFORMATS as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_lpReserved1 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_GetVideoPortField =
            <LPDDHALVPORTCB_GETFIELD as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_GetVideoPortLine =
            <LPDDHALVPORTCB_GETLINE as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_GetVideoPortConnectInfo =
            <LPDDHALVPORTCB_GETVPORTCONNECT as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_DestroyVideoPort =
            <LPDDHALVPORTCB_DESTROYVPORT as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_GetVideoPortFlipStatus =
            <LPDDHALVPORTCB_GETFLIPSTATUS as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_UpdateVideoPort =
            <LPDDHALVPORTCB_UPDATE as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_WaitForVideoPortSync =
            <LPDDHALVPORTCB_WAITFORSYNC as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_GetVideoSignalStatus =
            <LPDDHALVPORTCB_GETSIGNALSTATUS as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_ColorControl =
            <LPDDHALVPORTCB_COLORCONTROL as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            CanCreateVideoPort: f_CanCreateVideoPort,
            CreateVideoPort: f_CreateVideoPort,
            FlipVideoPort: f_FlipVideoPort,
            GetVideoPortBandwidth: f_GetVideoPortBandwidth,
            GetVideoPortInputFormats: f_GetVideoPortInputFormats,
            GetVideoPortOutputFormats: f_GetVideoPortOutputFormats,
            lpReserved1: f_lpReserved1,
            GetVideoPortField: f_GetVideoPortField,
            GetVideoPortLine: f_GetVideoPortLine,
            GetVideoPortConnectInfo: f_GetVideoPortConnectInfo,
            DestroyVideoPort: f_DestroyVideoPort,
            GetVideoPortFlipStatus: f_GetVideoPortFlipStatus,
            UpdateVideoPort: f_UpdateVideoPort,
            WaitForVideoPortSync: f_WaitForVideoPortSync,
            GetVideoSignalStatus: f_GetVideoSignalStatus,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 72);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateVideoPort, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateVideoPort, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.FlipVideoPort, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortBandwidth, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortInputFormats, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortOutputFormats, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpReserved1, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortField, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortLine, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortConnectInfo, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.DestroyVideoPort, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortFlipStatus, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.UpdateVideoPort, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.WaitForVideoPortSync, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoSignalStatus, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[68..68 + 4]);
    }
    fn size() -> usize {
        72
    }
}
pub struct DDHAL_DESTROYDDLOCALDATA {
    pub dwFlags: u32,
    pub pDDLcl: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DDHAL_DESTROYDDLOCALDATA {}
impl ::core::clone::Clone for DDHAL_DESTROYDDLOCALDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DESTROYDDLOCALDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DESTROYDDLOCALDATA")
            .field("dwFlags", &self.dwFlags)
            .field("pDDLcl", &self.pDDLcl)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DESTROYDDLOCALDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.pDDLcl == other.pDDLcl && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DDHAL_DESTROYDDLOCALDATA {}
impl FromIntoMemory for DDHAL_DESTROYDDLOCALDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pDDLcl =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwFlags: f_dwFlags,
            pDDLcl: f_pDDLcl,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pDDLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DDHAL_DESTROYDRIVERDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroyDriver: LPDDHAL_DESTROYDRIVER,
}
impl ::core::marker::Copy for DDHAL_DESTROYDRIVERDATA {}
impl ::core::clone::Clone for DDHAL_DESTROYDRIVERDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DESTROYDRIVERDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DESTROYDRIVERDATA")
            .field("lpDD", &self.lpDD)
            .field("ddRVal", &self.ddRVal)
            .field("DestroyDriver", &self.DestroyDriver)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DESTROYDRIVERDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.ddRVal == other.ddRVal
            && self.DestroyDriver == other.DestroyDriver
    }
}
impl ::core::cmp::Eq for DDHAL_DESTROYDRIVERDATA {}
impl FromIntoMemory for DDHAL_DESTROYDRIVERDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DestroyDriver =
            <LPDDHAL_DESTROYDRIVER as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            lpDD: f_lpDD,
            ddRVal: f_ddRVal,
            DestroyDriver: f_DestroyDriver,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DestroyDriver, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DDHAL_DESTROYMOCOMPDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpMoComp: MutPtr<DDRAWI_DDMOTIONCOMP_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroyMoComp: LPDDHALMOCOMPCB_DESTROY,
}
impl ::core::marker::Copy for DDHAL_DESTROYMOCOMPDATA {}
impl ::core::clone::Clone for DDHAL_DESTROYMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DESTROYMOCOMPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DESTROYMOCOMPDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("ddRVal", &self.ddRVal)
            .field("DestroyMoComp", &self.DestroyMoComp)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DESTROYMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.ddRVal == other.ddRVal
            && self.DestroyMoComp == other.DestroyMoComp
    }
}
impl ::core::cmp::Eq for DDHAL_DESTROYMOCOMPDATA {}
impl FromIntoMemory for DDHAL_DESTROYMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DDRAWI_DDMOTIONCOMP_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_DestroyMoComp =
            <LPDDHALMOCOMPCB_DESTROY as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            ddRVal: f_ddRVal,
            DestroyMoComp: f_DestroyMoComp,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.DestroyMoComp, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_DESTROYPALETTEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDPalette: MutPtr<DDRAWI_DDRAWPALETTE_GBL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroyPalette: LPDDHALPALCB_DESTROYPALETTE,
}
impl ::core::marker::Copy for DDHAL_DESTROYPALETTEDATA {}
impl ::core::clone::Clone for DDHAL_DESTROYPALETTEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DESTROYPALETTEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DESTROYPALETTEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("ddRVal", &self.ddRVal)
            .field("DestroyPalette", &self.DestroyPalette)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DESTROYPALETTEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDPalette == other.lpDDPalette
            && self.ddRVal == other.ddRVal
            && self.DestroyPalette == other.DestroyPalette
    }
}
impl ::core::cmp::Eq for DDHAL_DESTROYPALETTEDATA {}
impl FromIntoMemory for DDHAL_DESTROYPALETTEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDPalette =
            <MutPtr<DDRAWI_DDRAWPALETTE_GBL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_DestroyPalette =
            <LPDDHALPALCB_DESTROYPALETTE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDPalette: f_lpDDPalette,
            ddRVal: f_ddRVal,
            DestroyPalette: f_DestroyPalette,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.DestroyPalette, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_DESTROYSURFACEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroySurface: LPDDHALSURFCB_DESTROYSURFACE,
}
impl ::core::marker::Copy for DDHAL_DESTROYSURFACEDATA {}
impl ::core::clone::Clone for DDHAL_DESTROYSURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DESTROYSURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DESTROYSURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("ddRVal", &self.ddRVal)
            .field("DestroySurface", &self.DestroySurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DESTROYSURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.ddRVal == other.ddRVal
            && self.DestroySurface == other.DestroySurface
    }
}
impl ::core::cmp::Eq for DDHAL_DESTROYSURFACEDATA {}
impl FromIntoMemory for DDHAL_DESTROYSURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_DestroySurface =
            <LPDDHALSURFCB_DESTROYSURFACE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            ddRVal: f_ddRVal,
            DestroySurface: f_DestroySurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.DestroySurface, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_DESTROYVPORTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroyVideoPort: LPDDHALVPORTCB_DESTROYVPORT,
}
impl ::core::marker::Copy for DDHAL_DESTROYVPORTDATA {}
impl ::core::clone::Clone for DDHAL_DESTROYVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DESTROYVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DESTROYVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("ddRVal", &self.ddRVal)
            .field("DestroyVideoPort", &self.DestroyVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DESTROYVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.ddRVal == other.ddRVal
            && self.DestroyVideoPort == other.DestroyVideoPort
    }
}
impl ::core::cmp::Eq for DDHAL_DESTROYVPORTDATA {}
impl FromIntoMemory for DDHAL_DESTROYVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_DestroyVideoPort =
            <LPDDHALVPORTCB_DESTROYVPORT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            ddRVal: f_ddRVal,
            DestroyVideoPort: f_DestroyVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.DestroyVideoPort, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const DDHAL_DRIVER_DLLNAME: &'static str = "DDRAW16.DLL";
pub const DDHAL_DRIVER_HANDLED: i32 = 1i32;
pub const DDHAL_DRIVER_NOCKEYHW: i32 = 2i32;
pub const DDHAL_DRIVER_NOTHANDLED: i32 = 0i32;
pub struct DDHAL_DRVSETCOLORKEYDATA {
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwFlags: u32,
    pub ckNew: DDCOLORKEY,
    pub ddRVal: crate::core::HRESULT,
    pub SetColorKey: LPDDHAL_SETCOLORKEY,
}
impl ::core::marker::Copy for DDHAL_DRVSETCOLORKEYDATA {}
impl ::core::clone::Clone for DDHAL_DRVSETCOLORKEYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_DRVSETCOLORKEYDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_DRVSETCOLORKEYDATA")
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ckNew", &self.ckNew)
            .field("ddRVal", &self.ddRVal)
            .field("SetColorKey", &self.SetColorKey)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_DRVSETCOLORKEYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ckNew == other.ckNew
            && self.ddRVal == other.ddRVal
            && self.SetColorKey == other.SetColorKey
    }
}
impl ::core::cmp::Eq for DDHAL_DRVSETCOLORKEYDATA {}
impl FromIntoMemory for DDHAL_DRVSETCOLORKEYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ckNew = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[8..8 + 8]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_SetColorKey = <LPDDHAL_SETCOLORKEY as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ckNew: f_ckNew,
            ddRVal: f_ddRVal,
            SetColorKey: f_SetColorKey,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ckNew, &mut into[8..8 + 8]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_ENDMOCOMPFRAMEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpMoComp: MutPtr<DDRAWI_DDMOTIONCOMP_LCL>,
    pub lpInputData: MutPtr<::core::ffi::c_void>,
    pub dwInputDataSize: u32,
    pub ddRVal: crate::core::HRESULT,
    pub EndMoCompFrame: LPDDHALMOCOMPCB_ENDFRAME,
}
impl ::core::marker::Copy for DDHAL_ENDMOCOMPFRAMEDATA {}
impl ::core::clone::Clone for DDHAL_ENDMOCOMPFRAMEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_ENDMOCOMPFRAMEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_ENDMOCOMPFRAMEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("lpInputData", &self.lpInputData)
            .field("dwInputDataSize", &self.dwInputDataSize)
            .field("ddRVal", &self.ddRVal)
            .field("EndMoCompFrame", &self.EndMoCompFrame)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_ENDMOCOMPFRAMEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpInputData == other.lpInputData
            && self.dwInputDataSize == other.dwInputDataSize
            && self.ddRVal == other.ddRVal
            && self.EndMoCompFrame == other.EndMoCompFrame
    }
}
impl ::core::cmp::Eq for DDHAL_ENDMOCOMPFRAMEDATA {}
impl FromIntoMemory for DDHAL_ENDMOCOMPFRAMEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DDRAWI_DDMOTIONCOMP_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpInputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwInputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_EndMoCompFrame =
            <LPDDHALMOCOMPCB_ENDFRAME as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpInputData: f_lpInputData,
            dwInputDataSize: f_dwInputDataSize,
            ddRVal: f_ddRVal,
            EndMoCompFrame: f_EndMoCompFrame,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpInputData, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwInputDataSize, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.EndMoCompFrame, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub const DDHAL_EXEBUFCB32_CANCREATEEXEBUF: i32 = 1i32;
pub const DDHAL_EXEBUFCB32_CREATEEXEBUF: i32 = 2i32;
pub const DDHAL_EXEBUFCB32_DESTROYEXEBUF: i32 = 4i32;
pub const DDHAL_EXEBUFCB32_LOCKEXEBUF: i32 = 8i32;
pub const DDHAL_EXEBUFCB32_UNLOCKEXEBUF: i32 = 16i32;
pub struct DDHAL_FLIPDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpSurfCurr: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpSurfTarg: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub Flip: LPDDHALSURFCB_FLIP,
    pub lpSurfCurrLeft: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpSurfTargLeft: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
}
impl ::core::marker::Copy for DDHAL_FLIPDATA {}
impl ::core::clone::Clone for DDHAL_FLIPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_FLIPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_FLIPDATA")
            .field("lpDD", &self.lpDD)
            .field("lpSurfCurr", &self.lpSurfCurr)
            .field("lpSurfTarg", &self.lpSurfTarg)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("Flip", &self.Flip)
            .field("lpSurfCurrLeft", &self.lpSurfCurrLeft)
            .field("lpSurfTargLeft", &self.lpSurfTargLeft)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_FLIPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpSurfCurr == other.lpSurfCurr
            && self.lpSurfTarg == other.lpSurfTarg
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.Flip == other.Flip
            && self.lpSurfCurrLeft == other.lpSurfCurrLeft
            && self.lpSurfTargLeft == other.lpSurfTargLeft
    }
}
impl ::core::cmp::Eq for DDHAL_FLIPDATA {}
impl FromIntoMemory for DDHAL_FLIPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpSurfCurr =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurfTarg =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Flip = <LPDDHALSURFCB_FLIP as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpSurfCurrLeft =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpSurfTargLeft =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            lpDD: f_lpDD,
            lpSurfCurr: f_lpSurfCurr,
            lpSurfTarg: f_lpSurfTarg,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            Flip: f_Flip,
            lpSurfCurrLeft: f_lpSurfCurrLeft,
            lpSurfTargLeft: f_lpSurfTargLeft,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfCurr, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfTarg, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Flip, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfCurrLeft, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfTargLeft, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DDHAL_FLIPTOGDISURFACEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwToGDI: u32,
    pub dwReserved: u32,
    pub ddRVal: crate::core::HRESULT,
    pub FlipToGDISurface: LPDDHAL_FLIPTOGDISURFACE,
}
impl ::core::marker::Copy for DDHAL_FLIPTOGDISURFACEDATA {}
impl ::core::clone::Clone for DDHAL_FLIPTOGDISURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_FLIPTOGDISURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_FLIPTOGDISURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("dwToGDI", &self.dwToGDI)
            .field("dwReserved", &self.dwReserved)
            .field("ddRVal", &self.ddRVal)
            .field("FlipToGDISurface", &self.FlipToGDISurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_FLIPTOGDISURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwToGDI == other.dwToGDI
            && self.dwReserved == other.dwReserved
            && self.ddRVal == other.ddRVal
            && self.FlipToGDISurface == other.FlipToGDISurface
    }
}
impl ::core::cmp::Eq for DDHAL_FLIPTOGDISURFACEDATA {}
impl FromIntoMemory for DDHAL_FLIPTOGDISURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwToGDI = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_FlipToGDISurface =
            <LPDDHAL_FLIPTOGDISURFACE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            dwToGDI: f_dwToGDI,
            dwReserved: f_dwReserved,
            ddRVal: f_ddRVal,
            FlipToGDISurface: f_FlipToGDISurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwToGDI, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.FlipToGDISurface, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_FLIPVPORTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub lpSurfCurr: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpSurfTarg: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub FlipVideoPort: LPDDHALVPORTCB_FLIP,
}
impl ::core::marker::Copy for DDHAL_FLIPVPORTDATA {}
impl ::core::clone::Clone for DDHAL_FLIPVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_FLIPVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_FLIPVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("lpSurfCurr", &self.lpSurfCurr)
            .field("lpSurfTarg", &self.lpSurfTarg)
            .field("ddRVal", &self.ddRVal)
            .field("FlipVideoPort", &self.FlipVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_FLIPVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.lpSurfCurr == other.lpSurfCurr
            && self.lpSurfTarg == other.lpSurfTarg
            && self.ddRVal == other.ddRVal
            && self.FlipVideoPort == other.FlipVideoPort
    }
}
impl ::core::cmp::Eq for DDHAL_FLIPVPORTDATA {}
impl FromIntoMemory for DDHAL_FLIPVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurfCurr =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpSurfTarg =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_FlipVideoPort =
            <LPDDHALVPORTCB_FLIP as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            lpSurfCurr: f_lpSurfCurr,
            lpSurfTarg: f_lpSurfTarg,
            ddRVal: f_ddRVal,
            FlipVideoPort: f_FlipVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfCurr, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfTarg, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.FlipVideoPort, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_GETAVAILDRIVERMEMORYDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub DDSCaps: DDSCAPS,
    pub dwTotal: u32,
    pub dwFree: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetAvailDriverMemory: LPDDHAL_GETAVAILDRIVERMEMORY,
    pub ddsCapsEx: DDSCAPSEX,
}
impl ::core::marker::Copy for DDHAL_GETAVAILDRIVERMEMORYDATA {}
impl ::core::clone::Clone for DDHAL_GETAVAILDRIVERMEMORYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETAVAILDRIVERMEMORYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.DDSCaps == other.DDSCaps
            && self.dwTotal == other.dwTotal
            && self.dwFree == other.dwFree
            && self.ddRVal == other.ddRVal
            && self.GetAvailDriverMemory == other.GetAvailDriverMemory
            && self.ddsCapsEx == other.ddsCapsEx
    }
}
impl ::core::cmp::Eq for DDHAL_GETAVAILDRIVERMEMORYDATA {}
impl FromIntoMemory for DDHAL_GETAVAILDRIVERMEMORYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_DDSCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwTotal = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFree = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetAvailDriverMemory =
            <LPDDHAL_GETAVAILDRIVERMEMORY as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_ddsCapsEx = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[24..24 + 12]);
        Self {
            lpDD: f_lpDD,
            DDSCaps: f_DDSCaps,
            dwTotal: f_dwTotal,
            dwFree: f_dwFree,
            ddRVal: f_ddRVal,
            GetAvailDriverMemory: f_GetAvailDriverMemory,
            ddsCapsEx: f_ddsCapsEx,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.DDSCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwTotal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFree, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetAvailDriverMemory, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsEx, &mut into[24..24 + 12]);
    }
    fn size() -> usize {
        36
    }
}
pub struct DDHAL_GETBLTSTATUSDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
}
impl ::core::marker::Copy for DDHAL_GETBLTSTATUSDATA {}
impl ::core::clone::Clone for DDHAL_GETBLTSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETBLTSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETBLTSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("GetBltStatus", &self.GetBltStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETBLTSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.GetBltStatus == other.GetBltStatus
    }
}
impl ::core::cmp::Eq for DDHAL_GETBLTSTATUSDATA {}
impl FromIntoMemory for DDHAL_GETBLTSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetBltStatus =
            <LPDDHALSURFCB_GETBLTSTATUS as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            GetBltStatus: f_GetBltStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetBltStatus, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_GETDRIVERINFODATA {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub guidInfo: crate::core::GUID,
    pub dwExpectedSize: u32,
    pub lpvData: MutPtr<::core::ffi::c_void>,
    pub dwActualSize: u32,
    pub ddRVal: crate::core::HRESULT,
    pub dwContext: PtrRepr,
}
impl ::core::marker::Copy for DDHAL_GETDRIVERINFODATA {}
impl ::core::clone::Clone for DDHAL_GETDRIVERINFODATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETDRIVERINFODATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETDRIVERINFODATA")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("guidInfo", &self.guidInfo)
            .field("dwExpectedSize", &self.dwExpectedSize)
            .field("lpvData", &self.lpvData)
            .field("dwActualSize", &self.dwActualSize)
            .field("ddRVal", &self.ddRVal)
            .field("dwContext", &self.dwContext)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETDRIVERINFODATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.guidInfo == other.guidInfo
            && self.dwExpectedSize == other.dwExpectedSize
            && self.lpvData == other.lpvData
            && self.dwActualSize == other.dwActualSize
            && self.ddRVal == other.ddRVal
            && self.dwContext == other.dwContext
    }
}
impl ::core::cmp::Eq for DDHAL_GETDRIVERINFODATA {}
impl FromIntoMemory for DDHAL_GETDRIVERINFODATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_guidInfo = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_dwExpectedSize = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpvData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwActualSize = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwContext = <PtrRepr as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            guidInfo: f_guidInfo,
            dwExpectedSize: f_dwExpectedSize,
            lpvData: f_lpvData,
            dwActualSize: f_dwActualSize,
            ddRVal: f_ddRVal,
            dwContext: f_dwContext,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.guidInfo, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.dwExpectedSize, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpvData, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwActualSize, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwContext, &mut into[40..40 + 4]);
    }
    fn size() -> usize {
        44
    }
}
pub struct DDHAL_GETDRIVERSTATEDATA {
    pub dwFlags: u32,
    pub Anonymous: DDHAL_GETDRIVERSTATEDATA_0,
    pub lpdwStates: MutPtr<u32>,
    pub dwLength: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DDHAL_GETDRIVERSTATEDATA {}
impl ::core::clone::Clone for DDHAL_GETDRIVERSTATEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETDRIVERSTATEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.Anonymous == other.Anonymous
            && self.lpdwStates == other.lpdwStates
            && self.dwLength == other.dwLength
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DDHAL_GETDRIVERSTATEDATA {}
impl FromIntoMemory for DDHAL_GETDRIVERSTATEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_Anonymous =
            <DDHAL_GETDRIVERSTATEDATA_0 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpdwStates = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwLength = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwFlags: f_dwFlags,
            Anonymous: f_Anonymous,
            lpdwStates: f_lpdwStates,
            dwLength: f_dwLength,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpdwStates, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwLength, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_GETDRIVERSTATEDATA_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDHAL_GETDRIVERSTATEDATA_0 {}
impl ::core::clone::Clone for DDHAL_GETDRIVERSTATEDATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETDRIVERSTATEDATA_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDHAL_GETDRIVERSTATEDATA_0 {}
impl FromIntoMemory for DDHAL_GETDRIVERSTATEDATA_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDHAL_GETFLIPSTATUSDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetFlipStatus: LPDDHALSURFCB_GETFLIPSTATUS,
}
impl ::core::marker::Copy for DDHAL_GETFLIPSTATUSDATA {}
impl ::core::clone::Clone for DDHAL_GETFLIPSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETFLIPSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETFLIPSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("GetFlipStatus", &self.GetFlipStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETFLIPSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.GetFlipStatus == other.GetFlipStatus
    }
}
impl ::core::cmp::Eq for DDHAL_GETFLIPSTATUSDATA {}
impl FromIntoMemory for DDHAL_GETFLIPSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetFlipStatus =
            <LPDDHALSURFCB_GETFLIPSTATUS as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            GetFlipStatus: f_GetFlipStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetFlipStatus, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_GETHEAPALIGNMENTDATA {
    pub dwInstance: PtrRepr,
    pub dwHeap: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetHeapAlignment: LPDDHAL_GETHEAPALIGNMENT,
    pub Alignment: HEAPALIGNMENT,
}
impl ::core::marker::Copy for DDHAL_GETHEAPALIGNMENTDATA {}
impl ::core::clone::Clone for DDHAL_GETHEAPALIGNMENTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETHEAPALIGNMENTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwInstance == other.dwInstance
            && self.dwHeap == other.dwHeap
            && self.ddRVal == other.ddRVal
            && self.GetHeapAlignment == other.GetHeapAlignment
            && self.Alignment == other.Alignment
    }
}
impl ::core::cmp::Eq for DDHAL_GETHEAPALIGNMENTDATA {}
impl FromIntoMemory for DDHAL_GETHEAPALIGNMENTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 140);
        let f_dwInstance = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwHeap = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetHeapAlignment =
            <LPDDHAL_GETHEAPALIGNMENT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_Alignment = <HEAPALIGNMENT as FromIntoMemory>::from_bytes(&from[16..16 + 124]);
        Self {
            dwInstance: f_dwInstance,
            dwHeap: f_dwHeap,
            ddRVal: f_ddRVal,
            GetHeapAlignment: f_GetHeapAlignment,
            Alignment: f_Alignment,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 140);
        FromIntoMemory::into_bytes(self.dwInstance, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwHeap, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetHeapAlignment, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.Alignment, &mut into[16..16 + 124]);
    }
    fn size() -> usize {
        140
    }
}
pub struct DDHAL_GETINTERNALMOCOMPDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub ddPixelFormat: DDPIXELFORMAT,
    pub dwScratchMemAlloc: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetInternalMoCompInfo: LPDDHALMOCOMPCB_GETINTERNALINFO,
}
impl ::core::marker::Copy for DDHAL_GETINTERNALMOCOMPDATA {}
impl ::core::clone::Clone for DDHAL_GETINTERNALMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETINTERNALMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpGuid == other.lpGuid
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.ddPixelFormat == other.ddPixelFormat
            && self.dwScratchMemAlloc == other.dwScratchMemAlloc
            && self.ddRVal == other.ddRVal
            && self.GetInternalMoCompInfo == other.GetInternalMoCompInfo
    }
}
impl ::core::cmp::Eq for DDHAL_GETINTERNALMOCOMPDATA {}
impl FromIntoMemory for DDHAL_GETINTERNALMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddPixelFormat = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[16..16 + 32]);
        let f_dwScratchMemAlloc = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_GetInternalMoCompInfo =
            <LPDDHALMOCOMPCB_GETINTERNALINFO as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            lpDD: f_lpDD,
            lpGuid: f_lpGuid,
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            ddPixelFormat: f_ddPixelFormat,
            dwScratchMemAlloc: f_dwScratchMemAlloc,
            ddRVal: f_ddRVal,
            GetInternalMoCompInfo: f_GetInternalMoCompInfo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddPixelFormat, &mut into[16..16 + 32]);
        FromIntoMemory::into_bytes(self.dwScratchMemAlloc, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.GetInternalMoCompInfo, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
pub struct DDHAL_GETMOCOMPCOMPBUFFDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub ddPixelFormat: DDPIXELFORMAT,
    pub dwNumTypesCompBuffs: u32,
    pub lpCompBuffInfo: MutPtr<DDMCCOMPBUFFERINFO>,
    pub ddRVal: crate::core::HRESULT,
    pub GetMoCompBuffInfo: LPDDHALMOCOMPCB_GETCOMPBUFFINFO,
}
impl ::core::marker::Copy for DDHAL_GETMOCOMPCOMPBUFFDATA {}
impl ::core::clone::Clone for DDHAL_GETMOCOMPCOMPBUFFDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETMOCOMPCOMPBUFFDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpGuid == other.lpGuid
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.ddPixelFormat == other.ddPixelFormat
            && self.dwNumTypesCompBuffs == other.dwNumTypesCompBuffs
            && self.lpCompBuffInfo == other.lpCompBuffInfo
            && self.ddRVal == other.ddRVal
            && self.GetMoCompBuffInfo == other.GetMoCompBuffInfo
    }
}
impl ::core::cmp::Eq for DDHAL_GETMOCOMPCOMPBUFFDATA {}
impl FromIntoMemory for DDHAL_GETMOCOMPCOMPBUFFDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 64);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddPixelFormat = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[16..16 + 32]);
        let f_dwNumTypesCompBuffs = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_lpCompBuffInfo =
            <MutPtr<DDMCCOMPBUFFERINFO> as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_GetMoCompBuffInfo =
            <LPDDHALMOCOMPCB_GETCOMPBUFFINFO as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        Self {
            lpDD: f_lpDD,
            lpGuid: f_lpGuid,
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            ddPixelFormat: f_ddPixelFormat,
            dwNumTypesCompBuffs: f_dwNumTypesCompBuffs,
            lpCompBuffInfo: f_lpCompBuffInfo,
            ddRVal: f_ddRVal,
            GetMoCompBuffInfo: f_GetMoCompBuffInfo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 64);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddPixelFormat, &mut into[16..16 + 32]);
        FromIntoMemory::into_bytes(self.dwNumTypesCompBuffs, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.lpCompBuffInfo, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompBuffInfo, &mut into[60..60 + 4]);
    }
    fn size() -> usize {
        64
    }
}
pub struct DDHAL_GETMOCOMPFORMATSDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwNumFormats: u32,
    pub lpFormats: MutPtr<DDPIXELFORMAT>,
    pub ddRVal: crate::core::HRESULT,
    pub GetMoCompFormats: LPDDHALMOCOMPCB_GETFORMATS,
}
impl ::core::marker::Copy for DDHAL_GETMOCOMPFORMATSDATA {}
impl ::core::clone::Clone for DDHAL_GETMOCOMPFORMATSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETMOCOMPFORMATSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETMOCOMPFORMATSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpGuid", &self.lpGuid)
            .field("dwNumFormats", &self.dwNumFormats)
            .field("lpFormats", &self.lpFormats)
            .field("ddRVal", &self.ddRVal)
            .field("GetMoCompFormats", &self.GetMoCompFormats)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETMOCOMPFORMATSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpGuid == other.lpGuid
            && self.dwNumFormats == other.dwNumFormats
            && self.lpFormats == other.lpFormats
            && self.ddRVal == other.ddRVal
            && self.GetMoCompFormats == other.GetMoCompFormats
    }
}
impl ::core::cmp::Eq for DDHAL_GETMOCOMPFORMATSDATA {}
impl FromIntoMemory for DDHAL_GETMOCOMPFORMATSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwNumFormats = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpFormats = <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetMoCompFormats =
            <LPDDHALMOCOMPCB_GETFORMATS as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpGuid: f_lpGuid,
            dwNumFormats: f_dwNumFormats,
            lpFormats: f_lpFormats,
            ddRVal: f_ddRVal,
            GetMoCompFormats: f_GetMoCompFormats,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFormats, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpFormats, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompFormats, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_GETMOCOMPGUIDSDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub dwNumGuids: u32,
    pub lpGuids: MutPtr<crate::core::GUID>,
    pub ddRVal: crate::core::HRESULT,
    pub GetMoCompGuids: LPDDHALMOCOMPCB_GETGUIDS,
}
impl ::core::marker::Copy for DDHAL_GETMOCOMPGUIDSDATA {}
impl ::core::clone::Clone for DDHAL_GETMOCOMPGUIDSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETMOCOMPGUIDSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETMOCOMPGUIDSDATA")
            .field("lpDD", &self.lpDD)
            .field("dwNumGuids", &self.dwNumGuids)
            .field("lpGuids", &self.lpGuids)
            .field("ddRVal", &self.ddRVal)
            .field("GetMoCompGuids", &self.GetMoCompGuids)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETMOCOMPGUIDSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwNumGuids == other.dwNumGuids
            && self.lpGuids == other.lpGuids
            && self.ddRVal == other.ddRVal
            && self.GetMoCompGuids == other.GetMoCompGuids
    }
}
impl ::core::cmp::Eq for DDHAL_GETMOCOMPGUIDSDATA {}
impl FromIntoMemory for DDHAL_GETMOCOMPGUIDSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwNumGuids = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpGuids = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetMoCompGuids =
            <LPDDHALMOCOMPCB_GETGUIDS as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            dwNumGuids: f_dwNumGuids,
            lpGuids: f_lpGuids,
            ddRVal: f_ddRVal,
            GetMoCompGuids: f_GetMoCompGuids,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwNumGuids, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpGuids, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompGuids, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_GETSCANLINEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwScanLine: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetScanLine: LPDDHAL_GETSCANLINE,
}
impl ::core::marker::Copy for DDHAL_GETSCANLINEDATA {}
impl ::core::clone::Clone for DDHAL_GETSCANLINEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETSCANLINEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETSCANLINEDATA")
            .field("lpDD", &self.lpDD)
            .field("dwScanLine", &self.dwScanLine)
            .field("ddRVal", &self.ddRVal)
            .field("GetScanLine", &self.GetScanLine)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETSCANLINEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwScanLine == other.dwScanLine
            && self.ddRVal == other.ddRVal
            && self.GetScanLine == other.GetScanLine
    }
}
impl ::core::cmp::Eq for DDHAL_GETSCANLINEDATA {}
impl FromIntoMemory for DDHAL_GETSCANLINEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwScanLine = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetScanLine = <LPDDHAL_GETSCANLINE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            dwScanLine: f_dwScanLine,
            ddRVal: f_ddRVal,
            GetScanLine: f_GetScanLine,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwScanLine, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetScanLine, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_GETVPORTBANDWIDTHDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub lpddpfFormat: MutPtr<DDPIXELFORMAT>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dwFlags: u32,
    pub lpBandwidth: MutPtr<DDVIDEOPORTBANDWIDTH>,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortBandwidth: LPDDHALVPORTCB_GETBANDWIDTH,
}
impl ::core::marker::Copy for DDHAL_GETVPORTBANDWIDTHDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTBANDWIDTHDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTBANDWIDTHDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTBANDWIDTHDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("lpddpfFormat", &self.lpddpfFormat)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("dwFlags", &self.dwFlags)
            .field("lpBandwidth", &self.lpBandwidth)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortBandwidth", &self.GetVideoPortBandwidth)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTBANDWIDTHDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.lpddpfFormat == other.lpddpfFormat
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.dwFlags == other.dwFlags
            && self.lpBandwidth == other.lpBandwidth
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortBandwidth == other.GetVideoPortBandwidth
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTBANDWIDTHDATA {}
impl FromIntoMemory for DDHAL_GETVPORTBANDWIDTHDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpddpfFormat = <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpBandwidth =
            <MutPtr<DDVIDEOPORTBANDWIDTH> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_GetVideoPortBandwidth =
            <LPDDHALVPORTCB_GETBANDWIDTH as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            lpddpfFormat: f_lpddpfFormat,
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            dwFlags: f_dwFlags,
            lpBandwidth: f_lpBandwidth,
            ddRVal: f_ddRVal,
            GetVideoPortBandwidth: f_GetVideoPortBandwidth,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfFormat, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpBandwidth, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortBandwidth, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct DDHAL_GETVPORTCONNECTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub dwPortId: u32,
    pub lpConnect: MutPtr<DDVIDEOPORTCONNECT>,
    pub dwNumEntries: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortConnectInfo: LPDDHALVPORTCB_GETVPORTCONNECT,
}
impl ::core::marker::Copy for DDHAL_GETVPORTCONNECTDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTCONNECTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTCONNECTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTCONNECTDATA")
            .field("lpDD", &self.lpDD)
            .field("dwPortId", &self.dwPortId)
            .field("lpConnect", &self.lpConnect)
            .field("dwNumEntries", &self.dwNumEntries)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortConnectInfo", &self.GetVideoPortConnectInfo)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTCONNECTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwPortId == other.dwPortId
            && self.lpConnect == other.lpConnect
            && self.dwNumEntries == other.dwNumEntries
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortConnectInfo == other.GetVideoPortConnectInfo
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTCONNECTDATA {}
impl FromIntoMemory for DDHAL_GETVPORTCONNECTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwPortId = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpConnect =
            <MutPtr<DDVIDEOPORTCONNECT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwNumEntries = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetVideoPortConnectInfo =
            <LPDDHALVPORTCB_GETVPORTCONNECT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            dwPortId: f_dwPortId,
            lpConnect: f_lpConnect,
            dwNumEntries: f_dwNumEntries,
            ddRVal: f_ddRVal,
            GetVideoPortConnectInfo: f_GetVideoPortConnectInfo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwPortId, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpConnect, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwNumEntries, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortConnectInfo, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_GETVPORTFIELDDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub bField: super::super::Foundation::BOOL,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortField: LPDDHALVPORTCB_GETFIELD,
}
impl ::core::marker::Copy for DDHAL_GETVPORTFIELDDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTFIELDDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTFIELDDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTFIELDDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("bField", &self.bField)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortField", &self.GetVideoPortField)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTFIELDDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.bField == other.bField
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortField == other.GetVideoPortField
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTFIELDDATA {}
impl FromIntoMemory for DDHAL_GETVPORTFIELDDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bField =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetVideoPortField =
            <LPDDHALVPORTCB_GETFIELD as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            bField: f_bField,
            ddRVal: f_ddRVal,
            GetVideoPortField: f_GetVideoPortField,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bField, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortField, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_GETVPORTFLIPSTATUSDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub fpSurface: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortFlipStatus: LPDDHALVPORTCB_GETFLIPSTATUS,
}
impl ::core::marker::Copy for DDHAL_GETVPORTFLIPSTATUSDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTFLIPSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTFLIPSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTFLIPSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("fpSurface", &self.fpSurface)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortFlipStatus", &self.GetVideoPortFlipStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTFLIPSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.fpSurface == other.fpSurface
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortFlipStatus == other.GetVideoPortFlipStatus
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTFLIPSTATUSDATA {}
impl FromIntoMemory for DDHAL_GETVPORTFLIPSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fpSurface = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetVideoPortFlipStatus =
            <LPDDHALVPORTCB_GETFLIPSTATUS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            fpSurface: f_fpSurface,
            ddRVal: f_ddRVal,
            GetVideoPortFlipStatus: f_GetVideoPortFlipStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fpSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortFlipStatus, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_GETVPORTINPUTFORMATDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub dwFlags: u32,
    pub lpddpfFormat: MutPtr<DDPIXELFORMAT>,
    pub dwNumFormats: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortInputFormats: LPDDHALVPORTCB_GETINPUTFORMATS,
}
impl ::core::marker::Copy for DDHAL_GETVPORTINPUTFORMATDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTINPUTFORMATDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTINPUTFORMATDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTINPUTFORMATDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("lpddpfFormat", &self.lpddpfFormat)
            .field("dwNumFormats", &self.dwNumFormats)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortInputFormats", &self.GetVideoPortInputFormats)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTINPUTFORMATDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.lpddpfFormat == other.lpddpfFormat
            && self.dwNumFormats == other.dwNumFormats
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortInputFormats == other.GetVideoPortInputFormats
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTINPUTFORMATDATA {}
impl FromIntoMemory for DDHAL_GETVPORTINPUTFORMATDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpddpfFormat =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwNumFormats = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_GetVideoPortInputFormats =
            <LPDDHALVPORTCB_GETINPUTFORMATS as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            lpddpfFormat: f_lpddpfFormat,
            dwNumFormats: f_dwNumFormats,
            ddRVal: f_ddRVal,
            GetVideoPortInputFormats: f_GetVideoPortInputFormats,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfFormat, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFormats, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortInputFormats, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DDHAL_GETVPORTLINEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub dwLine: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortLine: LPDDHALVPORTCB_GETLINE,
}
impl ::core::marker::Copy for DDHAL_GETVPORTLINEDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTLINEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTLINEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTLINEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwLine", &self.dwLine)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortLine", &self.GetVideoPortLine)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTLINEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwLine == other.dwLine
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortLine == other.GetVideoPortLine
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTLINEDATA {}
impl FromIntoMemory for DDHAL_GETVPORTLINEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwLine = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetVideoPortLine =
            <LPDDHALVPORTCB_GETLINE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwLine: f_dwLine,
            ddRVal: f_ddRVal,
            GetVideoPortLine: f_GetVideoPortLine,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwLine, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortLine, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_GETVPORTOUTPUTFORMATDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub dwFlags: u32,
    pub lpddpfInputFormat: MutPtr<DDPIXELFORMAT>,
    pub lpddpfOutputFormats: MutPtr<DDPIXELFORMAT>,
    pub dwNumFormats: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortOutputFormats: LPDDHALVPORTCB_GETOUTPUTFORMATS,
}
impl ::core::marker::Copy for DDHAL_GETVPORTOUTPUTFORMATDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTOUTPUTFORMATDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTOUTPUTFORMATDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTOUTPUTFORMATDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("lpddpfInputFormat", &self.lpddpfInputFormat)
            .field("lpddpfOutputFormats", &self.lpddpfOutputFormats)
            .field("dwNumFormats", &self.dwNumFormats)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortOutputFormats", &self.GetVideoPortOutputFormats)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTOUTPUTFORMATDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.lpddpfInputFormat == other.lpddpfInputFormat
            && self.lpddpfOutputFormats == other.lpddpfOutputFormats
            && self.dwNumFormats == other.dwNumFormats
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortOutputFormats == other.GetVideoPortOutputFormats
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTOUTPUTFORMATDATA {}
impl FromIntoMemory for DDHAL_GETVPORTOUTPUTFORMATDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpddpfInputFormat =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpddpfOutputFormats =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwNumFormats = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_GetVideoPortOutputFormats =
            <LPDDHALVPORTCB_GETOUTPUTFORMATS as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            lpddpfInputFormat: f_lpddpfInputFormat,
            lpddpfOutputFormats: f_lpddpfOutputFormats,
            dwNumFormats: f_dwNumFormats,
            ddRVal: f_ddRVal,
            GetVideoPortOutputFormats: f_GetVideoPortOutputFormats,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfInputFormat, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfOutputFormats, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFormats, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortOutputFormats, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DDHAL_GETVPORTSIGNALDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub dwStatus: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoSignalStatus: LPDDHALVPORTCB_GETSIGNALSTATUS,
}
impl ::core::marker::Copy for DDHAL_GETVPORTSIGNALDATA {}
impl ::core::clone::Clone for DDHAL_GETVPORTSIGNALDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_GETVPORTSIGNALDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_GETVPORTSIGNALDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwStatus", &self.dwStatus)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoSignalStatus", &self.GetVideoSignalStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_GETVPORTSIGNALDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwStatus == other.dwStatus
            && self.ddRVal == other.ddRVal
            && self.GetVideoSignalStatus == other.GetVideoSignalStatus
    }
}
impl ::core::cmp::Eq for DDHAL_GETVPORTSIGNALDATA {}
impl FromIntoMemory for DDHAL_GETVPORTSIGNALDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwStatus = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetVideoSignalStatus =
            <LPDDHALVPORTCB_GETSIGNALSTATUS as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwStatus: f_dwStatus,
            ddRVal: f_ddRVal,
            GetVideoSignalStatus: f_GetVideoSignalStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwStatus, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoSignalStatus, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub const DDHAL_KERNEL_SYNCSURFACEDATA: i32 = 1i32;
pub const DDHAL_KERNEL_SYNCVIDEOPORTDATA: i32 = 2i32;
pub struct DDHAL_LOCKDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub bHasRect: u32,
    pub rArea: super::super::Foundation::RECTL,
    pub lpSurfData: MutPtr<::core::ffi::c_void>,
    pub ddRVal: crate::core::HRESULT,
    pub Lock: LPDDHALSURFCB_LOCK,
    pub dwFlags: u32,
}
impl ::core::marker::Copy for DDHAL_LOCKDATA {}
impl ::core::clone::Clone for DDHAL_LOCKDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_LOCKDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_LOCKDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("bHasRect", &self.bHasRect)
            .field("rArea", &self.rArea)
            .field("lpSurfData", &self.lpSurfData)
            .field("ddRVal", &self.ddRVal)
            .field("Lock", &self.Lock)
            .field("dwFlags", &self.dwFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_LOCKDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.bHasRect == other.bHasRect
            && self.rArea == other.rArea
            && self.lpSurfData == other.lpSurfData
            && self.ddRVal == other.ddRVal
            && self.Lock == other.Lock
            && self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for DDHAL_LOCKDATA {}
impl FromIntoMemory for DDHAL_LOCKDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bHasRect = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_rArea =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        let f_lpSurfData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_Lock = <LPDDHALSURFCB_LOCK as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            bHasRect: f_bHasRect,
            rArea: f_rArea,
            lpSurfData: f_lpSurfData,
            ddRVal: f_ddRVal,
            Lock: f_Lock,
            dwFlags: f_dwFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bHasRect, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.rArea, &mut into[12..12 + 16]);
        FromIntoMemory::into_bytes(self.lpSurfData, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.Lock, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[40..40 + 4]);
    }
    fn size() -> usize {
        44
    }
}
pub const DDHAL_MISC2CB32_ALPHABLT: i32 = 1i32;
pub const DDHAL_MISC2CB32_CREATESURFACEEX: i32 = 2i32;
pub const DDHAL_MISC2CB32_DESTROYDDLOCAL: i32 = 8i32;
pub const DDHAL_MISC2CB32_GETDRIVERSTATE: i32 = 4i32;
pub const DDHAL_MISCCB32_GETAVAILDRIVERMEMORY: i32 = 1i32;
pub const DDHAL_MISCCB32_GETHEAPALIGNMENT: i32 = 4i32;
pub const DDHAL_MISCCB32_GETSYSMEMBLTSTATUS: i32 = 8i32;
pub const DDHAL_MISCCB32_UPDATENONLOCALHEAP: i32 = 2i32;
pub const DDHAL_MOCOMP32_BEGINFRAME: u32 = 32u32;
pub const DDHAL_MOCOMP32_CREATE: u32 = 4u32;
pub const DDHAL_MOCOMP32_DESTROY: u32 = 512u32;
pub const DDHAL_MOCOMP32_ENDFRAME: u32 = 64u32;
pub const DDHAL_MOCOMP32_GETCOMPBUFFINFO: u32 = 8u32;
pub const DDHAL_MOCOMP32_GETFORMATS: u32 = 2u32;
pub const DDHAL_MOCOMP32_GETGUIDS: u32 = 1u32;
pub const DDHAL_MOCOMP32_GETINTERNALINFO: u32 = 16u32;
pub const DDHAL_MOCOMP32_QUERYSTATUS: u32 = 256u32;
pub const DDHAL_MOCOMP32_RENDER: u32 = 128u32;
pub const DDHAL_NTCB32_FLIPTOGDISURFACE: i32 = 4i32;
pub const DDHAL_NTCB32_FREEDRIVERMEMORY: i32 = 1i32;
pub const DDHAL_NTCB32_SETEXCLUSIVEMODE: i32 = 2i32;
pub const DDHAL_PALCB32_DESTROYPALETTE: i32 = 1i32;
pub const DDHAL_PALCB32_SETENTRIES: i32 = 2i32;
pub const DDHAL_PLEASEALLOC_BLOCKSIZE: i32 = 2i32;
pub const DDHAL_PLEASEALLOC_LINEARSIZE: i32 = 3i32;
pub const DDHAL_PLEASEALLOC_USERMEM: i32 = 4i32;
pub const DDHAL_PRIVATECAP_ATOMICSURFACECREATION: i32 = 1i32;
pub const DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION: i32 = 2i32;
pub const DDHAL_PRIVATECAP_RESERVED1: i32 = 4i32;
pub struct DDHAL_QUERYMOCOMPSTATUSDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpMoComp: MutPtr<DDRAWI_DDMOTIONCOMP_LCL>,
    pub lpSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub QueryMoCompStatus: LPDDHALMOCOMPCB_QUERYSTATUS,
}
impl ::core::marker::Copy for DDHAL_QUERYMOCOMPSTATUSDATA {}
impl ::core::clone::Clone for DDHAL_QUERYMOCOMPSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_QUERYMOCOMPSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_QUERYMOCOMPSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("lpSurface", &self.lpSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("QueryMoCompStatus", &self.QueryMoCompStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_QUERYMOCOMPSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpSurface == other.lpSurface
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.QueryMoCompStatus == other.QueryMoCompStatus
    }
}
impl ::core::cmp::Eq for DDHAL_QUERYMOCOMPSTATUSDATA {}
impl FromIntoMemory for DDHAL_QUERYMOCOMPSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DDRAWI_DDMOTIONCOMP_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_QueryMoCompStatus =
            <LPDDHALMOCOMPCB_QUERYSTATUS as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpSurface: f_lpSurface,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            QueryMoCompStatus: f_QueryMoCompStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.QueryMoCompStatus, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_RENDERMOCOMPDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpMoComp: MutPtr<DDRAWI_DDMOTIONCOMP_LCL>,
    pub dwNumBuffers: u32,
    pub lpBufferInfo: MutPtr<DDMCBUFFERINFO>,
    pub dwFunction: u32,
    pub lpInputData: MutPtr<::core::ffi::c_void>,
    pub dwInputDataSize: u32,
    pub lpOutputData: MutPtr<::core::ffi::c_void>,
    pub dwOutputDataSize: u32,
    pub ddRVal: crate::core::HRESULT,
    pub RenderMoComp: LPDDHALMOCOMPCB_RENDER,
}
impl ::core::marker::Copy for DDHAL_RENDERMOCOMPDATA {}
impl ::core::clone::Clone for DDHAL_RENDERMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_RENDERMOCOMPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_RENDERMOCOMPDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("dwNumBuffers", &self.dwNumBuffers)
            .field("lpBufferInfo", &self.lpBufferInfo)
            .field("dwFunction", &self.dwFunction)
            .field("lpInputData", &self.lpInputData)
            .field("dwInputDataSize", &self.dwInputDataSize)
            .field("lpOutputData", &self.lpOutputData)
            .field("dwOutputDataSize", &self.dwOutputDataSize)
            .field("ddRVal", &self.ddRVal)
            .field("RenderMoComp", &self.RenderMoComp)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_RENDERMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.dwNumBuffers == other.dwNumBuffers
            && self.lpBufferInfo == other.lpBufferInfo
            && self.dwFunction == other.dwFunction
            && self.lpInputData == other.lpInputData
            && self.dwInputDataSize == other.dwInputDataSize
            && self.lpOutputData == other.lpOutputData
            && self.dwOutputDataSize == other.dwOutputDataSize
            && self.ddRVal == other.ddRVal
            && self.RenderMoComp == other.RenderMoComp
    }
}
impl ::core::cmp::Eq for DDHAL_RENDERMOCOMPDATA {}
impl FromIntoMemory for DDHAL_RENDERMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DDRAWI_DDMOTIONCOMP_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwNumBuffers = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpBufferInfo =
            <MutPtr<DDMCBUFFERINFO> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFunction = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpInputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwInputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpOutputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwOutputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_RenderMoComp =
            <LPDDHALMOCOMPCB_RENDER as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            dwNumBuffers: f_dwNumBuffers,
            lpBufferInfo: f_lpBufferInfo,
            dwFunction: f_dwFunction,
            lpInputData: f_lpInputData,
            dwInputDataSize: f_dwInputDataSize,
            lpOutputData: f_lpOutputData,
            dwOutputDataSize: f_dwOutputDataSize,
            ddRVal: f_ddRVal,
            RenderMoComp: f_RenderMoComp,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwNumBuffers, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpBufferInfo, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFunction, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpInputData, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwInputDataSize, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpOutputData, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwOutputDataSize, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.RenderMoComp, &mut into[40..40 + 4]);
    }
    fn size() -> usize {
        44
    }
}
pub struct DDHAL_SETCLIPLISTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub SetClipList: LPDDHALSURFCB_SETCLIPLIST,
}
impl ::core::marker::Copy for DDHAL_SETCLIPLISTDATA {}
impl ::core::clone::Clone for DDHAL_SETCLIPLISTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SETCLIPLISTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SETCLIPLISTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("ddRVal", &self.ddRVal)
            .field("SetClipList", &self.SetClipList)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SETCLIPLISTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.ddRVal == other.ddRVal
            && self.SetClipList == other.SetClipList
    }
}
impl ::core::cmp::Eq for DDHAL_SETCLIPLISTDATA {}
impl FromIntoMemory for DDHAL_SETCLIPLISTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SetClipList =
            <LPDDHALSURFCB_SETCLIPLIST as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            ddRVal: f_ddRVal,
            SetClipList: f_SetClipList,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SetClipList, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_SETCOLORKEYDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwFlags: u32,
    pub ckNew: DDCOLORKEY,
    pub ddRVal: crate::core::HRESULT,
    pub SetColorKey: LPDDHALSURFCB_SETCOLORKEY,
}
impl ::core::marker::Copy for DDHAL_SETCOLORKEYDATA {}
impl ::core::clone::Clone for DDHAL_SETCOLORKEYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SETCOLORKEYDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SETCOLORKEYDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ckNew", &self.ckNew)
            .field("ddRVal", &self.ddRVal)
            .field("SetColorKey", &self.SetColorKey)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SETCOLORKEYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ckNew == other.ckNew
            && self.ddRVal == other.ddRVal
            && self.SetColorKey == other.SetColorKey
    }
}
impl ::core::cmp::Eq for DDHAL_SETCOLORKEYDATA {}
impl FromIntoMemory for DDHAL_SETCOLORKEYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ckNew = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[12..12 + 8]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_SetColorKey =
            <LPDDHALSURFCB_SETCOLORKEY as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ckNew: f_ckNew,
            ddRVal: f_ddRVal,
            SetColorKey: f_SetColorKey,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ckNew, &mut into[12..12 + 8]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DDHAL_SETENTRIESDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDPalette: MutPtr<DDRAWI_DDRAWPALETTE_GBL>,
    pub dwBase: u32,
    pub dwNumEntries: u32,
    pub lpEntries: MutPtr<super::Gdi::PALETTEENTRY>,
    pub ddRVal: crate::core::HRESULT,
    pub SetEntries: LPDDHALPALCB_SETENTRIES,
}
impl ::core::marker::Copy for DDHAL_SETENTRIESDATA {}
impl ::core::clone::Clone for DDHAL_SETENTRIESDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SETENTRIESDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SETENTRIESDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("dwBase", &self.dwBase)
            .field("dwNumEntries", &self.dwNumEntries)
            .field("lpEntries", &self.lpEntries)
            .field("ddRVal", &self.ddRVal)
            .field("SetEntries", &self.SetEntries)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SETENTRIESDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDPalette == other.lpDDPalette
            && self.dwBase == other.dwBase
            && self.dwNumEntries == other.dwNumEntries
            && self.lpEntries == other.lpEntries
            && self.ddRVal == other.ddRVal
            && self.SetEntries == other.SetEntries
    }
}
impl ::core::cmp::Eq for DDHAL_SETENTRIESDATA {}
impl FromIntoMemory for DDHAL_SETENTRIESDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDPalette =
            <MutPtr<DDRAWI_DDRAWPALETTE_GBL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwBase = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwNumEntries = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpEntries =
            <MutPtr<super::Gdi::PALETTEENTRY> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_SetEntries =
            <LPDDHALPALCB_SETENTRIES as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDPalette: f_lpDDPalette,
            dwBase: f_dwBase,
            dwNumEntries: f_dwNumEntries,
            lpEntries: f_lpEntries,
            ddRVal: f_ddRVal,
            SetEntries: f_SetEntries,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwBase, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwNumEntries, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpEntries, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.SetEntries, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DDHAL_SETEXCLUSIVEMODEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwEnterExcl: u32,
    pub dwReserved: u32,
    pub ddRVal: crate::core::HRESULT,
    pub SetExclusiveMode: LPDDHAL_SETEXCLUSIVEMODE,
}
impl ::core::marker::Copy for DDHAL_SETEXCLUSIVEMODEDATA {}
impl ::core::clone::Clone for DDHAL_SETEXCLUSIVEMODEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SETEXCLUSIVEMODEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SETEXCLUSIVEMODEDATA")
            .field("lpDD", &self.lpDD)
            .field("dwEnterExcl", &self.dwEnterExcl)
            .field("dwReserved", &self.dwReserved)
            .field("ddRVal", &self.ddRVal)
            .field("SetExclusiveMode", &self.SetExclusiveMode)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SETEXCLUSIVEMODEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwEnterExcl == other.dwEnterExcl
            && self.dwReserved == other.dwReserved
            && self.ddRVal == other.ddRVal
            && self.SetExclusiveMode == other.SetExclusiveMode
    }
}
impl ::core::cmp::Eq for DDHAL_SETEXCLUSIVEMODEDATA {}
impl FromIntoMemory for DDHAL_SETEXCLUSIVEMODEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwEnterExcl = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetExclusiveMode =
            <LPDDHAL_SETEXCLUSIVEMODE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            dwEnterExcl: f_dwEnterExcl,
            dwReserved: f_dwReserved,
            ddRVal: f_ddRVal,
            SetExclusiveMode: f_SetExclusiveMode,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwEnterExcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetExclusiveMode, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDHAL_SETMODEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwModeIndex: u32,
    pub ddRVal: crate::core::HRESULT,
    pub SetMode: LPDDHAL_SETMODE,
    pub inexcl: super::super::Foundation::BOOL,
    pub useRefreshRate: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DDHAL_SETMODEDATA {}
impl ::core::clone::Clone for DDHAL_SETMODEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SETMODEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SETMODEDATA")
            .field("lpDD", &self.lpDD)
            .field("dwModeIndex", &self.dwModeIndex)
            .field("ddRVal", &self.ddRVal)
            .field("SetMode", &self.SetMode)
            .field("inexcl", &self.inexcl)
            .field("useRefreshRate", &self.useRefreshRate)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SETMODEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwModeIndex == other.dwModeIndex
            && self.ddRVal == other.ddRVal
            && self.SetMode == other.SetMode
            && self.inexcl == other.inexcl
            && self.useRefreshRate == other.useRefreshRate
    }
}
impl ::core::cmp::Eq for DDHAL_SETMODEDATA {}
impl FromIntoMemory for DDHAL_SETMODEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwModeIndex = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SetMode = <LPDDHAL_SETMODE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_inexcl =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_useRefreshRate =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            dwModeIndex: f_dwModeIndex,
            ddRVal: f_ddRVal,
            SetMode: f_SetMode,
            inexcl: f_inexcl,
            useRefreshRate: f_useRefreshRate,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwModeIndex, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SetMode, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.inexcl, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.useRefreshRate, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_SETOVERLAYPOSITIONDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSrcSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpDDDestSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lXPos: i32,
    pub lYPos: i32,
    pub ddRVal: crate::core::HRESULT,
    pub SetOverlayPosition: LPDDHALSURFCB_SETOVERLAYPOSITION,
}
impl ::core::marker::Copy for DDHAL_SETOVERLAYPOSITIONDATA {}
impl ::core::clone::Clone for DDHAL_SETOVERLAYPOSITIONDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SETOVERLAYPOSITIONDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SETOVERLAYPOSITIONDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSrcSurface", &self.lpDDSrcSurface)
            .field("lpDDDestSurface", &self.lpDDDestSurface)
            .field("lXPos", &self.lXPos)
            .field("lYPos", &self.lYPos)
            .field("ddRVal", &self.ddRVal)
            .field("SetOverlayPosition", &self.SetOverlayPosition)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SETOVERLAYPOSITIONDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSrcSurface == other.lpDDSrcSurface
            && self.lpDDDestSurface == other.lpDDDestSurface
            && self.lXPos == other.lXPos
            && self.lYPos == other.lYPos
            && self.ddRVal == other.ddRVal
            && self.SetOverlayPosition == other.SetOverlayPosition
    }
}
impl ::core::cmp::Eq for DDHAL_SETOVERLAYPOSITIONDATA {}
impl FromIntoMemory for DDHAL_SETOVERLAYPOSITIONDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSrcSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDDestSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lXPos = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lYPos = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_SetOverlayPosition =
            <LPDDHALSURFCB_SETOVERLAYPOSITION as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSrcSurface: f_lpDDSrcSurface,
            lpDDDestSurface: f_lpDDDestSurface,
            lXPos: f_lXPos,
            lYPos: f_lYPos,
            ddRVal: f_ddRVal,
            SetOverlayPosition: f_SetOverlayPosition,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSrcSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDDestSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lXPos, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lYPos, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.SetOverlayPosition, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DDHAL_SETPALETTEDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpDDPalette: MutPtr<DDRAWI_DDRAWPALETTE_GBL>,
    pub ddRVal: crate::core::HRESULT,
    pub SetPalette: LPDDHALSURFCB_SETPALETTE,
    pub Attach: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DDHAL_SETPALETTEDATA {}
impl ::core::clone::Clone for DDHAL_SETPALETTEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SETPALETTEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SETPALETTEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("ddRVal", &self.ddRVal)
            .field("SetPalette", &self.SetPalette)
            .field("Attach", &self.Attach)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SETPALETTEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.lpDDPalette == other.lpDDPalette
            && self.ddRVal == other.ddRVal
            && self.SetPalette == other.SetPalette
            && self.Attach == other.Attach
    }
}
impl ::core::cmp::Eq for DDHAL_SETPALETTEDATA {}
impl FromIntoMemory for DDHAL_SETPALETTEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDPalette =
            <MutPtr<DDRAWI_DDRAWPALETTE_GBL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetPalette =
            <LPDDHALSURFCB_SETPALETTE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Attach =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            lpDDPalette: f_lpDDPalette,
            ddRVal: f_ddRVal,
            SetPalette: f_SetPalette,
            Attach: f_Attach,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetPalette, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Attach, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub const DDHAL_SURFCB32_ADDATTACHEDSURFACE: i32 = 128i32;
pub const DDHAL_SURFCB32_BLT: i32 = 32i32;
pub const DDHAL_SURFCB32_DESTROYSURFACE: i32 = 1i32;
pub const DDHAL_SURFCB32_FLIP: i32 = 2i32;
pub const DDHAL_SURFCB32_GETBLTSTATUS: i32 = 256i32;
pub const DDHAL_SURFCB32_GETFLIPSTATUS: i32 = 512i32;
pub const DDHAL_SURFCB32_LOCK: i32 = 8i32;
pub const DDHAL_SURFCB32_RESERVED4: i32 = 4096i32;
pub const DDHAL_SURFCB32_SETCLIPLIST: i32 = 4i32;
pub const DDHAL_SURFCB32_SETCOLORKEY: i32 = 64i32;
pub const DDHAL_SURFCB32_SETOVERLAYPOSITION: i32 = 2048i32;
pub const DDHAL_SURFCB32_SETPALETTE: i32 = 8192i32;
pub const DDHAL_SURFCB32_UNLOCK: i32 = 16i32;
pub const DDHAL_SURFCB32_UPDATEOVERLAY: i32 = 1024i32;
pub struct DDHAL_SYNCSURFACEDATA {
    pub dwSize: u32,
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwSurfaceOffset: u32,
    pub fpLockPtr: PtrRepr,
    pub lPitch: i32,
    pub dwOverlayOffset: u32,
    pub dwOverlaySrcWidth: u32,
    pub dwOverlaySrcHeight: u32,
    pub dwOverlayDestWidth: u32,
    pub dwOverlayDestHeight: u32,
    pub dwDriverReserved1: PtrRepr,
    pub dwDriverReserved2: PtrRepr,
    pub dwDriverReserved3: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DDHAL_SYNCSURFACEDATA {}
impl ::core::clone::Clone for DDHAL_SYNCSURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SYNCSURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SYNCSURFACEDATA")
            .field("dwSize", &self.dwSize)
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwSurfaceOffset", &self.dwSurfaceOffset)
            .field("fpLockPtr", &self.fpLockPtr)
            .field("lPitch", &self.lPitch)
            .field("dwOverlayOffset", &self.dwOverlayOffset)
            .field("dwOverlaySrcWidth", &self.dwOverlaySrcWidth)
            .field("dwOverlaySrcHeight", &self.dwOverlaySrcHeight)
            .field("dwOverlayDestWidth", &self.dwOverlayDestWidth)
            .field("dwOverlayDestHeight", &self.dwOverlayDestHeight)
            .field("dwDriverReserved1", &self.dwDriverReserved1)
            .field("dwDriverReserved2", &self.dwDriverReserved2)
            .field("dwDriverReserved3", &self.dwDriverReserved3)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SYNCSURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwSurfaceOffset == other.dwSurfaceOffset
            && self.fpLockPtr == other.fpLockPtr
            && self.lPitch == other.lPitch
            && self.dwOverlayOffset == other.dwOverlayOffset
            && self.dwOverlaySrcWidth == other.dwOverlaySrcWidth
            && self.dwOverlaySrcHeight == other.dwOverlaySrcHeight
            && self.dwOverlayDestWidth == other.dwOverlayDestWidth
            && self.dwOverlayDestHeight == other.dwOverlayDestHeight
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DDHAL_SYNCSURFACEDATA {}
impl FromIntoMemory for DDHAL_SYNCSURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwSurfaceOffset = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_fpLockPtr = <PtrRepr as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lPitch = <i32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwOverlayOffset = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwOverlaySrcWidth = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwOverlaySrcHeight = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwOverlayDestWidth = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwOverlayDestHeight = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwDriverReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwDriverReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwDriverReserved3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            dwSize: f_dwSize,
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwSurfaceOffset: f_dwSurfaceOffset,
            fpLockPtr: f_fpLockPtr,
            lPitch: f_lPitch,
            dwOverlayOffset: f_dwOverlayOffset,
            dwOverlaySrcWidth: f_dwOverlaySrcWidth,
            dwOverlaySrcHeight: f_dwOverlaySrcHeight,
            dwOverlayDestWidth: f_dwOverlayDestWidth,
            dwOverlayDestHeight: f_dwOverlayDestHeight,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwSurfaceOffset, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.fpLockPtr, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lPitch, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayOffset, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlaySrcWidth, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlaySrcHeight, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayDestWidth, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayDestHeight, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
pub struct DDHAL_SYNCVIDEOPORTDATA {
    pub dwSize: u32,
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub dwOriginOffset: u32,
    pub dwHeight: u32,
    pub dwVBIHeight: u32,
    pub dwDriverReserved1: PtrRepr,
    pub dwDriverReserved2: PtrRepr,
    pub dwDriverReserved3: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DDHAL_SYNCVIDEOPORTDATA {}
impl ::core::clone::Clone for DDHAL_SYNCVIDEOPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_SYNCVIDEOPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_SYNCVIDEOPORTDATA")
            .field("dwSize", &self.dwSize)
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwOriginOffset", &self.dwOriginOffset)
            .field("dwHeight", &self.dwHeight)
            .field("dwVBIHeight", &self.dwVBIHeight)
            .field("dwDriverReserved1", &self.dwDriverReserved1)
            .field("dwDriverReserved2", &self.dwDriverReserved2)
            .field("dwDriverReserved3", &self.dwDriverReserved3)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_SYNCVIDEOPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwOriginOffset == other.dwOriginOffset
            && self.dwHeight == other.dwHeight
            && self.dwVBIHeight == other.dwVBIHeight
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DDHAL_SYNCVIDEOPORTDATA {}
impl FromIntoMemory for DDHAL_SYNCVIDEOPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwOriginOffset = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwVBIHeight = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwDriverReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwDriverReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwDriverReserved3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        Self {
            dwSize: f_dwSize,
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwOriginOffset: f_dwOriginOffset,
            dwHeight: f_dwHeight,
            dwVBIHeight: f_dwVBIHeight,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwOriginOffset, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwVBIHeight, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[36..36 + 4]);
    }
    fn size() -> usize {
        40
    }
}
pub struct DDHAL_UNLOCKDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub ddRVal: crate::core::HRESULT,
    pub Unlock: LPDDHALSURFCB_UNLOCK,
}
impl ::core::marker::Copy for DDHAL_UNLOCKDATA {}
impl ::core::clone::Clone for DDHAL_UNLOCKDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_UNLOCKDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_UNLOCKDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("ddRVal", &self.ddRVal)
            .field("Unlock", &self.Unlock)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_UNLOCKDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.ddRVal == other.ddRVal
            && self.Unlock == other.Unlock
    }
}
impl ::core::cmp::Eq for DDHAL_UNLOCKDATA {}
impl FromIntoMemory for DDHAL_UNLOCKDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Unlock = <LPDDHALSURFCB_UNLOCK as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            ddRVal: f_ddRVal,
            Unlock: f_Unlock,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Unlock, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDHAL_UPDATENONLOCALHEAPDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwHeap: u32,
    pub fpGARTLin: PtrRepr,
    pub fpGARTDev: PtrRepr,
    pub ulPolicyMaxBytes: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
    pub UpdateNonLocalHeap: LPDDHAL_UPDATENONLOCALHEAP,
}
impl ::core::marker::Copy for DDHAL_UPDATENONLOCALHEAPDATA {}
impl ::core::clone::Clone for DDHAL_UPDATENONLOCALHEAPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_UPDATENONLOCALHEAPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_UPDATENONLOCALHEAPDATA")
            .field("lpDD", &self.lpDD)
            .field("dwHeap", &self.dwHeap)
            .field("fpGARTLin", &self.fpGARTLin)
            .field("fpGARTDev", &self.fpGARTDev)
            .field("ulPolicyMaxBytes", &self.ulPolicyMaxBytes)
            .field("ddRVal", &self.ddRVal)
            .field("UpdateNonLocalHeap", &self.UpdateNonLocalHeap)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_UPDATENONLOCALHEAPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwHeap == other.dwHeap
            && self.fpGARTLin == other.fpGARTLin
            && self.fpGARTDev == other.fpGARTDev
            && self.ulPolicyMaxBytes == other.ulPolicyMaxBytes
            && self.ddRVal == other.ddRVal
            && self.UpdateNonLocalHeap == other.UpdateNonLocalHeap
    }
}
impl ::core::cmp::Eq for DDHAL_UPDATENONLOCALHEAPDATA {}
impl FromIntoMemory for DDHAL_UPDATENONLOCALHEAPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwHeap = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_fpGARTLin = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_fpGARTDev = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ulPolicyMaxBytes = <PtrRepr as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_UpdateNonLocalHeap =
            <LPDDHAL_UPDATENONLOCALHEAP as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            dwHeap: f_dwHeap,
            fpGARTLin: f_fpGARTLin,
            fpGARTDev: f_fpGARTDev,
            ulPolicyMaxBytes: f_ulPolicyMaxBytes,
            ddRVal: f_ddRVal,
            UpdateNonLocalHeap: f_UpdateNonLocalHeap,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwHeap, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.fpGARTLin, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.fpGARTDev, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ulPolicyMaxBytes, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.UpdateNonLocalHeap, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DDHAL_UPDATEOVERLAYDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub lpDDDestSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub rDest: super::super::Foundation::RECTL,
    pub lpDDSrcSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub rSrc: super::super::Foundation::RECTL,
    pub dwFlags: u32,
    pub overlayFX: DDOVERLAYFX,
    pub ddRVal: crate::core::HRESULT,
    pub UpdateOverlay: LPDDHALSURFCB_UPDATEOVERLAY,
}
impl ::core::marker::Copy for DDHAL_UPDATEOVERLAYDATA {}
impl ::core::clone::Clone for DDHAL_UPDATEOVERLAYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDHAL_UPDATEOVERLAYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDDestSurface == other.lpDDDestSurface
            && self.rDest == other.rDest
            && self.lpDDSrcSurface == other.lpDDSrcSurface
            && self.rSrc == other.rSrc
            && self.dwFlags == other.dwFlags
            && self.overlayFX == other.overlayFX
            && self.ddRVal == other.ddRVal
            && self.UpdateOverlay == other.UpdateOverlay
    }
}
impl ::core::cmp::Eq for DDHAL_UPDATEOVERLAYDATA {}
impl FromIntoMemory for DDHAL_UPDATEOVERLAYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 112);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDDestSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_rDest =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_lpDDSrcSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_rSrc =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[28..28 + 16]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_overlayFX = <DDOVERLAYFX as FromIntoMemory>::from_bytes(&from[48..48 + 56]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[104..104 + 4]);
        let f_UpdateOverlay =
            <LPDDHALSURFCB_UPDATEOVERLAY as FromIntoMemory>::from_bytes(&from[108..108 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDDestSurface: f_lpDDDestSurface,
            rDest: f_rDest,
            lpDDSrcSurface: f_lpDDSrcSurface,
            rSrc: f_rSrc,
            dwFlags: f_dwFlags,
            overlayFX: f_overlayFX,
            ddRVal: f_ddRVal,
            UpdateOverlay: f_UpdateOverlay,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 112);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDDestSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.rDest, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.lpDDSrcSurface, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.rSrc, &mut into[28..28 + 16]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.overlayFX, &mut into[48..48 + 56]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[104..104 + 4]);
        FromIntoMemory::into_bytes(self.UpdateOverlay, &mut into[108..108 + 4]);
    }
    fn size() -> usize {
        112
    }
}
pub struct DDHAL_UPDATEVPORTDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub lplpDDSurface: MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_INT>>,
    pub lplpDDVBISurface: MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_INT>>,
    pub lpVideoInfo: MutPtr<DDVIDEOPORTINFO>,
    pub dwFlags: u32,
    pub dwNumAutoflip: u32,
    pub dwNumVBIAutoflip: u32,
    pub ddRVal: crate::core::HRESULT,
    pub UpdateVideoPort: LPDDHALVPORTCB_UPDATE,
}
impl ::core::marker::Copy for DDHAL_UPDATEVPORTDATA {}
impl ::core::clone::Clone for DDHAL_UPDATEVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_UPDATEVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_UPDATEVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("lplpDDSurface", &self.lplpDDSurface)
            .field("lplpDDVBISurface", &self.lplpDDVBISurface)
            .field("lpVideoInfo", &self.lpVideoInfo)
            .field("dwFlags", &self.dwFlags)
            .field("dwNumAutoflip", &self.dwNumAutoflip)
            .field("dwNumVBIAutoflip", &self.dwNumVBIAutoflip)
            .field("ddRVal", &self.ddRVal)
            .field("UpdateVideoPort", &self.UpdateVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_UPDATEVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.lplpDDSurface == other.lplpDDSurface
            && self.lplpDDVBISurface == other.lplpDDVBISurface
            && self.lpVideoInfo == other.lpVideoInfo
            && self.dwFlags == other.dwFlags
            && self.dwNumAutoflip == other.dwNumAutoflip
            && self.dwNumVBIAutoflip == other.dwNumVBIAutoflip
            && self.ddRVal == other.ddRVal
            && self.UpdateVideoPort == other.UpdateVideoPort
    }
}
impl ::core::cmp::Eq for DDHAL_UPDATEVPORTDATA {}
impl FromIntoMemory for DDHAL_UPDATEVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lplpDDSurface =
            <MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_INT>> as FromIntoMemory>::from_bytes(
                &from[8..8 + 4],
            );
        let f_lplpDDVBISurface =
            <MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_INT>> as FromIntoMemory>::from_bytes(
                &from[12..12 + 4],
            );
        let f_lpVideoInfo =
            <MutPtr<DDVIDEOPORTINFO> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwNumAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwNumVBIAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_UpdateVideoPort =
            <LPDDHALVPORTCB_UPDATE as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            lplpDDSurface: f_lplpDDSurface,
            lplpDDVBISurface: f_lplpDDVBISurface,
            lpVideoInfo: f_lpVideoInfo,
            dwFlags: f_dwFlags,
            dwNumAutoflip: f_dwNumAutoflip,
            dwNumVBIAutoflip: f_dwNumVBIAutoflip,
            ddRVal: f_ddRVal,
            UpdateVideoPort: f_UpdateVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lplpDDSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lplpDDVBISurface, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoInfo, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwNumAutoflip, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwNumVBIAutoflip, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.UpdateVideoPort, &mut into[36..36 + 4]);
    }
    fn size() -> usize {
        40
    }
}
pub const DDHAL_VPORT32_CANCREATEVIDEOPORT: i32 = 1i32;
pub const DDHAL_VPORT32_COLORCONTROL: i32 = 32768i32;
pub const DDHAL_VPORT32_CREATEVIDEOPORT: i32 = 2i32;
pub const DDHAL_VPORT32_DESTROY: i32 = 1024i32;
pub const DDHAL_VPORT32_FLIP: i32 = 4i32;
pub const DDHAL_VPORT32_GETAUTOFLIPSURF: i32 = 64i32;
pub const DDHAL_VPORT32_GETBANDWIDTH: i32 = 8i32;
pub const DDHAL_VPORT32_GETCONNECT: i32 = 512i32;
pub const DDHAL_VPORT32_GETFIELD: i32 = 128i32;
pub const DDHAL_VPORT32_GETFLIPSTATUS: i32 = 2048i32;
pub const DDHAL_VPORT32_GETINPUTFORMATS: i32 = 16i32;
pub const DDHAL_VPORT32_GETLINE: i32 = 256i32;
pub const DDHAL_VPORT32_GETOUTPUTFORMATS: i32 = 32i32;
pub const DDHAL_VPORT32_GETSIGNALSTATUS: i32 = 16384i32;
pub const DDHAL_VPORT32_UPDATE: i32 = 4096i32;
pub const DDHAL_VPORT32_WAITFORSYNC: i32 = 8192i32;
pub struct DDHAL_VPORTCOLORDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub dwFlags: u32,
    pub lpColorData: MutPtr<DDCOLORCONTROL>,
    pub ddRVal: crate::core::HRESULT,
    pub ColorControl: LPDDHALVPORTCB_COLORCONTROL,
}
impl ::core::marker::Copy for DDHAL_VPORTCOLORDATA {}
impl ::core::clone::Clone for DDHAL_VPORTCOLORDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_VPORTCOLORDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_VPORTCOLORDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("lpColorData", &self.lpColorData)
            .field("ddRVal", &self.ddRVal)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_VPORTCOLORDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.lpColorData == other.lpColorData
            && self.ddRVal == other.ddRVal
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DDHAL_VPORTCOLORDATA {}
impl FromIntoMemory for DDHAL_VPORTCOLORDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpColorData =
            <MutPtr<DDCOLORCONTROL> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ColorControl =
            <LPDDHALVPORTCB_COLORCONTROL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            lpColorData: f_lpColorData,
            ddRVal: f_ddRVal,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpColorData, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_WAITFORVERTICALBLANKDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwFlags: u32,
    pub bIsInVB: u32,
    pub hEvent: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
    pub WaitForVerticalBlank: LPDDHAL_WAITFORVERTICALBLANK,
}
impl ::core::marker::Copy for DDHAL_WAITFORVERTICALBLANKDATA {}
impl ::core::clone::Clone for DDHAL_WAITFORVERTICALBLANKDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_WAITFORVERTICALBLANKDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_WAITFORVERTICALBLANKDATA")
            .field("lpDD", &self.lpDD)
            .field("dwFlags", &self.dwFlags)
            .field("bIsInVB", &self.bIsInVB)
            .field("hEvent", &self.hEvent)
            .field("ddRVal", &self.ddRVal)
            .field("WaitForVerticalBlank", &self.WaitForVerticalBlank)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_WAITFORVERTICALBLANKDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwFlags == other.dwFlags
            && self.bIsInVB == other.bIsInVB
            && self.hEvent == other.hEvent
            && self.ddRVal == other.ddRVal
            && self.WaitForVerticalBlank == other.WaitForVerticalBlank
    }
}
impl ::core::cmp::Eq for DDHAL_WAITFORVERTICALBLANKDATA {}
impl FromIntoMemory for DDHAL_WAITFORVERTICALBLANKDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bIsInVB = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_hEvent = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_WaitForVerticalBlank =
            <LPDDHAL_WAITFORVERTICALBLANK as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            dwFlags: f_dwFlags,
            bIsInVB: f_bIsInVB,
            hEvent: f_hEvent,
            ddRVal: f_ddRVal,
            WaitForVerticalBlank: f_WaitForVerticalBlank,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bIsInVB, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.hEvent, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.WaitForVerticalBlank, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDHAL_WAITFORVPORTSYNCDATA {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub dwFlags: u32,
    pub dwLine: u32,
    pub dwTimeOut: u32,
    pub ddRVal: crate::core::HRESULT,
    pub WaitForVideoPortSync: LPDDHALVPORTCB_WAITFORSYNC,
}
impl ::core::marker::Copy for DDHAL_WAITFORVPORTSYNCDATA {}
impl ::core::clone::Clone for DDHAL_WAITFORVPORTSYNCDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDHAL_WAITFORVPORTSYNCDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDHAL_WAITFORVPORTSYNCDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("dwLine", &self.dwLine)
            .field("dwTimeOut", &self.dwTimeOut)
            .field("ddRVal", &self.ddRVal)
            .field("WaitForVideoPortSync", &self.WaitForVideoPortSync)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDHAL_WAITFORVPORTSYNCDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.dwLine == other.dwLine
            && self.dwTimeOut == other.dwTimeOut
            && self.ddRVal == other.ddRVal
            && self.WaitForVideoPortSync == other.WaitForVideoPortSync
    }
}
impl ::core::cmp::Eq for DDHAL_WAITFORVPORTSYNCDATA {}
impl FromIntoMemory for DDHAL_WAITFORVPORTSYNCDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwLine = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwTimeOut = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_WaitForVideoPortSync =
            <LPDDHALVPORTCB_WAITFORSYNC as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            dwLine: f_dwLine,
            dwTimeOut: f_dwTimeOut,
            ddRVal: f_ddRVal,
            WaitForVideoPortSync: f_WaitForVideoPortSync,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwLine, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwTimeOut, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.WaitForVideoPortSync, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub const DDIRQ_BUSMASTER: i32 = 2i32;
pub const DDIRQ_DISPLAY_VSYNC: i32 = 1i32;
pub const DDIRQ_RESERVED1: i32 = 2i32;
pub const DDIRQ_VPORT0_LINE: i32 = 8i32;
pub const DDIRQ_VPORT0_VSYNC: i32 = 4i32;
pub const DDIRQ_VPORT1_LINE: i32 = 32i32;
pub const DDIRQ_VPORT1_VSYNC: i32 = 16i32;
pub const DDIRQ_VPORT2_LINE: i32 = 128i32;
pub const DDIRQ_VPORT2_VSYNC: i32 = 64i32;
pub const DDIRQ_VPORT3_LINE: i32 = 512i32;
pub const DDIRQ_VPORT3_VSYNC: i32 = 256i32;
pub const DDIRQ_VPORT4_LINE: i32 = 2048i32;
pub const DDIRQ_VPORT4_VSYNC: i32 = 1024i32;
pub const DDIRQ_VPORT5_LINE: i32 = 8192i32;
pub const DDIRQ_VPORT5_VSYNC: i32 = 4096i32;
pub const DDIRQ_VPORT6_LINE: i32 = 32768i32;
pub const DDIRQ_VPORT6_VSYNC: i32 = 16384i32;
pub const DDIRQ_VPORT7_LINE: i32 = 131072i32;
pub const DDIRQ_VPORT7_VSYNC: i32 = 65536i32;
pub const DDIRQ_VPORT8_LINE: i32 = 524288i32;
pub const DDIRQ_VPORT8_VSYNC: i32 = 262144i32;
pub const DDIRQ_VPORT9_LINE: i32 = 131072i32;
pub const DDIRQ_VPORT9_VSYNC: i32 = 65536i32;
pub struct DDKERNELCAPS {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwIRQCaps: u32,
}
impl ::core::marker::Copy for DDKERNELCAPS {}
impl ::core::clone::Clone for DDKERNELCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDKERNELCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDKERNELCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwIRQCaps", &self.dwIRQCaps)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDKERNELCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwIRQCaps == other.dwIRQCaps
    }
}
impl ::core::cmp::Eq for DDKERNELCAPS {}
impl FromIntoMemory for DDKERNELCAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwIRQCaps = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwIRQCaps: f_dwIRQCaps,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwIRQCaps, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const DDKERNELCAPS_AUTOFLIP: i32 = 2i32;
pub const DDKERNELCAPS_CAPTURE_INVERTED: i32 = 512i32;
pub const DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM: i32 = 128i32;
pub const DDKERNELCAPS_CAPTURE_SYSMEM: i32 = 64i32;
pub const DDKERNELCAPS_FIELDPOLARITY: i32 = 256i32;
pub const DDKERNELCAPS_FLIPOVERLAY: i32 = 32i32;
pub const DDKERNELCAPS_FLIPVIDEOPORT: i32 = 16i32;
pub const DDKERNELCAPS_LOCK: i32 = 8i32;
pub const DDKERNELCAPS_SETSTATE: i32 = 4i32;
pub const DDKERNELCAPS_SKIPFIELDS: i32 = 1i32;
pub struct DDLOCKININFO {
    pub lpSurfaceData: MutPtr<DDSURFACEDATA>,
}
impl ::core::marker::Copy for DDLOCKININFO {}
impl ::core::clone::Clone for DDLOCKININFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDLOCKININFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDLOCKININFO")
            .field("lpSurfaceData", &self.lpSurfaceData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDLOCKININFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpSurfaceData == other.lpSurfaceData
    }
}
impl ::core::cmp::Eq for DDLOCKININFO {}
impl FromIntoMemory for DDLOCKININFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_lpSurfaceData =
            <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            lpSurfaceData: f_lpSurfaceData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.lpSurfaceData, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDLOCKOUTINFO {
    pub dwSurfacePtr: PtrRepr,
}
impl ::core::marker::Copy for DDLOCKOUTINFO {}
impl ::core::clone::Clone for DDLOCKOUTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDLOCKOUTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDLOCKOUTINFO")
            .field("dwSurfacePtr", &self.dwSurfacePtr)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDLOCKOUTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSurfacePtr == other.dwSurfacePtr
    }
}
impl ::core::cmp::Eq for DDLOCKOUTINFO {}
impl FromIntoMemory for DDLOCKOUTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwSurfacePtr = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            dwSurfacePtr: f_dwSurfacePtr,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwSurfacePtr, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub const DDLOCK_DISCARDCONTENTS: i32 = 8192i32;
pub const DDLOCK_DONOTWAIT: i32 = 16384i32;
pub const DDLOCK_EVENT: i32 = 2i32;
pub const DDLOCK_HASVOLUMETEXTUREBOXRECT: i32 = 32768i32;
pub const DDLOCK_NODIRTYUPDATE: i32 = 65536i32;
pub const DDLOCK_NOOVERWRITE: i32 = 4096i32;
pub const DDLOCK_NOSYSLOCK: i32 = 2048i32;
pub const DDLOCK_OKTOSWAP: i32 = 8192i32;
pub const DDLOCK_READONLY: i32 = 16i32;
pub const DDLOCK_SURFACEMEMORYPTR: i32 = 0i32;
pub const DDLOCK_WAIT: i32 = 1i32;
pub const DDLOCK_WRITEONLY: i32 = 32i32;
pub struct DDMCBUFFERINFO {
    pub dwSize: u32,
    pub lpCompSurface: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub dwDataOffset: u32,
    pub dwDataSize: u32,
    pub lpPrivate: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DDMCBUFFERINFO {}
impl ::core::clone::Clone for DDMCBUFFERINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDMCBUFFERINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDMCBUFFERINFO")
            .field("dwSize", &self.dwSize)
            .field("lpCompSurface", &self.lpCompSurface)
            .field("dwDataOffset", &self.dwDataOffset)
            .field("dwDataSize", &self.dwDataSize)
            .field("lpPrivate", &self.lpPrivate)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDMCBUFFERINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpCompSurface == other.lpCompSurface
            && self.dwDataOffset == other.dwDataOffset
            && self.dwDataSize == other.dwDataSize
            && self.lpPrivate == other.lpPrivate
    }
}
impl ::core::cmp::Eq for DDMCBUFFERINFO {}
impl FromIntoMemory for DDMCBUFFERINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpCompSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwDataOffset = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwDataSize = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpPrivate =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwSize: f_dwSize,
            lpCompSurface: f_lpCompSurface,
            dwDataOffset: f_dwDataOffset,
            dwDataSize: f_dwDataSize,
            lpPrivate: f_lpPrivate,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpCompSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwDataOffset, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwDataSize, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpPrivate, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDMCCOMPBUFFERINFO {
    pub dwSize: u32,
    pub dwNumCompBuffers: u32,
    pub dwWidthToCreate: u32,
    pub dwHeightToCreate: u32,
    pub dwBytesToAllocate: u32,
    pub ddCompCaps: DDSCAPS2,
    pub ddPixelFormat: DDPIXELFORMAT,
}
impl ::core::marker::Copy for DDMCCOMPBUFFERINFO {}
impl ::core::clone::Clone for DDMCCOMPBUFFERINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDMCCOMPBUFFERINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwNumCompBuffers == other.dwNumCompBuffers
            && self.dwWidthToCreate == other.dwWidthToCreate
            && self.dwHeightToCreate == other.dwHeightToCreate
            && self.dwBytesToAllocate == other.dwBytesToAllocate
            && self.ddCompCaps == other.ddCompCaps
            && self.ddPixelFormat == other.ddPixelFormat
    }
}
impl ::core::cmp::Eq for DDMCCOMPBUFFERINFO {}
impl FromIntoMemory for DDMCCOMPBUFFERINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 68);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwNumCompBuffers = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidthToCreate = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeightToCreate = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwBytesToAllocate = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddCompCaps = <DDSCAPS2 as FromIntoMemory>::from_bytes(&from[20..20 + 16]);
        let f_ddPixelFormat = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[36..36 + 32]);
        Self {
            dwSize: f_dwSize,
            dwNumCompBuffers: f_dwNumCompBuffers,
            dwWidthToCreate: f_dwWidthToCreate,
            dwHeightToCreate: f_dwHeightToCreate,
            dwBytesToAllocate: f_dwBytesToAllocate,
            ddCompCaps: f_ddCompCaps,
            ddPixelFormat: f_ddPixelFormat,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 68);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwNumCompBuffers, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidthToCreate, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeightToCreate, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwBytesToAllocate, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddCompCaps, &mut into[20..20 + 16]);
        FromIntoMemory::into_bytes(self.ddPixelFormat, &mut into[36..36 + 32]);
    }
    fn size() -> usize {
        68
    }
}
pub const DDMCQUERY_READ: u32 = 1u32;
pub struct DDMOCOMPBUFFERINFO {
    pub dwSize: u32,
    pub lpCompSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwDataOffset: u32,
    pub dwDataSize: u32,
    pub lpPrivate: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DDMOCOMPBUFFERINFO {}
impl ::core::clone::Clone for DDMOCOMPBUFFERINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDMOCOMPBUFFERINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDMOCOMPBUFFERINFO")
            .field("dwSize", &self.dwSize)
            .field("lpCompSurface", &self.lpCompSurface)
            .field("dwDataOffset", &self.dwDataOffset)
            .field("dwDataSize", &self.dwDataSize)
            .field("lpPrivate", &self.lpPrivate)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDMOCOMPBUFFERINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpCompSurface == other.lpCompSurface
            && self.dwDataOffset == other.dwDataOffset
            && self.dwDataSize == other.dwDataSize
            && self.lpPrivate == other.lpPrivate
    }
}
impl ::core::cmp::Eq for DDMOCOMPBUFFERINFO {}
impl FromIntoMemory for DDMOCOMPBUFFERINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpCompSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwDataOffset = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwDataSize = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpPrivate =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwSize: f_dwSize,
            lpCompSurface: f_lpCompSurface,
            dwDataOffset: f_dwDataOffset,
            dwDataSize: f_dwDataSize,
            lpPrivate: f_lpPrivate,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpCompSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwDataOffset, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwDataSize, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpPrivate, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub const DDMODEINFO_MAXREFRESH: u32 = 16u32;
pub const DDMODEINFO_MODEX: u32 = 2u32;
pub const DDMODEINFO_PALETTIZED: u32 = 1u32;
pub const DDMODEINFO_STANDARDVGA: u32 = 8u32;
pub const DDMODEINFO_STEREO: u32 = 32u32;
pub const DDMODEINFO_UNSUPPORTED: u32 = 4u32;
pub struct DDMONITORINFO {
    pub Manufacturer: u16,
    pub Product: u16,
    pub SerialNumber: u32,
    pub DeviceIdentifier: crate::core::GUID,
    pub Mode640x480: i32,
    pub Mode800x600: i32,
    pub Mode1024x768: i32,
    pub Mode1280x1024: i32,
    pub Mode1600x1200: i32,
    pub ModeReserved1: i32,
    pub ModeReserved2: i32,
    pub ModeReserved3: i32,
}
impl ::core::marker::Copy for DDMONITORINFO {}
impl ::core::clone::Clone for DDMONITORINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDMONITORINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDMONITORINFO")
            .field("Manufacturer", &self.Manufacturer)
            .field("Product", &self.Product)
            .field("SerialNumber", &self.SerialNumber)
            .field("DeviceIdentifier", &self.DeviceIdentifier)
            .field("Mode640x480", &self.Mode640x480)
            .field("Mode800x600", &self.Mode800x600)
            .field("Mode1024x768", &self.Mode1024x768)
            .field("Mode1280x1024", &self.Mode1280x1024)
            .field("Mode1600x1200", &self.Mode1600x1200)
            .field("ModeReserved1", &self.ModeReserved1)
            .field("ModeReserved2", &self.ModeReserved2)
            .field("ModeReserved3", &self.ModeReserved3)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDMONITORINFO {
    fn eq(&self, other: &Self) -> bool {
        self.Manufacturer == other.Manufacturer
            && self.Product == other.Product
            && self.SerialNumber == other.SerialNumber
            && self.DeviceIdentifier == other.DeviceIdentifier
            && self.Mode640x480 == other.Mode640x480
            && self.Mode800x600 == other.Mode800x600
            && self.Mode1024x768 == other.Mode1024x768
            && self.Mode1280x1024 == other.Mode1280x1024
            && self.Mode1600x1200 == other.Mode1600x1200
            && self.ModeReserved1 == other.ModeReserved1
            && self.ModeReserved2 == other.ModeReserved2
            && self.ModeReserved3 == other.ModeReserved3
    }
}
impl ::core::cmp::Eq for DDMONITORINFO {}
impl FromIntoMemory for DDMONITORINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 56);
        let f_Manufacturer = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_Product = <u16 as FromIntoMemory>::from_bytes(&from[2..2 + 2]);
        let f_SerialNumber = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DeviceIdentifier =
            <crate::core::GUID as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_Mode640x480 = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_Mode800x600 = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_Mode1024x768 = <i32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_Mode1280x1024 = <i32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_Mode1600x1200 = <i32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_ModeReserved1 = <i32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_ModeReserved2 = <i32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_ModeReserved3 = <i32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        Self {
            Manufacturer: f_Manufacturer,
            Product: f_Product,
            SerialNumber: f_SerialNumber,
            DeviceIdentifier: f_DeviceIdentifier,
            Mode640x480: f_Mode640x480,
            Mode800x600: f_Mode800x600,
            Mode1024x768: f_Mode1024x768,
            Mode1280x1024: f_Mode1280x1024,
            Mode1600x1200: f_Mode1600x1200,
            ModeReserved1: f_ModeReserved1,
            ModeReserved2: f_ModeReserved2,
            ModeReserved3: f_ModeReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 56);
        FromIntoMemory::into_bytes(self.Manufacturer, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.Product, &mut into[2..2 + 2]);
        FromIntoMemory::into_bytes(self.SerialNumber, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DeviceIdentifier, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.Mode640x480, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.Mode800x600, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.Mode1024x768, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.Mode1280x1024, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.Mode1600x1200, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.ModeReserved1, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.ModeReserved2, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.ModeReserved3, &mut into[52..52 + 4]);
    }
    fn size() -> usize {
        56
    }
}
pub struct DDMORESURFACECAPS {
    pub dwSize: u32,
    pub ddsCapsMore: DDSCAPSEX,
    pub ddsExtendedHeapRestrictions: [DDMORESURFACECAPS_0; 1],
}
impl ::core::marker::Copy for DDMORESURFACECAPS {}
impl ::core::clone::Clone for DDMORESURFACECAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDMORESURFACECAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.ddsCapsMore == other.ddsCapsMore
            && self.ddsExtendedHeapRestrictions == other.ddsExtendedHeapRestrictions
    }
}
impl ::core::cmp::Eq for DDMORESURFACECAPS {}
impl FromIntoMemory for DDMORESURFACECAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ddsCapsMore = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[4..4 + 12]);
        let f_ddsExtendedHeapRestrictions =
            <[DDMORESURFACECAPS_0; 1] as FromIntoMemory>::from_bytes(&from[16..16 + 24]);
        Self {
            dwSize: f_dwSize,
            ddsCapsMore: f_ddsCapsMore,
            ddsExtendedHeapRestrictions: f_ddsExtendedHeapRestrictions,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsMore, &mut into[4..4 + 12]);
        FromIntoMemory::into_bytes(self.ddsExtendedHeapRestrictions, &mut into[16..16 + 24]);
    }
    fn size() -> usize {
        40
    }
}
pub struct DDMORESURFACECAPS_0 {
    pub ddsCapsEx: DDSCAPSEX,
    pub ddsCapsExAlt: DDSCAPSEX,
}
impl ::core::marker::Copy for DDMORESURFACECAPS_0 {}
impl ::core::clone::Clone for DDMORESURFACECAPS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDMORESURFACECAPS_0 {
    fn eq(&self, other: &Self) -> bool {
        self.ddsCapsEx == other.ddsCapsEx && self.ddsCapsExAlt == other.ddsCapsExAlt
    }
}
impl ::core::cmp::Eq for DDMORESURFACECAPS_0 {}
impl FromIntoMemory for DDMORESURFACECAPS_0 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_ddsCapsEx = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[0..0 + 12]);
        let f_ddsCapsExAlt = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[12..12 + 12]);
        Self {
            ddsCapsEx: f_ddsCapsEx,
            ddsCapsExAlt: f_ddsCapsExAlt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.ddsCapsEx, &mut into[0..0 + 12]);
        FromIntoMemory::into_bytes(self.ddsCapsExAlt, &mut into[12..12 + 12]);
    }
    fn size() -> usize {
        24
    }
}
pub const DDNEWCALLBACKFNS: u32 = 12u32;
pub struct DDNONLOCALVIDMEMCAPS {
    pub dwSize: u32,
    pub dwNLVBCaps: u32,
    pub dwNLVBCaps2: u32,
    pub dwNLVBCKeyCaps: u32,
    pub dwNLVBFXCaps: u32,
    pub dwNLVBRops: [u32; 8],
}
impl ::core::marker::Copy for DDNONLOCALVIDMEMCAPS {}
impl ::core::clone::Clone for DDNONLOCALVIDMEMCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDNONLOCALVIDMEMCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDNONLOCALVIDMEMCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwNLVBCaps", &self.dwNLVBCaps)
            .field("dwNLVBCaps2", &self.dwNLVBCaps2)
            .field("dwNLVBCKeyCaps", &self.dwNLVBCKeyCaps)
            .field("dwNLVBFXCaps", &self.dwNLVBFXCaps)
            .field("dwNLVBRops", &self.dwNLVBRops)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDNONLOCALVIDMEMCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwNLVBCaps == other.dwNLVBCaps
            && self.dwNLVBCaps2 == other.dwNLVBCaps2
            && self.dwNLVBCKeyCaps == other.dwNLVBCKeyCaps
            && self.dwNLVBFXCaps == other.dwNLVBFXCaps
            && self.dwNLVBRops == other.dwNLVBRops
    }
}
impl ::core::cmp::Eq for DDNONLOCALVIDMEMCAPS {}
impl FromIntoMemory for DDNONLOCALVIDMEMCAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 52);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwNLVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwNLVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwNLVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwNLVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwNLVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[20..20 + 32]);
        Self {
            dwSize: f_dwSize,
            dwNLVBCaps: f_dwNLVBCaps,
            dwNLVBCaps2: f_dwNLVBCaps2,
            dwNLVBCKeyCaps: f_dwNLVBCKeyCaps,
            dwNLVBFXCaps: f_dwNLVBFXCaps,
            dwNLVBRops: f_dwNLVBRops,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 52);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBRops, &mut into[20..20 + 32]);
    }
    fn size() -> usize {
        52
    }
}
pub struct DDNTCORECAPS {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCKeyCaps: u32,
    pub dwFXCaps: u32,
    pub dwFXAlphaCaps: u32,
    pub dwPalCaps: u32,
    pub dwSVCaps: u32,
    pub dwAlphaBltConstBitDepths: u32,
    pub dwAlphaBltPixelBitDepths: u32,
    pub dwAlphaBltSurfaceBitDepths: u32,
    pub dwAlphaOverlayConstBitDepths: u32,
    pub dwAlphaOverlayPixelBitDepths: u32,
    pub dwAlphaOverlaySurfaceBitDepths: u32,
    pub dwZBufferBitDepths: u32,
    pub dwVidMemTotal: u32,
    pub dwVidMemFree: u32,
    pub dwMaxVisibleOverlays: u32,
    pub dwCurrVisibleOverlays: u32,
    pub dwNumFourCCCodes: u32,
    pub dwAlignBoundarySrc: u32,
    pub dwAlignSizeSrc: u32,
    pub dwAlignBoundaryDest: u32,
    pub dwAlignSizeDest: u32,
    pub dwAlignStrideAlign: u32,
    pub dwRops: [u32; 8],
    pub ddsCaps: DDSCAPS,
    pub dwMinOverlayStretch: u32,
    pub dwMaxOverlayStretch: u32,
    pub dwMinLiveVideoStretch: u32,
    pub dwMaxLiveVideoStretch: u32,
    pub dwMinHwCodecStretch: u32,
    pub dwMaxHwCodecStretch: u32,
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dwReserved3: u32,
    pub dwSVBCaps: u32,
    pub dwSVBCKeyCaps: u32,
    pub dwSVBFXCaps: u32,
    pub dwSVBRops: [u32; 8],
    pub dwVSBCaps: u32,
    pub dwVSBCKeyCaps: u32,
    pub dwVSBFXCaps: u32,
    pub dwVSBRops: [u32; 8],
    pub dwSSBCaps: u32,
    pub dwSSBCKeyCaps: u32,
    pub dwSSBFXCaps: u32,
    pub dwSSBRops: [u32; 8],
    pub dwMaxVideoPorts: u32,
    pub dwCurrVideoPorts: u32,
    pub dwSVBCaps2: u32,
}
impl ::core::marker::Copy for DDNTCORECAPS {}
impl ::core::clone::Clone for DDNTCORECAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDNTCORECAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDNTCORECAPS")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwCaps2", &self.dwCaps2)
            .field("dwCKeyCaps", &self.dwCKeyCaps)
            .field("dwFXCaps", &self.dwFXCaps)
            .field("dwFXAlphaCaps", &self.dwFXAlphaCaps)
            .field("dwPalCaps", &self.dwPalCaps)
            .field("dwSVCaps", &self.dwSVCaps)
            .field("dwAlphaBltConstBitDepths", &self.dwAlphaBltConstBitDepths)
            .field("dwAlphaBltPixelBitDepths", &self.dwAlphaBltPixelBitDepths)
            .field(
                "dwAlphaBltSurfaceBitDepths",
                &self.dwAlphaBltSurfaceBitDepths,
            )
            .field(
                "dwAlphaOverlayConstBitDepths",
                &self.dwAlphaOverlayConstBitDepths,
            )
            .field(
                "dwAlphaOverlayPixelBitDepths",
                &self.dwAlphaOverlayPixelBitDepths,
            )
            .field(
                "dwAlphaOverlaySurfaceBitDepths",
                &self.dwAlphaOverlaySurfaceBitDepths,
            )
            .field("dwZBufferBitDepths", &self.dwZBufferBitDepths)
            .field("dwVidMemTotal", &self.dwVidMemTotal)
            .field("dwVidMemFree", &self.dwVidMemFree)
            .field("dwMaxVisibleOverlays", &self.dwMaxVisibleOverlays)
            .field("dwCurrVisibleOverlays", &self.dwCurrVisibleOverlays)
            .field("dwNumFourCCCodes", &self.dwNumFourCCCodes)
            .field("dwAlignBoundarySrc", &self.dwAlignBoundarySrc)
            .field("dwAlignSizeSrc", &self.dwAlignSizeSrc)
            .field("dwAlignBoundaryDest", &self.dwAlignBoundaryDest)
            .field("dwAlignSizeDest", &self.dwAlignSizeDest)
            .field("dwAlignStrideAlign", &self.dwAlignStrideAlign)
            .field("dwRops", &self.dwRops)
            .field("ddsCaps", &self.ddsCaps)
            .field("dwMinOverlayStretch", &self.dwMinOverlayStretch)
            .field("dwMaxOverlayStretch", &self.dwMaxOverlayStretch)
            .field("dwMinLiveVideoStretch", &self.dwMinLiveVideoStretch)
            .field("dwMaxLiveVideoStretch", &self.dwMaxLiveVideoStretch)
            .field("dwMinHwCodecStretch", &self.dwMinHwCodecStretch)
            .field("dwMaxHwCodecStretch", &self.dwMaxHwCodecStretch)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .field("dwSVBCaps", &self.dwSVBCaps)
            .field("dwSVBCKeyCaps", &self.dwSVBCKeyCaps)
            .field("dwSVBFXCaps", &self.dwSVBFXCaps)
            .field("dwSVBRops", &self.dwSVBRops)
            .field("dwVSBCaps", &self.dwVSBCaps)
            .field("dwVSBCKeyCaps", &self.dwVSBCKeyCaps)
            .field("dwVSBFXCaps", &self.dwVSBFXCaps)
            .field("dwVSBRops", &self.dwVSBRops)
            .field("dwSSBCaps", &self.dwSSBCaps)
            .field("dwSSBCKeyCaps", &self.dwSSBCKeyCaps)
            .field("dwSSBFXCaps", &self.dwSSBFXCaps)
            .field("dwSSBRops", &self.dwSSBRops)
            .field("dwMaxVideoPorts", &self.dwMaxVideoPorts)
            .field("dwCurrVideoPorts", &self.dwCurrVideoPorts)
            .field("dwSVBCaps2", &self.dwSVBCaps2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDNTCORECAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCKeyCaps == other.dwCKeyCaps
            && self.dwFXCaps == other.dwFXCaps
            && self.dwFXAlphaCaps == other.dwFXAlphaCaps
            && self.dwPalCaps == other.dwPalCaps
            && self.dwSVCaps == other.dwSVCaps
            && self.dwAlphaBltConstBitDepths == other.dwAlphaBltConstBitDepths
            && self.dwAlphaBltPixelBitDepths == other.dwAlphaBltPixelBitDepths
            && self.dwAlphaBltSurfaceBitDepths == other.dwAlphaBltSurfaceBitDepths
            && self.dwAlphaOverlayConstBitDepths == other.dwAlphaOverlayConstBitDepths
            && self.dwAlphaOverlayPixelBitDepths == other.dwAlphaOverlayPixelBitDepths
            && self.dwAlphaOverlaySurfaceBitDepths == other.dwAlphaOverlaySurfaceBitDepths
            && self.dwZBufferBitDepths == other.dwZBufferBitDepths
            && self.dwVidMemTotal == other.dwVidMemTotal
            && self.dwVidMemFree == other.dwVidMemFree
            && self.dwMaxVisibleOverlays == other.dwMaxVisibleOverlays
            && self.dwCurrVisibleOverlays == other.dwCurrVisibleOverlays
            && self.dwNumFourCCCodes == other.dwNumFourCCCodes
            && self.dwAlignBoundarySrc == other.dwAlignBoundarySrc
            && self.dwAlignSizeSrc == other.dwAlignSizeSrc
            && self.dwAlignBoundaryDest == other.dwAlignBoundaryDest
            && self.dwAlignSizeDest == other.dwAlignSizeDest
            && self.dwAlignStrideAlign == other.dwAlignStrideAlign
            && self.dwRops == other.dwRops
            && self.ddsCaps == other.ddsCaps
            && self.dwMinOverlayStretch == other.dwMinOverlayStretch
            && self.dwMaxOverlayStretch == other.dwMaxOverlayStretch
            && self.dwMinLiveVideoStretch == other.dwMinLiveVideoStretch
            && self.dwMaxLiveVideoStretch == other.dwMaxLiveVideoStretch
            && self.dwMinHwCodecStretch == other.dwMinHwCodecStretch
            && self.dwMaxHwCodecStretch == other.dwMaxHwCodecStretch
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
            && self.dwSVBCaps == other.dwSVBCaps
            && self.dwSVBCKeyCaps == other.dwSVBCKeyCaps
            && self.dwSVBFXCaps == other.dwSVBFXCaps
            && self.dwSVBRops == other.dwSVBRops
            && self.dwVSBCaps == other.dwVSBCaps
            && self.dwVSBCKeyCaps == other.dwVSBCKeyCaps
            && self.dwVSBFXCaps == other.dwVSBFXCaps
            && self.dwVSBRops == other.dwVSBRops
            && self.dwSSBCaps == other.dwSSBCaps
            && self.dwSSBCKeyCaps == other.dwSSBCKeyCaps
            && self.dwSSBFXCaps == other.dwSSBFXCaps
            && self.dwSSBRops == other.dwSSBRops
            && self.dwMaxVideoPorts == other.dwMaxVideoPorts
            && self.dwCurrVideoPorts == other.dwCurrVideoPorts
            && self.dwSVBCaps2 == other.dwSVBCaps2
    }
}
impl ::core::cmp::Eq for DDNTCORECAPS {}
impl FromIntoMemory for DDNTCORECAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 316);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFXAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwPalCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwSVCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwAlphaBltConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlphaBltPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlphaBltSurfaceBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlphaOverlayConstBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlphaOverlayPixelBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAlphaOverlaySurfaceBitDepths =
            <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwZBufferBitDepths = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwVidMemTotal = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwVidMemFree = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwMaxVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwCurrVisibleOverlays = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwNumFourCCCodes = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwAlignBoundarySrc = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwAlignSizeSrc = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwAlignBoundaryDest = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_dwAlignSizeDest = <u32 as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dwAlignStrideAlign = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[100..100 + 32]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        let f_dwMinOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[136..136 + 4]);
        let f_dwMaxOverlayStretch = <u32 as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_dwMinLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwMaxLiveVideoStretch = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwMinHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwMaxHwCodecStretch = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        let f_dwSVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[172..172 + 4]);
        let f_dwSVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[176..176 + 4]);
        let f_dwSVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[180..180 + 4]);
        let f_dwSVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[184..184 + 32]);
        let f_dwVSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[216..216 + 4]);
        let f_dwVSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[220..220 + 4]);
        let f_dwVSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[224..224 + 4]);
        let f_dwVSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[228..228 + 32]);
        let f_dwSSBCaps = <u32 as FromIntoMemory>::from_bytes(&from[260..260 + 4]);
        let f_dwSSBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[264..264 + 4]);
        let f_dwSSBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[268..268 + 4]);
        let f_dwSSBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[272..272 + 32]);
        let f_dwMaxVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[304..304 + 4]);
        let f_dwCurrVideoPorts = <u32 as FromIntoMemory>::from_bytes(&from[308..308 + 4]);
        let f_dwSVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[312..312 + 4]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCKeyCaps: f_dwCKeyCaps,
            dwFXCaps: f_dwFXCaps,
            dwFXAlphaCaps: f_dwFXAlphaCaps,
            dwPalCaps: f_dwPalCaps,
            dwSVCaps: f_dwSVCaps,
            dwAlphaBltConstBitDepths: f_dwAlphaBltConstBitDepths,
            dwAlphaBltPixelBitDepths: f_dwAlphaBltPixelBitDepths,
            dwAlphaBltSurfaceBitDepths: f_dwAlphaBltSurfaceBitDepths,
            dwAlphaOverlayConstBitDepths: f_dwAlphaOverlayConstBitDepths,
            dwAlphaOverlayPixelBitDepths: f_dwAlphaOverlayPixelBitDepths,
            dwAlphaOverlaySurfaceBitDepths: f_dwAlphaOverlaySurfaceBitDepths,
            dwZBufferBitDepths: f_dwZBufferBitDepths,
            dwVidMemTotal: f_dwVidMemTotal,
            dwVidMemFree: f_dwVidMemFree,
            dwMaxVisibleOverlays: f_dwMaxVisibleOverlays,
            dwCurrVisibleOverlays: f_dwCurrVisibleOverlays,
            dwNumFourCCCodes: f_dwNumFourCCCodes,
            dwAlignBoundarySrc: f_dwAlignBoundarySrc,
            dwAlignSizeSrc: f_dwAlignSizeSrc,
            dwAlignBoundaryDest: f_dwAlignBoundaryDest,
            dwAlignSizeDest: f_dwAlignSizeDest,
            dwAlignStrideAlign: f_dwAlignStrideAlign,
            dwRops: f_dwRops,
            ddsCaps: f_ddsCaps,
            dwMinOverlayStretch: f_dwMinOverlayStretch,
            dwMaxOverlayStretch: f_dwMaxOverlayStretch,
            dwMinLiveVideoStretch: f_dwMinLiveVideoStretch,
            dwMaxLiveVideoStretch: f_dwMaxLiveVideoStretch,
            dwMinHwCodecStretch: f_dwMinHwCodecStretch,
            dwMaxHwCodecStretch: f_dwMaxHwCodecStretch,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
            dwSVBCaps: f_dwSVBCaps,
            dwSVBCKeyCaps: f_dwSVBCKeyCaps,
            dwSVBFXCaps: f_dwSVBFXCaps,
            dwSVBRops: f_dwSVBRops,
            dwVSBCaps: f_dwVSBCaps,
            dwVSBCKeyCaps: f_dwVSBCKeyCaps,
            dwVSBFXCaps: f_dwVSBFXCaps,
            dwVSBRops: f_dwVSBRops,
            dwSSBCaps: f_dwSSBCaps,
            dwSSBCKeyCaps: f_dwSSBCKeyCaps,
            dwSSBFXCaps: f_dwSSBFXCaps,
            dwSSBRops: f_dwSSBRops,
            dwMaxVideoPorts: f_dwMaxVideoPorts,
            dwCurrVideoPorts: f_dwCurrVideoPorts,
            dwSVBCaps2: f_dwSVBCaps2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 316);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFXAlphaCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwPalCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwSVCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltConstBitDepths, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltPixelBitDepths, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBltSurfaceBitDepths, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayConstBitDepths, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlayPixelBitDepths, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaOverlaySurfaceBitDepths, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferBitDepths, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemTotal, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwVidMemFree, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVisibleOverlays, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVisibleOverlays, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCCCodes, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundarySrc, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeSrc, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignBoundaryDest, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignSizeDest, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignStrideAlign, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwRops, &mut into[100..100 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[132..132 + 4]);
        FromIntoMemory::into_bytes(self.dwMinOverlayStretch, &mut into[136..136 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlayStretch, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.dwMinLiveVideoStretch, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxLiveVideoStretch, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwMinHwCodecStretch, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHwCodecStretch, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[168..168 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps, &mut into[172..172 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCKeyCaps, &mut into[176..176 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBFXCaps, &mut into[180..180 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBRops, &mut into[184..184 + 32]);
        FromIntoMemory::into_bytes(self.dwVSBCaps, &mut into[216..216 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBCKeyCaps, &mut into[220..220 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBFXCaps, &mut into[224..224 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBRops, &mut into[228..228 + 32]);
        FromIntoMemory::into_bytes(self.dwSSBCaps, &mut into[260..260 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBCKeyCaps, &mut into[264..264 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBFXCaps, &mut into[268..268 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBRops, &mut into[272..272 + 32]);
        FromIntoMemory::into_bytes(self.dwMaxVideoPorts, &mut into[304..304 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrVideoPorts, &mut into[308..308 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBCaps2, &mut into[312..312 + 4]);
    }
    fn size() -> usize {
        316
    }
}
pub struct DDOPTSURFACEDESC {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub ddSCaps: DDSCAPS2,
    pub ddOSCaps: DDOSCAPS,
    pub guid: crate::core::GUID,
    pub dwCompressionRatio: u32,
}
impl ::core::marker::Copy for DDOPTSURFACEDESC {}
impl ::core::clone::Clone for DDOPTSURFACEDESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDOPTSURFACEDESC {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.ddSCaps == other.ddSCaps
            && self.ddOSCaps == other.ddOSCaps
            && self.guid == other.guid
            && self.dwCompressionRatio == other.dwCompressionRatio
    }
}
impl ::core::cmp::Eq for DDOPTSURFACEDESC {}
impl FromIntoMemory for DDOPTSURFACEDESC {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 48);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddSCaps = <DDSCAPS2 as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_ddOSCaps = <DDOSCAPS as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_guid = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[28..28 + 16]);
        let f_dwCompressionRatio = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            ddSCaps: f_ddSCaps,
            ddOSCaps: f_ddOSCaps,
            guid: f_guid,
            dwCompressionRatio: f_dwCompressionRatio,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 48);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddSCaps, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.ddOSCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.guid, &mut into[28..28 + 16]);
        FromIntoMemory::into_bytes(self.dwCompressionRatio, &mut into[44..44 + 4]);
    }
    fn size() -> usize {
        48
    }
}
pub struct DDOSCAPS {
    pub dwCaps: u32,
}
impl ::core::marker::Copy for DDOSCAPS {}
impl ::core::clone::Clone for DDOSCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDOSCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDOSCAPS")
            .field("dwCaps", &self.dwCaps)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDOSCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwCaps == other.dwCaps
    }
}
impl ::core::cmp::Eq for DDOSCAPS {}
impl FromIntoMemory for DDOSCAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self { dwCaps: f_dwCaps }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub const DDOSDCAPS_MONOLITHICMIPMAP: i32 = 4i32;
pub const DDOSDCAPS_OPTCOMPRESSED: i32 = 1i32;
pub const DDOSDCAPS_OPTREORDERED: i32 = 2i32;
pub const DDOSDCAPS_VALIDOSCAPS: i32 = 7i32;
pub const DDOSDCAPS_VALIDSCAPS: i32 = 805324800i32;
pub const DDOSD_ALL: i32 = 15i32;
pub const DDOSD_COMPRESSION_RATIO: i32 = 2i32;
pub const DDOSD_GUID: i32 = 1i32;
pub const DDOSD_OSCAPS: i32 = 8i32;
pub const DDOSD_SCAPS: i32 = 4i32;
pub const DDOVERFX_ARITHSTRETCHY: i32 = 1i32;
pub const DDOVERFX_DEINTERLACE: i32 = 8i32;
pub const DDOVERFX_MIRRORLEFTRIGHT: i32 = 2i32;
pub const DDOVERFX_MIRRORUPDOWN: i32 = 4i32;
pub struct DDOVERLAYFX {
    pub dwSize: u32,
    pub dwAlphaEdgeBlendBitDepth: u32,
    pub dwAlphaEdgeBlend: u32,
    pub dwReserved: u32,
    pub dwAlphaDestConstBitDepth: u32,
    pub Anonymous1: DDOVERLAYFX_0,
    pub dwAlphaSrcConstBitDepth: u32,
    pub Anonymous2: DDOVERLAYFX_1,
    pub dckDestColorkey: DDCOLORKEY,
    pub dckSrcColorkey: DDCOLORKEY,
    pub dwDDFX: u32,
    pub dwFlags: u32,
}
impl ::core::marker::Copy for DDOVERLAYFX {}
impl ::core::clone::Clone for DDOVERLAYFX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDOVERLAYFX {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwAlphaEdgeBlendBitDepth == other.dwAlphaEdgeBlendBitDepth
            && self.dwAlphaEdgeBlend == other.dwAlphaEdgeBlend
            && self.dwReserved == other.dwReserved
            && self.dwAlphaDestConstBitDepth == other.dwAlphaDestConstBitDepth
            && self.Anonymous1 == other.Anonymous1
            && self.dwAlphaSrcConstBitDepth == other.dwAlphaSrcConstBitDepth
            && self.Anonymous2 == other.Anonymous2
            && self.dckDestColorkey == other.dckDestColorkey
            && self.dckSrcColorkey == other.dckSrcColorkey
            && self.dwDDFX == other.dwDDFX
            && self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for DDOVERLAYFX {}
impl FromIntoMemory for DDOVERLAYFX {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 56);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwAlphaEdgeBlendBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwAlphaEdgeBlend = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwAlphaDestConstBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Anonymous1 = <DDOVERLAYFX_0 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwAlphaSrcConstBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_Anonymous2 = <DDOVERLAYFX_1 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dckDestColorkey = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[32..32 + 8]);
        let f_dckSrcColorkey = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[40..40 + 8]);
        let f_dwDDFX = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        Self {
            dwSize: f_dwSize,
            dwAlphaEdgeBlendBitDepth: f_dwAlphaEdgeBlendBitDepth,
            dwAlphaEdgeBlend: f_dwAlphaEdgeBlend,
            dwReserved: f_dwReserved,
            dwAlphaDestConstBitDepth: f_dwAlphaDestConstBitDepth,
            Anonymous1: f_Anonymous1,
            dwAlphaSrcConstBitDepth: f_dwAlphaSrcConstBitDepth,
            Anonymous2: f_Anonymous2,
            dckDestColorkey: f_dckDestColorkey,
            dckSrcColorkey: f_dckSrcColorkey,
            dwDDFX: f_dwDDFX,
            dwFlags: f_dwFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 56);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaEdgeBlendBitDepth, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaEdgeBlend, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaDestConstBitDepth, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaSrcConstBitDepth, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dckDestColorkey, &mut into[32..32 + 8]);
        FromIntoMemory::into_bytes(self.dckSrcColorkey, &mut into[40..40 + 8]);
        FromIntoMemory::into_bytes(self.dwDDFX, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[52..52 + 4]);
    }
    fn size() -> usize {
        56
    }
}
pub struct DDOVERLAYFX_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDOVERLAYFX_0 {}
impl ::core::clone::Clone for DDOVERLAYFX_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDOVERLAYFX_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDOVERLAYFX_0 {}
impl FromIntoMemory for DDOVERLAYFX_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDOVERLAYFX_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDOVERLAYFX_1 {}
impl ::core::clone::Clone for DDOVERLAYFX_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDOVERLAYFX_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDOVERLAYFX_1 {}
impl FromIntoMemory for DDOVERLAYFX_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub const DDOVERZ_INSERTINBACKOF: i32 = 5i32;
pub const DDOVERZ_INSERTINFRONTOF: i32 = 4i32;
pub const DDOVERZ_MOVEBACKWARD: i32 = 3i32;
pub const DDOVERZ_MOVEFORWARD: i32 = 2i32;
pub const DDOVERZ_SENDTOBACK: i32 = 1i32;
pub const DDOVERZ_SENDTOFRONT: i32 = 0i32;
pub const DDOVER_ADDDIRTYRECT: i32 = 32768i32;
pub const DDOVER_ALPHADEST: i32 = 1i32;
pub const DDOVER_ALPHADESTCONSTOVERRIDE: i32 = 2i32;
pub const DDOVER_ALPHADESTNEG: i32 = 4i32;
pub const DDOVER_ALPHADESTSURFACEOVERRIDE: i32 = 8i32;
pub const DDOVER_ALPHAEDGEBLEND: i32 = 16i32;
pub const DDOVER_ALPHASRC: i32 = 32i32;
pub const DDOVER_ALPHASRCCONSTOVERRIDE: i32 = 64i32;
pub const DDOVER_ALPHASRCNEG: i32 = 128i32;
pub const DDOVER_ALPHASRCSURFACEOVERRIDE: i32 = 256i32;
pub const DDOVER_ARGBSCALEFACTORS: i32 = 33554432i32;
pub const DDOVER_AUTOFLIP: i32 = 1048576i32;
pub const DDOVER_BOB: i32 = 2097152i32;
pub const DDOVER_BOBHARDWARE: i32 = 16777216i32;
pub const DDOVER_DDFX: i32 = 524288i32;
pub const DDOVER_DEGRADEARGBSCALING: i32 = 67108864i32;
pub const DDOVER_HIDE: i32 = 512i32;
pub const DDOVER_INTERLEAVED: i32 = 8388608i32;
pub const DDOVER_KEYDEST: i32 = 1024i32;
pub const DDOVER_KEYDESTOVERRIDE: i32 = 2048i32;
pub const DDOVER_KEYSRC: i32 = 4096i32;
pub const DDOVER_KEYSRCOVERRIDE: i32 = 8192i32;
pub const DDOVER_OVERRIDEBOBWEAVE: i32 = 4194304i32;
pub const DDOVER_REFRESHALL: i32 = 131072i32;
pub const DDOVER_REFRESHDIRTYRECTS: i32 = 65536i32;
pub const DDOVER_SHOW: i32 = 16384i32;
pub const DDPCAPS_1BIT: i32 = 256i32;
pub const DDPCAPS_2BIT: i32 = 512i32;
pub const DDPCAPS_4BIT: i32 = 1i32;
pub const DDPCAPS_8BIT: i32 = 4i32;
pub const DDPCAPS_8BITENTRIES: i32 = 2i32;
pub const DDPCAPS_ALLOW256: i32 = 64i32;
pub const DDPCAPS_ALPHA: i32 = 1024i32;
pub const DDPCAPS_INITIALIZE: i32 = 0i32;
pub const DDPCAPS_PRIMARYSURFACE: i32 = 16i32;
pub const DDPCAPS_PRIMARYSURFACELEFT: i32 = 32i32;
pub const DDPCAPS_VSYNC: i32 = 128i32;
pub const DDPF_ALPHA: i32 = 2i32;
pub const DDPF_ALPHAPIXELS: i32 = 1i32;
pub const DDPF_ALPHAPREMULT: i32 = 32768i32;
pub const DDPF_BUMPDUDV: i32 = 524288i32;
pub const DDPF_BUMPLUMINANCE: i32 = 262144i32;
pub const DDPF_COMPRESSED: i32 = 128i32;
pub const DDPF_D3DFORMAT: i32 = 2097152i32;
pub const DDPF_FOURCC: i32 = 4i32;
pub const DDPF_LUMINANCE: i32 = 131072i32;
pub const DDPF_NOVEL_TEXTURE_FORMAT: i32 = 1048576i32;
pub const DDPF_PALETTEINDEXED1: i32 = 2048i32;
pub const DDPF_PALETTEINDEXED2: i32 = 4096i32;
pub const DDPF_PALETTEINDEXED4: i32 = 8i32;
pub const DDPF_PALETTEINDEXED8: i32 = 32i32;
pub const DDPF_PALETTEINDEXEDTO8: i32 = 16i32;
pub const DDPF_RGB: i32 = 64i32;
pub const DDPF_RGBTOYUV: i32 = 256i32;
pub const DDPF_STENCILBUFFER: i32 = 16384i32;
pub const DDPF_YUV: i32 = 512i32;
pub const DDPF_ZBUFFER: i32 = 1024i32;
pub const DDPF_ZPIXELS: i32 = 8192i32;
pub struct DDPIXELFORMAT {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwFourCC: u32,
    pub Anonymous1: DDPIXELFORMAT_0,
    pub Anonymous2: DDPIXELFORMAT_1,
    pub Anonymous3: DDPIXELFORMAT_2,
    pub Anonymous4: DDPIXELFORMAT_3,
    pub Anonymous5: DDPIXELFORMAT_4,
}
impl ::core::marker::Copy for DDPIXELFORMAT {}
impl ::core::clone::Clone for DDPIXELFORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDPIXELFORMAT {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dwFourCC == other.dwFourCC
            && self.Anonymous1 == other.Anonymous1
            && self.Anonymous2 == other.Anonymous2
            && self.Anonymous3 == other.Anonymous3
            && self.Anonymous4 == other.Anonymous4
            && self.Anonymous5 == other.Anonymous5
    }
}
impl ::core::cmp::Eq for DDPIXELFORMAT {}
impl FromIntoMemory for DDPIXELFORMAT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFourCC = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Anonymous1 = <DDPIXELFORMAT_0 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_Anonymous2 = <DDPIXELFORMAT_1 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Anonymous3 = <DDPIXELFORMAT_2 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_Anonymous4 = <DDPIXELFORMAT_3 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_Anonymous5 = <DDPIXELFORMAT_4 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            dwFourCC: f_dwFourCC,
            Anonymous1: f_Anonymous1,
            Anonymous2: f_Anonymous2,
            Anonymous3: f_Anonymous3,
            Anonymous4: f_Anonymous4,
            Anonymous5: f_Anonymous5,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFourCC, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous3, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous4, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous5, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DDPIXELFORMAT_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDPIXELFORMAT_0 {}
impl ::core::clone::Clone for DDPIXELFORMAT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDPIXELFORMAT_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDPIXELFORMAT_0 {}
impl FromIntoMemory for DDPIXELFORMAT_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDPIXELFORMAT_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDPIXELFORMAT_1 {}
impl ::core::clone::Clone for DDPIXELFORMAT_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDPIXELFORMAT_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDPIXELFORMAT_1 {}
impl FromIntoMemory for DDPIXELFORMAT_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDPIXELFORMAT_2 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDPIXELFORMAT_2 {}
impl ::core::clone::Clone for DDPIXELFORMAT_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDPIXELFORMAT_2 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDPIXELFORMAT_2 {}
impl FromIntoMemory for DDPIXELFORMAT_2 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDPIXELFORMAT_2_0 {
    pub wFlipMSTypes: u16,
    pub wBltMSTypes: u16,
}
impl ::core::marker::Copy for DDPIXELFORMAT_2_0 {}
impl ::core::clone::Clone for DDPIXELFORMAT_2_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDPIXELFORMAT_2_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDPIXELFORMAT_2_0")
            .field("wFlipMSTypes", &self.wFlipMSTypes)
            .field("wBltMSTypes", &self.wBltMSTypes)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDPIXELFORMAT_2_0 {
    fn eq(&self, other: &Self) -> bool {
        self.wFlipMSTypes == other.wFlipMSTypes && self.wBltMSTypes == other.wBltMSTypes
    }
}
impl ::core::cmp::Eq for DDPIXELFORMAT_2_0 {}
impl FromIntoMemory for DDPIXELFORMAT_2_0 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_wFlipMSTypes = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_wBltMSTypes = <u16 as FromIntoMemory>::from_bytes(&from[2..2 + 2]);
        Self {
            wFlipMSTypes: f_wFlipMSTypes,
            wBltMSTypes: f_wBltMSTypes,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.wFlipMSTypes, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.wBltMSTypes, &mut into[2..2 + 2]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDPIXELFORMAT_3 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDPIXELFORMAT_3 {}
impl ::core::clone::Clone for DDPIXELFORMAT_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDPIXELFORMAT_3 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDPIXELFORMAT_3 {}
impl FromIntoMemory for DDPIXELFORMAT_3 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDPIXELFORMAT_4 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDPIXELFORMAT_4 {}
impl ::core::clone::Clone for DDPIXELFORMAT_4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDPIXELFORMAT_4 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDPIXELFORMAT_4 {}
impl FromIntoMemory for DDPIXELFORMAT_4 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub const DDRAWICLIP_INMASTERSPRITELIST: i32 = 4i32;
pub const DDRAWICLIP_ISINITIALIZED: i32 = 2i32;
pub const DDRAWICLIP_WATCHWINDOW: i32 = 1i32;
pub const DDRAWILCL_ACTIVENO: i32 = 16i32;
pub const DDRAWILCL_ACTIVEYES: i32 = 8i32;
pub const DDRAWILCL_ALLOWMODEX: i32 = 64i32;
pub const DDRAWILCL_ATTEMPTEDD3DCONTEXT: i32 = 262144i32;
pub const DDRAWILCL_CREATEDWINDOW: i32 = 512i32;
pub const DDRAWILCL_CURSORCLIPPED: i32 = 4096i32;
pub const DDRAWILCL_DIRECTDRAW7: i32 = 131072i32;
pub const DDRAWILCL_DIRECTDRAW8: i32 = 2097152i32;
pub const DDRAWILCL_DIRTYDC: i32 = 1024i32;
pub const DDRAWILCL_DISABLEINACTIVATE: i32 = 2048i32;
pub const DDRAWILCL_DX8DRIVER: i32 = 1048576i32;
pub const DDRAWILCL_EXPLICITMONITOR: i32 = 8192i32;
pub const DDRAWILCL_FPUPRESERVE: i32 = 524288i32;
pub const DDRAWILCL_FPUSETUP: i32 = 32768i32;
pub const DDRAWILCL_HASEXCLUSIVEMODE: i32 = 1i32;
pub const DDRAWILCL_HOOKEDHWND: i32 = 32i32;
pub const DDRAWILCL_ISFULLSCREEN: i32 = 2i32;
pub const DDRAWILCL_MODEHASBEENCHANGED: i32 = 256i32;
pub const DDRAWILCL_MULTITHREADED: i32 = 16384i32;
pub const DDRAWILCL_POWEREDDOWN: i32 = 65536i32;
pub const DDRAWILCL_SETCOOPCALLED: i32 = 4i32;
pub const DDRAWILCL_V1SCLBEHAVIOUR: i32 = 128i32;
pub const DDRAWIPAL_16: i32 = 2i32;
pub const DDRAWIPAL_2: i32 = 2048i32;
pub const DDRAWIPAL_256: i32 = 1i32;
pub const DDRAWIPAL_4: i32 = 1024i32;
pub const DDRAWIPAL_ALLOW256: i32 = 512i32;
pub const DDRAWIPAL_ALPHA: i32 = 8192i32;
pub const DDRAWIPAL_DIRTY: i32 = 256i32;
pub const DDRAWIPAL_EXCLUSIVE: i32 = 64i32;
pub const DDRAWIPAL_GDI: i32 = 4i32;
pub const DDRAWIPAL_INHEL: i32 = 128i32;
pub const DDRAWIPAL_STORED_16: i32 = 16i32;
pub const DDRAWIPAL_STORED_24: i32 = 32i32;
pub const DDRAWIPAL_STORED_8: i32 = 8i32;
pub const DDRAWIPAL_STORED_8INDEX: i32 = 4096i32;
pub const DDRAWISURFGBL_DDHELDONTFREE: i32 = 1048576i32;
pub const DDRAWISURFGBL_DX8SURFACE: i32 = 524288i32;
pub const DDRAWISURFGBL_FASTLOCKHELD: i32 = 32768i32;
pub const DDRAWISURFGBL_HARDWAREOPDEST: i32 = 1024i32;
pub const DDRAWISURFGBL_HARDWAREOPSOURCE: i32 = 512i32;
pub const DDRAWISURFGBL_IMPLICITHANDLE: i32 = 128i32;
pub const DDRAWISURFGBL_ISCLIENTMEM: i32 = 256i32;
pub const DDRAWISURFGBL_ISGDISURFACE: i32 = 4i32;
pub const DDRAWISURFGBL_LATEALLOCATELINEAR: i32 = 8192i32;
pub const DDRAWISURFGBL_LOCKBROKEN: i32 = 64i32;
pub const DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK: i32 = 16i32;
pub const DDRAWISURFGBL_LOCKVRAMSTYLE: i32 = 32i32;
pub const DDRAWISURFGBL_MEMFREE: i32 = 1i32;
pub const DDRAWISURFGBL_NOTIFYWHENUNLOCKED: i32 = 2097152i32;
pub const DDRAWISURFGBL_READONLYLOCKHELD: i32 = 65536i32;
pub const DDRAWISURFGBL_RESERVED0: i32 = -2147483648i32;
pub const DDRAWISURFGBL_SOFTWAREAUTOFLIP: i32 = 8i32;
pub const DDRAWISURFGBL_SYSMEMEXECUTEBUFFER: i32 = 16384i32;
pub const DDRAWISURFGBL_SYSMEMREQUESTED: i32 = 2i32;
pub const DDRAWISURFGBL_VPORTDATA: i32 = 4096i32;
pub const DDRAWISURFGBL_VPORTINTERLEAVED: i32 = 2048i32;
pub const DDRAWISURF_ATTACHED: i32 = 1i32;
pub const DDRAWISURF_ATTACHED_FROM: i32 = 8i32;
pub const DDRAWISURF_BACKBUFFER: i32 = 134217728i32;
pub const DDRAWISURF_DATAISALIASED: i32 = 64i32;
pub const DDRAWISURF_DCIBUSY: i32 = 536870912i32;
pub const DDRAWISURF_DCILOCK: i32 = -2147483648i32;
pub const DDRAWISURF_DRIVERMANAGED: i32 = 1073741824i32;
pub const DDRAWISURF_FRONTBUFFER: i32 = 67108864i32;
pub const DDRAWISURF_GETDCNULL: i32 = 1073741824i32;
pub const DDRAWISURF_HASCKEYDESTBLT: i32 = 512i32;
pub const DDRAWISURF_HASCKEYDESTOVERLAY: i32 = 256i32;
pub const DDRAWISURF_HASCKEYSRCBLT: i32 = 2048i32;
pub const DDRAWISURF_HASCKEYSRCOVERLAY: i32 = 1024i32;
pub const DDRAWISURF_HASDC: i32 = 128i32;
pub const DDRAWISURF_HASOVERLAYDATA: i32 = 16384i32;
pub const DDRAWISURF_HASPIXELFORMAT: i32 = 8192i32;
pub const DDRAWISURF_HELCB: i32 = 33554432i32;
pub const DDRAWISURF_HW_CKEYDESTBLT: i32 = 2097152i32;
pub const DDRAWISURF_HW_CKEYDESTOVERLAY: i32 = 1048576i32;
pub const DDRAWISURF_HW_CKEYSRCBLT: i32 = 8388608i32;
pub const DDRAWISURF_HW_CKEYSRCOVERLAY: i32 = 4194304i32;
pub const DDRAWISURF_IMPLICITCREATE: i32 = 2i32;
pub const DDRAWISURF_IMPLICITROOT: i32 = 16i32;
pub const DDRAWISURF_INMASTERSPRITELIST: i32 = 16777216i32;
pub const DDRAWISURF_INVALID: i32 = 268435456i32;
pub const DDRAWISURF_ISFREE: i32 = 4i32;
pub const DDRAWISURF_LOCKEXCLUDEDCURSOR: i32 = 4096i32;
pub const DDRAWISURF_PARTOFPRIMARYCHAIN: i32 = 32i32;
pub const DDRAWISURF_SETGAMMA: i32 = 32768i32;
pub const DDRAWISURF_STEREOSURFACELEFT: i32 = 536870912i32;
pub const DDRAWISURF_SW_CKEYDESTBLT: i32 = 131072i32;
pub const DDRAWISURF_SW_CKEYDESTOVERLAY: i32 = 65536i32;
pub const DDRAWISURF_SW_CKEYSRCBLT: i32 = 524288i32;
pub const DDRAWISURF_SW_CKEYSRCOVERLAY: i32 = 262144i32;
pub const DDRAWIVPORT_COLORKEYANDINTERP: u32 = 4u32;
pub const DDRAWIVPORT_NOKERNELHANDLES: u32 = 8u32;
pub const DDRAWIVPORT_ON: u32 = 1u32;
pub const DDRAWIVPORT_SOFTWARE_AUTOFLIP: u32 = 2u32;
pub const DDRAWIVPORT_SOFTWARE_BOB: u32 = 16u32;
pub const DDRAWIVPORT_VBION: u32 = 32u32;
pub const DDRAWIVPORT_VIDEOON: u32 = 64u32;
pub const DDRAWI_ATTACHEDTODESKTOP: i32 = 16777216i32;
pub const DDRAWI_BADPDEV: i32 = 1073741824i32;
pub const DDRAWI_CHANGINGMODE: i32 = 4194304i32;
pub struct DDRAWI_DDMOTIONCOMP_INT {
    pub lpVtbl: MutPtr<::core::ffi::c_void>,
    pub lpLcl: MutPtr<DDRAWI_DDMOTIONCOMP_LCL>,
    pub lpLink: MutPtr<DDRAWI_DDMOTIONCOMP_INT>,
    pub dwIntRefCnt: u32,
}
impl ::core::marker::Copy for DDRAWI_DDMOTIONCOMP_INT {}
impl ::core::clone::Clone for DDRAWI_DDMOTIONCOMP_INT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDMOTIONCOMP_INT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDMOTIONCOMP_INT")
            .field("lpVtbl", &self.lpVtbl)
            .field("lpLcl", &self.lpLcl)
            .field("lpLink", &self.lpLink)
            .field("dwIntRefCnt", &self.dwIntRefCnt)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDMOTIONCOMP_INT {
    fn eq(&self, other: &Self) -> bool {
        self.lpVtbl == other.lpVtbl
            && self.lpLcl == other.lpLcl
            && self.lpLink == other.lpLink
            && self.dwIntRefCnt == other.dwIntRefCnt
    }
}
impl ::core::cmp::Eq for DDRAWI_DDMOTIONCOMP_INT {}
impl FromIntoMemory for DDRAWI_DDMOTIONCOMP_INT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpVtbl = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpLcl =
            <MutPtr<DDRAWI_DDMOTIONCOMP_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpLink =
            <MutPtr<DDRAWI_DDMOTIONCOMP_INT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwIntRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpVtbl: f_lpVtbl,
            lpLcl: f_lpLcl,
            lpLink: f_lpLink,
            dwIntRefCnt: f_dwIntRefCnt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpVtbl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwIntRefCnt, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDRAWI_DDMOTIONCOMP_LCL {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub guid: crate::core::GUID,
    pub dwUncompWidth: u32,
    pub dwUncompHeight: u32,
    pub ddUncompPixelFormat: DDPIXELFORMAT,
    pub dwInternalFlags: u32,
    pub dwRefCnt: u32,
    pub dwProcessId: u32,
    pub hMoComp: super::super::Foundation::HANDLE,
    pub dwDriverReserved1: u32,
    pub dwDriverReserved2: u32,
    pub dwDriverReserved3: u32,
    pub lpDriverReserved1: MutPtr<::core::ffi::c_void>,
    pub lpDriverReserved2: MutPtr<::core::ffi::c_void>,
    pub lpDriverReserved3: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DDRAWI_DDMOTIONCOMP_LCL {}
impl ::core::clone::Clone for DDRAWI_DDMOTIONCOMP_LCL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDMOTIONCOMP_LCL {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.guid == other.guid
            && self.dwUncompWidth == other.dwUncompWidth
            && self.dwUncompHeight == other.dwUncompHeight
            && self.ddUncompPixelFormat == other.ddUncompPixelFormat
            && self.dwInternalFlags == other.dwInternalFlags
            && self.dwRefCnt == other.dwRefCnt
            && self.dwProcessId == other.dwProcessId
            && self.hMoComp == other.hMoComp
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
            && self.lpDriverReserved1 == other.lpDriverReserved1
            && self.lpDriverReserved2 == other.lpDriverReserved2
            && self.lpDriverReserved3 == other.lpDriverReserved3
    }
}
impl ::core::cmp::Eq for DDRAWI_DDMOTIONCOMP_LCL {}
impl FromIntoMemory for DDRAWI_DDMOTIONCOMP_LCL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 100);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_guid = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        let f_dwUncompWidth = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwUncompHeight = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_ddUncompPixelFormat =
            <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[28..28 + 32]);
        let f_dwInternalFlags = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwProcessId = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_hMoComp =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwDriverReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwDriverReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwDriverReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_lpDriverReserved1 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_lpDriverReserved2 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_lpDriverReserved3 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        Self {
            lpDD: f_lpDD,
            guid: f_guid,
            dwUncompWidth: f_dwUncompWidth,
            dwUncompHeight: f_dwUncompHeight,
            ddUncompPixelFormat: f_ddUncompPixelFormat,
            dwInternalFlags: f_dwInternalFlags,
            dwRefCnt: f_dwRefCnt,
            dwProcessId: f_dwProcessId,
            hMoComp: f_hMoComp,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
            lpDriverReserved1: f_lpDriverReserved1,
            lpDriverReserved2: f_lpDriverReserved2,
            lpDriverReserved3: f_lpDriverReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 100);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.guid, &mut into[4..4 + 16]);
        FromIntoMemory::into_bytes(self.dwUncompWidth, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwUncompHeight, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.ddUncompPixelFormat, &mut into[28..28 + 32]);
        FromIntoMemory::into_bytes(self.dwInternalFlags, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessId, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.hMoComp, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.lpDriverReserved1, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.lpDriverReserved2, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.lpDriverReserved3, &mut into[96..96 + 4]);
    }
    fn size() -> usize {
        100
    }
}
pub struct DDRAWI_DDRAWCLIPPER_GBL {
    pub dwRefCnt: u32,
    pub dwFlags: u32,
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwProcessId: u32,
    pub dwReserved1: PtrRepr,
    pub hWnd: PtrRepr,
    pub lpStaticClipList: MutPtr<super::Gdi::RGNDATA>,
}
impl ::core::marker::Copy for DDRAWI_DDRAWCLIPPER_GBL {}
impl ::core::clone::Clone for DDRAWI_DDRAWCLIPPER_GBL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDRAWCLIPPER_GBL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDRAWCLIPPER_GBL")
            .field("dwRefCnt", &self.dwRefCnt)
            .field("dwFlags", &self.dwFlags)
            .field("lpDD", &self.lpDD)
            .field("dwProcessId", &self.dwProcessId)
            .field("dwReserved1", &self.dwReserved1)
            .field("hWnd", &self.hWnd)
            .field("lpStaticClipList", &self.lpStaticClipList)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWCLIPPER_GBL {
    fn eq(&self, other: &Self) -> bool {
        self.dwRefCnt == other.dwRefCnt
            && self.dwFlags == other.dwFlags
            && self.lpDD == other.lpDD
            && self.dwProcessId == other.dwProcessId
            && self.dwReserved1 == other.dwReserved1
            && self.hWnd == other.hWnd
            && self.lpStaticClipList == other.lpStaticClipList
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWCLIPPER_GBL {}
impl FromIntoMemory for DDRAWI_DDRAWCLIPPER_GBL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwProcessId = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_hWnd = <PtrRepr as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpStaticClipList =
            <MutPtr<super::Gdi::RGNDATA> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            dwRefCnt: f_dwRefCnt,
            dwFlags: f_dwFlags,
            lpDD: f_lpDD,
            dwProcessId: f_dwProcessId,
            dwReserved1: f_dwReserved1,
            hWnd: f_hWnd,
            lpStaticClipList: f_lpStaticClipList,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessId, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpStaticClipList, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DDRAWI_DDRAWCLIPPER_INT {
    pub lpVtbl: MutPtr<::core::ffi::c_void>,
    pub lpLcl: MutPtr<DDRAWI_DDRAWCLIPPER_LCL>,
    pub lpLink: MutPtr<DDRAWI_DDRAWCLIPPER_INT>,
    pub dwIntRefCnt: u32,
}
impl ::core::marker::Copy for DDRAWI_DDRAWCLIPPER_INT {}
impl ::core::clone::Clone for DDRAWI_DDRAWCLIPPER_INT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDRAWCLIPPER_INT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDRAWCLIPPER_INT")
            .field("lpVtbl", &self.lpVtbl)
            .field("lpLcl", &self.lpLcl)
            .field("lpLink", &self.lpLink)
            .field("dwIntRefCnt", &self.dwIntRefCnt)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWCLIPPER_INT {
    fn eq(&self, other: &Self) -> bool {
        self.lpVtbl == other.lpVtbl
            && self.lpLcl == other.lpLcl
            && self.lpLink == other.lpLink
            && self.dwIntRefCnt == other.dwIntRefCnt
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWCLIPPER_INT {}
impl FromIntoMemory for DDRAWI_DDRAWCLIPPER_INT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpVtbl = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpLcl =
            <MutPtr<DDRAWI_DDRAWCLIPPER_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpLink =
            <MutPtr<DDRAWI_DDRAWCLIPPER_INT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwIntRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpVtbl: f_lpVtbl,
            lpLcl: f_lpLcl,
            lpLink: f_lpLink,
            dwIntRefCnt: f_dwIntRefCnt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpVtbl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwIntRefCnt, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDRAWI_DDRAWCLIPPER_LCL {
    pub lpClipMore: u32,
    pub lpGbl: MutPtr<DDRAWI_DDRAWCLIPPER_GBL>,
    pub lpDD_lcl: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub dwLocalRefCnt: u32,
    pub pUnkOuter: crate::core::IUnknown,
    pub lpDD_int: MutPtr<DDRAWI_DIRECTDRAW_INT>,
    pub dwReserved1: PtrRepr,
    pub pAddrefedThisOwner: crate::core::IUnknown,
}
impl ::core::marker::Copy for DDRAWI_DDRAWCLIPPER_LCL {}
impl ::core::clone::Clone for DDRAWI_DDRAWCLIPPER_LCL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDRAWCLIPPER_LCL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDRAWCLIPPER_LCL")
            .field("lpClipMore", &self.lpClipMore)
            .field("lpGbl", &self.lpGbl)
            .field("lpDD_lcl", &self.lpDD_lcl)
            .field("dwLocalRefCnt", &self.dwLocalRefCnt)
            .field("pUnkOuter", &self.pUnkOuter)
            .field("lpDD_int", &self.lpDD_int)
            .field("dwReserved1", &self.dwReserved1)
            .field("pAddrefedThisOwner", &self.pAddrefedThisOwner)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWCLIPPER_LCL {
    fn eq(&self, other: &Self) -> bool {
        self.lpClipMore == other.lpClipMore
            && self.lpGbl == other.lpGbl
            && self.lpDD_lcl == other.lpDD_lcl
            && self.dwLocalRefCnt == other.dwLocalRefCnt
            && self.pUnkOuter == other.pUnkOuter
            && self.lpDD_int == other.lpDD_int
            && self.dwReserved1 == other.dwReserved1
            && self.pAddrefedThisOwner == other.pAddrefedThisOwner
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWCLIPPER_LCL {}
impl FromIntoMemory for DDRAWI_DDRAWCLIPPER_LCL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_lpClipMore = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGbl =
            <MutPtr<DDRAWI_DDRAWCLIPPER_GBL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDD_lcl =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwLocalRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pUnkOuter = <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpDD_int =
            <MutPtr<DDRAWI_DIRECTDRAW_INT> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_pAddrefedThisOwner =
            <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            lpClipMore: f_lpClipMore,
            lpGbl: f_lpGbl,
            lpDD_lcl: f_lpDD_lcl,
            dwLocalRefCnt: f_dwLocalRefCnt,
            pUnkOuter: f_pUnkOuter,
            lpDD_int: f_lpDD_int,
            dwReserved1: f_dwReserved1,
            pAddrefedThisOwner: f_pAddrefedThisOwner,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.lpClipMore, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGbl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDD_lcl, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwLocalRefCnt, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pUnkOuter, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpDD_int, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.pAddrefedThisOwner, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub const DDRAWI_DDRAWDATANOTFETCHED: i32 = 67108864i32;
pub struct DDRAWI_DDRAWPALETTE_GBL {
    pub dwRefCnt: u32,
    pub dwFlags: u32,
    pub lpDD_lcl: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub dwProcessId: u32,
    pub lpColorTable: MutPtr<super::Gdi::PALETTEENTRY>,
    pub Anonymous: DDRAWI_DDRAWPALETTE_GBL_0,
    pub dwDriverReserved: u32,
    pub dwContentsStamp: u32,
    pub dwSaveStamp: u32,
    pub dwHandle: u32,
}
impl ::core::marker::Copy for DDRAWI_DDRAWPALETTE_GBL {}
impl ::core::clone::Clone for DDRAWI_DDRAWPALETTE_GBL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWPALETTE_GBL {
    fn eq(&self, other: &Self) -> bool {
        self.dwRefCnt == other.dwRefCnt
            && self.dwFlags == other.dwFlags
            && self.lpDD_lcl == other.lpDD_lcl
            && self.dwProcessId == other.dwProcessId
            && self.lpColorTable == other.lpColorTable
            && self.Anonymous == other.Anonymous
            && self.dwDriverReserved == other.dwDriverReserved
            && self.dwContentsStamp == other.dwContentsStamp
            && self.dwSaveStamp == other.dwSaveStamp
            && self.dwHandle == other.dwHandle
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWPALETTE_GBL {}
impl FromIntoMemory for DDRAWI_DDRAWPALETTE_GBL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDD_lcl =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwProcessId = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpColorTable =
            <MutPtr<super::Gdi::PALETTEENTRY> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Anonymous =
            <DDRAWI_DDRAWPALETTE_GBL_0 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwDriverReserved = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwContentsStamp = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwSaveStamp = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwHandle = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        Self {
            dwRefCnt: f_dwRefCnt,
            dwFlags: f_dwFlags,
            lpDD_lcl: f_lpDD_lcl,
            dwProcessId: f_dwProcessId,
            lpColorTable: f_lpColorTable,
            Anonymous: f_Anonymous,
            dwDriverReserved: f_dwDriverReserved,
            dwContentsStamp: f_dwContentsStamp,
            dwSaveStamp: f_dwSaveStamp,
            dwHandle: f_dwHandle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDD_lcl, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessId, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpColorTable, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwContentsStamp, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwSaveStamp, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwHandle, &mut into[36..36 + 4]);
    }
    fn size() -> usize {
        40
    }
}
pub struct DDRAWI_DDRAWPALETTE_GBL_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWPALETTE_GBL_0 {}
impl ::core::clone::Clone for DDRAWI_DDRAWPALETTE_GBL_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWPALETTE_GBL_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWPALETTE_GBL_0 {}
impl FromIntoMemory for DDRAWI_DDRAWPALETTE_GBL_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWPALETTE_INT {
    pub lpVtbl: MutPtr<::core::ffi::c_void>,
    pub lpLcl: MutPtr<DDRAWI_DDRAWPALETTE_LCL>,
    pub lpLink: MutPtr<DDRAWI_DDRAWPALETTE_INT>,
    pub dwIntRefCnt: u32,
}
impl ::core::marker::Copy for DDRAWI_DDRAWPALETTE_INT {}
impl ::core::clone::Clone for DDRAWI_DDRAWPALETTE_INT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDRAWPALETTE_INT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDRAWPALETTE_INT")
            .field("lpVtbl", &self.lpVtbl)
            .field("lpLcl", &self.lpLcl)
            .field("lpLink", &self.lpLink)
            .field("dwIntRefCnt", &self.dwIntRefCnt)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWPALETTE_INT {
    fn eq(&self, other: &Self) -> bool {
        self.lpVtbl == other.lpVtbl
            && self.lpLcl == other.lpLcl
            && self.lpLink == other.lpLink
            && self.dwIntRefCnt == other.dwIntRefCnt
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWPALETTE_INT {}
impl FromIntoMemory for DDRAWI_DDRAWPALETTE_INT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpVtbl = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpLcl =
            <MutPtr<DDRAWI_DDRAWPALETTE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpLink =
            <MutPtr<DDRAWI_DDRAWPALETTE_INT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwIntRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpVtbl: f_lpVtbl,
            lpLcl: f_lpLcl,
            lpLink: f_lpLink,
            dwIntRefCnt: f_dwIntRefCnt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpVtbl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwIntRefCnt, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDRAWI_DDRAWPALETTE_LCL {
    pub lpPalMore: u32,
    pub lpGbl: MutPtr<DDRAWI_DDRAWPALETTE_GBL>,
    pub dwUnused0: PtrRepr,
    pub dwLocalRefCnt: u32,
    pub pUnkOuter: crate::core::IUnknown,
    pub lpDD_lcl: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub dwReserved1: PtrRepr,
    pub dwDDRAWReserved1: PtrRepr,
    pub dwDDRAWReserved2: PtrRepr,
    pub dwDDRAWReserved3: PtrRepr,
}
impl ::core::marker::Copy for DDRAWI_DDRAWPALETTE_LCL {}
impl ::core::clone::Clone for DDRAWI_DDRAWPALETTE_LCL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDRAWPALETTE_LCL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDRAWPALETTE_LCL")
            .field("lpPalMore", &self.lpPalMore)
            .field("lpGbl", &self.lpGbl)
            .field("dwUnused0", &self.dwUnused0)
            .field("dwLocalRefCnt", &self.dwLocalRefCnt)
            .field("pUnkOuter", &self.pUnkOuter)
            .field("lpDD_lcl", &self.lpDD_lcl)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwDDRAWReserved1", &self.dwDDRAWReserved1)
            .field("dwDDRAWReserved2", &self.dwDDRAWReserved2)
            .field("dwDDRAWReserved3", &self.dwDDRAWReserved3)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWPALETTE_LCL {
    fn eq(&self, other: &Self) -> bool {
        self.lpPalMore == other.lpPalMore
            && self.lpGbl == other.lpGbl
            && self.dwUnused0 == other.dwUnused0
            && self.dwLocalRefCnt == other.dwLocalRefCnt
            && self.pUnkOuter == other.pUnkOuter
            && self.lpDD_lcl == other.lpDD_lcl
            && self.dwReserved1 == other.dwReserved1
            && self.dwDDRAWReserved1 == other.dwDDRAWReserved1
            && self.dwDDRAWReserved2 == other.dwDDRAWReserved2
            && self.dwDDRAWReserved3 == other.dwDDRAWReserved3
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWPALETTE_LCL {}
impl FromIntoMemory for DDRAWI_DDRAWPALETTE_LCL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_lpPalMore = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGbl =
            <MutPtr<DDRAWI_DDRAWPALETTE_GBL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwUnused0 = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwLocalRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pUnkOuter = <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpDD_lcl =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwDDRAWReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwDDRAWReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwDDRAWReserved3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        Self {
            lpPalMore: f_lpPalMore,
            lpGbl: f_lpGbl,
            dwUnused0: f_dwUnused0,
            dwLocalRefCnt: f_dwLocalRefCnt,
            pUnkOuter: f_pUnkOuter,
            lpDD_lcl: f_lpDD_lcl,
            dwReserved1: f_dwReserved1,
            dwDDRAWReserved1: f_dwDDRAWReserved1,
            dwDDRAWReserved2: f_dwDDRAWReserved2,
            dwDDRAWReserved3: f_dwDDRAWReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.lpPalMore, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGbl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwUnused0, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwLocalRefCnt, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pUnkOuter, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpDD_lcl, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwDDRAWReserved1, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwDDRAWReserved2, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwDDRAWReserved3, &mut into[36..36 + 4]);
    }
    fn size() -> usize {
        40
    }
}
pub struct DDRAWI_DDRAWSURFACE_GBL {
    pub dwRefCnt: u32,
    pub dwGlobalFlags: u32,
    pub Anonymous1: DDRAWI_DDRAWSURFACE_GBL_0,
    pub Anonymous2: DDRAWI_DDRAWSURFACE_GBL_1,
    pub Anonymous3: DDRAWI_DDRAWSURFACE_GBL_2,
    pub fpVidMem: PtrRepr,
    pub Anonymous4: DDRAWI_DDRAWSURFACE_GBL_3,
    pub wHeight: u16,
    pub wWidth: u16,
    pub dwUsageCount: u32,
    pub dwReserved1: PtrRepr,
    pub ddpfSurface: DDPIXELFORMAT,
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_GBL {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_GBL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_GBL {
    fn eq(&self, other: &Self) -> bool {
        self.dwRefCnt == other.dwRefCnt
            && self.dwGlobalFlags == other.dwGlobalFlags
            && self.Anonymous1 == other.Anonymous1
            && self.Anonymous2 == other.Anonymous2
            && self.Anonymous3 == other.Anonymous3
            && self.fpVidMem == other.fpVidMem
            && self.Anonymous4 == other.Anonymous4
            && self.wHeight == other.wHeight
            && self.wWidth == other.wWidth
            && self.dwUsageCount == other.dwUsageCount
            && self.dwReserved1 == other.dwReserved1
            && self.ddpfSurface == other.ddpfSurface
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_GBL {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_GBL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 72);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwGlobalFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_Anonymous1 =
            <DDRAWI_DDRAWSURFACE_GBL_0 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Anonymous2 =
            <DDRAWI_DDRAWSURFACE_GBL_1 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_Anonymous3 =
            <DDRAWI_DDRAWSURFACE_GBL_2 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_fpVidMem = <PtrRepr as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_Anonymous4 =
            <DDRAWI_DDRAWSURFACE_GBL_3 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_wHeight = <u16 as FromIntoMemory>::from_bytes(&from[28..28 + 2]);
        let f_wWidth = <u16 as FromIntoMemory>::from_bytes(&from[30..30 + 2]);
        let f_dwUsageCount = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_ddpfSurface = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[40..40 + 32]);
        Self {
            dwRefCnt: f_dwRefCnt,
            dwGlobalFlags: f_dwGlobalFlags,
            Anonymous1: f_Anonymous1,
            Anonymous2: f_Anonymous2,
            Anonymous3: f_Anonymous3,
            fpVidMem: f_fpVidMem,
            Anonymous4: f_Anonymous4,
            wHeight: f_wHeight,
            wWidth: f_wWidth,
            dwUsageCount: f_dwUsageCount,
            dwReserved1: f_dwReserved1,
            ddpfSurface: f_ddpfSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 72);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwGlobalFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous3, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.fpVidMem, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous4, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.wHeight, &mut into[28..28 + 2]);
        FromIntoMemory::into_bytes(self.wWidth, &mut into[30..30 + 2]);
        FromIntoMemory::into_bytes(self.dwUsageCount, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.ddpfSurface, &mut into[40..40 + 32]);
    }
    fn size() -> usize {
        72
    }
}
pub struct DDRAWI_DDRAWSURFACE_GBL_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_GBL_0 {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_GBL_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_GBL_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_GBL_0 {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_GBL_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWSURFACE_GBL_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_GBL_1 {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_GBL_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_GBL_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_GBL_1 {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_GBL_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWSURFACE_GBL_2 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_GBL_2 {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_GBL_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_GBL_2 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_GBL_2 {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_GBL_2 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWSURFACE_GBL_3 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_GBL_3 {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_GBL_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_GBL_3 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_GBL_3 {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_GBL_3 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWSURFACE_GBL_MORE {
    pub dwSize: u32,
    pub Anonymous: DDRAWI_DDRAWSURFACE_GBL_MORE_0,
    pub pPageTable: MutPtr<u32>,
    pub cPages: u32,
    pub dwSavedDCContext: PtrRepr,
    pub fpAliasedVidMem: PtrRepr,
    pub dwDriverReserved: PtrRepr,
    pub dwHELReserved: PtrRepr,
    pub cPageUnlocks: u32,
    pub hKernelSurface: PtrRepr,
    pub dwKernelRefCnt: u32,
    pub lpColorInfo: MutPtr<DDCOLORCONTROL>,
    pub fpNTAlias: PtrRepr,
    pub dwContentsStamp: u32,
    pub lpvUnswappedDriverReserved: MutPtr<::core::ffi::c_void>,
    pub lpDDRAWReserved2: MutPtr<::core::ffi::c_void>,
    pub dwDDRAWReserved1: u32,
    pub dwDDRAWReserved2: u32,
    pub fpAliasOfVidMem: PtrRepr,
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_GBL_MORE {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_GBL_MORE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_GBL_MORE {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.Anonymous == other.Anonymous
            && self.pPageTable == other.pPageTable
            && self.cPages == other.cPages
            && self.dwSavedDCContext == other.dwSavedDCContext
            && self.fpAliasedVidMem == other.fpAliasedVidMem
            && self.dwDriverReserved == other.dwDriverReserved
            && self.dwHELReserved == other.dwHELReserved
            && self.cPageUnlocks == other.cPageUnlocks
            && self.hKernelSurface == other.hKernelSurface
            && self.dwKernelRefCnt == other.dwKernelRefCnt
            && self.lpColorInfo == other.lpColorInfo
            && self.fpNTAlias == other.fpNTAlias
            && self.dwContentsStamp == other.dwContentsStamp
            && self.lpvUnswappedDriverReserved == other.lpvUnswappedDriverReserved
            && self.lpDDRAWReserved2 == other.lpDDRAWReserved2
            && self.dwDDRAWReserved1 == other.dwDDRAWReserved1
            && self.dwDDRAWReserved2 == other.dwDDRAWReserved2
            && self.fpAliasOfVidMem == other.fpAliasOfVidMem
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_GBL_MORE {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_GBL_MORE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 76);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_Anonymous =
            <DDRAWI_DDRAWSURFACE_GBL_MORE_0 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pPageTable = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_cPages = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwSavedDCContext = <PtrRepr as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_fpAliasedVidMem = <PtrRepr as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwDriverReserved = <PtrRepr as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwHELReserved = <PtrRepr as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_cPageUnlocks = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_hKernelSurface = <PtrRepr as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwKernelRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpColorInfo =
            <MutPtr<DDCOLORCONTROL> as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_fpNTAlias = <PtrRepr as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwContentsStamp = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_lpvUnswappedDriverReserved =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_lpDDRAWReserved2 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwDDRAWReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwDDRAWReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_fpAliasOfVidMem = <PtrRepr as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        Self {
            dwSize: f_dwSize,
            Anonymous: f_Anonymous,
            pPageTable: f_pPageTable,
            cPages: f_cPages,
            dwSavedDCContext: f_dwSavedDCContext,
            fpAliasedVidMem: f_fpAliasedVidMem,
            dwDriverReserved: f_dwDriverReserved,
            dwHELReserved: f_dwHELReserved,
            cPageUnlocks: f_cPageUnlocks,
            hKernelSurface: f_hKernelSurface,
            dwKernelRefCnt: f_dwKernelRefCnt,
            lpColorInfo: f_lpColorInfo,
            fpNTAlias: f_fpNTAlias,
            dwContentsStamp: f_dwContentsStamp,
            lpvUnswappedDriverReserved: f_lpvUnswappedDriverReserved,
            lpDDRAWReserved2: f_lpDDRAWReserved2,
            dwDDRAWReserved1: f_dwDDRAWReserved1,
            dwDDRAWReserved2: f_dwDDRAWReserved2,
            fpAliasOfVidMem: f_fpAliasOfVidMem,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 76);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pPageTable, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.cPages, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwSavedDCContext, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.fpAliasedVidMem, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwHELReserved, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.cPageUnlocks, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.hKernelSurface, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwKernelRefCnt, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpColorInfo, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.fpNTAlias, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwContentsStamp, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.lpvUnswappedDriverReserved, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.lpDDRAWReserved2, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwDDRAWReserved1, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwDDRAWReserved2, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.fpAliasOfVidMem, &mut into[72..72 + 4]);
    }
    fn size() -> usize {
        76
    }
}
pub struct DDRAWI_DDRAWSURFACE_GBL_MORE_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_GBL_MORE_0 {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_GBL_MORE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_GBL_MORE_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_GBL_MORE_0 {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_GBL_MORE_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWSURFACE_INT {
    pub lpVtbl: MutPtr<::core::ffi::c_void>,
    pub lpLcl: MutPtr<DDRAWI_DDRAWSURFACE_LCL>,
    pub lpLink: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
    pub dwIntRefCnt: u32,
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_INT {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_INT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDRAWSURFACE_INT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDRAWSURFACE_INT")
            .field("lpVtbl", &self.lpVtbl)
            .field("lpLcl", &self.lpLcl)
            .field("lpLink", &self.lpLink)
            .field("dwIntRefCnt", &self.dwIntRefCnt)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_INT {
    fn eq(&self, other: &Self) -> bool {
        self.lpVtbl == other.lpVtbl
            && self.lpLcl == other.lpLcl
            && self.lpLink == other.lpLink
            && self.dwIntRefCnt == other.dwIntRefCnt
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_INT {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_INT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpVtbl = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpLcl =
            <MutPtr<DDRAWI_DDRAWSURFACE_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpLink =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwIntRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpVtbl: f_lpVtbl,
            lpLcl: f_lpLcl,
            lpLink: f_lpLink,
            dwIntRefCnt: f_dwIntRefCnt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpVtbl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwIntRefCnt, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDRAWI_DDRAWSURFACE_LCL {
    pub lpSurfMore: MutPtr<DDRAWI_DDRAWSURFACE_MORE>,
    pub lpGbl: MutPtr<DDRAWI_DDRAWSURFACE_GBL>,
    pub hDDSurface: PtrRepr,
    pub lpAttachList: MutPtr<ATTACHLIST>,
    pub lpAttachListFrom: MutPtr<ATTACHLIST>,
    pub dwLocalRefCnt: u32,
    pub dwProcessId: u32,
    pub dwFlags: u32,
    pub ddsCaps: DDSCAPS,
    pub Anonymous1: DDRAWI_DDRAWSURFACE_LCL_0,
    pub Anonymous2: DDRAWI_DDRAWSURFACE_LCL_1,
    pub dwModeCreatedIn: u32,
    pub dwBackBufferCount: u32,
    pub ddckCKDestBlt: DDCOLORKEY,
    pub ddckCKSrcBlt: DDCOLORKEY,
    pub hDC: PtrRepr,
    pub dwReserved1: PtrRepr,
    pub ddckCKSrcOverlay: DDCOLORKEY,
    pub ddckCKDestOverlay: DDCOLORKEY,
    pub lpSurfaceOverlaying: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
    pub dbnOverlayNode: DBLNODE,
    pub rcOverlaySrc: super::super::Foundation::RECT,
    pub rcOverlayDest: super::super::Foundation::RECT,
    pub dwClrXparent: u32,
    pub dwAlpha: u32,
    pub lOverlayX: i32,
    pub lOverlayY: i32,
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_LCL {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_LCL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_LCL {
    fn eq(&self, other: &Self) -> bool {
        self.lpSurfMore == other.lpSurfMore
            && self.lpGbl == other.lpGbl
            && self.hDDSurface == other.hDDSurface
            && self.lpAttachList == other.lpAttachList
            && self.lpAttachListFrom == other.lpAttachListFrom
            && self.dwLocalRefCnt == other.dwLocalRefCnt
            && self.dwProcessId == other.dwProcessId
            && self.dwFlags == other.dwFlags
            && self.ddsCaps == other.ddsCaps
            && self.Anonymous1 == other.Anonymous1
            && self.Anonymous2 == other.Anonymous2
            && self.dwModeCreatedIn == other.dwModeCreatedIn
            && self.dwBackBufferCount == other.dwBackBufferCount
            && self.ddckCKDestBlt == other.ddckCKDestBlt
            && self.ddckCKSrcBlt == other.ddckCKSrcBlt
            && self.hDC == other.hDC
            && self.dwReserved1 == other.dwReserved1
            && self.ddckCKSrcOverlay == other.ddckCKSrcOverlay
            && self.ddckCKDestOverlay == other.ddckCKDestOverlay
            && self.lpSurfaceOverlaying == other.lpSurfaceOverlaying
            && self.dbnOverlayNode == other.dbnOverlayNode
            && self.rcOverlaySrc == other.rcOverlaySrc
            && self.rcOverlayDest == other.rcOverlayDest
            && self.dwClrXparent == other.dwClrXparent
            && self.dwAlpha == other.dwAlpha
            && self.lOverlayX == other.lOverlayX
            && self.lOverlayY == other.lOverlayY
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_LCL {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_LCL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 160);
        let f_lpSurfMore =
            <MutPtr<DDRAWI_DDRAWSURFACE_MORE> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGbl =
            <MutPtr<DDRAWI_DDRAWSURFACE_GBL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hDDSurface = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpAttachList = <MutPtr<ATTACHLIST> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpAttachListFrom =
            <MutPtr<ATTACHLIST> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwLocalRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwProcessId = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_Anonymous1 =
            <DDRAWI_DDRAWSURFACE_LCL_0 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_Anonymous2 =
            <DDRAWI_DDRAWSURFACE_LCL_1 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwModeCreatedIn = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwBackBufferCount = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_ddckCKDestBlt = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[52..52 + 8]);
        let f_ddckCKSrcBlt = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[60..60 + 8]);
        let f_hDC = <PtrRepr as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_ddckCKSrcOverlay = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[76..76 + 8]);
        let f_ddckCKDestOverlay = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[84..84 + 8]);
        let f_lpSurfaceOverlaying =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_dbnOverlayNode = <DBLNODE as FromIntoMemory>::from_bytes(&from[96..96 + 16]);
        let f_rcOverlaySrc =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[112..112 + 16]);
        let f_rcOverlayDest =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[128..128 + 16]);
        let f_dwClrXparent = <u32 as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwAlpha = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_lOverlayX = <i32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_lOverlayY = <i32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        Self {
            lpSurfMore: f_lpSurfMore,
            lpGbl: f_lpGbl,
            hDDSurface: f_hDDSurface,
            lpAttachList: f_lpAttachList,
            lpAttachListFrom: f_lpAttachListFrom,
            dwLocalRefCnt: f_dwLocalRefCnt,
            dwProcessId: f_dwProcessId,
            dwFlags: f_dwFlags,
            ddsCaps: f_ddsCaps,
            Anonymous1: f_Anonymous1,
            Anonymous2: f_Anonymous2,
            dwModeCreatedIn: f_dwModeCreatedIn,
            dwBackBufferCount: f_dwBackBufferCount,
            ddckCKDestBlt: f_ddckCKDestBlt,
            ddckCKSrcBlt: f_ddckCKSrcBlt,
            hDC: f_hDC,
            dwReserved1: f_dwReserved1,
            ddckCKSrcOverlay: f_ddckCKSrcOverlay,
            ddckCKDestOverlay: f_ddckCKDestOverlay,
            lpSurfaceOverlaying: f_lpSurfaceOverlaying,
            dbnOverlayNode: f_dbnOverlayNode,
            rcOverlaySrc: f_rcOverlaySrc,
            rcOverlayDest: f_rcOverlayDest,
            dwClrXparent: f_dwClrXparent,
            dwAlpha: f_dwAlpha,
            lOverlayX: f_lOverlayX,
            lOverlayY: f_lOverlayY,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 160);
        FromIntoMemory::into_bytes(self.lpSurfMore, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGbl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hDDSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpAttachList, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpAttachListFrom, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwLocalRefCnt, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessId, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwModeCreatedIn, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwBackBufferCount, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.ddckCKDestBlt, &mut into[52..52 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKSrcBlt, &mut into[60..60 + 8]);
        FromIntoMemory::into_bytes(self.hDC, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.ddckCKSrcOverlay, &mut into[76..76 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKDestOverlay, &mut into[84..84 + 8]);
        FromIntoMemory::into_bytes(self.lpSurfaceOverlaying, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.dbnOverlayNode, &mut into[96..96 + 16]);
        FromIntoMemory::into_bytes(self.rcOverlaySrc, &mut into[112..112 + 16]);
        FromIntoMemory::into_bytes(self.rcOverlayDest, &mut into[128..128 + 16]);
        FromIntoMemory::into_bytes(self.dwClrXparent, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwAlpha, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.lOverlayX, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.lOverlayY, &mut into[156..156 + 4]);
    }
    fn size() -> usize {
        160
    }
}
pub struct DDRAWI_DDRAWSURFACE_LCL_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_LCL_0 {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_LCL_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_LCL_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_LCL_0 {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_LCL_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWSURFACE_LCL_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_LCL_1 {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_LCL_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_LCL_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_LCL_1 {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_LCL_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDRAWI_DDRAWSURFACE_MORE {
    pub dwSize: u32,
    pub lpIUnknowns: MutPtr<IUNKNOWN_LIST>,
    pub lpDD_lcl: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub dwPageLockCount: u32,
    pub dwBytesAllocated: u32,
    pub lpDD_int: MutPtr<DDRAWI_DIRECTDRAW_INT>,
    pub dwMipMapCount: u32,
    pub lpDDIClipper: MutPtr<DDRAWI_DDRAWCLIPPER_INT>,
    pub lpHeapAliasInfo: MutPtr<HEAPALIASINFO>,
    pub dwOverlayFlags: u32,
    pub rgjunc: MutPtr<::core::ffi::c_void>,
    pub lpVideoPort: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub lpddOverlayFX: MutPtr<DDOVERLAYFX>,
    pub ddsCapsEx: DDSCAPSEX,
    pub dwTextureStage: u32,
    pub lpDDRAWReserved: MutPtr<::core::ffi::c_void>,
    pub lpDDRAWReserved2: MutPtr<::core::ffi::c_void>,
    pub lpDDrawReserved3: MutPtr<::core::ffi::c_void>,
    pub dwDDrawReserved4: u32,
    pub lpDDrawReserved5: MutPtr<::core::ffi::c_void>,
    pub lpGammaRamp: MutPtr<u32>,
    pub lpOriginalGammaRamp: MutPtr<u32>,
    pub lpDDrawReserved6: MutPtr<::core::ffi::c_void>,
    pub dwSurfaceHandle: u32,
    pub qwDDrawReserved8: [u32; 2],
    pub lpDDrawReserved9: MutPtr<::core::ffi::c_void>,
    pub cSurfaces: u32,
    pub pCreatedDDSurfaceDesc2: MutPtr<DDSURFACEDESC2>,
    pub slist: MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_LCL>>,
    pub dwFVF: u32,
    pub lpVB: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DDRAWI_DDRAWSURFACE_MORE {}
impl ::core::clone::Clone for DDRAWI_DDRAWSURFACE_MORE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDRAWSURFACE_MORE {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.lpIUnknowns == other.lpIUnknowns
            && self.lpDD_lcl == other.lpDD_lcl
            && self.dwPageLockCount == other.dwPageLockCount
            && self.dwBytesAllocated == other.dwBytesAllocated
            && self.lpDD_int == other.lpDD_int
            && self.dwMipMapCount == other.dwMipMapCount
            && self.lpDDIClipper == other.lpDDIClipper
            && self.lpHeapAliasInfo == other.lpHeapAliasInfo
            && self.dwOverlayFlags == other.dwOverlayFlags
            && self.rgjunc == other.rgjunc
            && self.lpVideoPort == other.lpVideoPort
            && self.lpddOverlayFX == other.lpddOverlayFX
            && self.ddsCapsEx == other.ddsCapsEx
            && self.dwTextureStage == other.dwTextureStage
            && self.lpDDRAWReserved == other.lpDDRAWReserved
            && self.lpDDRAWReserved2 == other.lpDDRAWReserved2
            && self.lpDDrawReserved3 == other.lpDDrawReserved3
            && self.dwDDrawReserved4 == other.dwDDrawReserved4
            && self.lpDDrawReserved5 == other.lpDDrawReserved5
            && self.lpGammaRamp == other.lpGammaRamp
            && self.lpOriginalGammaRamp == other.lpOriginalGammaRamp
            && self.lpDDrawReserved6 == other.lpDDrawReserved6
            && self.dwSurfaceHandle == other.dwSurfaceHandle
            && self.qwDDrawReserved8 == other.qwDDrawReserved8
            && self.lpDDrawReserved9 == other.lpDDrawReserved9
            && self.cSurfaces == other.cSurfaces
            && self.pCreatedDDSurfaceDesc2 == other.pCreatedDDSurfaceDesc2
            && self.slist == other.slist
            && self.dwFVF == other.dwFVF
            && self.lpVB == other.lpVB
    }
}
impl ::core::cmp::Eq for DDRAWI_DDRAWSURFACE_MORE {}
impl FromIntoMemory for DDRAWI_DDRAWSURFACE_MORE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 136);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpIUnknowns = <MutPtr<IUNKNOWN_LIST> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDD_lcl =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwPageLockCount = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwBytesAllocated = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpDD_int =
            <MutPtr<DDRAWI_DIRECTDRAW_INT> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwMipMapCount = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpDDIClipper =
            <MutPtr<DDRAWI_DDRAWCLIPPER_INT> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_lpHeapAliasInfo =
            <MutPtr<HEAPALIASINFO> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwOverlayFlags = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_rgjunc =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpVideoPort =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_lpddOverlayFX =
            <MutPtr<DDOVERLAYFX> as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_ddsCapsEx = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[52..52 + 12]);
        let f_dwTextureStage = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_lpDDRAWReserved =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_lpDDRAWReserved2 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_lpDDrawReserved3 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwDDrawReserved4 = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_lpDDrawReserved5 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_lpGammaRamp = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_lpOriginalGammaRamp = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_lpDDrawReserved6 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_dwSurfaceHandle = <u32 as FromIntoMemory>::from_bytes(&from[100..100 + 4]);
        let f_qwDDrawReserved8 = <[u32; 2] as FromIntoMemory>::from_bytes(&from[104..104 + 8]);
        let f_lpDDrawReserved9 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[112..112 + 4]);
        let f_cSurfaces = <u32 as FromIntoMemory>::from_bytes(&from[116..116 + 4]);
        let f_pCreatedDDSurfaceDesc2 =
            <MutPtr<DDSURFACEDESC2> as FromIntoMemory>::from_bytes(&from[120..120 + 4]);
        let f_slist = <MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_LCL>> as FromIntoMemory>::from_bytes(
            &from[124..124 + 4],
        );
        let f_dwFVF = <u32 as FromIntoMemory>::from_bytes(&from[128..128 + 4]);
        let f_lpVB =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[132..132 + 4]);
        Self {
            dwSize: f_dwSize,
            lpIUnknowns: f_lpIUnknowns,
            lpDD_lcl: f_lpDD_lcl,
            dwPageLockCount: f_dwPageLockCount,
            dwBytesAllocated: f_dwBytesAllocated,
            lpDD_int: f_lpDD_int,
            dwMipMapCount: f_dwMipMapCount,
            lpDDIClipper: f_lpDDIClipper,
            lpHeapAliasInfo: f_lpHeapAliasInfo,
            dwOverlayFlags: f_dwOverlayFlags,
            rgjunc: f_rgjunc,
            lpVideoPort: f_lpVideoPort,
            lpddOverlayFX: f_lpddOverlayFX,
            ddsCapsEx: f_ddsCapsEx,
            dwTextureStage: f_dwTextureStage,
            lpDDRAWReserved: f_lpDDRAWReserved,
            lpDDRAWReserved2: f_lpDDRAWReserved2,
            lpDDrawReserved3: f_lpDDrawReserved3,
            dwDDrawReserved4: f_dwDDrawReserved4,
            lpDDrawReserved5: f_lpDDrawReserved5,
            lpGammaRamp: f_lpGammaRamp,
            lpOriginalGammaRamp: f_lpOriginalGammaRamp,
            lpDDrawReserved6: f_lpDDrawReserved6,
            dwSurfaceHandle: f_dwSurfaceHandle,
            qwDDrawReserved8: f_qwDDrawReserved8,
            lpDDrawReserved9: f_lpDDrawReserved9,
            cSurfaces: f_cSurfaces,
            pCreatedDDSurfaceDesc2: f_pCreatedDDSurfaceDesc2,
            slist: f_slist,
            dwFVF: f_dwFVF,
            lpVB: f_lpVB,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 136);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpIUnknowns, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDD_lcl, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwPageLockCount, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwBytesAllocated, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpDD_int, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwMipMapCount, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpDDIClipper, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpHeapAliasInfo, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayFlags, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.rgjunc, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.lpddOverlayFX, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsEx, &mut into[52..52 + 12]);
        FromIntoMemory::into_bytes(self.dwTextureStage, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.lpDDRAWReserved, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.lpDDRAWReserved2, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.lpDDrawReserved3, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwDDrawReserved4, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.lpDDrawReserved5, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.lpGammaRamp, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.lpOriginalGammaRamp, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.lpDDrawReserved6, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.dwSurfaceHandle, &mut into[100..100 + 4]);
        FromIntoMemory::into_bytes(self.qwDDrawReserved8, &mut into[104..104 + 8]);
        FromIntoMemory::into_bytes(self.lpDDrawReserved9, &mut into[112..112 + 4]);
        FromIntoMemory::into_bytes(self.cSurfaces, &mut into[116..116 + 4]);
        FromIntoMemory::into_bytes(self.pCreatedDDSurfaceDesc2, &mut into[120..120 + 4]);
        FromIntoMemory::into_bytes(self.slist, &mut into[124..124 + 4]);
        FromIntoMemory::into_bytes(self.dwFVF, &mut into[128..128 + 4]);
        FromIntoMemory::into_bytes(self.lpVB, &mut into[132..132 + 4]);
    }
    fn size() -> usize {
        136
    }
}
pub struct DDRAWI_DDVIDEOPORT_INT {
    pub lpVtbl: MutPtr<::core::ffi::c_void>,
    pub lpLcl: MutPtr<DDRAWI_DDVIDEOPORT_LCL>,
    pub lpLink: MutPtr<DDRAWI_DDVIDEOPORT_INT>,
    pub dwIntRefCnt: u32,
    pub dwFlags: u32,
}
impl ::core::marker::Copy for DDRAWI_DDVIDEOPORT_INT {}
impl ::core::clone::Clone for DDRAWI_DDVIDEOPORT_INT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDVIDEOPORT_INT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDVIDEOPORT_INT")
            .field("lpVtbl", &self.lpVtbl)
            .field("lpLcl", &self.lpLcl)
            .field("lpLink", &self.lpLink)
            .field("dwIntRefCnt", &self.dwIntRefCnt)
            .field("dwFlags", &self.dwFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDVIDEOPORT_INT {
    fn eq(&self, other: &Self) -> bool {
        self.lpVtbl == other.lpVtbl
            && self.lpLcl == other.lpLcl
            && self.lpLink == other.lpLink
            && self.dwIntRefCnt == other.dwIntRefCnt
            && self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for DDRAWI_DDVIDEOPORT_INT {}
impl FromIntoMemory for DDRAWI_DDVIDEOPORT_INT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpVtbl = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpLcl =
            <MutPtr<DDRAWI_DDVIDEOPORT_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpLink =
            <MutPtr<DDRAWI_DDVIDEOPORT_INT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwIntRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpVtbl: f_lpVtbl,
            lpLcl: f_lpLcl,
            lpLink: f_lpLink,
            dwIntRefCnt: f_dwIntRefCnt,
            dwFlags: f_dwFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpVtbl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwIntRefCnt, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DDRAWI_DDVIDEOPORT_LCL {
    pub lpDD: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub ddvpDesc: DDVIDEOPORTDESC,
    pub ddvpInfo: DDVIDEOPORTINFO,
    pub lpSurface: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
    pub lpVBISurface: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
    pub lpFlipInts: MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_INT>>,
    pub dwNumAutoflip: u32,
    pub dwProcessID: u32,
    pub dwStateFlags: u32,
    pub dwFlags: u32,
    pub dwRefCnt: u32,
    pub fpLastFlip: PtrRepr,
    pub dwReserved1: PtrRepr,
    pub dwReserved2: PtrRepr,
    pub hDDVideoPort: super::super::Foundation::HANDLE,
    pub dwNumVBIAutoflip: u32,
    pub lpVBIDesc: MutPtr<DDVIDEOPORTDESC>,
    pub lpVideoDesc: MutPtr<DDVIDEOPORTDESC>,
    pub lpVBIInfo: MutPtr<DDVIDEOPORTINFO>,
    pub lpVideoInfo: MutPtr<DDVIDEOPORTINFO>,
    pub dwVBIProcessID: u32,
    pub lpVPNotify: MutPtr<DDRAWI_DDVIDEOPORT_INT>,
}
impl ::core::marker::Copy for DDRAWI_DDVIDEOPORT_LCL {}
impl ::core::clone::Clone for DDRAWI_DDVIDEOPORT_LCL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DDVIDEOPORT_LCL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DDVIDEOPORT_LCL")
            .field("lpDD", &self.lpDD)
            .field("ddvpDesc", &self.ddvpDesc)
            .field("ddvpInfo", &self.ddvpInfo)
            .field("lpSurface", &self.lpSurface)
            .field("lpVBISurface", &self.lpVBISurface)
            .field("lpFlipInts", &self.lpFlipInts)
            .field("dwNumAutoflip", &self.dwNumAutoflip)
            .field("dwProcessID", &self.dwProcessID)
            .field("dwStateFlags", &self.dwStateFlags)
            .field("dwFlags", &self.dwFlags)
            .field("dwRefCnt", &self.dwRefCnt)
            .field("fpLastFlip", &self.fpLastFlip)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("hDDVideoPort", &self.hDDVideoPort)
            .field("dwNumVBIAutoflip", &self.dwNumVBIAutoflip)
            .field("lpVBIDesc", &self.lpVBIDesc)
            .field("lpVideoDesc", &self.lpVideoDesc)
            .field("lpVBIInfo", &self.lpVBIInfo)
            .field("lpVideoInfo", &self.lpVideoInfo)
            .field("dwVBIProcessID", &self.dwVBIProcessID)
            .field("lpVPNotify", &self.lpVPNotify)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DDVIDEOPORT_LCL {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.ddvpDesc == other.ddvpDesc
            && self.ddvpInfo == other.ddvpInfo
            && self.lpSurface == other.lpSurface
            && self.lpVBISurface == other.lpVBISurface
            && self.lpFlipInts == other.lpFlipInts
            && self.dwNumAutoflip == other.dwNumAutoflip
            && self.dwProcessID == other.dwProcessID
            && self.dwStateFlags == other.dwStateFlags
            && self.dwFlags == other.dwFlags
            && self.dwRefCnt == other.dwRefCnt
            && self.fpLastFlip == other.fpLastFlip
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.hDDVideoPort == other.hDDVideoPort
            && self.dwNumVBIAutoflip == other.dwNumVBIAutoflip
            && self.lpVBIDesc == other.lpVBIDesc
            && self.lpVideoDesc == other.lpVideoDesc
            && self.lpVBIInfo == other.lpVBIInfo
            && self.lpVideoInfo == other.lpVideoInfo
            && self.dwVBIProcessID == other.dwVBIProcessID
            && self.lpVPNotify == other.lpVPNotify
    }
}
impl ::core::cmp::Eq for DDRAWI_DDVIDEOPORT_LCL {}
impl FromIntoMemory for DDRAWI_DDVIDEOPORT_LCL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 216);
        let f_lpDD = <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ddvpDesc = <DDVIDEOPORTDESC as FromIntoMemory>::from_bytes(&from[4..4 + 72]);
        let f_ddvpInfo = <DDVIDEOPORTINFO as FromIntoMemory>::from_bytes(&from[76..76 + 64]);
        let f_lpSurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_lpVBISurface =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_lpFlipInts =
            <MutPtr<ConstPtr<DDRAWI_DDRAWSURFACE_INT>> as FromIntoMemory>::from_bytes(
                &from[148..148 + 4],
            );
        let f_dwNumAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwProcessID = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwStateFlags = <u32 as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[168..168 + 4]);
        let f_fpLastFlip = <PtrRepr as FromIntoMemory>::from_bytes(&from[172..172 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[176..176 + 4]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[180..180 + 4]);
        let f_hDDVideoPort =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[184..184 + 4]);
        let f_dwNumVBIAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[188..188 + 4]);
        let f_lpVBIDesc =
            <MutPtr<DDVIDEOPORTDESC> as FromIntoMemory>::from_bytes(&from[192..192 + 4]);
        let f_lpVideoDesc =
            <MutPtr<DDVIDEOPORTDESC> as FromIntoMemory>::from_bytes(&from[196..196 + 4]);
        let f_lpVBIInfo =
            <MutPtr<DDVIDEOPORTINFO> as FromIntoMemory>::from_bytes(&from[200..200 + 4]);
        let f_lpVideoInfo =
            <MutPtr<DDVIDEOPORTINFO> as FromIntoMemory>::from_bytes(&from[204..204 + 4]);
        let f_dwVBIProcessID = <u32 as FromIntoMemory>::from_bytes(&from[208..208 + 4]);
        let f_lpVPNotify =
            <MutPtr<DDRAWI_DDVIDEOPORT_INT> as FromIntoMemory>::from_bytes(&from[212..212 + 4]);
        Self {
            lpDD: f_lpDD,
            ddvpDesc: f_ddvpDesc,
            ddvpInfo: f_ddvpInfo,
            lpSurface: f_lpSurface,
            lpVBISurface: f_lpVBISurface,
            lpFlipInts: f_lpFlipInts,
            dwNumAutoflip: f_dwNumAutoflip,
            dwProcessID: f_dwProcessID,
            dwStateFlags: f_dwStateFlags,
            dwFlags: f_dwFlags,
            dwRefCnt: f_dwRefCnt,
            fpLastFlip: f_fpLastFlip,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            hDDVideoPort: f_hDDVideoPort,
            dwNumVBIAutoflip: f_dwNumVBIAutoflip,
            lpVBIDesc: f_lpVBIDesc,
            lpVideoDesc: f_lpVideoDesc,
            lpVBIInfo: f_lpVBIInfo,
            lpVideoInfo: f_lpVideoInfo,
            dwVBIProcessID: f_dwVBIProcessID,
            lpVPNotify: f_lpVPNotify,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 216);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ddvpDesc, &mut into[4..4 + 72]);
        FromIntoMemory::into_bytes(self.ddvpInfo, &mut into[76..76 + 64]);
        FromIntoMemory::into_bytes(self.lpSurface, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.lpVBISurface, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.lpFlipInts, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwNumAutoflip, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessID, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwStateFlags, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[164..164 + 4]);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[168..168 + 4]);
        FromIntoMemory::into_bytes(self.fpLastFlip, &mut into[172..172 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[176..176 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[180..180 + 4]);
        FromIntoMemory::into_bytes(self.hDDVideoPort, &mut into[184..184 + 4]);
        FromIntoMemory::into_bytes(self.dwNumVBIAutoflip, &mut into[188..188 + 4]);
        FromIntoMemory::into_bytes(self.lpVBIDesc, &mut into[192..192 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoDesc, &mut into[196..196 + 4]);
        FromIntoMemory::into_bytes(self.lpVBIInfo, &mut into[200..200 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoInfo, &mut into[204..204 + 4]);
        FromIntoMemory::into_bytes(self.dwVBIProcessID, &mut into[208..208 + 4]);
        FromIntoMemory::into_bytes(self.lpVPNotify, &mut into[212..212 + 4]);
    }
    fn size() -> usize {
        216
    }
}
pub struct DDRAWI_DIRECTDRAW_GBL {
    pub dwRefCnt: u32,
    pub dwFlags: u32,
    pub fpPrimaryOrig: PtrRepr,
    pub ddCaps: DDCORECAPS,
    pub dwInternal1: u32,
    pub dwUnused1: [u32; 9],
    pub lpDDCBtmp: MutPtr<DDHAL_CALLBACKS>,
    pub dsList: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
    pub palList: MutPtr<DDRAWI_DDRAWPALETTE_INT>,
    pub clipperList: MutPtr<DDRAWI_DDRAWCLIPPER_INT>,
    pub lp16DD: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwMaxOverlays: u32,
    pub dwCurrOverlays: u32,
    pub dwMonitorFrequency: u32,
    pub ddHELCaps: DDCORECAPS,
    pub dwUnused2: [u32; 50],
    pub ddckCKDestOverlay: DDCOLORKEY,
    pub ddckCKSrcOverlay: DDCOLORKEY,
    pub vmiData: VIDMEMINFO,
    pub lpDriverHandle: MutPtr<::core::ffi::c_void>,
    pub lpExclusiveOwner: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub dwModeIndex: u32,
    pub dwModeIndexOrig: u32,
    pub dwNumFourCC: u32,
    pub lpdwFourCC: MutPtr<u32>,
    pub dwNumModes: u32,
    pub lpModeInfo: MutPtr<DDHALMODEINFO>,
    pub plProcessList: PROCESS_LIST,
    pub dwSurfaceLockCount: u32,
    pub dwAliasedLockCnt: u32,
    pub dwReserved3: PtrRepr,
    pub hDD: PtrRepr,
    pub cObsolete: [super::super::Foundation::CHAR; 12],
    pub dwReserved1: u32,
    pub dwReserved2: u32,
    pub dbnOverlayRoot: DBLNODE,
    pub lpwPDeviceFlags: MutPtr<u16>,
    pub dwPDevice: u32,
    pub dwWin16LockCnt: u32,
    pub dwUnused3: u32,
    pub hInstance: u32,
    pub dwEvent16: u32,
    pub dwSaveNumModes: u32,
    pub lpD3DGlobalDriverData: PtrRepr,
    pub lpD3DHALCallbacks: PtrRepr,
    pub ddBothCaps: DDCORECAPS,
    pub lpDDVideoPortCaps: MutPtr<DDVIDEOPORTCAPS>,
    pub dvpList: MutPtr<DDRAWI_DDVIDEOPORT_INT>,
    pub lpD3DHALCallbacks2: PtrRepr,
    pub rectDevice: super::super::Foundation::RECT,
    pub cMonitors: u32,
    pub gpbmiSrc: MutPtr<::core::ffi::c_void>,
    pub gpbmiDest: MutPtr<::core::ffi::c_void>,
    pub phaiHeapAliases: MutPtr<HEAPALIASINFO>,
    pub hKernelHandle: PtrRepr,
    pub pfnNotifyProc: PtrRepr,
    pub lpDDKernelCaps: MutPtr<DDKERNELCAPS>,
    pub lpddNLVCaps: MutPtr<DDNONLOCALVIDMEMCAPS>,
    pub lpddNLVHELCaps: MutPtr<DDNONLOCALVIDMEMCAPS>,
    pub lpddNLVBothCaps: MutPtr<DDNONLOCALVIDMEMCAPS>,
    pub lpD3DExtendedCaps: PtrRepr,
    pub dwDOSBoxEvent: u32,
    pub rectDesktop: super::super::Foundation::RECT,
    pub cDriverName: [super::super::Foundation::CHAR; 32],
    pub lpD3DHALCallbacks3: PtrRepr,
    pub dwNumZPixelFormats: u32,
    pub lpZPixelFormats: MutPtr<DDPIXELFORMAT>,
    pub mcList: MutPtr<DDRAWI_DDMOTIONCOMP_INT>,
    pub hDDVxd: u32,
    pub ddsCapsMore: DDSCAPSEX,
}
impl ::core::marker::Copy for DDRAWI_DIRECTDRAW_GBL {}
impl ::core::clone::Clone for DDRAWI_DIRECTDRAW_GBL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DIRECTDRAW_GBL {
    fn eq(&self, other: &Self) -> bool {
        self.dwRefCnt == other.dwRefCnt
            && self.dwFlags == other.dwFlags
            && self.fpPrimaryOrig == other.fpPrimaryOrig
            && self.ddCaps == other.ddCaps
            && self.dwInternal1 == other.dwInternal1
            && self.dwUnused1 == other.dwUnused1
            && self.lpDDCBtmp == other.lpDDCBtmp
            && self.dsList == other.dsList
            && self.palList == other.palList
            && self.clipperList == other.clipperList
            && self.lp16DD == other.lp16DD
            && self.dwMaxOverlays == other.dwMaxOverlays
            && self.dwCurrOverlays == other.dwCurrOverlays
            && self.dwMonitorFrequency == other.dwMonitorFrequency
            && self.ddHELCaps == other.ddHELCaps
            && self.dwUnused2 == other.dwUnused2
            && self.ddckCKDestOverlay == other.ddckCKDestOverlay
            && self.ddckCKSrcOverlay == other.ddckCKSrcOverlay
            && self.vmiData == other.vmiData
            && self.lpDriverHandle == other.lpDriverHandle
            && self.lpExclusiveOwner == other.lpExclusiveOwner
            && self.dwModeIndex == other.dwModeIndex
            && self.dwModeIndexOrig == other.dwModeIndexOrig
            && self.dwNumFourCC == other.dwNumFourCC
            && self.lpdwFourCC == other.lpdwFourCC
            && self.dwNumModes == other.dwNumModes
            && self.lpModeInfo == other.lpModeInfo
            && self.plProcessList == other.plProcessList
            && self.dwSurfaceLockCount == other.dwSurfaceLockCount
            && self.dwAliasedLockCnt == other.dwAliasedLockCnt
            && self.dwReserved3 == other.dwReserved3
            && self.hDD == other.hDD
            && self.cObsolete == other.cObsolete
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dbnOverlayRoot == other.dbnOverlayRoot
            && self.lpwPDeviceFlags == other.lpwPDeviceFlags
            && self.dwPDevice == other.dwPDevice
            && self.dwWin16LockCnt == other.dwWin16LockCnt
            && self.dwUnused3 == other.dwUnused3
            && self.hInstance == other.hInstance
            && self.dwEvent16 == other.dwEvent16
            && self.dwSaveNumModes == other.dwSaveNumModes
            && self.lpD3DGlobalDriverData == other.lpD3DGlobalDriverData
            && self.lpD3DHALCallbacks == other.lpD3DHALCallbacks
            && self.ddBothCaps == other.ddBothCaps
            && self.lpDDVideoPortCaps == other.lpDDVideoPortCaps
            && self.dvpList == other.dvpList
            && self.lpD3DHALCallbacks2 == other.lpD3DHALCallbacks2
            && self.rectDevice == other.rectDevice
            && self.cMonitors == other.cMonitors
            && self.gpbmiSrc == other.gpbmiSrc
            && self.gpbmiDest == other.gpbmiDest
            && self.phaiHeapAliases == other.phaiHeapAliases
            && self.hKernelHandle == other.hKernelHandle
            && self.pfnNotifyProc == other.pfnNotifyProc
            && self.lpDDKernelCaps == other.lpDDKernelCaps
            && self.lpddNLVCaps == other.lpddNLVCaps
            && self.lpddNLVHELCaps == other.lpddNLVHELCaps
            && self.lpddNLVBothCaps == other.lpddNLVBothCaps
            && self.lpD3DExtendedCaps == other.lpD3DExtendedCaps
            && self.dwDOSBoxEvent == other.dwDOSBoxEvent
            && self.rectDesktop == other.rectDesktop
            && self.cDriverName == other.cDriverName
            && self.lpD3DHALCallbacks3 == other.lpD3DHALCallbacks3
            && self.dwNumZPixelFormats == other.dwNumZPixelFormats
            && self.lpZPixelFormats == other.lpZPixelFormats
            && self.mcList == other.mcList
            && self.hDDVxd == other.hDDVxd
            && self.ddsCapsMore == other.ddsCapsMore
    }
}
impl ::core::cmp::Eq for DDRAWI_DIRECTDRAW_GBL {}
impl FromIntoMemory for DDRAWI_DIRECTDRAW_GBL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 1624);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_fpPrimaryOrig = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddCaps = <DDCORECAPS as FromIntoMemory>::from_bytes(&from[12..12 + 316]);
        let f_dwInternal1 = <u32 as FromIntoMemory>::from_bytes(&from[328..328 + 4]);
        let f_dwUnused1 = <[u32; 9] as FromIntoMemory>::from_bytes(&from[332..332 + 36]);
        let f_lpDDCBtmp =
            <MutPtr<DDHAL_CALLBACKS> as FromIntoMemory>::from_bytes(&from[368..368 + 4]);
        let f_dsList =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[372..372 + 4]);
        let f_palList =
            <MutPtr<DDRAWI_DDRAWPALETTE_INT> as FromIntoMemory>::from_bytes(&from[376..376 + 4]);
        let f_clipperList =
            <MutPtr<DDRAWI_DDRAWCLIPPER_INT> as FromIntoMemory>::from_bytes(&from[380..380 + 4]);
        let f_lp16DD =
            <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[384..384 + 4]);
        let f_dwMaxOverlays = <u32 as FromIntoMemory>::from_bytes(&from[388..388 + 4]);
        let f_dwCurrOverlays = <u32 as FromIntoMemory>::from_bytes(&from[392..392 + 4]);
        let f_dwMonitorFrequency = <u32 as FromIntoMemory>::from_bytes(&from[396..396 + 4]);
        let f_ddHELCaps = <DDCORECAPS as FromIntoMemory>::from_bytes(&from[400..400 + 316]);
        let f_dwUnused2 = <[u32; 50] as FromIntoMemory>::from_bytes(&from[716..716 + 200]);
        let f_ddckCKDestOverlay = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[916..916 + 8]);
        let f_ddckCKSrcOverlay = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[924..924 + 8]);
        let f_vmiData = <VIDMEMINFO as FromIntoMemory>::from_bytes(&from[932..932 + 80]);
        let f_lpDriverHandle =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[1012..1012 + 4]);
        let f_lpExclusiveOwner =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[1016..1016 + 4]);
        let f_dwModeIndex = <u32 as FromIntoMemory>::from_bytes(&from[1020..1020 + 4]);
        let f_dwModeIndexOrig = <u32 as FromIntoMemory>::from_bytes(&from[1024..1024 + 4]);
        let f_dwNumFourCC = <u32 as FromIntoMemory>::from_bytes(&from[1028..1028 + 4]);
        let f_lpdwFourCC = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[1032..1032 + 4]);
        let f_dwNumModes = <u32 as FromIntoMemory>::from_bytes(&from[1036..1036 + 4]);
        let f_lpModeInfo =
            <MutPtr<DDHALMODEINFO> as FromIntoMemory>::from_bytes(&from[1040..1040 + 4]);
        let f_plProcessList = <PROCESS_LIST as FromIntoMemory>::from_bytes(&from[1044..1044 + 20]);
        let f_dwSurfaceLockCount = <u32 as FromIntoMemory>::from_bytes(&from[1064..1064 + 4]);
        let f_dwAliasedLockCnt = <u32 as FromIntoMemory>::from_bytes(&from[1068..1068 + 4]);
        let f_dwReserved3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[1072..1072 + 4]);
        let f_hDD = <PtrRepr as FromIntoMemory>::from_bytes(&from[1076..1076 + 4]);
        let f_cObsolete = <[super::super::Foundation::CHAR; 12] as FromIntoMemory>::from_bytes(
            &from[1080..1080 + 12],
        );
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[1092..1092 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[1096..1096 + 4]);
        let f_dbnOverlayRoot = <DBLNODE as FromIntoMemory>::from_bytes(&from[1100..1100 + 16]);
        let f_lpwPDeviceFlags = <MutPtr<u16> as FromIntoMemory>::from_bytes(&from[1116..1116 + 4]);
        let f_dwPDevice = <u32 as FromIntoMemory>::from_bytes(&from[1120..1120 + 4]);
        let f_dwWin16LockCnt = <u32 as FromIntoMemory>::from_bytes(&from[1124..1124 + 4]);
        let f_dwUnused3 = <u32 as FromIntoMemory>::from_bytes(&from[1128..1128 + 4]);
        let f_hInstance = <u32 as FromIntoMemory>::from_bytes(&from[1132..1132 + 4]);
        let f_dwEvent16 = <u32 as FromIntoMemory>::from_bytes(&from[1136..1136 + 4]);
        let f_dwSaveNumModes = <u32 as FromIntoMemory>::from_bytes(&from[1140..1140 + 4]);
        let f_lpD3DGlobalDriverData =
            <PtrRepr as FromIntoMemory>::from_bytes(&from[1144..1144 + 4]);
        let f_lpD3DHALCallbacks = <PtrRepr as FromIntoMemory>::from_bytes(&from[1148..1148 + 4]);
        let f_ddBothCaps = <DDCORECAPS as FromIntoMemory>::from_bytes(&from[1152..1152 + 316]);
        let f_lpDDVideoPortCaps =
            <MutPtr<DDVIDEOPORTCAPS> as FromIntoMemory>::from_bytes(&from[1468..1468 + 4]);
        let f_dvpList =
            <MutPtr<DDRAWI_DDVIDEOPORT_INT> as FromIntoMemory>::from_bytes(&from[1472..1472 + 4]);
        let f_lpD3DHALCallbacks2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[1476..1476 + 4]);
        let f_rectDevice =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[1480..1480 + 16]);
        let f_cMonitors = <u32 as FromIntoMemory>::from_bytes(&from[1496..1496 + 4]);
        let f_gpbmiSrc =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[1500..1500 + 4]);
        let f_gpbmiDest =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[1504..1504 + 4]);
        let f_phaiHeapAliases =
            <MutPtr<HEAPALIASINFO> as FromIntoMemory>::from_bytes(&from[1508..1508 + 4]);
        let f_hKernelHandle = <PtrRepr as FromIntoMemory>::from_bytes(&from[1512..1512 + 4]);
        let f_pfnNotifyProc = <PtrRepr as FromIntoMemory>::from_bytes(&from[1516..1516 + 4]);
        let f_lpDDKernelCaps =
            <MutPtr<DDKERNELCAPS> as FromIntoMemory>::from_bytes(&from[1520..1520 + 4]);
        let f_lpddNLVCaps =
            <MutPtr<DDNONLOCALVIDMEMCAPS> as FromIntoMemory>::from_bytes(&from[1524..1524 + 4]);
        let f_lpddNLVHELCaps =
            <MutPtr<DDNONLOCALVIDMEMCAPS> as FromIntoMemory>::from_bytes(&from[1528..1528 + 4]);
        let f_lpddNLVBothCaps =
            <MutPtr<DDNONLOCALVIDMEMCAPS> as FromIntoMemory>::from_bytes(&from[1532..1532 + 4]);
        let f_lpD3DExtendedCaps = <PtrRepr as FromIntoMemory>::from_bytes(&from[1536..1536 + 4]);
        let f_dwDOSBoxEvent = <u32 as FromIntoMemory>::from_bytes(&from[1540..1540 + 4]);
        let f_rectDesktop =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[1544..1544 + 16]);
        let f_cDriverName = <[super::super::Foundation::CHAR; 32] as FromIntoMemory>::from_bytes(
            &from[1560..1560 + 32],
        );
        let f_lpD3DHALCallbacks3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[1592..1592 + 4]);
        let f_dwNumZPixelFormats = <u32 as FromIntoMemory>::from_bytes(&from[1596..1596 + 4]);
        let f_lpZPixelFormats =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[1600..1600 + 4]);
        let f_mcList =
            <MutPtr<DDRAWI_DDMOTIONCOMP_INT> as FromIntoMemory>::from_bytes(&from[1604..1604 + 4]);
        let f_hDDVxd = <u32 as FromIntoMemory>::from_bytes(&from[1608..1608 + 4]);
        let f_ddsCapsMore = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[1612..1612 + 12]);
        Self {
            dwRefCnt: f_dwRefCnt,
            dwFlags: f_dwFlags,
            fpPrimaryOrig: f_fpPrimaryOrig,
            ddCaps: f_ddCaps,
            dwInternal1: f_dwInternal1,
            dwUnused1: f_dwUnused1,
            lpDDCBtmp: f_lpDDCBtmp,
            dsList: f_dsList,
            palList: f_palList,
            clipperList: f_clipperList,
            lp16DD: f_lp16DD,
            dwMaxOverlays: f_dwMaxOverlays,
            dwCurrOverlays: f_dwCurrOverlays,
            dwMonitorFrequency: f_dwMonitorFrequency,
            ddHELCaps: f_ddHELCaps,
            dwUnused2: f_dwUnused2,
            ddckCKDestOverlay: f_ddckCKDestOverlay,
            ddckCKSrcOverlay: f_ddckCKSrcOverlay,
            vmiData: f_vmiData,
            lpDriverHandle: f_lpDriverHandle,
            lpExclusiveOwner: f_lpExclusiveOwner,
            dwModeIndex: f_dwModeIndex,
            dwModeIndexOrig: f_dwModeIndexOrig,
            dwNumFourCC: f_dwNumFourCC,
            lpdwFourCC: f_lpdwFourCC,
            dwNumModes: f_dwNumModes,
            lpModeInfo: f_lpModeInfo,
            plProcessList: f_plProcessList,
            dwSurfaceLockCount: f_dwSurfaceLockCount,
            dwAliasedLockCnt: f_dwAliasedLockCnt,
            dwReserved3: f_dwReserved3,
            hDD: f_hDD,
            cObsolete: f_cObsolete,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dbnOverlayRoot: f_dbnOverlayRoot,
            lpwPDeviceFlags: f_lpwPDeviceFlags,
            dwPDevice: f_dwPDevice,
            dwWin16LockCnt: f_dwWin16LockCnt,
            dwUnused3: f_dwUnused3,
            hInstance: f_hInstance,
            dwEvent16: f_dwEvent16,
            dwSaveNumModes: f_dwSaveNumModes,
            lpD3DGlobalDriverData: f_lpD3DGlobalDriverData,
            lpD3DHALCallbacks: f_lpD3DHALCallbacks,
            ddBothCaps: f_ddBothCaps,
            lpDDVideoPortCaps: f_lpDDVideoPortCaps,
            dvpList: f_dvpList,
            lpD3DHALCallbacks2: f_lpD3DHALCallbacks2,
            rectDevice: f_rectDevice,
            cMonitors: f_cMonitors,
            gpbmiSrc: f_gpbmiSrc,
            gpbmiDest: f_gpbmiDest,
            phaiHeapAliases: f_phaiHeapAliases,
            hKernelHandle: f_hKernelHandle,
            pfnNotifyProc: f_pfnNotifyProc,
            lpDDKernelCaps: f_lpDDKernelCaps,
            lpddNLVCaps: f_lpddNLVCaps,
            lpddNLVHELCaps: f_lpddNLVHELCaps,
            lpddNLVBothCaps: f_lpddNLVBothCaps,
            lpD3DExtendedCaps: f_lpD3DExtendedCaps,
            dwDOSBoxEvent: f_dwDOSBoxEvent,
            rectDesktop: f_rectDesktop,
            cDriverName: f_cDriverName,
            lpD3DHALCallbacks3: f_lpD3DHALCallbacks3,
            dwNumZPixelFormats: f_dwNumZPixelFormats,
            lpZPixelFormats: f_lpZPixelFormats,
            mcList: f_mcList,
            hDDVxd: f_hDDVxd,
            ddsCapsMore: f_ddsCapsMore,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 1624);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.fpPrimaryOrig, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddCaps, &mut into[12..12 + 316]);
        FromIntoMemory::into_bytes(self.dwInternal1, &mut into[328..328 + 4]);
        FromIntoMemory::into_bytes(self.dwUnused1, &mut into[332..332 + 36]);
        FromIntoMemory::into_bytes(self.lpDDCBtmp, &mut into[368..368 + 4]);
        FromIntoMemory::into_bytes(self.dsList, &mut into[372..372 + 4]);
        FromIntoMemory::into_bytes(self.palList, &mut into[376..376 + 4]);
        FromIntoMemory::into_bytes(self.clipperList, &mut into[380..380 + 4]);
        FromIntoMemory::into_bytes(self.lp16DD, &mut into[384..384 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxOverlays, &mut into[388..388 + 4]);
        FromIntoMemory::into_bytes(self.dwCurrOverlays, &mut into[392..392 + 4]);
        FromIntoMemory::into_bytes(self.dwMonitorFrequency, &mut into[396..396 + 4]);
        FromIntoMemory::into_bytes(self.ddHELCaps, &mut into[400..400 + 316]);
        FromIntoMemory::into_bytes(self.dwUnused2, &mut into[716..716 + 200]);
        FromIntoMemory::into_bytes(self.ddckCKDestOverlay, &mut into[916..916 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKSrcOverlay, &mut into[924..924 + 8]);
        FromIntoMemory::into_bytes(self.vmiData, &mut into[932..932 + 80]);
        FromIntoMemory::into_bytes(self.lpDriverHandle, &mut into[1012..1012 + 4]);
        FromIntoMemory::into_bytes(self.lpExclusiveOwner, &mut into[1016..1016 + 4]);
        FromIntoMemory::into_bytes(self.dwModeIndex, &mut into[1020..1020 + 4]);
        FromIntoMemory::into_bytes(self.dwModeIndexOrig, &mut into[1024..1024 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFourCC, &mut into[1028..1028 + 4]);
        FromIntoMemory::into_bytes(self.lpdwFourCC, &mut into[1032..1032 + 4]);
        FromIntoMemory::into_bytes(self.dwNumModes, &mut into[1036..1036 + 4]);
        FromIntoMemory::into_bytes(self.lpModeInfo, &mut into[1040..1040 + 4]);
        FromIntoMemory::into_bytes(self.plProcessList, &mut into[1044..1044 + 20]);
        FromIntoMemory::into_bytes(self.dwSurfaceLockCount, &mut into[1064..1064 + 4]);
        FromIntoMemory::into_bytes(self.dwAliasedLockCnt, &mut into[1068..1068 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[1072..1072 + 4]);
        FromIntoMemory::into_bytes(self.hDD, &mut into[1076..1076 + 4]);
        FromIntoMemory::into_bytes(self.cObsolete, &mut into[1080..1080 + 12]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[1092..1092 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[1096..1096 + 4]);
        FromIntoMemory::into_bytes(self.dbnOverlayRoot, &mut into[1100..1100 + 16]);
        FromIntoMemory::into_bytes(self.lpwPDeviceFlags, &mut into[1116..1116 + 4]);
        FromIntoMemory::into_bytes(self.dwPDevice, &mut into[1120..1120 + 4]);
        FromIntoMemory::into_bytes(self.dwWin16LockCnt, &mut into[1124..1124 + 4]);
        FromIntoMemory::into_bytes(self.dwUnused3, &mut into[1128..1128 + 4]);
        FromIntoMemory::into_bytes(self.hInstance, &mut into[1132..1132 + 4]);
        FromIntoMemory::into_bytes(self.dwEvent16, &mut into[1136..1136 + 4]);
        FromIntoMemory::into_bytes(self.dwSaveNumModes, &mut into[1140..1140 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DGlobalDriverData, &mut into[1144..1144 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DHALCallbacks, &mut into[1148..1148 + 4]);
        FromIntoMemory::into_bytes(self.ddBothCaps, &mut into[1152..1152 + 316]);
        FromIntoMemory::into_bytes(self.lpDDVideoPortCaps, &mut into[1468..1468 + 4]);
        FromIntoMemory::into_bytes(self.dvpList, &mut into[1472..1472 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DHALCallbacks2, &mut into[1476..1476 + 4]);
        FromIntoMemory::into_bytes(self.rectDevice, &mut into[1480..1480 + 16]);
        FromIntoMemory::into_bytes(self.cMonitors, &mut into[1496..1496 + 4]);
        FromIntoMemory::into_bytes(self.gpbmiSrc, &mut into[1500..1500 + 4]);
        FromIntoMemory::into_bytes(self.gpbmiDest, &mut into[1504..1504 + 4]);
        FromIntoMemory::into_bytes(self.phaiHeapAliases, &mut into[1508..1508 + 4]);
        FromIntoMemory::into_bytes(self.hKernelHandle, &mut into[1512..1512 + 4]);
        FromIntoMemory::into_bytes(self.pfnNotifyProc, &mut into[1516..1516 + 4]);
        FromIntoMemory::into_bytes(self.lpDDKernelCaps, &mut into[1520..1520 + 4]);
        FromIntoMemory::into_bytes(self.lpddNLVCaps, &mut into[1524..1524 + 4]);
        FromIntoMemory::into_bytes(self.lpddNLVHELCaps, &mut into[1528..1528 + 4]);
        FromIntoMemory::into_bytes(self.lpddNLVBothCaps, &mut into[1532..1532 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DExtendedCaps, &mut into[1536..1536 + 4]);
        FromIntoMemory::into_bytes(self.dwDOSBoxEvent, &mut into[1540..1540 + 4]);
        FromIntoMemory::into_bytes(self.rectDesktop, &mut into[1544..1544 + 16]);
        FromIntoMemory::into_bytes(self.cDriverName, &mut into[1560..1560 + 32]);
        FromIntoMemory::into_bytes(self.lpD3DHALCallbacks3, &mut into[1592..1592 + 4]);
        FromIntoMemory::into_bytes(self.dwNumZPixelFormats, &mut into[1596..1596 + 4]);
        FromIntoMemory::into_bytes(self.lpZPixelFormats, &mut into[1600..1600 + 4]);
        FromIntoMemory::into_bytes(self.mcList, &mut into[1604..1604 + 4]);
        FromIntoMemory::into_bytes(self.hDDVxd, &mut into[1608..1608 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsMore, &mut into[1612..1612 + 12]);
    }
    fn size() -> usize {
        1624
    }
}
pub struct DDRAWI_DIRECTDRAW_INT {
    pub lpVtbl: MutPtr<::core::ffi::c_void>,
    pub lpLcl: MutPtr<DDRAWI_DIRECTDRAW_LCL>,
    pub lpLink: MutPtr<DDRAWI_DIRECTDRAW_INT>,
    pub dwIntRefCnt: u32,
}
impl ::core::marker::Copy for DDRAWI_DIRECTDRAW_INT {}
impl ::core::clone::Clone for DDRAWI_DIRECTDRAW_INT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DIRECTDRAW_INT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DIRECTDRAW_INT")
            .field("lpVtbl", &self.lpVtbl)
            .field("lpLcl", &self.lpLcl)
            .field("lpLink", &self.lpLink)
            .field("dwIntRefCnt", &self.dwIntRefCnt)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DIRECTDRAW_INT {
    fn eq(&self, other: &Self) -> bool {
        self.lpVtbl == other.lpVtbl
            && self.lpLcl == other.lpLcl
            && self.lpLink == other.lpLink
            && self.dwIntRefCnt == other.dwIntRefCnt
    }
}
impl ::core::cmp::Eq for DDRAWI_DIRECTDRAW_INT {}
impl FromIntoMemory for DDRAWI_DIRECTDRAW_INT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpVtbl = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpLcl =
            <MutPtr<DDRAWI_DIRECTDRAW_LCL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpLink =
            <MutPtr<DDRAWI_DIRECTDRAW_INT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwIntRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpVtbl: f_lpVtbl,
            lpLcl: f_lpLcl,
            lpLink: f_lpLink,
            dwIntRefCnt: f_dwIntRefCnt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpVtbl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwIntRefCnt, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDRAWI_DIRECTDRAW_LCL {
    pub lpDDMore: u32,
    pub lpGbl: MutPtr<DDRAWI_DIRECTDRAW_GBL>,
    pub dwUnused0: u32,
    pub dwLocalFlags: u32,
    pub dwLocalRefCnt: u32,
    pub dwProcessId: u32,
    pub pUnkOuter: crate::core::IUnknown,
    pub dwObsolete1: u32,
    pub hWnd: PtrRepr,
    pub hDC: PtrRepr,
    pub dwErrorMode: u32,
    pub lpPrimary: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
    pub lpCB: MutPtr<DDRAWI_DDRAWSURFACE_INT>,
    pub dwPreferredMode: u32,
    pub hD3DInstance: super::super::Foundation::HINSTANCE,
    pub pD3DIUnknown: crate::core::IUnknown,
    pub lpDDCB: MutPtr<DDHAL_CALLBACKS>,
    pub hDDVxd: PtrRepr,
    pub dwAppHackFlags: u32,
    pub hFocusWnd: PtrRepr,
    pub dwHotTracking: u32,
    pub dwIMEState: u32,
    pub hWndPopup: PtrRepr,
    pub hDD: PtrRepr,
    pub hGammaCalibrator: PtrRepr,
    pub lpGammaCalibrator: LPDDGAMMACALIBRATORPROC,
}
impl ::core::marker::Copy for DDRAWI_DIRECTDRAW_LCL {}
impl ::core::clone::Clone for DDRAWI_DIRECTDRAW_LCL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRAWI_DIRECTDRAW_LCL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRAWI_DIRECTDRAW_LCL")
            .field("lpDDMore", &self.lpDDMore)
            .field("lpGbl", &self.lpGbl)
            .field("dwUnused0", &self.dwUnused0)
            .field("dwLocalFlags", &self.dwLocalFlags)
            .field("dwLocalRefCnt", &self.dwLocalRefCnt)
            .field("dwProcessId", &self.dwProcessId)
            .field("pUnkOuter", &self.pUnkOuter)
            .field("dwObsolete1", &self.dwObsolete1)
            .field("hWnd", &self.hWnd)
            .field("hDC", &self.hDC)
            .field("dwErrorMode", &self.dwErrorMode)
            .field("lpPrimary", &self.lpPrimary)
            .field("lpCB", &self.lpCB)
            .field("dwPreferredMode", &self.dwPreferredMode)
            .field("hD3DInstance", &self.hD3DInstance)
            .field("pD3DIUnknown", &self.pD3DIUnknown)
            .field("lpDDCB", &self.lpDDCB)
            .field("hDDVxd", &self.hDDVxd)
            .field("dwAppHackFlags", &self.dwAppHackFlags)
            .field("hFocusWnd", &self.hFocusWnd)
            .field("dwHotTracking", &self.dwHotTracking)
            .field("dwIMEState", &self.dwIMEState)
            .field("hWndPopup", &self.hWndPopup)
            .field("hDD", &self.hDD)
            .field("hGammaCalibrator", &self.hGammaCalibrator)
            .field("lpGammaCalibrator", &self.lpGammaCalibrator)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRAWI_DIRECTDRAW_LCL {
    fn eq(&self, other: &Self) -> bool {
        self.lpDDMore == other.lpDDMore
            && self.lpGbl == other.lpGbl
            && self.dwUnused0 == other.dwUnused0
            && self.dwLocalFlags == other.dwLocalFlags
            && self.dwLocalRefCnt == other.dwLocalRefCnt
            && self.dwProcessId == other.dwProcessId
            && self.pUnkOuter == other.pUnkOuter
            && self.dwObsolete1 == other.dwObsolete1
            && self.hWnd == other.hWnd
            && self.hDC == other.hDC
            && self.dwErrorMode == other.dwErrorMode
            && self.lpPrimary == other.lpPrimary
            && self.lpCB == other.lpCB
            && self.dwPreferredMode == other.dwPreferredMode
            && self.hD3DInstance == other.hD3DInstance
            && self.pD3DIUnknown == other.pD3DIUnknown
            && self.lpDDCB == other.lpDDCB
            && self.hDDVxd == other.hDDVxd
            && self.dwAppHackFlags == other.dwAppHackFlags
            && self.hFocusWnd == other.hFocusWnd
            && self.dwHotTracking == other.dwHotTracking
            && self.dwIMEState == other.dwIMEState
            && self.hWndPopup == other.hWndPopup
            && self.hDD == other.hDD
            && self.hGammaCalibrator == other.hGammaCalibrator
            && self.lpGammaCalibrator == other.lpGammaCalibrator
    }
}
impl ::core::cmp::Eq for DDRAWI_DIRECTDRAW_LCL {}
impl FromIntoMemory for DDRAWI_DIRECTDRAW_LCL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 104);
        let f_lpDDMore = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGbl =
            <MutPtr<DDRAWI_DIRECTDRAW_GBL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwUnused0 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwLocalFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwLocalRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwProcessId = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_pUnkOuter = <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwObsolete1 = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_hWnd = <PtrRepr as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_hDC = <PtrRepr as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwErrorMode = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpPrimary =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_lpCB =
            <MutPtr<DDRAWI_DDRAWSURFACE_INT> as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwPreferredMode = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_hD3DInstance =
            <super::super::Foundation::HINSTANCE as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_pD3DIUnknown =
            <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_lpDDCB = <MutPtr<DDHAL_CALLBACKS> as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_hDDVxd = <PtrRepr as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwAppHackFlags = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_hFocusWnd = <PtrRepr as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwHotTracking = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwIMEState = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_hWndPopup = <PtrRepr as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_hDD = <PtrRepr as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_hGammaCalibrator = <PtrRepr as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_lpGammaCalibrator =
            <LPDDGAMMACALIBRATORPROC as FromIntoMemory>::from_bytes(&from[100..100 + 4]);
        Self {
            lpDDMore: f_lpDDMore,
            lpGbl: f_lpGbl,
            dwUnused0: f_dwUnused0,
            dwLocalFlags: f_dwLocalFlags,
            dwLocalRefCnt: f_dwLocalRefCnt,
            dwProcessId: f_dwProcessId,
            pUnkOuter: f_pUnkOuter,
            dwObsolete1: f_dwObsolete1,
            hWnd: f_hWnd,
            hDC: f_hDC,
            dwErrorMode: f_dwErrorMode,
            lpPrimary: f_lpPrimary,
            lpCB: f_lpCB,
            dwPreferredMode: f_dwPreferredMode,
            hD3DInstance: f_hD3DInstance,
            pD3DIUnknown: f_pD3DIUnknown,
            lpDDCB: f_lpDDCB,
            hDDVxd: f_hDDVxd,
            dwAppHackFlags: f_dwAppHackFlags,
            hFocusWnd: f_hFocusWnd,
            dwHotTracking: f_dwHotTracking,
            dwIMEState: f_dwIMEState,
            hWndPopup: f_hWndPopup,
            hDD: f_hDD,
            hGammaCalibrator: f_hGammaCalibrator,
            lpGammaCalibrator: f_lpGammaCalibrator,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 104);
        FromIntoMemory::into_bytes(self.lpDDMore, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGbl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwUnused0, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwLocalFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwLocalRefCnt, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessId, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.pUnkOuter, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwObsolete1, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.hDC, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwErrorMode, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpPrimary, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.lpCB, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwPreferredMode, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.hD3DInstance, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.pD3DIUnknown, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.lpDDCB, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.hDDVxd, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwAppHackFlags, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.hFocusWnd, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwHotTracking, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwIMEState, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.hWndPopup, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.hDD, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.hGammaCalibrator, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.lpGammaCalibrator, &mut into[100..100 + 4]);
    }
    fn size() -> usize {
        104
    }
}
pub const DDRAWI_DISPLAYDRV: i32 = 32i32;
pub const DDRAWI_DRIVERINFO2: i32 = 536870912i32;
pub const DDRAWI_EMULATIONINITIALIZED: i32 = 16384i32;
pub const DDRAWI_EXTENDEDALIGNMENT: i32 = 2097152i32;
pub const DDRAWI_FLIPPEDTOGDI: i32 = 131072i32;
pub const DDRAWI_FULLSCREEN: i32 = 64i32;
pub const DDRAWI_GDIDRV: i32 = 8388608i32;
pub const DDRAWI_GETCOLOR: u32 = 1u32;
pub const DDRAWI_HASCKEYDESTOVERLAY: i32 = 2048i32;
pub const DDRAWI_HASCKEYSRCOVERLAY: i32 = 4096i32;
pub const DDRAWI_HASGDIPALETTE: i32 = 8192i32;
pub const DDRAWI_HASGDIPALETTE_EXCLUSIVE: i32 = 32768i32;
pub const DDRAWI_MODECHANGED: i32 = 128i32;
pub const DDRAWI_MODEX: i32 = 16i32;
pub const DDRAWI_MODEXILLEGAL: i32 = 65536i32;
pub const DDRAWI_NEEDSWIN16FORVRAMLOCK: i32 = 262144i32;
pub const DDRAWI_NOEMULATION: i32 = 1024i32;
pub const DDRAWI_NOHARDWARE: i32 = 256i32;
pub const DDRAWI_PALETTEINIT: i32 = 512i32;
pub const DDRAWI_PDEVICEVRAMBITCLEARED: i32 = 524288i32;
pub const DDRAWI_SECONDARYDRIVERLOADED: i32 = 134217728i32;
pub const DDRAWI_SETCOLOR: u32 = 2u32;
pub const DDRAWI_STANDARDVGA: i32 = 1048576i32;
pub const DDRAWI_TESTINGMODES: i32 = 268435456i32;
pub const DDRAWI_UMODELOADED: i32 = 33554432i32;
pub const DDRAWI_VIRTUALDESKTOP: i32 = 8i32;
pub const DDRAWI_VPORTGETCOLOR: u32 = 1u32;
pub const DDRAWI_VPORTSETCOLOR: u32 = 2u32;
pub const DDRAWI_VPORTSTART: u32 = 1u32;
pub const DDRAWI_VPORTSTOP: u32 = 2u32;
pub const DDRAWI_VPORTUPDATE: u32 = 3u32;
pub const DDRAWI_xxxxxxxxx1: i32 = 1i32;
pub const DDRAWI_xxxxxxxxx2: i32 = 2i32;
pub struct DDRGBA {
    pub red: u8,
    pub green: u8,
    pub blue: u8,
    pub alpha: u8,
}
impl ::core::marker::Copy for DDRGBA {}
impl ::core::clone::Clone for DDRGBA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDRGBA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDRGBA")
            .field("red", &self.red)
            .field("green", &self.green)
            .field("blue", &self.blue)
            .field("alpha", &self.alpha)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDRGBA {
    fn eq(&self, other: &Self) -> bool {
        self.red == other.red
            && self.green == other.green
            && self.blue == other.blue
            && self.alpha == other.alpha
    }
}
impl ::core::cmp::Eq for DDRGBA {}
impl FromIntoMemory for DDRGBA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_red = <u8 as FromIntoMemory>::from_bytes(&from[0..0 + 1]);
        let f_green = <u8 as FromIntoMemory>::from_bytes(&from[1..1 + 1]);
        let f_blue = <u8 as FromIntoMemory>::from_bytes(&from[2..2 + 1]);
        let f_alpha = <u8 as FromIntoMemory>::from_bytes(&from[3..3 + 1]);
        Self {
            red: f_red,
            green: f_green,
            blue: f_blue,
            alpha: f_alpha,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.red, &mut into[0..0 + 1]);
        FromIntoMemory::into_bytes(self.green, &mut into[1..1 + 1]);
        FromIntoMemory::into_bytes(self.blue, &mut into[2..2 + 1]);
        FromIntoMemory::into_bytes(self.alpha, &mut into[3..3 + 1]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSCAPS {
    pub dwCaps: u32,
}
impl ::core::marker::Copy for DDSCAPS {}
impl ::core::clone::Clone for DDSCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDSCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDSCAPS")
            .field("dwCaps", &self.dwCaps)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDSCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwCaps == other.dwCaps
    }
}
impl ::core::cmp::Eq for DDSCAPS {}
impl FromIntoMemory for DDSCAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self { dwCaps: f_dwCaps }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSCAPS2 {
    pub dwCaps: u32,
    pub dwCaps2: u32,
    pub dwCaps3: u32,
    pub Anonymous: DDSCAPS2_0,
}
impl ::core::marker::Copy for DDSCAPS2 {}
impl ::core::clone::Clone for DDSCAPS2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSCAPS2 {
    fn eq(&self, other: &Self) -> bool {
        self.dwCaps == other.dwCaps
            && self.dwCaps2 == other.dwCaps2
            && self.dwCaps3 == other.dwCaps3
            && self.Anonymous == other.Anonymous
    }
}
impl ::core::cmp::Eq for DDSCAPS2 {}
impl FromIntoMemory for DDSCAPS2 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwCaps3 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Anonymous = <DDSCAPS2_0 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwCaps: f_dwCaps,
            dwCaps2: f_dwCaps2,
            dwCaps3: f_dwCaps3,
            Anonymous: f_Anonymous,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps3, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DDSCAPS2_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSCAPS2_0 {}
impl ::core::clone::Clone for DDSCAPS2_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSCAPS2_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSCAPS2_0 {}
impl FromIntoMemory for DDSCAPS2_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub const DDSCAPS2_ADDITIONALPRIMARY: i32 = -2147483648i32;
pub const DDSCAPS2_COMMANDBUFFER: i32 = 64i32;
pub const DDSCAPS2_CUBEMAP: i32 = 512i32;
pub const DDSCAPS2_CUBEMAP_NEGATIVEX: i32 = 2048i32;
pub const DDSCAPS2_CUBEMAP_NEGATIVEY: i32 = 8192i32;
pub const DDSCAPS2_CUBEMAP_NEGATIVEZ: i32 = 32768i32;
pub const DDSCAPS2_CUBEMAP_POSITIVEX: i32 = 1024i32;
pub const DDSCAPS2_CUBEMAP_POSITIVEY: i32 = 4096i32;
pub const DDSCAPS2_CUBEMAP_POSITIVEZ: i32 = 16384i32;
pub const DDSCAPS2_D3DTEXTUREMANAGE: i32 = 131072i32;
pub const DDSCAPS2_DISCARDBACKBUFFER: i32 = 268435456i32;
pub const DDSCAPS2_DONOTPERSIST: i32 = 262144i32;
pub const DDSCAPS2_ENABLEALPHACHANNEL: i32 = 536870912i32;
pub const DDSCAPS2_EXTENDEDFORMATPRIMARY: i32 = 1073741824i32;
pub const DDSCAPS2_HARDWAREDEINTERLACE: i32 = 0i32;
pub const DDSCAPS2_HINTANTIALIASING: i32 = 256i32;
pub const DDSCAPS2_HINTDYNAMIC: i32 = 4i32;
pub const DDSCAPS2_HINTSTATIC: i32 = 8i32;
pub const DDSCAPS2_INDEXBUFFER: i32 = 67108864i32;
pub const DDSCAPS2_MIPMAPSUBLEVEL: i32 = 65536i32;
pub const DDSCAPS2_NOTUSERLOCKABLE: i32 = 4194304i32;
pub const DDSCAPS2_NPATCHES: i32 = 33554432i32;
pub const DDSCAPS2_OPAQUE: i32 = 128i32;
pub const DDSCAPS2_POINTS: i32 = 8388608i32;
pub const DDSCAPS2_RESERVED1: i32 = 32i32;
pub const DDSCAPS2_RESERVED2: i32 = 64i32;
pub const DDSCAPS2_RESERVED3: i32 = 67108864i32;
pub const DDSCAPS2_RESERVED4: i32 = 2i32;
pub const DDSCAPS2_RTPATCHES: i32 = 16777216i32;
pub const DDSCAPS2_STEREOSURFACELEFT: i32 = 524288i32;
pub const DDSCAPS2_TEXTUREMANAGE: i32 = 16i32;
pub const DDSCAPS2_VERTEXBUFFER: i32 = 32i32;
pub const DDSCAPS2_VOLUME: i32 = 2097152i32;
pub const DDSCAPS3_AUTOGENMIPMAP: i32 = 2048i32;
pub const DDSCAPS3_CREATESHAREDRESOURCE: i32 = 8192i32;
pub const DDSCAPS3_DMAP: i32 = 4096i32;
pub const DDSCAPS3_LIGHTWEIGHTMIPMAP: i32 = 1024i32;
pub const DDSCAPS3_MULTISAMPLE_MASK: i32 = 31i32;
pub const DDSCAPS3_MULTISAMPLE_QUALITY_MASK: i32 = 224i32;
pub const DDSCAPS3_MULTISAMPLE_QUALITY_SHIFT: u32 = 5u32;
pub const DDSCAPS3_OPENSHAREDRESOURCE: i32 = 32768i32;
pub const DDSCAPS3_READONLYRESOURCE: i32 = 16384i32;
pub const DDSCAPS3_RESERVED1: i32 = 256i32;
pub const DDSCAPS3_RESERVED2: i32 = 512i32;
pub const DDSCAPS3_VIDEO: i32 = 512i32;
pub struct DDSCAPSEX {
    pub dwCaps2: u32,
    pub dwCaps3: u32,
    pub Anonymous: DDSCAPSEX_0,
}
impl ::core::marker::Copy for DDSCAPSEX {}
impl ::core::clone::Clone for DDSCAPSEX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSCAPSEX {
    fn eq(&self, other: &Self) -> bool {
        self.dwCaps2 == other.dwCaps2
            && self.dwCaps3 == other.dwCaps3
            && self.Anonymous == other.Anonymous
    }
}
impl ::core::cmp::Eq for DDSCAPSEX {}
impl FromIntoMemory for DDSCAPSEX {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps3 = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_Anonymous = <DDSCAPSEX_0 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwCaps2: f_dwCaps2,
            dwCaps3: f_dwCaps3,
            Anonymous: f_Anonymous,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwCaps2, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps3, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DDSCAPSEX_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSCAPSEX_0 {}
impl ::core::clone::Clone for DDSCAPSEX_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSCAPSEX_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSCAPSEX_0 {}
impl FromIntoMemory for DDSCAPSEX_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub const DDSCAPS_3DDEVICE: i32 = 8192i32;
pub const DDSCAPS_ALLOCONLOAD: i32 = 67108864i32;
pub const DDSCAPS_ALPHA: i32 = 2i32;
pub const DDSCAPS_BACKBUFFER: i32 = 4i32;
pub const DDSCAPS_COMMANDBUFFER: i32 = 1024i32;
pub const DDSCAPS_COMPLEX: i32 = 8i32;
pub const DDSCAPS_EXECUTEBUFFER: i32 = 8388608i32;
pub const DDSCAPS_FLIP: i32 = 16i32;
pub const DDSCAPS_FRONTBUFFER: i32 = 32i32;
pub const DDSCAPS_HWCODEC: i32 = 1048576i32;
pub const DDSCAPS_LIVEVIDEO: i32 = 524288i32;
pub const DDSCAPS_LOCALVIDMEM: i32 = 268435456i32;
pub const DDSCAPS_MIPMAP: i32 = 4194304i32;
pub const DDSCAPS_MODEX: i32 = 2097152i32;
pub const DDSCAPS_NONLOCALVIDMEM: i32 = 536870912i32;
pub const DDSCAPS_OFFSCREENPLAIN: i32 = 64i32;
pub const DDSCAPS_OPTIMIZED: i32 = -2147483648i32;
pub const DDSCAPS_OVERLAY: i32 = 128i32;
pub const DDSCAPS_OWNDC: i32 = 262144i32;
pub const DDSCAPS_PALETTE: i32 = 256i32;
pub const DDSCAPS_PRIMARYSURFACE: i32 = 512i32;
pub const DDSCAPS_PRIMARYSURFACELEFT: i32 = 0i32;
pub const DDSCAPS_RESERVED1: i32 = 1i32;
pub const DDSCAPS_RESERVED2: i32 = 8388608i32;
pub const DDSCAPS_RESERVED3: i32 = 1024i32;
pub const DDSCAPS_STANDARDVGAMODE: i32 = 1073741824i32;
pub const DDSCAPS_SYSTEMMEMORY: i32 = 2048i32;
pub const DDSCAPS_TEXTURE: i32 = 4096i32;
pub const DDSCAPS_VIDEOMEMORY: i32 = 16384i32;
pub const DDSCAPS_VIDEOPORT: i32 = 134217728i32;
pub const DDSCAPS_VISIBLE: i32 = 32768i32;
pub const DDSCAPS_WRITEONLY: i32 = 65536i32;
pub const DDSCAPS_ZBUFFER: i32 = 131072i32;
pub const DDSCL_ALLOWMODEX: i32 = 64i32;
pub const DDSCL_ALLOWREBOOT: i32 = 2i32;
pub const DDSCL_CREATEDEVICEWINDOW: i32 = 512i32;
pub const DDSCL_EXCLUSIVE: i32 = 16i32;
pub const DDSCL_FPUPRESERVE: i32 = 4096i32;
pub const DDSCL_FPUSETUP: i32 = 2048i32;
pub const DDSCL_FULLSCREEN: i32 = 1i32;
pub const DDSCL_MULTITHREADED: i32 = 1024i32;
pub const DDSCL_NORMAL: i32 = 8i32;
pub const DDSCL_NOWINDOWCHANGES: i32 = 4i32;
pub const DDSCL_SETDEVICEWINDOW: i32 = 256i32;
pub const DDSCL_SETFOCUSWINDOW: i32 = 128i32;
pub const DDSDM_STANDARDVGAMODE: i32 = 1i32;
pub const DDSD_ALL: i32 = 16775662i32;
pub const DDSD_ALPHABITDEPTH: i32 = 128i32;
pub const DDSD_BACKBUFFERCOUNT: i32 = 32i32;
pub const DDSD_CAPS: i32 = 1i32;
pub const DDSD_CKDESTBLT: i32 = 16384i32;
pub const DDSD_CKDESTOVERLAY: i32 = 8192i32;
pub const DDSD_CKSRCBLT: i32 = 65536i32;
pub const DDSD_CKSRCOVERLAY: i32 = 32768i32;
pub const DDSD_DEPTH: i32 = 8388608i32;
pub const DDSD_FVF: i32 = 2097152i32;
pub const DDSD_HEIGHT: i32 = 2i32;
pub const DDSD_LINEARSIZE: i32 = 524288i32;
pub const DDSD_LPSURFACE: i32 = 2048i32;
pub const DDSD_MIPMAPCOUNT: i32 = 131072i32;
pub const DDSD_PITCH: i32 = 8i32;
pub const DDSD_PIXELFORMAT: i32 = 4096i32;
pub const DDSD_REFRESHRATE: i32 = 262144i32;
pub const DDSD_SRCVBHANDLE: i32 = 4194304i32;
pub const DDSD_TEXTURESTAGE: i32 = 1048576i32;
pub const DDSD_WIDTH: i32 = 4i32;
pub const DDSD_ZBUFFERBITDEPTH: i32 = 64i32;
pub struct DDSETSTATEININFO {
    pub lpSurfaceData: MutPtr<DDSURFACEDATA>,
    pub lpVideoPortData: MutPtr<DDVIDEOPORTDATA>,
}
impl ::core::marker::Copy for DDSETSTATEININFO {}
impl ::core::clone::Clone for DDSETSTATEININFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDSETSTATEININFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDSETSTATEININFO")
            .field("lpSurfaceData", &self.lpSurfaceData)
            .field("lpVideoPortData", &self.lpVideoPortData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDSETSTATEININFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpSurfaceData == other.lpSurfaceData && self.lpVideoPortData == other.lpVideoPortData
    }
}
impl ::core::cmp::Eq for DDSETSTATEININFO {}
impl FromIntoMemory for DDSETSTATEININFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_lpSurfaceData =
            <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPortData =
            <MutPtr<DDVIDEOPORTDATA> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            lpSurfaceData: f_lpSurfaceData,
            lpVideoPortData: f_lpVideoPortData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.lpSurfaceData, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPortData, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub struct DDSETSTATEOUTINFO {
    pub bSoftwareAutoflip: super::super::Foundation::BOOL,
    pub dwSurfaceIndex: u32,
    pub dwVBISurfaceIndex: u32,
}
impl ::core::marker::Copy for DDSETSTATEOUTINFO {}
impl ::core::clone::Clone for DDSETSTATEOUTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDSETSTATEOUTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDSETSTATEOUTINFO")
            .field("bSoftwareAutoflip", &self.bSoftwareAutoflip)
            .field("dwSurfaceIndex", &self.dwSurfaceIndex)
            .field("dwVBISurfaceIndex", &self.dwVBISurfaceIndex)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDSETSTATEOUTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.bSoftwareAutoflip == other.bSoftwareAutoflip
            && self.dwSurfaceIndex == other.dwSurfaceIndex
            && self.dwVBISurfaceIndex == other.dwVBISurfaceIndex
    }
}
impl ::core::cmp::Eq for DDSETSTATEOUTINFO {}
impl FromIntoMemory for DDSETSTATEOUTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_bSoftwareAutoflip =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSurfaceIndex = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwVBISurfaceIndex = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            bSoftwareAutoflip: f_bSoftwareAutoflip,
            dwSurfaceIndex: f_dwSurfaceIndex,
            dwVBISurfaceIndex: f_dwVBISurfaceIndex,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.bSoftwareAutoflip, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSurfaceIndex, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwVBISurfaceIndex, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const DDSETSURFACEDESC_PRESERVEDC: i32 = 1i32;
pub const DDSETSURFACEDESC_RECREATEDC: i32 = 0i32;
pub const DDSGR_CALIBRATE: i32 = 1i32;
pub struct DDSKIPNEXTFIELDINFO {
    pub lpVideoPortData: MutPtr<DDVIDEOPORTDATA>,
    pub dwSkipFlags: u32,
}
impl ::core::marker::Copy for DDSKIPNEXTFIELDINFO {}
impl ::core::clone::Clone for DDSKIPNEXTFIELDINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDSKIPNEXTFIELDINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDSKIPNEXTFIELDINFO")
            .field("lpVideoPortData", &self.lpVideoPortData)
            .field("dwSkipFlags", &self.dwSkipFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDSKIPNEXTFIELDINFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpVideoPortData == other.lpVideoPortData && self.dwSkipFlags == other.dwSkipFlags
    }
}
impl ::core::cmp::Eq for DDSKIPNEXTFIELDINFO {}
impl FromIntoMemory for DDSKIPNEXTFIELDINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_lpVideoPortData =
            <MutPtr<DDVIDEOPORTDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSkipFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            lpVideoPortData: f_lpVideoPortData,
            dwSkipFlags: f_dwSkipFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.lpVideoPortData, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSkipFlags, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub const DDSKIP_ENABLENEXT: u32 = 2u32;
pub const DDSKIP_SKIPNEXT: u32 = 1u32;
pub const DDSMT_ISTESTREQUIRED: i32 = 1i32;
pub const DDSPD_IUNKNOWNPOINTER: i32 = 1i32;
pub const DDSPD_VOLATILE: i32 = 2i32;
pub struct DDSTEREOMODE {
    pub dwSize: u32,
    pub dwHeight: u32,
    pub dwWidth: u32,
    pub dwBpp: u32,
    pub dwRefreshRate: u32,
    pub bSupported: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DDSTEREOMODE {}
impl ::core::clone::Clone for DDSTEREOMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDSTEREOMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDSTEREOMODE")
            .field("dwSize", &self.dwSize)
            .field("dwHeight", &self.dwHeight)
            .field("dwWidth", &self.dwWidth)
            .field("dwBpp", &self.dwBpp)
            .field("dwRefreshRate", &self.dwRefreshRate)
            .field("bSupported", &self.bSupported)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDSTEREOMODE {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwHeight == other.dwHeight
            && self.dwWidth == other.dwWidth
            && self.dwBpp == other.dwBpp
            && self.dwRefreshRate == other.dwRefreshRate
            && self.bSupported == other.bSupported
    }
}
impl ::core::cmp::Eq for DDSTEREOMODE {}
impl FromIntoMemory for DDSTEREOMODE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwBpp = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwRefreshRate = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_bSupported =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwSize: f_dwSize,
            dwHeight: f_dwHeight,
            dwWidth: f_dwWidth,
            dwBpp: f_dwBpp,
            dwRefreshRate: f_dwRefreshRate,
            bSupported: f_bSupported,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwBpp, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwRefreshRate, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.bSupported, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDSURFACEDATA {
    pub ddsCaps: u32,
    pub dwSurfaceOffset: u32,
    pub fpLockPtr: PtrRepr,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub lPitch: i32,
    pub dwOverlayFlags: u32,
    pub dwOverlayOffset: u32,
    pub dwOverlaySrcWidth: u32,
    pub dwOverlaySrcHeight: u32,
    pub dwOverlayDestWidth: u32,
    pub dwOverlayDestHeight: u32,
    pub dwVideoPortId: u32,
    pub dwFormatFlags: u32,
    pub dwFormatFourCC: u32,
    pub dwFormatBitCount: u32,
    pub dwRBitMask: u32,
    pub dwGBitMask: u32,
    pub dwBBitMask: u32,
    pub dwDriverReserved1: u32,
    pub dwDriverReserved2: u32,
    pub dwDriverReserved3: u32,
    pub dwDriverReserved4: u32,
}
impl ::core::marker::Copy for DDSURFACEDATA {}
impl ::core::clone::Clone for DDSURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDSURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDSURFACEDATA")
            .field("ddsCaps", &self.ddsCaps)
            .field("dwSurfaceOffset", &self.dwSurfaceOffset)
            .field("fpLockPtr", &self.fpLockPtr)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("lPitch", &self.lPitch)
            .field("dwOverlayFlags", &self.dwOverlayFlags)
            .field("dwOverlayOffset", &self.dwOverlayOffset)
            .field("dwOverlaySrcWidth", &self.dwOverlaySrcWidth)
            .field("dwOverlaySrcHeight", &self.dwOverlaySrcHeight)
            .field("dwOverlayDestWidth", &self.dwOverlayDestWidth)
            .field("dwOverlayDestHeight", &self.dwOverlayDestHeight)
            .field("dwVideoPortId", &self.dwVideoPortId)
            .field("dwFormatFlags", &self.dwFormatFlags)
            .field("dwFormatFourCC", &self.dwFormatFourCC)
            .field("dwFormatBitCount", &self.dwFormatBitCount)
            .field("dwRBitMask", &self.dwRBitMask)
            .field("dwGBitMask", &self.dwGBitMask)
            .field("dwBBitMask", &self.dwBBitMask)
            .field("dwDriverReserved1", &self.dwDriverReserved1)
            .field("dwDriverReserved2", &self.dwDriverReserved2)
            .field("dwDriverReserved3", &self.dwDriverReserved3)
            .field("dwDriverReserved4", &self.dwDriverReserved4)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.ddsCaps == other.ddsCaps
            && self.dwSurfaceOffset == other.dwSurfaceOffset
            && self.fpLockPtr == other.fpLockPtr
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.lPitch == other.lPitch
            && self.dwOverlayFlags == other.dwOverlayFlags
            && self.dwOverlayOffset == other.dwOverlayOffset
            && self.dwOverlaySrcWidth == other.dwOverlaySrcWidth
            && self.dwOverlaySrcHeight == other.dwOverlaySrcHeight
            && self.dwOverlayDestWidth == other.dwOverlayDestWidth
            && self.dwOverlayDestHeight == other.dwOverlayDestHeight
            && self.dwVideoPortId == other.dwVideoPortId
            && self.dwFormatFlags == other.dwFormatFlags
            && self.dwFormatFourCC == other.dwFormatFourCC
            && self.dwFormatBitCount == other.dwFormatBitCount
            && self.dwRBitMask == other.dwRBitMask
            && self.dwGBitMask == other.dwGBitMask
            && self.dwBBitMask == other.dwBBitMask
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
            && self.dwDriverReserved4 == other.dwDriverReserved4
    }
}
impl ::core::cmp::Eq for DDSURFACEDATA {}
impl FromIntoMemory for DDSURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 92);
        let f_ddsCaps = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSurfaceOffset = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_fpLockPtr = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lPitch = <i32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwOverlayFlags = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwOverlayOffset = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwOverlaySrcWidth = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwOverlaySrcHeight = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwOverlayDestWidth = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwOverlayDestHeight = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwVideoPortId = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwFormatFlags = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwFormatFourCC = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwFormatBitCount = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwRBitMask = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwGBitMask = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwBBitMask = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_dwDriverReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_dwDriverReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_dwDriverReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_dwDriverReserved4 = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        Self {
            ddsCaps: f_ddsCaps,
            dwSurfaceOffset: f_dwSurfaceOffset,
            fpLockPtr: f_fpLockPtr,
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            lPitch: f_lPitch,
            dwOverlayFlags: f_dwOverlayFlags,
            dwOverlayOffset: f_dwOverlayOffset,
            dwOverlaySrcWidth: f_dwOverlaySrcWidth,
            dwOverlaySrcHeight: f_dwOverlaySrcHeight,
            dwOverlayDestWidth: f_dwOverlayDestWidth,
            dwOverlayDestHeight: f_dwOverlayDestHeight,
            dwVideoPortId: f_dwVideoPortId,
            dwFormatFlags: f_dwFormatFlags,
            dwFormatFourCC: f_dwFormatFourCC,
            dwFormatBitCount: f_dwFormatBitCount,
            dwRBitMask: f_dwRBitMask,
            dwGBitMask: f_dwGBitMask,
            dwBBitMask: f_dwBBitMask,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
            dwDriverReserved4: f_dwDriverReserved4,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 92);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSurfaceOffset, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.fpLockPtr, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lPitch, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayFlags, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayOffset, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlaySrcWidth, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlaySrcHeight, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayDestWidth, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayDestHeight, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwVideoPortId, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwFormatFlags, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwFormatFourCC, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwFormatBitCount, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwRBitMask, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwGBitMask, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwBBitMask, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved4, &mut into[88..88 + 4]);
    }
    fn size() -> usize {
        92
    }
}
pub struct DDSURFACEDESC {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwHeight: u32,
    pub dwWidth: u32,
    pub Anonymous1: DDSURFACEDESC_0,
    pub dwBackBufferCount: u32,
    pub Anonymous2: DDSURFACEDESC_1,
    pub dwAlphaBitDepth: u32,
    pub dwReserved: u32,
    pub lpSurface: MutPtr<::core::ffi::c_void>,
    pub ddckCKDestOverlay: DDCOLORKEY,
    pub ddckCKDestBlt: DDCOLORKEY,
    pub ddckCKSrcOverlay: DDCOLORKEY,
    pub ddckCKSrcBlt: DDCOLORKEY,
    pub ddpfPixelFormat: DDPIXELFORMAT,
    pub ddsCaps: DDSCAPS,
}
impl ::core::marker::Copy for DDSURFACEDESC {}
impl ::core::clone::Clone for DDSURFACEDESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dwHeight == other.dwHeight
            && self.dwWidth == other.dwWidth
            && self.Anonymous1 == other.Anonymous1
            && self.dwBackBufferCount == other.dwBackBufferCount
            && self.Anonymous2 == other.Anonymous2
            && self.dwAlphaBitDepth == other.dwAlphaBitDepth
            && self.dwReserved == other.dwReserved
            && self.lpSurface == other.lpSurface
            && self.ddckCKDestOverlay == other.ddckCKDestOverlay
            && self.ddckCKDestBlt == other.ddckCKDestBlt
            && self.ddckCKSrcOverlay == other.ddckCKSrcOverlay
            && self.ddckCKSrcBlt == other.ddckCKSrcBlt
            && self.ddpfPixelFormat == other.ddpfPixelFormat
            && self.ddsCaps == other.ddsCaps
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC {}
impl FromIntoMemory for DDSURFACEDESC {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 108);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_Anonymous1 = <DDSURFACEDESC_0 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwBackBufferCount = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_Anonymous2 = <DDSURFACEDESC_1 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwAlphaBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpSurface =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_ddckCKDestOverlay = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[40..40 + 8]);
        let f_ddckCKDestBlt = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[48..48 + 8]);
        let f_ddckCKSrcOverlay = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[56..56 + 8]);
        let f_ddckCKSrcBlt = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[64..64 + 8]);
        let f_ddpfPixelFormat = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[72..72 + 32]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[104..104 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            dwHeight: f_dwHeight,
            dwWidth: f_dwWidth,
            Anonymous1: f_Anonymous1,
            dwBackBufferCount: f_dwBackBufferCount,
            Anonymous2: f_Anonymous2,
            dwAlphaBitDepth: f_dwAlphaBitDepth,
            dwReserved: f_dwReserved,
            lpSurface: f_lpSurface,
            ddckCKDestOverlay: f_ddckCKDestOverlay,
            ddckCKDestBlt: f_ddckCKDestBlt,
            ddckCKSrcOverlay: f_ddckCKSrcOverlay,
            ddckCKSrcBlt: f_ddckCKSrcBlt,
            ddpfPixelFormat: f_ddpfPixelFormat,
            ddsCaps: f_ddsCaps,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 108);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwBackBufferCount, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBitDepth, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpSurface, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.ddckCKDestOverlay, &mut into[40..40 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKDestBlt, &mut into[48..48 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKSrcOverlay, &mut into[56..56 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKSrcBlt, &mut into[64..64 + 8]);
        FromIntoMemory::into_bytes(self.ddpfPixelFormat, &mut into[72..72 + 32]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[104..104 + 4]);
    }
    fn size() -> usize {
        108
    }
}
pub struct DDSURFACEDESC_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSURFACEDESC_0 {}
impl ::core::clone::Clone for DDSURFACEDESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC_0 {}
impl FromIntoMemory for DDSURFACEDESC_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSURFACEDESC_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSURFACEDESC_1 {}
impl ::core::clone::Clone for DDSURFACEDESC_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC_1 {}
impl FromIntoMemory for DDSURFACEDESC_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSURFACEDESC2 {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwHeight: u32,
    pub dwWidth: u32,
    pub Anonymous1: DDSURFACEDESC2_0,
    pub Anonymous2: DDSURFACEDESC2_1,
    pub Anonymous3: DDSURFACEDESC2_2,
    pub dwAlphaBitDepth: u32,
    pub dwReserved: u32,
    pub lpSurface: MutPtr<::core::ffi::c_void>,
    pub Anonymous4: DDSURFACEDESC2_3,
    pub ddckCKDestBlt: DDCOLORKEY,
    pub ddckCKSrcOverlay: DDCOLORKEY,
    pub ddckCKSrcBlt: DDCOLORKEY,
    pub Anonymous5: DDSURFACEDESC2_4,
    pub ddsCaps: DDSCAPS2,
    pub dwTextureStage: u32,
}
impl ::core::marker::Copy for DDSURFACEDESC2 {}
impl ::core::clone::Clone for DDSURFACEDESC2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC2 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dwHeight == other.dwHeight
            && self.dwWidth == other.dwWidth
            && self.Anonymous1 == other.Anonymous1
            && self.Anonymous2 == other.Anonymous2
            && self.Anonymous3 == other.Anonymous3
            && self.dwAlphaBitDepth == other.dwAlphaBitDepth
            && self.dwReserved == other.dwReserved
            && self.lpSurface == other.lpSurface
            && self.Anonymous4 == other.Anonymous4
            && self.ddckCKDestBlt == other.ddckCKDestBlt
            && self.ddckCKSrcOverlay == other.ddckCKSrcOverlay
            && self.ddckCKSrcBlt == other.ddckCKSrcBlt
            && self.Anonymous5 == other.Anonymous5
            && self.ddsCaps == other.ddsCaps
            && self.dwTextureStage == other.dwTextureStage
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC2 {}
impl FromIntoMemory for DDSURFACEDESC2 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 92);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_Anonymous1 = <DDSURFACEDESC2_0 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Anonymous2 = <DDSURFACEDESC2_1 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_Anonymous3 = <DDSURFACEDESC2_2 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwAlphaBitDepth = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpSurface =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_Anonymous4 = <DDSURFACEDESC2_3 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_ddckCKDestBlt = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[44..44 + 8]);
        let f_ddckCKSrcOverlay = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[52..52 + 8]);
        let f_ddckCKSrcBlt = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[60..60 + 8]);
        let f_Anonymous5 = <DDSURFACEDESC2_4 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_ddsCaps = <DDSCAPS2 as FromIntoMemory>::from_bytes(&from[72..72 + 16]);
        let f_dwTextureStage = <u32 as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            dwHeight: f_dwHeight,
            dwWidth: f_dwWidth,
            Anonymous1: f_Anonymous1,
            Anonymous2: f_Anonymous2,
            Anonymous3: f_Anonymous3,
            dwAlphaBitDepth: f_dwAlphaBitDepth,
            dwReserved: f_dwReserved,
            lpSurface: f_lpSurface,
            Anonymous4: f_Anonymous4,
            ddckCKDestBlt: f_ddckCKDestBlt,
            ddckCKSrcOverlay: f_ddckCKSrcOverlay,
            ddckCKSrcBlt: f_ddckCKSrcBlt,
            Anonymous5: f_Anonymous5,
            ddsCaps: f_ddsCaps,
            dwTextureStage: f_dwTextureStage,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 92);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous3, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaBitDepth, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpSurface, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous4, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.ddckCKDestBlt, &mut into[44..44 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKSrcOverlay, &mut into[52..52 + 8]);
        FromIntoMemory::into_bytes(self.ddckCKSrcBlt, &mut into[60..60 + 8]);
        FromIntoMemory::into_bytes(self.Anonymous5, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[72..72 + 16]);
        FromIntoMemory::into_bytes(self.dwTextureStage, &mut into[88..88 + 4]);
    }
    fn size() -> usize {
        92
    }
}
pub struct DDSURFACEDESC2_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSURFACEDESC2_0 {}
impl ::core::clone::Clone for DDSURFACEDESC2_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC2_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC2_0 {}
impl FromIntoMemory for DDSURFACEDESC2_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSURFACEDESC2_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSURFACEDESC2_1 {}
impl ::core::clone::Clone for DDSURFACEDESC2_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC2_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC2_1 {}
impl FromIntoMemory for DDSURFACEDESC2_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSURFACEDESC2_2 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSURFACEDESC2_2 {}
impl ::core::clone::Clone for DDSURFACEDESC2_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC2_2 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC2_2 {}
impl FromIntoMemory for DDSURFACEDESC2_2 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSURFACEDESC2_3 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSURFACEDESC2_3 {}
impl ::core::clone::Clone for DDSURFACEDESC2_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC2_3 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC2_3 {}
impl FromIntoMemory for DDSURFACEDESC2_3 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DDSURFACEDESC2_4 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DDSURFACEDESC2_4 {}
impl ::core::clone::Clone for DDSURFACEDESC2_4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DDSURFACEDESC2_4 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DDSURFACEDESC2_4 {}
impl FromIntoMemory for DDSURFACEDESC2_4 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub const DDSVCAPS_RESERVED1: i32 = 1i32;
pub const DDSVCAPS_RESERVED2: i32 = 2i32;
pub const DDSVCAPS_RESERVED3: i32 = 4i32;
pub const DDSVCAPS_RESERVED4: i32 = 8i32;
pub const DDSVCAPS_STEREOSEQUENTIAL: i32 = 16i32;
pub struct DDTRANSFERININFO {
    pub lpSurfaceData: MutPtr<DDSURFACEDATA>,
    pub dwStartLine: u32,
    pub dwEndLine: u32,
    pub dwTransferID: PtrRepr,
    pub dwTransferFlags: u32,
    pub lpDestMDL: MutPtr<MDL>,
}
impl ::core::marker::Copy for DDTRANSFERININFO {}
impl ::core::clone::Clone for DDTRANSFERININFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDTRANSFERININFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDTRANSFERININFO")
            .field("lpSurfaceData", &self.lpSurfaceData)
            .field("dwStartLine", &self.dwStartLine)
            .field("dwEndLine", &self.dwEndLine)
            .field("dwTransferID", &self.dwTransferID)
            .field("dwTransferFlags", &self.dwTransferFlags)
            .field("lpDestMDL", &self.lpDestMDL)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDTRANSFERININFO {
    fn eq(&self, other: &Self) -> bool {
        self.lpSurfaceData == other.lpSurfaceData
            && self.dwStartLine == other.dwStartLine
            && self.dwEndLine == other.dwEndLine
            && self.dwTransferID == other.dwTransferID
            && self.dwTransferFlags == other.dwTransferFlags
            && self.lpDestMDL == other.lpDestMDL
    }
}
impl ::core::cmp::Eq for DDTRANSFERININFO {}
impl FromIntoMemory for DDTRANSFERININFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpSurfaceData =
            <MutPtr<DDSURFACEDATA> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwStartLine = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwEndLine = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwTransferID = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwTransferFlags = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpDestMDL = <MutPtr<MDL> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpSurfaceData: f_lpSurfaceData,
            dwStartLine: f_dwStartLine,
            dwEndLine: f_dwEndLine,
            dwTransferID: f_dwTransferID,
            dwTransferFlags: f_dwTransferFlags,
            lpDestMDL: f_lpDestMDL,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpSurfaceData, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwStartLine, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwEndLine, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwTransferID, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwTransferFlags, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpDestMDL, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDTRANSFEROUTINFO {
    pub dwBufferPolarity: u32,
}
impl ::core::marker::Copy for DDTRANSFEROUTINFO {}
impl ::core::clone::Clone for DDTRANSFEROUTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDTRANSFEROUTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDTRANSFEROUTINFO")
            .field("dwBufferPolarity", &self.dwBufferPolarity)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDTRANSFEROUTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwBufferPolarity == other.dwBufferPolarity
    }
}
impl ::core::cmp::Eq for DDTRANSFEROUTINFO {}
impl FromIntoMemory for DDTRANSFEROUTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwBufferPolarity = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            dwBufferPolarity: f_dwBufferPolarity,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwBufferPolarity, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub const DDTRANSFER_CANCEL: u32 = 128u32;
pub const DDTRANSFER_HALFLINES: u32 = 256u32;
pub const DDTRANSFER_INVERT: u32 = 4u32;
pub const DDTRANSFER_NONLOCALVIDMEM: u32 = 2u32;
pub const DDTRANSFER_SYSTEMMEMORY: u32 = 1u32;
pub const DDUNSUPPORTEDMODE: u32 = 4294967295u32;
pub struct DDVERSIONDATA {
    pub dwHALVersion: u32,
    pub dwReserved1: PtrRepr,
    pub dwReserved2: PtrRepr,
}
impl ::core::marker::Copy for DDVERSIONDATA {}
impl ::core::clone::Clone for DDVERSIONDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVERSIONDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVERSIONDATA")
            .field("dwHALVersion", &self.dwHALVersion)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVERSIONDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwHALVersion == other.dwHALVersion
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
    }
}
impl ::core::cmp::Eq for DDVERSIONDATA {}
impl FromIntoMemory for DDVERSIONDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwHALVersion = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwHALVersion: f_dwHALVersion,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwHALVersion, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const DDVERSIONINFO: u32 = 13u32;
pub struct DDVIDEOPORTBANDWIDTH {
    pub dwSize: u32,
    pub dwCaps: u32,
    pub dwOverlay: u32,
    pub dwColorkey: u32,
    pub dwYInterpolate: u32,
    pub dwYInterpAndColorkey: u32,
    pub dwReserved1: PtrRepr,
    pub dwReserved2: PtrRepr,
}
impl ::core::marker::Copy for DDVIDEOPORTBANDWIDTH {}
impl ::core::clone::Clone for DDVIDEOPORTBANDWIDTH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTBANDWIDTH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTBANDWIDTH")
            .field("dwSize", &self.dwSize)
            .field("dwCaps", &self.dwCaps)
            .field("dwOverlay", &self.dwOverlay)
            .field("dwColorkey", &self.dwColorkey)
            .field("dwYInterpolate", &self.dwYInterpolate)
            .field("dwYInterpAndColorkey", &self.dwYInterpAndColorkey)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTBANDWIDTH {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwCaps == other.dwCaps
            && self.dwOverlay == other.dwOverlay
            && self.dwColorkey == other.dwColorkey
            && self.dwYInterpolate == other.dwYInterpolate
            && self.dwYInterpAndColorkey == other.dwYInterpAndColorkey
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTBANDWIDTH {}
impl FromIntoMemory for DDVIDEOPORTBANDWIDTH {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwOverlay = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwColorkey = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwYInterpolate = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwYInterpAndColorkey = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            dwSize: f_dwSize,
            dwCaps: f_dwCaps,
            dwOverlay: f_dwOverlay,
            dwColorkey: f_dwColorkey,
            dwYInterpolate: f_dwYInterpolate,
            dwYInterpAndColorkey: f_dwYInterpAndColorkey,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlay, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwColorkey, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwYInterpolate, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwYInterpAndColorkey, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DDVIDEOPORTCAPS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwMaxWidth: u32,
    pub dwMaxVBIWidth: u32,
    pub dwMaxHeight: u32,
    pub dwVideoPortID: u32,
    pub dwCaps: u32,
    pub dwFX: u32,
    pub dwNumAutoFlipSurfaces: u32,
    pub dwAlignVideoPortBoundary: u32,
    pub dwAlignVideoPortPrescaleWidth: u32,
    pub dwAlignVideoPortCropBoundary: u32,
    pub dwAlignVideoPortCropWidth: u32,
    pub dwPreshrinkXStep: u32,
    pub dwPreshrinkYStep: u32,
    pub dwNumVBIAutoFlipSurfaces: u32,
    pub dwNumPreferredAutoflip: u32,
    pub wNumFilterTapsX: u16,
    pub wNumFilterTapsY: u16,
}
impl ::core::marker::Copy for DDVIDEOPORTCAPS {}
impl ::core::clone::Clone for DDVIDEOPORTCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dwMaxWidth", &self.dwMaxWidth)
            .field("dwMaxVBIWidth", &self.dwMaxVBIWidth)
            .field("dwMaxHeight", &self.dwMaxHeight)
            .field("dwVideoPortID", &self.dwVideoPortID)
            .field("dwCaps", &self.dwCaps)
            .field("dwFX", &self.dwFX)
            .field("dwNumAutoFlipSurfaces", &self.dwNumAutoFlipSurfaces)
            .field("dwAlignVideoPortBoundary", &self.dwAlignVideoPortBoundary)
            .field(
                "dwAlignVideoPortPrescaleWidth",
                &self.dwAlignVideoPortPrescaleWidth,
            )
            .field(
                "dwAlignVideoPortCropBoundary",
                &self.dwAlignVideoPortCropBoundary,
            )
            .field("dwAlignVideoPortCropWidth", &self.dwAlignVideoPortCropWidth)
            .field("dwPreshrinkXStep", &self.dwPreshrinkXStep)
            .field("dwPreshrinkYStep", &self.dwPreshrinkYStep)
            .field("dwNumVBIAutoFlipSurfaces", &self.dwNumVBIAutoFlipSurfaces)
            .field("dwNumPreferredAutoflip", &self.dwNumPreferredAutoflip)
            .field("wNumFilterTapsX", &self.wNumFilterTapsX)
            .field("wNumFilterTapsY", &self.wNumFilterTapsY)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dwMaxWidth == other.dwMaxWidth
            && self.dwMaxVBIWidth == other.dwMaxVBIWidth
            && self.dwMaxHeight == other.dwMaxHeight
            && self.dwVideoPortID == other.dwVideoPortID
            && self.dwCaps == other.dwCaps
            && self.dwFX == other.dwFX
            && self.dwNumAutoFlipSurfaces == other.dwNumAutoFlipSurfaces
            && self.dwAlignVideoPortBoundary == other.dwAlignVideoPortBoundary
            && self.dwAlignVideoPortPrescaleWidth == other.dwAlignVideoPortPrescaleWidth
            && self.dwAlignVideoPortCropBoundary == other.dwAlignVideoPortCropBoundary
            && self.dwAlignVideoPortCropWidth == other.dwAlignVideoPortCropWidth
            && self.dwPreshrinkXStep == other.dwPreshrinkXStep
            && self.dwPreshrinkYStep == other.dwPreshrinkYStep
            && self.dwNumVBIAutoFlipSurfaces == other.dwNumVBIAutoFlipSurfaces
            && self.dwNumPreferredAutoflip == other.dwNumPreferredAutoflip
            && self.wNumFilterTapsX == other.wNumFilterTapsX
            && self.wNumFilterTapsY == other.wNumFilterTapsY
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTCAPS {}
impl FromIntoMemory for DDVIDEOPORTCAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 72);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwMaxWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwMaxVBIWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwMaxHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwVideoPortID = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwFX = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwNumAutoFlipSurfaces = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwAlignVideoPortBoundary = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwAlignVideoPortPrescaleWidth =
            <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_dwAlignVideoPortCropBoundary = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwAlignVideoPortCropWidth = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwPreshrinkXStep = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwPreshrinkYStep = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwNumVBIAutoFlipSurfaces = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwNumPreferredAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_wNumFilterTapsX = <u16 as FromIntoMemory>::from_bytes(&from[68..68 + 2]);
        let f_wNumFilterTapsY = <u16 as FromIntoMemory>::from_bytes(&from[70..70 + 2]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            dwMaxWidth: f_dwMaxWidth,
            dwMaxVBIWidth: f_dwMaxVBIWidth,
            dwMaxHeight: f_dwMaxHeight,
            dwVideoPortID: f_dwVideoPortID,
            dwCaps: f_dwCaps,
            dwFX: f_dwFX,
            dwNumAutoFlipSurfaces: f_dwNumAutoFlipSurfaces,
            dwAlignVideoPortBoundary: f_dwAlignVideoPortBoundary,
            dwAlignVideoPortPrescaleWidth: f_dwAlignVideoPortPrescaleWidth,
            dwAlignVideoPortCropBoundary: f_dwAlignVideoPortCropBoundary,
            dwAlignVideoPortCropWidth: f_dwAlignVideoPortCropWidth,
            dwPreshrinkXStep: f_dwPreshrinkXStep,
            dwPreshrinkYStep: f_dwPreshrinkYStep,
            dwNumVBIAutoFlipSurfaces: f_dwNumVBIAutoFlipSurfaces,
            dwNumPreferredAutoflip: f_dwNumPreferredAutoflip,
            wNumFilterTapsX: f_wNumFilterTapsX,
            wNumFilterTapsY: f_wNumFilterTapsY,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 72);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxVBIWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwVideoPortID, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwFX, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwNumAutoFlipSurfaces, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignVideoPortBoundary, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignVideoPortPrescaleWidth, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignVideoPortCropBoundary, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwAlignVideoPortCropWidth, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwPreshrinkXStep, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwPreshrinkYStep, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwNumVBIAutoFlipSurfaces, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwNumPreferredAutoflip, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.wNumFilterTapsX, &mut into[68..68 + 2]);
        FromIntoMemory::into_bytes(self.wNumFilterTapsY, &mut into[70..70 + 2]);
    }
    fn size() -> usize {
        72
    }
}
pub struct DDVIDEOPORTCONNECT {
    pub dwSize: u32,
    pub dwPortWidth: u32,
    pub guidTypeID: crate::core::GUID,
    pub dwFlags: u32,
    pub dwReserved1: PtrRepr,
}
impl ::core::marker::Copy for DDVIDEOPORTCONNECT {}
impl ::core::clone::Clone for DDVIDEOPORTCONNECT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTCONNECT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTCONNECT")
            .field("dwSize", &self.dwSize)
            .field("dwPortWidth", &self.dwPortWidth)
            .field("guidTypeID", &self.guidTypeID)
            .field("dwFlags", &self.dwFlags)
            .field("dwReserved1", &self.dwReserved1)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTCONNECT {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwPortWidth == other.dwPortWidth
            && self.guidTypeID == other.guidTypeID
            && self.dwFlags == other.dwFlags
            && self.dwReserved1 == other.dwReserved1
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTCONNECT {}
impl FromIntoMemory for DDVIDEOPORTCONNECT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwPortWidth = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_guidTypeID = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            dwSize: f_dwSize,
            dwPortWidth: f_dwPortWidth,
            guidTypeID: f_guidTypeID,
            dwFlags: f_dwFlags,
            dwReserved1: f_dwReserved1,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwPortWidth, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.guidTypeID, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DDVIDEOPORTDATA {
    pub dwVideoPortId: u32,
    pub dwVPFlags: u32,
    pub dwOriginOffset: u32,
    pub dwHeight: u32,
    pub dwVBIHeight: u32,
    pub dwDriverReserved1: u32,
    pub dwDriverReserved2: u32,
    pub dwDriverReserved3: u32,
}
impl ::core::marker::Copy for DDVIDEOPORTDATA {}
impl ::core::clone::Clone for DDVIDEOPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTDATA")
            .field("dwVideoPortId", &self.dwVideoPortId)
            .field("dwVPFlags", &self.dwVPFlags)
            .field("dwOriginOffset", &self.dwOriginOffset)
            .field("dwHeight", &self.dwHeight)
            .field("dwVBIHeight", &self.dwVBIHeight)
            .field("dwDriverReserved1", &self.dwDriverReserved1)
            .field("dwDriverReserved2", &self.dwDriverReserved2)
            .field("dwDriverReserved3", &self.dwDriverReserved3)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwVideoPortId == other.dwVideoPortId
            && self.dwVPFlags == other.dwVPFlags
            && self.dwOriginOffset == other.dwOriginOffset
            && self.dwHeight == other.dwHeight
            && self.dwVBIHeight == other.dwVBIHeight
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTDATA {}
impl FromIntoMemory for DDVIDEOPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_dwVideoPortId = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwVPFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwOriginOffset = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwVBIHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwDriverReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwDriverReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwDriverReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            dwVideoPortId: f_dwVideoPortId,
            dwVPFlags: f_dwVPFlags,
            dwOriginOffset: f_dwOriginOffset,
            dwHeight: f_dwHeight,
            dwVBIHeight: f_dwVBIHeight,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.dwVideoPortId, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwVPFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwOriginOffset, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwVBIHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DDVIDEOPORTDESC {
    pub dwSize: u32,
    pub dwFieldWidth: u32,
    pub dwVBIWidth: u32,
    pub dwFieldHeight: u32,
    pub dwMicrosecondsPerField: u32,
    pub dwMaxPixelsPerSecond: u32,
    pub dwVideoPortID: u32,
    pub dwReserved1: u32,
    pub VideoPortType: DDVIDEOPORTCONNECT,
    pub dwReserved2: PtrRepr,
    pub dwReserved3: PtrRepr,
}
impl ::core::marker::Copy for DDVIDEOPORTDESC {}
impl ::core::clone::Clone for DDVIDEOPORTDESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTDESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTDESC")
            .field("dwSize", &self.dwSize)
            .field("dwFieldWidth", &self.dwFieldWidth)
            .field("dwVBIWidth", &self.dwVBIWidth)
            .field("dwFieldHeight", &self.dwFieldHeight)
            .field("dwMicrosecondsPerField", &self.dwMicrosecondsPerField)
            .field("dwMaxPixelsPerSecond", &self.dwMaxPixelsPerSecond)
            .field("dwVideoPortID", &self.dwVideoPortID)
            .field("dwReserved1", &self.dwReserved1)
            .field("VideoPortType", &self.VideoPortType)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTDESC {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFieldWidth == other.dwFieldWidth
            && self.dwVBIWidth == other.dwVBIWidth
            && self.dwFieldHeight == other.dwFieldHeight
            && self.dwMicrosecondsPerField == other.dwMicrosecondsPerField
            && self.dwMaxPixelsPerSecond == other.dwMaxPixelsPerSecond
            && self.dwVideoPortID == other.dwVideoPortID
            && self.dwReserved1 == other.dwReserved1
            && self.VideoPortType == other.VideoPortType
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTDESC {}
impl FromIntoMemory for DDVIDEOPORTDESC {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 72);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFieldWidth = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwVBIWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFieldHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwMicrosecondsPerField = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwMaxPixelsPerSecond = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwVideoPortID = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_VideoPortType =
            <DDVIDEOPORTCONNECT as FromIntoMemory>::from_bytes(&from[32..32 + 32]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwReserved3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFieldWidth: f_dwFieldWidth,
            dwVBIWidth: f_dwVBIWidth,
            dwFieldHeight: f_dwFieldHeight,
            dwMicrosecondsPerField: f_dwMicrosecondsPerField,
            dwMaxPixelsPerSecond: f_dwMaxPixelsPerSecond,
            dwVideoPortID: f_dwVideoPortID,
            dwReserved1: f_dwReserved1,
            VideoPortType: f_VideoPortType,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 72);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFieldWidth, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwVBIWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFieldHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwMicrosecondsPerField, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwMaxPixelsPerSecond, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwVideoPortID, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.VideoPortType, &mut into[32..32 + 32]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[68..68 + 4]);
    }
    fn size() -> usize {
        72
    }
}
pub struct DDVIDEOPORTINFO {
    pub dwSize: u32,
    pub dwOriginX: u32,
    pub dwOriginY: u32,
    pub dwVPFlags: u32,
    pub rCrop: super::super::Foundation::RECT,
    pub dwPrescaleWidth: u32,
    pub dwPrescaleHeight: u32,
    pub lpddpfInputFormat: MutPtr<DDPIXELFORMAT>,
    pub lpddpfVBIInputFormat: MutPtr<DDPIXELFORMAT>,
    pub lpddpfVBIOutputFormat: MutPtr<DDPIXELFORMAT>,
    pub dwVBIHeight: u32,
    pub dwReserved1: PtrRepr,
    pub dwReserved2: PtrRepr,
}
impl ::core::marker::Copy for DDVIDEOPORTINFO {}
impl ::core::clone::Clone for DDVIDEOPORTINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTINFO")
            .field("dwSize", &self.dwSize)
            .field("dwOriginX", &self.dwOriginX)
            .field("dwOriginY", &self.dwOriginY)
            .field("dwVPFlags", &self.dwVPFlags)
            .field("rCrop", &self.rCrop)
            .field("dwPrescaleWidth", &self.dwPrescaleWidth)
            .field("dwPrescaleHeight", &self.dwPrescaleHeight)
            .field("lpddpfInputFormat", &self.lpddpfInputFormat)
            .field("lpddpfVBIInputFormat", &self.lpddpfVBIInputFormat)
            .field("lpddpfVBIOutputFormat", &self.lpddpfVBIOutputFormat)
            .field("dwVBIHeight", &self.dwVBIHeight)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwOriginX == other.dwOriginX
            && self.dwOriginY == other.dwOriginY
            && self.dwVPFlags == other.dwVPFlags
            && self.rCrop == other.rCrop
            && self.dwPrescaleWidth == other.dwPrescaleWidth
            && self.dwPrescaleHeight == other.dwPrescaleHeight
            && self.lpddpfInputFormat == other.lpddpfInputFormat
            && self.lpddpfVBIInputFormat == other.lpddpfVBIInputFormat
            && self.lpddpfVBIOutputFormat == other.lpddpfVBIOutputFormat
            && self.dwVBIHeight == other.dwVBIHeight
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTINFO {}
impl FromIntoMemory for DDVIDEOPORTINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 64);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwOriginX = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwOriginY = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwVPFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_rCrop =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[16..16 + 16]);
        let f_dwPrescaleWidth = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwPrescaleHeight = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpddpfInputFormat =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpddpfVBIInputFormat =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_lpddpfVBIOutputFormat =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwVBIHeight = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        Self {
            dwSize: f_dwSize,
            dwOriginX: f_dwOriginX,
            dwOriginY: f_dwOriginY,
            dwVPFlags: f_dwVPFlags,
            rCrop: f_rCrop,
            dwPrescaleWidth: f_dwPrescaleWidth,
            dwPrescaleHeight: f_dwPrescaleHeight,
            lpddpfInputFormat: f_lpddpfInputFormat,
            lpddpfVBIInputFormat: f_lpddpfVBIInputFormat,
            lpddpfVBIOutputFormat: f_lpddpfVBIOutputFormat,
            dwVBIHeight: f_dwVBIHeight,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 64);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwOriginX, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwOriginY, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwVPFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.rCrop, &mut into[16..16 + 16]);
        FromIntoMemory::into_bytes(self.dwPrescaleWidth, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwPrescaleHeight, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfInputFormat, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfVBIInputFormat, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfVBIOutputFormat, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwVBIHeight, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[60..60 + 4]);
    }
    fn size() -> usize {
        64
    }
}
pub struct DDVIDEOPORTNOTIFY {
    pub ApproximateTimeStamp: i64,
    pub lField: i32,
    pub dwSurfaceIndex: u32,
    pub lDone: i32,
}
impl ::core::marker::Copy for DDVIDEOPORTNOTIFY {}
impl ::core::clone::Clone for DDVIDEOPORTNOTIFY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTNOTIFY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTNOTIFY")
            .field("ApproximateTimeStamp", &self.ApproximateTimeStamp)
            .field("lField", &self.lField)
            .field("dwSurfaceIndex", &self.dwSurfaceIndex)
            .field("lDone", &self.lDone)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTNOTIFY {
    fn eq(&self, other: &Self) -> bool {
        self.ApproximateTimeStamp == other.ApproximateTimeStamp
            && self.lField == other.lField
            && self.dwSurfaceIndex == other.dwSurfaceIndex
            && self.lDone == other.lDone
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTNOTIFY {}
impl FromIntoMemory for DDVIDEOPORTNOTIFY {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_ApproximateTimeStamp = <i64 as FromIntoMemory>::from_bytes(&from[0..0 + 8]);
        let f_lField = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwSurfaceIndex = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lDone = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            ApproximateTimeStamp: f_ApproximateTimeStamp,
            lField: f_lField,
            dwSurfaceIndex: f_dwSurfaceIndex,
            lDone: f_lDone,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.ApproximateTimeStamp, &mut into[0..0 + 8]);
        FromIntoMemory::into_bytes(self.lField, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwSurfaceIndex, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lDone, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DDVIDEOPORTSTATUS {
    pub dwSize: u32,
    pub bInUse: super::super::Foundation::BOOL,
    pub dwFlags: u32,
    pub dwReserved1: u32,
    pub VideoPortType: DDVIDEOPORTCONNECT,
    pub dwReserved2: PtrRepr,
    pub dwReserved3: PtrRepr,
}
impl ::core::marker::Copy for DDVIDEOPORTSTATUS {}
impl ::core::clone::Clone for DDVIDEOPORTSTATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DDVIDEOPORTSTATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DDVIDEOPORTSTATUS")
            .field("dwSize", &self.dwSize)
            .field("bInUse", &self.bInUse)
            .field("dwFlags", &self.dwFlags)
            .field("dwReserved1", &self.dwReserved1)
            .field("VideoPortType", &self.VideoPortType)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DDVIDEOPORTSTATUS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.bInUse == other.bInUse
            && self.dwFlags == other.dwFlags
            && self.dwReserved1 == other.dwReserved1
            && self.VideoPortType == other.VideoPortType
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
    }
}
impl ::core::cmp::Eq for DDVIDEOPORTSTATUS {}
impl FromIntoMemory for DDVIDEOPORTSTATUS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 56);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_bInUse =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_VideoPortType =
            <DDVIDEOPORTCONNECT as FromIntoMemory>::from_bytes(&from[16..16 + 32]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwReserved3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        Self {
            dwSize: f_dwSize,
            bInUse: f_bInUse,
            dwFlags: f_dwFlags,
            dwReserved1: f_dwReserved1,
            VideoPortType: f_VideoPortType,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 56);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.bInUse, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.VideoPortType, &mut into[16..16 + 32]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[52..52 + 4]);
    }
    fn size() -> usize {
        56
    }
}
pub const DDVPBCAPS_DESTINATION: i32 = 2i32;
pub const DDVPBCAPS_SOURCE: i32 = 1i32;
pub const DDVPB_OVERLAY: i32 = 2i32;
pub const DDVPB_TYPE: i32 = 4i32;
pub const DDVPB_VIDEOPORT: i32 = 1i32;
pub const DDVPCAPS_AUTOFLIP: i32 = 1i32;
pub const DDVPCAPS_COLORCONTROL: i32 = 1024i32;
pub const DDVPCAPS_HARDWAREDEINTERLACE: i32 = 16384i32;
pub const DDVPCAPS_INTERLACED: i32 = 2i32;
pub const DDVPCAPS_NONINTERLACED: i32 = 4i32;
pub const DDVPCAPS_OVERSAMPLEDVBI: i32 = 2048i32;
pub const DDVPCAPS_READBACKFIELD: i32 = 8i32;
pub const DDVPCAPS_READBACKLINE: i32 = 16i32;
pub const DDVPCAPS_SHAREABLE: i32 = 32i32;
pub const DDVPCAPS_SKIPEVENFIELDS: i32 = 64i32;
pub const DDVPCAPS_SKIPODDFIELDS: i32 = 128i32;
pub const DDVPCAPS_SYNCMASTER: i32 = 256i32;
pub const DDVPCAPS_SYSTEMMEMORY: i32 = 4096i32;
pub const DDVPCAPS_VBIANDVIDEOINDEPENDENT: i32 = 8192i32;
pub const DDVPCAPS_VBISURFACE: i32 = 512i32;
pub const DDVPCONNECT_DISCARDSVREFDATA: i32 = 8i32;
pub const DDVPCONNECT_DOUBLECLOCK: i32 = 1i32;
pub const DDVPCONNECT_HALFLINE: i32 = 16i32;
pub const DDVPCONNECT_INTERLACED: i32 = 32i32;
pub const DDVPCONNECT_INVERTPOLARITY: i32 = 4i32;
pub const DDVPCONNECT_SHAREEVEN: i32 = 64i32;
pub const DDVPCONNECT_SHAREODD: i32 = 128i32;
pub const DDVPCONNECT_VACT: i32 = 2i32;
pub const DDVPCREATE_VBIONLY: i32 = 1i32;
pub const DDVPCREATE_VIDEOONLY: i32 = 2i32;
pub const DDVPD_ALIGN: i32 = 64i32;
pub const DDVPD_AUTOFLIP: i32 = 32i32;
pub const DDVPD_CAPS: i32 = 8i32;
pub const DDVPD_FILTERQUALITY: i32 = 256i32;
pub const DDVPD_FX: i32 = 16i32;
pub const DDVPD_HEIGHT: i32 = 2i32;
pub const DDVPD_ID: i32 = 4i32;
pub const DDVPD_PREFERREDAUTOFLIP: i32 = 128i32;
pub const DDVPD_WIDTH: i32 = 1i32;
pub const DDVPFLIP_VBI: i32 = 2i32;
pub const DDVPFLIP_VIDEO: i32 = 1i32;
pub const DDVPFORMAT_VBI: i32 = 2i32;
pub const DDVPFORMAT_VIDEO: i32 = 1i32;
pub const DDVPFX_CROPTOPDATA: i32 = 1i32;
pub const DDVPFX_CROPX: i32 = 2i32;
pub const DDVPFX_CROPY: i32 = 4i32;
pub const DDVPFX_IGNOREVBIXCROP: i32 = 262144i32;
pub const DDVPFX_INTERLEAVE: i32 = 8i32;
pub const DDVPFX_MIRRORLEFTRIGHT: i32 = 16i32;
pub const DDVPFX_MIRRORUPDOWN: i32 = 32i32;
pub const DDVPFX_PRESHRINKX: i32 = 64i32;
pub const DDVPFX_PRESHRINKXB: i32 = 256i32;
pub const DDVPFX_PRESHRINKXS: i32 = 1024i32;
pub const DDVPFX_PRESHRINKY: i32 = 128i32;
pub const DDVPFX_PRESHRINKYB: i32 = 512i32;
pub const DDVPFX_PRESHRINKYS: i32 = 2048i32;
pub const DDVPFX_PRESTRETCHX: i32 = 4096i32;
pub const DDVPFX_PRESTRETCHXN: i32 = 16384i32;
pub const DDVPFX_PRESTRETCHY: i32 = 8192i32;
pub const DDVPFX_PRESTRETCHYN: i32 = 32768i32;
pub const DDVPFX_VBICONVERT: i32 = 65536i32;
pub const DDVPFX_VBINOINTERLEAVE: i32 = 524288i32;
pub const DDVPFX_VBINOSCALE: i32 = 131072i32;
pub const DDVPSQ_NOSIGNAL: i32 = 1i32;
pub const DDVPSQ_SIGNALOK: i32 = 2i32;
pub const DDVPSTATUS_VBIONLY: i32 = 1i32;
pub const DDVPSTATUS_VIDEOONLY: i32 = 2i32;
pub const DDVPTARGET_VBI: i32 = 2i32;
pub const DDVPTARGET_VIDEO: i32 = 1i32;
pub const DDVPTYPE_BROOKTREE: crate::core::GUID =
    crate::core::GUID::from_u128(0x1352a560_da61_11cf_9b06_00a0c903a3b8);
pub const DDVPTYPE_CCIR656: crate::core::GUID =
    crate::core::GUID::from_u128(0xfca326a0_da60_11cf_9b06_00a0c903a3b8);
pub const DDVPTYPE_E_HREFH_VREFH: crate::core::GUID =
    crate::core::GUID::from_u128(0x54f39980_da60_11cf_9b06_00a0c903a3b8);
pub const DDVPTYPE_E_HREFH_VREFL: crate::core::GUID =
    crate::core::GUID::from_u128(0x92783220_da60_11cf_9b06_00a0c903a3b8);
pub const DDVPTYPE_E_HREFL_VREFH: crate::core::GUID =
    crate::core::GUID::from_u128(0xa07a02e0_da60_11cf_9b06_00a0c903a3b8);
pub const DDVPTYPE_E_HREFL_VREFL: crate::core::GUID =
    crate::core::GUID::from_u128(0xe09c77e0_da60_11cf_9b06_00a0c903a3b8);
pub const DDVPTYPE_PHILIPS: crate::core::GUID =
    crate::core::GUID::from_u128(0x332cf160_da61_11cf_9b06_00a0c903a3b8);
pub const DDVPWAIT_BEGIN: i32 = 1i32;
pub const DDVPWAIT_END: i32 = 2i32;
pub const DDVPWAIT_LINE: i32 = 3i32;
pub const DDVP_AUTOFLIP: i32 = 1i32;
pub const DDVP_CONVERT: i32 = 2i32;
pub const DDVP_CROP: i32 = 4i32;
pub const DDVP_HARDWAREDEINTERLACE: i32 = 32768i32;
pub const DDVP_IGNOREVBIXCROP: i32 = 8192i32;
pub const DDVP_INTERLEAVE: i32 = 8i32;
pub const DDVP_MIRRORLEFTRIGHT: i32 = 16i32;
pub const DDVP_MIRRORUPDOWN: i32 = 32i32;
pub const DDVP_OVERRIDEBOBWEAVE: i32 = 4096i32;
pub const DDVP_PRESCALE: i32 = 64i32;
pub const DDVP_SKIPEVENFIELDS: i32 = 128i32;
pub const DDVP_SKIPODDFIELDS: i32 = 256i32;
pub const DDVP_SYNCMASTER: i32 = 512i32;
pub const DDVP_VBICONVERT: i32 = 1024i32;
pub const DDVP_VBINOINTERLEAVE: i32 = 16384i32;
pub const DDVP_VBINOSCALE: i32 = 2048i32;
pub const DDWAITVB_BLOCKBEGIN: i32 = 1i32;
pub const DDWAITVB_BLOCKBEGINEVENT: i32 = 2i32;
pub const DDWAITVB_BLOCKEND: i32 = 4i32;
pub const DDWAITVB_I_TESTVB: i32 = -2147483642i32;
pub struct DD_ADDATTACHEDSURFACEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub lpSurfAttached: MutPtr<DD_SURFACE_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub AddAttachedSurface: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_ADDATTACHEDSURFACEDATA {}
impl ::core::clone::Clone for DD_ADDATTACHEDSURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_ADDATTACHEDSURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_ADDATTACHEDSURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("lpSurfAttached", &self.lpSurfAttached)
            .field("ddRVal", &self.ddRVal)
            .field("AddAttachedSurface", &self.AddAttachedSurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_ADDATTACHEDSURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.lpSurfAttached == other.lpSurfAttached
            && self.ddRVal == other.ddRVal
            && self.AddAttachedSurface == other.AddAttachedSurface
    }
}
impl ::core::cmp::Eq for DD_ADDATTACHEDSURFACEDATA {}
impl FromIntoMemory for DD_ADDATTACHEDSURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurfAttached =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_AddAttachedSurface =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            lpSurfAttached: f_lpSurfAttached,
            ddRVal: f_ddRVal,
            AddAttachedSurface: f_AddAttachedSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfAttached, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.AddAttachedSurface, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_ATTACHLIST {
    pub lpLink: MutPtr<DD_ATTACHLIST>,
    pub lpAttached: MutPtr<DD_SURFACE_LOCAL>,
}
impl ::core::marker::Copy for DD_ATTACHLIST {}
impl ::core::clone::Clone for DD_ATTACHLIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_ATTACHLIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_ATTACHLIST")
            .field("lpLink", &self.lpLink)
            .field("lpAttached", &self.lpAttached)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_ATTACHLIST {
    fn eq(&self, other: &Self) -> bool {
        self.lpLink == other.lpLink && self.lpAttached == other.lpAttached
    }
}
impl ::core::cmp::Eq for DD_ATTACHLIST {}
impl FromIntoMemory for DD_ATTACHLIST {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_lpLink = <MutPtr<DD_ATTACHLIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpAttached =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            lpLink: f_lpLink,
            lpAttached: f_lpAttached,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpAttached, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub struct DD_BEGINMOCOMPFRAMEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpMoComp: MutPtr<DD_MOTIONCOMP_LOCAL>,
    pub lpDestSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwInputDataSize: u32,
    pub lpInputData: MutPtr<::core::ffi::c_void>,
    pub dwOutputDataSize: u32,
    pub lpOutputData: MutPtr<::core::ffi::c_void>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_BEGINMOCOMPFRAMEDATA {}
impl ::core::clone::Clone for DD_BEGINMOCOMPFRAMEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_BEGINMOCOMPFRAMEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_BEGINMOCOMPFRAMEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("lpDestSurface", &self.lpDestSurface)
            .field("dwInputDataSize", &self.dwInputDataSize)
            .field("lpInputData", &self.lpInputData)
            .field("dwOutputDataSize", &self.dwOutputDataSize)
            .field("lpOutputData", &self.lpOutputData)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_BEGINMOCOMPFRAMEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpDestSurface == other.lpDestSurface
            && self.dwInputDataSize == other.dwInputDataSize
            && self.lpInputData == other.lpInputData
            && self.dwOutputDataSize == other.dwOutputDataSize
            && self.lpOutputData == other.lpOutputData
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_BEGINMOCOMPFRAMEDATA {}
impl FromIntoMemory for DD_BEGINMOCOMPFRAMEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DD_MOTIONCOMP_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDestSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwInputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpInputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwOutputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpOutputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpDestSurface: f_lpDestSurface,
            dwInputDataSize: f_dwInputDataSize,
            lpInputData: f_lpInputData,
            dwOutputDataSize: f_dwOutputDataSize,
            lpOutputData: f_lpOutputData,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDestSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwInputDataSize, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpInputData, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwOutputDataSize, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpOutputData, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DD_BLTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDDestSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub rDest: super::super::Foundation::RECTL,
    pub lpDDSrcSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub rSrc: super::super::Foundation::RECTL,
    pub dwFlags: u32,
    pub dwROPFlags: u32,
    pub bltFX: DDBLTFX,
    pub ddRVal: crate::core::HRESULT,
    pub Blt: MutPtr<::core::ffi::c_void>,
    pub IsClipped: super::super::Foundation::BOOL,
    pub rOrigDest: super::super::Foundation::RECTL,
    pub rOrigSrc: super::super::Foundation::RECTL,
    pub dwRectCnt: u32,
    pub prDestRects: MutPtr<super::super::Foundation::RECT>,
    pub dwAFlags: u32,
    pub ddargbScaleFactors: DDARGB,
}
impl ::core::marker::Copy for DD_BLTDATA {}
impl ::core::clone::Clone for DD_BLTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_BLTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDDestSurface == other.lpDDDestSurface
            && self.rDest == other.rDest
            && self.lpDDSrcSurface == other.lpDDSrcSurface
            && self.rSrc == other.rSrc
            && self.dwFlags == other.dwFlags
            && self.dwROPFlags == other.dwROPFlags
            && self.bltFX == other.bltFX
            && self.ddRVal == other.ddRVal
            && self.Blt == other.Blt
            && self.IsClipped == other.IsClipped
            && self.rOrigDest == other.rOrigDest
            && self.rOrigSrc == other.rOrigSrc
            && self.dwRectCnt == other.dwRectCnt
            && self.prDestRects == other.prDestRects
            && self.dwAFlags == other.dwAFlags
            && self.ddargbScaleFactors == other.ddargbScaleFactors
    }
}
impl ::core::cmp::Eq for DD_BLTDATA {}
impl FromIntoMemory for DD_BLTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 212);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDDestSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_rDest =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_lpDDSrcSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_rSrc =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[28..28 + 16]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwROPFlags = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_bltFX = <DDBLTFX as FromIntoMemory>::from_bytes(&from[52..52 + 100]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_Blt =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_IsClipped =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_rOrigDest =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[164..164 + 16]);
        let f_rOrigSrc =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[180..180 + 16]);
        let f_dwRectCnt = <u32 as FromIntoMemory>::from_bytes(&from[196..196 + 4]);
        let f_prDestRects = <MutPtr<super::super::Foundation::RECT> as FromIntoMemory>::from_bytes(
            &from[200..200 + 4],
        );
        let f_dwAFlags = <u32 as FromIntoMemory>::from_bytes(&from[204..204 + 4]);
        let f_ddargbScaleFactors = <DDARGB as FromIntoMemory>::from_bytes(&from[208..208 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDDestSurface: f_lpDDDestSurface,
            rDest: f_rDest,
            lpDDSrcSurface: f_lpDDSrcSurface,
            rSrc: f_rSrc,
            dwFlags: f_dwFlags,
            dwROPFlags: f_dwROPFlags,
            bltFX: f_bltFX,
            ddRVal: f_ddRVal,
            Blt: f_Blt,
            IsClipped: f_IsClipped,
            rOrigDest: f_rOrigDest,
            rOrigSrc: f_rOrigSrc,
            dwRectCnt: f_dwRectCnt,
            prDestRects: f_prDestRects,
            dwAFlags: f_dwAFlags,
            ddargbScaleFactors: f_ddargbScaleFactors,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 212);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDDestSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.rDest, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.lpDDSrcSurface, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.rSrc, &mut into[28..28 + 16]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwROPFlags, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.bltFX, &mut into[52..52 + 100]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.Blt, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.IsClipped, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.rOrigDest, &mut into[164..164 + 16]);
        FromIntoMemory::into_bytes(self.rOrigSrc, &mut into[180..180 + 16]);
        FromIntoMemory::into_bytes(self.dwRectCnt, &mut into[196..196 + 4]);
        FromIntoMemory::into_bytes(self.prDestRects, &mut into[200..200 + 4]);
        FromIntoMemory::into_bytes(self.dwAFlags, &mut into[204..204 + 4]);
        FromIntoMemory::into_bytes(self.ddargbScaleFactors, &mut into[208..208 + 4]);
    }
    fn size() -> usize {
        212
    }
}
pub struct DD_CALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub DestroyDriver: PDD_DESTROYDRIVER,
    pub CreateSurface: PDD_CREATESURFACE,
    pub SetColorKey: PDD_SETCOLORKEY,
    pub SetMode: PDD_SETMODE,
    pub WaitForVerticalBlank: PDD_WAITFORVERTICALBLANK,
    pub CanCreateSurface: PDD_CANCREATESURFACE,
    pub CreatePalette: PDD_CREATEPALETTE,
    pub GetScanLine: PDD_GETSCANLINE,
    pub MapMemory: PDD_MAPMEMORY,
}
impl ::core::marker::Copy for DD_CALLBACKS {}
impl ::core::clone::Clone for DD_CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("DestroyDriver", &self.DestroyDriver)
            .field("CreateSurface", &self.CreateSurface)
            .field("SetColorKey", &self.SetColorKey)
            .field("SetMode", &self.SetMode)
            .field("WaitForVerticalBlank", &self.WaitForVerticalBlank)
            .field("CanCreateSurface", &self.CanCreateSurface)
            .field("CreatePalette", &self.CreatePalette)
            .field("GetScanLine", &self.GetScanLine)
            .field("MapMemory", &self.MapMemory)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.DestroyDriver == other.DestroyDriver
            && self.CreateSurface == other.CreateSurface
            && self.SetColorKey == other.SetColorKey
            && self.SetMode == other.SetMode
            && self.WaitForVerticalBlank == other.WaitForVerticalBlank
            && self.CanCreateSurface == other.CanCreateSurface
            && self.CreatePalette == other.CreatePalette
            && self.GetScanLine == other.GetScanLine
            && self.MapMemory == other.MapMemory
    }
}
impl ::core::cmp::Eq for DD_CALLBACKS {}
impl FromIntoMemory for DD_CALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DestroyDriver = <PDD_DESTROYDRIVER as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateSurface = <PDD_CREATESURFACE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetColorKey = <PDD_SETCOLORKEY as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_SetMode = <PDD_SETMODE as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_WaitForVerticalBlank =
            <PDD_WAITFORVERTICALBLANK as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_CanCreateSurface =
            <PDD_CANCREATESURFACE as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_CreatePalette = <PDD_CREATEPALETTE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_GetScanLine = <PDD_GETSCANLINE as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_MapMemory = <PDD_MAPMEMORY as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            DestroyDriver: f_DestroyDriver,
            CreateSurface: f_CreateSurface,
            SetColorKey: f_SetColorKey,
            SetMode: f_SetMode,
            WaitForVerticalBlank: f_WaitForVerticalBlank,
            CanCreateSurface: f_CanCreateSurface,
            CreatePalette: f_CreatePalette,
            GetScanLine: f_GetScanLine,
            MapMemory: f_MapMemory,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DestroyDriver, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateSurface, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.SetMode, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.WaitForVerticalBlank, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateSurface, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.CreatePalette, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.GetScanLine, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.MapMemory, &mut into[40..40 + 4]);
    }
    fn size() -> usize {
        44
    }
}
pub struct DD_CANCREATESURFACEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurfaceDesc: MutPtr<DDSURFACEDESC>,
    pub bIsDifferentPixelFormat: u32,
    pub ddRVal: crate::core::HRESULT,
    pub CanCreateSurface: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_CANCREATESURFACEDATA {}
impl ::core::clone::Clone for DD_CANCREATESURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CANCREATESURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CANCREATESURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurfaceDesc", &self.lpDDSurfaceDesc)
            .field("bIsDifferentPixelFormat", &self.bIsDifferentPixelFormat)
            .field("ddRVal", &self.ddRVal)
            .field("CanCreateSurface", &self.CanCreateSurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CANCREATESURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurfaceDesc == other.lpDDSurfaceDesc
            && self.bIsDifferentPixelFormat == other.bIsDifferentPixelFormat
            && self.ddRVal == other.ddRVal
            && self.CanCreateSurface == other.CanCreateSurface
    }
}
impl ::core::cmp::Eq for DD_CANCREATESURFACEDATA {}
impl FromIntoMemory for DD_CANCREATESURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurfaceDesc =
            <MutPtr<DDSURFACEDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bIsDifferentPixelFormat = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CanCreateSurface =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurfaceDesc: f_lpDDSurfaceDesc,
            bIsDifferentPixelFormat: f_bIsDifferentPixelFormat,
            ddRVal: f_ddRVal,
            CanCreateSurface: f_CanCreateSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurfaceDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bIsDifferentPixelFormat, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateSurface, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_CANCREATEVPORTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpDDVideoPortDesc: MutPtr<DDVIDEOPORTDESC>,
    pub ddRVal: crate::core::HRESULT,
    pub CanCreateVideoPort: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_CANCREATEVPORTDATA {}
impl ::core::clone::Clone for DD_CANCREATEVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CANCREATEVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CANCREATEVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDVideoPortDesc", &self.lpDDVideoPortDesc)
            .field("ddRVal", &self.ddRVal)
            .field("CanCreateVideoPort", &self.CanCreateVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CANCREATEVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDVideoPortDesc == other.lpDDVideoPortDesc
            && self.ddRVal == other.ddRVal
            && self.CanCreateVideoPort == other.CanCreateVideoPort
    }
}
impl ::core::cmp::Eq for DD_CANCREATEVPORTDATA {}
impl FromIntoMemory for DD_CANCREATEVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDVideoPortDesc =
            <MutPtr<DDVIDEOPORTDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CanCreateVideoPort =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDVideoPortDesc: f_lpDDVideoPortDesc,
            ddRVal: f_ddRVal,
            CanCreateVideoPort: f_CanCreateVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDVideoPortDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateVideoPort, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_CLIPPER_GLOBAL {
    pub dwReserved1: PtrRepr,
}
impl ::core::marker::Copy for DD_CLIPPER_GLOBAL {}
impl ::core::clone::Clone for DD_CLIPPER_GLOBAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CLIPPER_GLOBAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CLIPPER_GLOBAL")
            .field("dwReserved1", &self.dwReserved1)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CLIPPER_GLOBAL {
    fn eq(&self, other: &Self) -> bool {
        self.dwReserved1 == other.dwReserved1
    }
}
impl ::core::cmp::Eq for DD_CLIPPER_GLOBAL {}
impl FromIntoMemory for DD_CLIPPER_GLOBAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            dwReserved1: f_dwReserved1,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_CLIPPER_LOCAL {
    pub dwReserved1: PtrRepr,
}
impl ::core::marker::Copy for DD_CLIPPER_LOCAL {}
impl ::core::clone::Clone for DD_CLIPPER_LOCAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CLIPPER_LOCAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CLIPPER_LOCAL")
            .field("dwReserved1", &self.dwReserved1)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CLIPPER_LOCAL {
    fn eq(&self, other: &Self) -> bool {
        self.dwReserved1 == other.dwReserved1
    }
}
impl ::core::cmp::Eq for DD_CLIPPER_LOCAL {}
impl FromIntoMemory for DD_CLIPPER_LOCAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            dwReserved1: f_dwReserved1,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_COLORCONTROLCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub ColorControl: PDD_COLORCB_COLORCONTROL,
}
impl ::core::marker::Copy for DD_COLORCONTROLCALLBACKS {}
impl ::core::clone::Clone for DD_COLORCONTROLCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_COLORCONTROLCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_COLORCONTROLCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_COLORCONTROLCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DD_COLORCONTROLCALLBACKS {}
impl FromIntoMemory for DD_COLORCONTROLCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ColorControl =
            <PDD_COLORCB_COLORCONTROL as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DD_COLORCONTROLDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub lpColorData: MutPtr<DDCOLORCONTROL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub ColorControl: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_COLORCONTROLDATA {}
impl ::core::clone::Clone for DD_COLORCONTROLDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_COLORCONTROLDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_COLORCONTROLDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("lpColorData", &self.lpColorData)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_COLORCONTROLDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.lpColorData == other.lpColorData
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DD_COLORCONTROLDATA {}
impl FromIntoMemory for DD_COLORCONTROLDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpColorData = <MutPtr<DDCOLORCONTROL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ColorControl =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            lpColorData: f_lpColorData,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpColorData, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_CREATEMOCOMPDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpMoComp: MutPtr<DD_MOTIONCOMP_LOCAL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwUncompWidth: u32,
    pub dwUncompHeight: u32,
    pub ddUncompPixelFormat: DDPIXELFORMAT,
    pub lpData: MutPtr<::core::ffi::c_void>,
    pub dwDataSize: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_CREATEMOCOMPDATA {}
impl ::core::clone::Clone for DD_CREATEMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_CREATEMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpGuid == other.lpGuid
            && self.dwUncompWidth == other.dwUncompWidth
            && self.dwUncompHeight == other.dwUncompHeight
            && self.ddUncompPixelFormat == other.ddUncompPixelFormat
            && self.lpData == other.lpData
            && self.dwDataSize == other.dwDataSize
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_CREATEMOCOMPDATA {}
impl FromIntoMemory for DD_CREATEMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 64);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DD_MOTIONCOMP_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwUncompWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwUncompHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddUncompPixelFormat =
            <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[20..20 + 32]);
        let f_lpData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwDataSize = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpGuid: f_lpGuid,
            dwUncompWidth: f_dwUncompWidth,
            dwUncompHeight: f_dwUncompHeight,
            ddUncompPixelFormat: f_ddUncompPixelFormat,
            lpData: f_lpData,
            dwDataSize: f_dwDataSize,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 64);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwUncompWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwUncompHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddUncompPixelFormat, &mut into[20..20 + 32]);
        FromIntoMemory::into_bytes(self.lpData, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwDataSize, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[60..60 + 4]);
    }
    fn size() -> usize {
        64
    }
}
pub struct DD_CREATEPALETTEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDPalette: MutPtr<DD_PALETTE_GLOBAL>,
    pub lpColorTable: MutPtr<super::Gdi::PALETTEENTRY>,
    pub ddRVal: crate::core::HRESULT,
    pub CreatePalette: MutPtr<::core::ffi::c_void>,
    pub is_excl: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DD_CREATEPALETTEDATA {}
impl ::core::clone::Clone for DD_CREATEPALETTEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CREATEPALETTEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CREATEPALETTEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("lpColorTable", &self.lpColorTable)
            .field("ddRVal", &self.ddRVal)
            .field("CreatePalette", &self.CreatePalette)
            .field("is_excl", &self.is_excl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CREATEPALETTEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDPalette == other.lpDDPalette
            && self.lpColorTable == other.lpColorTable
            && self.ddRVal == other.ddRVal
            && self.CreatePalette == other.CreatePalette
            && self.is_excl == other.is_excl
    }
}
impl ::core::cmp::Eq for DD_CREATEPALETTEDATA {}
impl FromIntoMemory for DD_CREATEPALETTEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDPalette =
            <MutPtr<DD_PALETTE_GLOBAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpColorTable =
            <MutPtr<super::Gdi::PALETTEENTRY> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CreatePalette =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_is_excl =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDPalette: f_lpDDPalette,
            lpColorTable: f_lpColorTable,
            ddRVal: f_ddRVal,
            CreatePalette: f_CreatePalette,
            is_excl: f_is_excl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpColorTable, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CreatePalette, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.is_excl, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_CREATESURFACEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurfaceDesc: MutPtr<DDSURFACEDESC>,
    pub lplpSList: MutPtr<ConstPtr<DD_SURFACE_LOCAL>>,
    pub dwSCnt: u32,
    pub ddRVal: crate::core::HRESULT,
    pub CreateSurface: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_CREATESURFACEDATA {}
impl ::core::clone::Clone for DD_CREATESURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CREATESURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CREATESURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurfaceDesc", &self.lpDDSurfaceDesc)
            .field("lplpSList", &self.lplpSList)
            .field("dwSCnt", &self.dwSCnt)
            .field("ddRVal", &self.ddRVal)
            .field("CreateSurface", &self.CreateSurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CREATESURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurfaceDesc == other.lpDDSurfaceDesc
            && self.lplpSList == other.lplpSList
            && self.dwSCnt == other.dwSCnt
            && self.ddRVal == other.ddRVal
            && self.CreateSurface == other.CreateSurface
    }
}
impl ::core::cmp::Eq for DD_CREATESURFACEDATA {}
impl FromIntoMemory for DD_CREATESURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurfaceDesc =
            <MutPtr<DDSURFACEDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lplpSList =
            <MutPtr<ConstPtr<DD_SURFACE_LOCAL>> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwSCnt = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_CreateSurface =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurfaceDesc: f_lpDDSurfaceDesc,
            lplpSList: f_lplpSList,
            dwSCnt: f_dwSCnt,
            ddRVal: f_ddRVal,
            CreateSurface: f_CreateSurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurfaceDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lplpSList, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwSCnt, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.CreateSurface, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_CREATESURFACEEXDATA {
    pub dwFlags: u32,
    pub lpDDLcl: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpDDSLcl: MutPtr<DD_SURFACE_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_CREATESURFACEEXDATA {}
impl ::core::clone::Clone for DD_CREATESURFACEEXDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CREATESURFACEEXDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CREATESURFACEEXDATA")
            .field("dwFlags", &self.dwFlags)
            .field("lpDDLcl", &self.lpDDLcl)
            .field("lpDDSLcl", &self.lpDDSLcl)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CREATESURFACEEXDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.lpDDLcl == other.lpDDLcl
            && self.lpDDSLcl == other.lpDDSLcl
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_CREATESURFACEEXDATA {}
impl FromIntoMemory for DD_CREATESURFACEEXDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDLcl =
            <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDSLcl = <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwFlags: f_dwFlags,
            lpDDLcl: f_lpDDLcl,
            lpDDSLcl: f_lpDDSLcl,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSLcl, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_CREATEVPORTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpDDVideoPortDesc: MutPtr<DDVIDEOPORTDESC>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub CreateVideoPort: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_CREATEVPORTDATA {}
impl ::core::clone::Clone for DD_CREATEVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_CREATEVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_CREATEVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDVideoPortDesc", &self.lpDDVideoPortDesc)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("ddRVal", &self.ddRVal)
            .field("CreateVideoPort", &self.CreateVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_CREATEVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDVideoPortDesc == other.lpDDVideoPortDesc
            && self.lpVideoPort == other.lpVideoPort
            && self.ddRVal == other.ddRVal
            && self.CreateVideoPort == other.CreateVideoPort
    }
}
impl ::core::cmp::Eq for DD_CREATEVPORTDATA {}
impl FromIntoMemory for DD_CREATEVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDVideoPortDesc =
            <MutPtr<DDVIDEOPORTDESC> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CreateVideoPort =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDVideoPortDesc: f_lpDDVideoPortDesc,
            lpVideoPort: f_lpVideoPort,
            ddRVal: f_ddRVal,
            CreateVideoPort: f_CreateVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDVideoPortDesc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CreateVideoPort, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_D3DBUFCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub CanCreateD3DBuffer: PDD_CANCREATESURFACE,
    pub CreateD3DBuffer: PDD_CREATESURFACE,
    pub DestroyD3DBuffer: PDD_SURFCB_DESTROYSURFACE,
    pub LockD3DBuffer: PDD_SURFCB_LOCK,
    pub UnlockD3DBuffer: PDD_SURFCB_UNLOCK,
}
impl ::core::marker::Copy for DD_D3DBUFCALLBACKS {}
impl ::core::clone::Clone for DD_D3DBUFCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_D3DBUFCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_D3DBUFCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("CanCreateD3DBuffer", &self.CanCreateD3DBuffer)
            .field("CreateD3DBuffer", &self.CreateD3DBuffer)
            .field("DestroyD3DBuffer", &self.DestroyD3DBuffer)
            .field("LockD3DBuffer", &self.LockD3DBuffer)
            .field("UnlockD3DBuffer", &self.UnlockD3DBuffer)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_D3DBUFCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.CanCreateD3DBuffer == other.CanCreateD3DBuffer
            && self.CreateD3DBuffer == other.CreateD3DBuffer
            && self.DestroyD3DBuffer == other.DestroyD3DBuffer
            && self.LockD3DBuffer == other.LockD3DBuffer
            && self.UnlockD3DBuffer == other.UnlockD3DBuffer
    }
}
impl ::core::cmp::Eq for DD_D3DBUFCALLBACKS {}
impl FromIntoMemory for DD_D3DBUFCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_CanCreateD3DBuffer =
            <PDD_CANCREATESURFACE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateD3DBuffer =
            <PDD_CREATESURFACE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_DestroyD3DBuffer =
            <PDD_SURFCB_DESTROYSURFACE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_LockD3DBuffer = <PDD_SURFCB_LOCK as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_UnlockD3DBuffer =
            <PDD_SURFCB_UNLOCK as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            CanCreateD3DBuffer: f_CanCreateD3DBuffer,
            CreateD3DBuffer: f_CreateD3DBuffer,
            DestroyD3DBuffer: f_DestroyD3DBuffer,
            LockD3DBuffer: f_LockD3DBuffer,
            UnlockD3DBuffer: f_UnlockD3DBuffer,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateD3DBuffer, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateD3DBuffer, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.DestroyD3DBuffer, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.LockD3DBuffer, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.UnlockD3DBuffer, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DD_DESTROYDDLOCALDATA {
    pub dwFlags: u32,
    pub pDDLcl: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_DESTROYDDLOCALDATA {}
impl ::core::clone::Clone for DD_DESTROYDDLOCALDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DESTROYDDLOCALDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DESTROYDDLOCALDATA")
            .field("dwFlags", &self.dwFlags)
            .field("pDDLcl", &self.pDDLcl)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DESTROYDDLOCALDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.pDDLcl == other.pDDLcl && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_DESTROYDDLOCALDATA {}
impl FromIntoMemory for DD_DESTROYDDLOCALDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pDDLcl = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwFlags: f_dwFlags,
            pDDLcl: f_pDDLcl,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pDDLcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DD_DESTROYMOCOMPDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpMoComp: MutPtr<DD_MOTIONCOMP_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_DESTROYMOCOMPDATA {}
impl ::core::clone::Clone for DD_DESTROYMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DESTROYMOCOMPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DESTROYMOCOMPDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DESTROYMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD && self.lpMoComp == other.lpMoComp && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_DESTROYMOCOMPDATA {}
impl FromIntoMemory for DD_DESTROYMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DD_MOTIONCOMP_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DD_DESTROYPALETTEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDPalette: MutPtr<DD_PALETTE_GLOBAL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroyPalette: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_DESTROYPALETTEDATA {}
impl ::core::clone::Clone for DD_DESTROYPALETTEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DESTROYPALETTEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DESTROYPALETTEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("ddRVal", &self.ddRVal)
            .field("DestroyPalette", &self.DestroyPalette)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DESTROYPALETTEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDPalette == other.lpDDPalette
            && self.ddRVal == other.ddRVal
            && self.DestroyPalette == other.DestroyPalette
    }
}
impl ::core::cmp::Eq for DD_DESTROYPALETTEDATA {}
impl FromIntoMemory for DD_DESTROYPALETTEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDPalette =
            <MutPtr<DD_PALETTE_GLOBAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_DestroyPalette =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDPalette: f_lpDDPalette,
            ddRVal: f_ddRVal,
            DestroyPalette: f_DestroyPalette,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.DestroyPalette, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_DESTROYSURFACEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroySurface: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_DESTROYSURFACEDATA {}
impl ::core::clone::Clone for DD_DESTROYSURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DESTROYSURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DESTROYSURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("ddRVal", &self.ddRVal)
            .field("DestroySurface", &self.DestroySurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DESTROYSURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.ddRVal == other.ddRVal
            && self.DestroySurface == other.DestroySurface
    }
}
impl ::core::cmp::Eq for DD_DESTROYSURFACEDATA {}
impl FromIntoMemory for DD_DESTROYSURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_DestroySurface =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            ddRVal: f_ddRVal,
            DestroySurface: f_DestroySurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.DestroySurface, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_DESTROYVPORTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub DestroyVideoPort: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_DESTROYVPORTDATA {}
impl ::core::clone::Clone for DD_DESTROYVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DESTROYVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DESTROYVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("ddRVal", &self.ddRVal)
            .field("DestroyVideoPort", &self.DestroyVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DESTROYVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.ddRVal == other.ddRVal
            && self.DestroyVideoPort == other.DestroyVideoPort
    }
}
impl ::core::cmp::Eq for DD_DESTROYVPORTDATA {}
impl FromIntoMemory for DD_DESTROYVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_DestroyVideoPort =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            ddRVal: f_ddRVal,
            DestroyVideoPort: f_DestroyVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.DestroyVideoPort, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_DIRECTDRAW_GLOBAL {
    pub dhpdev: MutPtr<::core::ffi::c_void>,
    pub dwReserved1: PtrRepr,
    pub dwReserved2: PtrRepr,
    pub lpDDVideoPortCaps: MutPtr<DDVIDEOPORTCAPS>,
}
impl ::core::marker::Copy for DD_DIRECTDRAW_GLOBAL {}
impl ::core::clone::Clone for DD_DIRECTDRAW_GLOBAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DIRECTDRAW_GLOBAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DIRECTDRAW_GLOBAL")
            .field("dhpdev", &self.dhpdev)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("lpDDVideoPortCaps", &self.lpDDVideoPortCaps)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DIRECTDRAW_GLOBAL {
    fn eq(&self, other: &Self) -> bool {
        self.dhpdev == other.dhpdev
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.lpDDVideoPortCaps == other.lpDDVideoPortCaps
    }
}
impl ::core::cmp::Eq for DD_DIRECTDRAW_GLOBAL {}
impl FromIntoMemory for DD_DIRECTDRAW_GLOBAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dhpdev = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpDDVideoPortCaps =
            <MutPtr<DDVIDEOPORTCAPS> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dhpdev: f_dhpdev,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            lpDDVideoPortCaps: f_lpDDVideoPortCaps,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dhpdev, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpDDVideoPortCaps, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_DIRECTDRAW_LOCAL {
    pub lpGbl: MutPtr<DD_DIRECTDRAW_GLOBAL>,
}
impl ::core::marker::Copy for DD_DIRECTDRAW_LOCAL {}
impl ::core::clone::Clone for DD_DIRECTDRAW_LOCAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DIRECTDRAW_LOCAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DIRECTDRAW_LOCAL")
            .field("lpGbl", &self.lpGbl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DIRECTDRAW_LOCAL {
    fn eq(&self, other: &Self) -> bool {
        self.lpGbl == other.lpGbl
    }
}
impl ::core::cmp::Eq for DD_DIRECTDRAW_LOCAL {}
impl FromIntoMemory for DD_DIRECTDRAW_LOCAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_lpGbl = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self { lpGbl: f_lpGbl }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.lpGbl, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_DRVSETCOLORKEYDATA {
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwFlags: u32,
    pub ckNew: DDCOLORKEY,
    pub ddRVal: crate::core::HRESULT,
    pub SetColorKey: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_DRVSETCOLORKEYDATA {}
impl ::core::clone::Clone for DD_DRVSETCOLORKEYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_DRVSETCOLORKEYDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_DRVSETCOLORKEYDATA")
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ckNew", &self.ckNew)
            .field("ddRVal", &self.ddRVal)
            .field("SetColorKey", &self.SetColorKey)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_DRVSETCOLORKEYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ckNew == other.ckNew
            && self.ddRVal == other.ddRVal
            && self.SetColorKey == other.SetColorKey
    }
}
impl ::core::cmp::Eq for DD_DRVSETCOLORKEYDATA {}
impl FromIntoMemory for DD_DRVSETCOLORKEYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ckNew = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[8..8 + 8]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_SetColorKey =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ckNew: f_ckNew,
            ddRVal: f_ddRVal,
            SetColorKey: f_SetColorKey,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ckNew, &mut into[8..8 + 8]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_ENDMOCOMPFRAMEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpMoComp: MutPtr<DD_MOTIONCOMP_LOCAL>,
    pub lpInputData: MutPtr<::core::ffi::c_void>,
    pub dwInputDataSize: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_ENDMOCOMPFRAMEDATA {}
impl ::core::clone::Clone for DD_ENDMOCOMPFRAMEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_ENDMOCOMPFRAMEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_ENDMOCOMPFRAMEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("lpInputData", &self.lpInputData)
            .field("dwInputDataSize", &self.dwInputDataSize)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_ENDMOCOMPFRAMEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpInputData == other.lpInputData
            && self.dwInputDataSize == other.dwInputDataSize
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_ENDMOCOMPFRAMEDATA {}
impl FromIntoMemory for DD_ENDMOCOMPFRAMEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DD_MOTIONCOMP_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpInputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwInputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpInputData: f_lpInputData,
            dwInputDataSize: f_dwInputDataSize,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpInputData, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwInputDataSize, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_FLIPDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpSurfCurr: MutPtr<DD_SURFACE_LOCAL>,
    pub lpSurfTarg: MutPtr<DD_SURFACE_LOCAL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub Flip: MutPtr<::core::ffi::c_void>,
    pub lpSurfCurrLeft: MutPtr<DD_SURFACE_LOCAL>,
    pub lpSurfTargLeft: MutPtr<DD_SURFACE_LOCAL>,
}
impl ::core::marker::Copy for DD_FLIPDATA {}
impl ::core::clone::Clone for DD_FLIPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_FLIPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_FLIPDATA")
            .field("lpDD", &self.lpDD)
            .field("lpSurfCurr", &self.lpSurfCurr)
            .field("lpSurfTarg", &self.lpSurfTarg)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("Flip", &self.Flip)
            .field("lpSurfCurrLeft", &self.lpSurfCurrLeft)
            .field("lpSurfTargLeft", &self.lpSurfTargLeft)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_FLIPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpSurfCurr == other.lpSurfCurr
            && self.lpSurfTarg == other.lpSurfTarg
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.Flip == other.Flip
            && self.lpSurfCurrLeft == other.lpSurfCurrLeft
            && self.lpSurfTargLeft == other.lpSurfTargLeft
    }
}
impl ::core::cmp::Eq for DD_FLIPDATA {}
impl FromIntoMemory for DD_FLIPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpSurfCurr =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurfTarg =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Flip = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpSurfCurrLeft =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpSurfTargLeft =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            lpDD: f_lpDD,
            lpSurfCurr: f_lpSurfCurr,
            lpSurfTarg: f_lpSurfTarg,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            Flip: f_Flip,
            lpSurfCurrLeft: f_lpSurfCurrLeft,
            lpSurfTargLeft: f_lpSurfTargLeft,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfCurr, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfTarg, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Flip, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfCurrLeft, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfTargLeft, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DD_FLIPTOGDISURFACEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub dwToGDI: u32,
    pub dwReserved: u32,
    pub ddRVal: crate::core::HRESULT,
    pub FlipToGDISurface: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_FLIPTOGDISURFACEDATA {}
impl ::core::clone::Clone for DD_FLIPTOGDISURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_FLIPTOGDISURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_FLIPTOGDISURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("dwToGDI", &self.dwToGDI)
            .field("dwReserved", &self.dwReserved)
            .field("ddRVal", &self.ddRVal)
            .field("FlipToGDISurface", &self.FlipToGDISurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_FLIPTOGDISURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwToGDI == other.dwToGDI
            && self.dwReserved == other.dwReserved
            && self.ddRVal == other.ddRVal
            && self.FlipToGDISurface == other.FlipToGDISurface
    }
}
impl ::core::cmp::Eq for DD_FLIPTOGDISURFACEDATA {}
impl FromIntoMemory for DD_FLIPTOGDISURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwToGDI = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_FlipToGDISurface =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            dwToGDI: f_dwToGDI,
            dwReserved: f_dwReserved,
            ddRVal: f_ddRVal,
            FlipToGDISurface: f_FlipToGDISurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwToGDI, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.FlipToGDISurface, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_FLIPVPORTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub lpSurfCurr: MutPtr<DD_SURFACE_LOCAL>,
    pub lpSurfTarg: MutPtr<DD_SURFACE_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub FlipVideoPort: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_FLIPVPORTDATA {}
impl ::core::clone::Clone for DD_FLIPVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_FLIPVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_FLIPVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("lpSurfCurr", &self.lpSurfCurr)
            .field("lpSurfTarg", &self.lpSurfTarg)
            .field("ddRVal", &self.ddRVal)
            .field("FlipVideoPort", &self.FlipVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_FLIPVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.lpSurfCurr == other.lpSurfCurr
            && self.lpSurfTarg == other.lpSurfTarg
            && self.ddRVal == other.ddRVal
            && self.FlipVideoPort == other.FlipVideoPort
    }
}
impl ::core::cmp::Eq for DD_FLIPVPORTDATA {}
impl FromIntoMemory for DD_FLIPVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurfCurr =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpSurfTarg =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_FlipVideoPort =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            lpSurfCurr: f_lpSurfCurr,
            lpSurfTarg: f_lpSurfTarg,
            ddRVal: f_ddRVal,
            FlipVideoPort: f_FlipVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfCurr, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpSurfTarg, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.FlipVideoPort, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_FREEDRIVERMEMORYDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub FreeDriverMemory: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_FREEDRIVERMEMORYDATA {}
impl ::core::clone::Clone for DD_FREEDRIVERMEMORYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_FREEDRIVERMEMORYDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_FREEDRIVERMEMORYDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("ddRVal", &self.ddRVal)
            .field("FreeDriverMemory", &self.FreeDriverMemory)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_FREEDRIVERMEMORYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.ddRVal == other.ddRVal
            && self.FreeDriverMemory == other.FreeDriverMemory
    }
}
impl ::core::cmp::Eq for DD_FREEDRIVERMEMORYDATA {}
impl FromIntoMemory for DD_FREEDRIVERMEMORYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_FreeDriverMemory =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            ddRVal: f_ddRVal,
            FreeDriverMemory: f_FreeDriverMemory,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.FreeDriverMemory, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_GETAVAILDRIVERMEMORYDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub DDSCaps: DDSCAPS,
    pub dwTotal: u32,
    pub dwFree: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetAvailDriverMemory: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETAVAILDRIVERMEMORYDATA {}
impl ::core::clone::Clone for DD_GETAVAILDRIVERMEMORYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETAVAILDRIVERMEMORYDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETAVAILDRIVERMEMORYDATA")
            .field("lpDD", &self.lpDD)
            .field("DDSCaps", &self.DDSCaps)
            .field("dwTotal", &self.dwTotal)
            .field("dwFree", &self.dwFree)
            .field("ddRVal", &self.ddRVal)
            .field("GetAvailDriverMemory", &self.GetAvailDriverMemory)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETAVAILDRIVERMEMORYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.DDSCaps == other.DDSCaps
            && self.dwTotal == other.dwTotal
            && self.dwFree == other.dwFree
            && self.ddRVal == other.ddRVal
            && self.GetAvailDriverMemory == other.GetAvailDriverMemory
    }
}
impl ::core::cmp::Eq for DD_GETAVAILDRIVERMEMORYDATA {}
impl FromIntoMemory for DD_GETAVAILDRIVERMEMORYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_DDSCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwTotal = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFree = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetAvailDriverMemory =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            DDSCaps: f_DDSCaps,
            dwTotal: f_dwTotal,
            dwFree: f_dwFree,
            ddRVal: f_ddRVal,
            GetAvailDriverMemory: f_GetAvailDriverMemory,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.DDSCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwTotal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFree, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetAvailDriverMemory, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_GETBLTSTATUSDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetBltStatus: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETBLTSTATUSDATA {}
impl ::core::clone::Clone for DD_GETBLTSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETBLTSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETBLTSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("GetBltStatus", &self.GetBltStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETBLTSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.GetBltStatus == other.GetBltStatus
    }
}
impl ::core::cmp::Eq for DD_GETBLTSTATUSDATA {}
impl FromIntoMemory for DD_GETBLTSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetBltStatus =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            GetBltStatus: f_GetBltStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetBltStatus, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_GETDRIVERINFODATA {
    pub dhpdev: MutPtr<::core::ffi::c_void>,
    pub dwSize: u32,
    pub dwFlags: u32,
    pub guidInfo: crate::core::GUID,
    pub dwExpectedSize: u32,
    pub lpvData: MutPtr<::core::ffi::c_void>,
    pub dwActualSize: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_GETDRIVERINFODATA {}
impl ::core::clone::Clone for DD_GETDRIVERINFODATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETDRIVERINFODATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETDRIVERINFODATA")
            .field("dhpdev", &self.dhpdev)
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("guidInfo", &self.guidInfo)
            .field("dwExpectedSize", &self.dwExpectedSize)
            .field("lpvData", &self.lpvData)
            .field("dwActualSize", &self.dwActualSize)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETDRIVERINFODATA {
    fn eq(&self, other: &Self) -> bool {
        self.dhpdev == other.dhpdev
            && self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.guidInfo == other.guidInfo
            && self.dwExpectedSize == other.dwExpectedSize
            && self.lpvData == other.lpvData
            && self.dwActualSize == other.dwActualSize
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_GETDRIVERINFODATA {}
impl FromIntoMemory for DD_GETDRIVERINFODATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_dhpdev = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_guidInfo = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        let f_dwExpectedSize = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_lpvData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwActualSize = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        Self {
            dhpdev: f_dhpdev,
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            guidInfo: f_guidInfo,
            dwExpectedSize: f_dwExpectedSize,
            lpvData: f_lpvData,
            dwActualSize: f_dwActualSize,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.dhpdev, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.guidInfo, &mut into[12..12 + 16]);
        FromIntoMemory::into_bytes(self.dwExpectedSize, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpvData, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwActualSize, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[40..40 + 4]);
    }
    fn size() -> usize {
        44
    }
}
pub struct DD_GETDRIVERSTATEDATA {
    pub dwFlags: u32,
    pub Anonymous: DD_GETDRIVERSTATEDATA_0,
    pub lpdwStates: MutPtr<u32>,
    pub dwLength: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_GETDRIVERSTATEDATA {}
impl ::core::clone::Clone for DD_GETDRIVERSTATEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_GETDRIVERSTATEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.Anonymous == other.Anonymous
            && self.lpdwStates == other.lpdwStates
            && self.dwLength == other.dwLength
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_GETDRIVERSTATEDATA {}
impl FromIntoMemory for DD_GETDRIVERSTATEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_Anonymous = <DD_GETDRIVERSTATEDATA_0 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpdwStates = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwLength = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwFlags: f_dwFlags,
            Anonymous: f_Anonymous,
            lpdwStates: f_lpdwStates,
            dwLength: f_dwLength,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpdwStates, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwLength, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_GETDRIVERSTATEDATA_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DD_GETDRIVERSTATEDATA_0 {}
impl ::core::clone::Clone for DD_GETDRIVERSTATEDATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_GETDRIVERSTATEDATA_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DD_GETDRIVERSTATEDATA_0 {}
impl FromIntoMemory for DD_GETDRIVERSTATEDATA_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_GETFLIPSTATUSDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetFlipStatus: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETFLIPSTATUSDATA {}
impl ::core::clone::Clone for DD_GETFLIPSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETFLIPSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETFLIPSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .field("GetFlipStatus", &self.GetFlipStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETFLIPSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
            && self.GetFlipStatus == other.GetFlipStatus
    }
}
impl ::core::cmp::Eq for DD_GETFLIPSTATUSDATA {}
impl FromIntoMemory for DD_GETFLIPSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetFlipStatus =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
            GetFlipStatus: f_GetFlipStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetFlipStatus, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_GETHEAPALIGNMENTDATA {
    pub dwInstance: PtrRepr,
    pub dwHeap: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetHeapAlignment: MutPtr<::core::ffi::c_void>,
    pub Alignment: HEAPALIGNMENT,
}
impl ::core::marker::Copy for DD_GETHEAPALIGNMENTDATA {}
impl ::core::clone::Clone for DD_GETHEAPALIGNMENTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_GETHEAPALIGNMENTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwInstance == other.dwInstance
            && self.dwHeap == other.dwHeap
            && self.ddRVal == other.ddRVal
            && self.GetHeapAlignment == other.GetHeapAlignment
            && self.Alignment == other.Alignment
    }
}
impl ::core::cmp::Eq for DD_GETHEAPALIGNMENTDATA {}
impl FromIntoMemory for DD_GETHEAPALIGNMENTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 140);
        let f_dwInstance = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwHeap = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetHeapAlignment =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_Alignment = <HEAPALIGNMENT as FromIntoMemory>::from_bytes(&from[16..16 + 124]);
        Self {
            dwInstance: f_dwInstance,
            dwHeap: f_dwHeap,
            ddRVal: f_ddRVal,
            GetHeapAlignment: f_GetHeapAlignment,
            Alignment: f_Alignment,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 140);
        FromIntoMemory::into_bytes(self.dwInstance, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwHeap, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetHeapAlignment, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.Alignment, &mut into[16..16 + 124]);
    }
    fn size() -> usize {
        140
    }
}
pub struct DD_GETINTERNALMOCOMPDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub ddPixelFormat: DDPIXELFORMAT,
    pub dwScratchMemAlloc: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_GETINTERNALMOCOMPDATA {}
impl ::core::clone::Clone for DD_GETINTERNALMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_GETINTERNALMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpGuid == other.lpGuid
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.ddPixelFormat == other.ddPixelFormat
            && self.dwScratchMemAlloc == other.dwScratchMemAlloc
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_GETINTERNALMOCOMPDATA {}
impl FromIntoMemory for DD_GETINTERNALMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 56);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddPixelFormat = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[16..16 + 32]);
        let f_dwScratchMemAlloc = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        Self {
            lpDD: f_lpDD,
            lpGuid: f_lpGuid,
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            ddPixelFormat: f_ddPixelFormat,
            dwScratchMemAlloc: f_dwScratchMemAlloc,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 56);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddPixelFormat, &mut into[16..16 + 32]);
        FromIntoMemory::into_bytes(self.dwScratchMemAlloc, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[52..52 + 4]);
    }
    fn size() -> usize {
        56
    }
}
pub struct DD_GETMOCOMPCOMPBUFFDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub ddPixelFormat: DDPIXELFORMAT,
    pub dwNumTypesCompBuffs: u32,
    pub lpCompBuffInfo: MutPtr<DDCOMPBUFFERINFO>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_GETMOCOMPCOMPBUFFDATA {}
impl ::core::clone::Clone for DD_GETMOCOMPCOMPBUFFDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_GETMOCOMPCOMPBUFFDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpGuid == other.lpGuid
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.ddPixelFormat == other.ddPixelFormat
            && self.dwNumTypesCompBuffs == other.dwNumTypesCompBuffs
            && self.lpCompBuffInfo == other.lpCompBuffInfo
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_GETMOCOMPCOMPBUFFDATA {}
impl FromIntoMemory for DD_GETMOCOMPCOMPBUFFDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddPixelFormat = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[16..16 + 32]);
        let f_dwNumTypesCompBuffs = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_lpCompBuffInfo =
            <MutPtr<DDCOMPBUFFERINFO> as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            lpDD: f_lpDD,
            lpGuid: f_lpGuid,
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            ddPixelFormat: f_ddPixelFormat,
            dwNumTypesCompBuffs: f_dwNumTypesCompBuffs,
            lpCompBuffInfo: f_lpCompBuffInfo,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddPixelFormat, &mut into[16..16 + 32]);
        FromIntoMemory::into_bytes(self.dwNumTypesCompBuffs, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.lpCompBuffInfo, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
pub struct DD_GETMOCOMPFORMATSDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub dwNumFormats: u32,
    pub lpFormats: MutPtr<DDPIXELFORMAT>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_GETMOCOMPFORMATSDATA {}
impl ::core::clone::Clone for DD_GETMOCOMPFORMATSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETMOCOMPFORMATSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETMOCOMPFORMATSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpGuid", &self.lpGuid)
            .field("dwNumFormats", &self.dwNumFormats)
            .field("lpFormats", &self.lpFormats)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETMOCOMPFORMATSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpGuid == other.lpGuid
            && self.dwNumFormats == other.dwNumFormats
            && self.lpFormats == other.lpFormats
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_GETMOCOMPFORMATSDATA {}
impl FromIntoMemory for DD_GETMOCOMPFORMATSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwNumFormats = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpFormats = <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpGuid: f_lpGuid,
            dwNumFormats: f_dwNumFormats,
            lpFormats: f_lpFormats,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFormats, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpFormats, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_GETMOCOMPGUIDSDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub dwNumGuids: u32,
    pub lpGuids: MutPtr<crate::core::GUID>,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_GETMOCOMPGUIDSDATA {}
impl ::core::clone::Clone for DD_GETMOCOMPGUIDSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETMOCOMPGUIDSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETMOCOMPGUIDSDATA")
            .field("lpDD", &self.lpDD)
            .field("dwNumGuids", &self.dwNumGuids)
            .field("lpGuids", &self.lpGuids)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETMOCOMPGUIDSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwNumGuids == other.dwNumGuids
            && self.lpGuids == other.lpGuids
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_GETMOCOMPGUIDSDATA {}
impl FromIntoMemory for DD_GETMOCOMPGUIDSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwNumGuids = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpGuids = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            dwNumGuids: f_dwNumGuids,
            lpGuids: f_lpGuids,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwNumGuids, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpGuids, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_GETSCANLINEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub dwScanLine: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetScanLine: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETSCANLINEDATA {}
impl ::core::clone::Clone for DD_GETSCANLINEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETSCANLINEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETSCANLINEDATA")
            .field("lpDD", &self.lpDD)
            .field("dwScanLine", &self.dwScanLine)
            .field("ddRVal", &self.ddRVal)
            .field("GetScanLine", &self.GetScanLine)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETSCANLINEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwScanLine == other.dwScanLine
            && self.ddRVal == other.ddRVal
            && self.GetScanLine == other.GetScanLine
    }
}
impl ::core::cmp::Eq for DD_GETSCANLINEDATA {}
impl FromIntoMemory for DD_GETSCANLINEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwScanLine = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetScanLine =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            dwScanLine: f_dwScanLine,
            ddRVal: f_ddRVal,
            GetScanLine: f_GetScanLine,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwScanLine, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetScanLine, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_GETVPORTBANDWIDTHDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub lpddpfFormat: MutPtr<DDPIXELFORMAT>,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dwFlags: u32,
    pub lpBandwidth: MutPtr<DDVIDEOPORTBANDWIDTH>,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortBandwidth: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTBANDWIDTHDATA {}
impl ::core::clone::Clone for DD_GETVPORTBANDWIDTHDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTBANDWIDTHDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTBANDWIDTHDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("lpddpfFormat", &self.lpddpfFormat)
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("dwFlags", &self.dwFlags)
            .field("lpBandwidth", &self.lpBandwidth)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortBandwidth", &self.GetVideoPortBandwidth)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTBANDWIDTHDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.lpddpfFormat == other.lpddpfFormat
            && self.dwWidth == other.dwWidth
            && self.dwHeight == other.dwHeight
            && self.dwFlags == other.dwFlags
            && self.lpBandwidth == other.lpBandwidth
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortBandwidth == other.GetVideoPortBandwidth
    }
}
impl ::core::cmp::Eq for DD_GETVPORTBANDWIDTHDATA {}
impl FromIntoMemory for DD_GETVPORTBANDWIDTHDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpddpfFormat = <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpBandwidth =
            <MutPtr<DDVIDEOPORTBANDWIDTH> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_GetVideoPortBandwidth =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            lpddpfFormat: f_lpddpfFormat,
            dwWidth: f_dwWidth,
            dwHeight: f_dwHeight,
            dwFlags: f_dwFlags,
            lpBandwidth: f_lpBandwidth,
            ddRVal: f_ddRVal,
            GetVideoPortBandwidth: f_GetVideoPortBandwidth,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfFormat, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpBandwidth, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortBandwidth, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct DD_GETVPORTCONNECTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub dwPortId: u32,
    pub lpConnect: MutPtr<DDVIDEOPORTCONNECT>,
    pub dwNumEntries: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortConnectInfo: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTCONNECTDATA {}
impl ::core::clone::Clone for DD_GETVPORTCONNECTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTCONNECTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTCONNECTDATA")
            .field("lpDD", &self.lpDD)
            .field("dwPortId", &self.dwPortId)
            .field("lpConnect", &self.lpConnect)
            .field("dwNumEntries", &self.dwNumEntries)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortConnectInfo", &self.GetVideoPortConnectInfo)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTCONNECTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwPortId == other.dwPortId
            && self.lpConnect == other.lpConnect
            && self.dwNumEntries == other.dwNumEntries
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortConnectInfo == other.GetVideoPortConnectInfo
    }
}
impl ::core::cmp::Eq for DD_GETVPORTCONNECTDATA {}
impl FromIntoMemory for DD_GETVPORTCONNECTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwPortId = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpConnect =
            <MutPtr<DDVIDEOPORTCONNECT> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwNumEntries = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetVideoPortConnectInfo =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            dwPortId: f_dwPortId,
            lpConnect: f_lpConnect,
            dwNumEntries: f_dwNumEntries,
            ddRVal: f_ddRVal,
            GetVideoPortConnectInfo: f_GetVideoPortConnectInfo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwPortId, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpConnect, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwNumEntries, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortConnectInfo, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_GETVPORTFIELDDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub bField: super::super::Foundation::BOOL,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortField: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTFIELDDATA {}
impl ::core::clone::Clone for DD_GETVPORTFIELDDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTFIELDDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTFIELDDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("bField", &self.bField)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortField", &self.GetVideoPortField)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTFIELDDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.bField == other.bField
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortField == other.GetVideoPortField
    }
}
impl ::core::cmp::Eq for DD_GETVPORTFIELDDATA {}
impl FromIntoMemory for DD_GETVPORTFIELDDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bField =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetVideoPortField =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            bField: f_bField,
            ddRVal: f_ddRVal,
            GetVideoPortField: f_GetVideoPortField,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bField, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortField, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_GETVPORTFLIPSTATUSDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub fpSurface: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortFlipStatus: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTFLIPSTATUSDATA {}
impl ::core::clone::Clone for DD_GETVPORTFLIPSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTFLIPSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTFLIPSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("fpSurface", &self.fpSurface)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortFlipStatus", &self.GetVideoPortFlipStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTFLIPSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.fpSurface == other.fpSurface
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortFlipStatus == other.GetVideoPortFlipStatus
    }
}
impl ::core::cmp::Eq for DD_GETVPORTFLIPSTATUSDATA {}
impl FromIntoMemory for DD_GETVPORTFLIPSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fpSurface = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetVideoPortFlipStatus =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            fpSurface: f_fpSurface,
            ddRVal: f_ddRVal,
            GetVideoPortFlipStatus: f_GetVideoPortFlipStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fpSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortFlipStatus, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_GETVPORTINPUTFORMATDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwFlags: u32,
    pub lpddpfFormat: MutPtr<DDPIXELFORMAT>,
    pub dwNumFormats: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortInputFormats: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTINPUTFORMATDATA {}
impl ::core::clone::Clone for DD_GETVPORTINPUTFORMATDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTINPUTFORMATDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTINPUTFORMATDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("lpddpfFormat", &self.lpddpfFormat)
            .field("dwNumFormats", &self.dwNumFormats)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortInputFormats", &self.GetVideoPortInputFormats)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTINPUTFORMATDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.lpddpfFormat == other.lpddpfFormat
            && self.dwNumFormats == other.dwNumFormats
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortInputFormats == other.GetVideoPortInputFormats
    }
}
impl ::core::cmp::Eq for DD_GETVPORTINPUTFORMATDATA {}
impl FromIntoMemory for DD_GETVPORTINPUTFORMATDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpddpfFormat =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwNumFormats = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_GetVideoPortInputFormats =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            lpddpfFormat: f_lpddpfFormat,
            dwNumFormats: f_dwNumFormats,
            ddRVal: f_ddRVal,
            GetVideoPortInputFormats: f_GetVideoPortInputFormats,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfFormat, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFormats, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortInputFormats, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DD_GETVPORTLINEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwLine: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortLine: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTLINEDATA {}
impl ::core::clone::Clone for DD_GETVPORTLINEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTLINEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTLINEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwLine", &self.dwLine)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortLine", &self.GetVideoPortLine)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTLINEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwLine == other.dwLine
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortLine == other.GetVideoPortLine
    }
}
impl ::core::cmp::Eq for DD_GETVPORTLINEDATA {}
impl FromIntoMemory for DD_GETVPORTLINEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwLine = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetVideoPortLine =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwLine: f_dwLine,
            ddRVal: f_ddRVal,
            GetVideoPortLine: f_GetVideoPortLine,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwLine, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortLine, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_GETVPORTOUTPUTFORMATDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwFlags: u32,
    pub lpddpfInputFormat: MutPtr<DDPIXELFORMAT>,
    pub lpddpfOutputFormats: MutPtr<DDPIXELFORMAT>,
    pub dwNumFormats: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoPortInputFormats: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTOUTPUTFORMATDATA {}
impl ::core::clone::Clone for DD_GETVPORTOUTPUTFORMATDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTOUTPUTFORMATDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTOUTPUTFORMATDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("lpddpfInputFormat", &self.lpddpfInputFormat)
            .field("lpddpfOutputFormats", &self.lpddpfOutputFormats)
            .field("dwNumFormats", &self.dwNumFormats)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoPortInputFormats", &self.GetVideoPortInputFormats)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTOUTPUTFORMATDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.lpddpfInputFormat == other.lpddpfInputFormat
            && self.lpddpfOutputFormats == other.lpddpfOutputFormats
            && self.dwNumFormats == other.dwNumFormats
            && self.ddRVal == other.ddRVal
            && self.GetVideoPortInputFormats == other.GetVideoPortInputFormats
    }
}
impl ::core::cmp::Eq for DD_GETVPORTOUTPUTFORMATDATA {}
impl FromIntoMemory for DD_GETVPORTOUTPUTFORMATDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpddpfInputFormat =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpddpfOutputFormats =
            <MutPtr<DDPIXELFORMAT> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwNumFormats = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_GetVideoPortInputFormats =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            lpddpfInputFormat: f_lpddpfInputFormat,
            lpddpfOutputFormats: f_lpddpfOutputFormats,
            dwNumFormats: f_dwNumFormats,
            ddRVal: f_ddRVal,
            GetVideoPortInputFormats: f_GetVideoPortInputFormats,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfInputFormat, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpddpfOutputFormats, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwNumFormats, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortInputFormats, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct DD_GETVPORTSIGNALDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwStatus: u32,
    pub ddRVal: crate::core::HRESULT,
    pub GetVideoSignalStatus: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_GETVPORTSIGNALDATA {}
impl ::core::clone::Clone for DD_GETVPORTSIGNALDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_GETVPORTSIGNALDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_GETVPORTSIGNALDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwStatus", &self.dwStatus)
            .field("ddRVal", &self.ddRVal)
            .field("GetVideoSignalStatus", &self.GetVideoSignalStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_GETVPORTSIGNALDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwStatus == other.dwStatus
            && self.ddRVal == other.ddRVal
            && self.GetVideoSignalStatus == other.GetVideoSignalStatus
    }
}
impl ::core::cmp::Eq for DD_GETVPORTSIGNALDATA {}
impl FromIntoMemory for DD_GETVPORTSIGNALDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwStatus = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetVideoSignalStatus =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwStatus: f_dwStatus,
            ddRVal: f_ddRVal,
            GetVideoSignalStatus: f_GetVideoSignalStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwStatus, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoSignalStatus, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_HALINFO {
    pub dwSize: u32,
    pub vmiData: VIDEOMEMORYINFO,
    pub ddCaps: DDNTCORECAPS,
    pub GetDriverInfo: PDD_GETDRIVERINFO,
    pub dwFlags: u32,
    pub lpD3DGlobalDriverData: MutPtr<::core::ffi::c_void>,
    pub lpD3DHALCallbacks: MutPtr<::core::ffi::c_void>,
    pub lpD3DBufCallbacks: MutPtr<DD_D3DBUFCALLBACKS>,
}
impl ::core::marker::Copy for DD_HALINFO {}
impl ::core::clone::Clone for DD_HALINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_HALINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.vmiData == other.vmiData
            && self.ddCaps == other.ddCaps
            && self.GetDriverInfo == other.GetDriverInfo
            && self.dwFlags == other.dwFlags
            && self.lpD3DGlobalDriverData == other.lpD3DGlobalDriverData
            && self.lpD3DHALCallbacks == other.lpD3DHALCallbacks
            && self.lpD3DBufCallbacks == other.lpD3DBufCallbacks
    }
}
impl ::core::cmp::Eq for DD_HALINFO {}
impl FromIntoMemory for DD_HALINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 416);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_vmiData = <VIDEOMEMORYINFO as FromIntoMemory>::from_bytes(&from[4..4 + 76]);
        let f_ddCaps = <DDNTCORECAPS as FromIntoMemory>::from_bytes(&from[80..80 + 316]);
        let f_GetDriverInfo =
            <PDD_GETDRIVERINFO as FromIntoMemory>::from_bytes(&from[396..396 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[400..400 + 4]);
        let f_lpD3DGlobalDriverData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[404..404 + 4]);
        let f_lpD3DHALCallbacks =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[408..408 + 4]);
        let f_lpD3DBufCallbacks =
            <MutPtr<DD_D3DBUFCALLBACKS> as FromIntoMemory>::from_bytes(&from[412..412 + 4]);
        Self {
            dwSize: f_dwSize,
            vmiData: f_vmiData,
            ddCaps: f_ddCaps,
            GetDriverInfo: f_GetDriverInfo,
            dwFlags: f_dwFlags,
            lpD3DGlobalDriverData: f_lpD3DGlobalDriverData,
            lpD3DHALCallbacks: f_lpD3DHALCallbacks,
            lpD3DBufCallbacks: f_lpD3DBufCallbacks,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 416);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.vmiData, &mut into[4..4 + 76]);
        FromIntoMemory::into_bytes(self.ddCaps, &mut into[80..80 + 316]);
        FromIntoMemory::into_bytes(self.GetDriverInfo, &mut into[396..396 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[400..400 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DGlobalDriverData, &mut into[404..404 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DHALCallbacks, &mut into[408..408 + 4]);
        FromIntoMemory::into_bytes(self.lpD3DBufCallbacks, &mut into[412..412 + 4]);
    }
    fn size() -> usize {
        416
    }
}
pub struct DD_HALINFO_V4 {
    pub dwSize: u32,
    pub vmiData: VIDEOMEMORYINFO,
    pub ddCaps: DDNTCORECAPS,
    pub GetDriverInfo: PDD_GETDRIVERINFO,
    pub dwFlags: u32,
}
impl ::core::marker::Copy for DD_HALINFO_V4 {}
impl ::core::clone::Clone for DD_HALINFO_V4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_HALINFO_V4 {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.vmiData == other.vmiData
            && self.ddCaps == other.ddCaps
            && self.GetDriverInfo == other.GetDriverInfo
            && self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for DD_HALINFO_V4 {}
impl FromIntoMemory for DD_HALINFO_V4 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 404);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_vmiData = <VIDEOMEMORYINFO as FromIntoMemory>::from_bytes(&from[4..4 + 76]);
        let f_ddCaps = <DDNTCORECAPS as FromIntoMemory>::from_bytes(&from[80..80 + 316]);
        let f_GetDriverInfo =
            <PDD_GETDRIVERINFO as FromIntoMemory>::from_bytes(&from[396..396 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[400..400 + 4]);
        Self {
            dwSize: f_dwSize,
            vmiData: f_vmiData,
            ddCaps: f_ddCaps,
            GetDriverInfo: f_GetDriverInfo,
            dwFlags: f_dwFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 404);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.vmiData, &mut into[4..4 + 76]);
        FromIntoMemory::into_bytes(self.ddCaps, &mut into[80..80 + 316]);
        FromIntoMemory::into_bytes(self.GetDriverInfo, &mut into[396..396 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[400..400 + 4]);
    }
    fn size() -> usize {
        404
    }
}
pub const DD_HAL_VERSION: u32 = 256u32;
pub struct DD_KERNELCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub SyncSurfaceData: PDD_KERNELCB_SYNCSURFACE,
    pub SyncVideoPortData: PDD_KERNELCB_SYNCVIDEOPORT,
}
impl ::core::marker::Copy for DD_KERNELCALLBACKS {}
impl ::core::clone::Clone for DD_KERNELCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_KERNELCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_KERNELCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("SyncSurfaceData", &self.SyncSurfaceData)
            .field("SyncVideoPortData", &self.SyncVideoPortData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_KERNELCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.SyncSurfaceData == other.SyncSurfaceData
            && self.SyncVideoPortData == other.SyncVideoPortData
    }
}
impl ::core::cmp::Eq for DD_KERNELCALLBACKS {}
impl FromIntoMemory for DD_KERNELCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_SyncSurfaceData =
            <PDD_KERNELCB_SYNCSURFACE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SyncVideoPortData =
            <PDD_KERNELCB_SYNCVIDEOPORT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            SyncSurfaceData: f_SyncSurfaceData,
            SyncVideoPortData: f_SyncVideoPortData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.SyncSurfaceData, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SyncVideoPortData, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_LOCKDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub bHasRect: u32,
    pub rArea: super::super::Foundation::RECTL,
    pub lpSurfData: MutPtr<::core::ffi::c_void>,
    pub ddRVal: crate::core::HRESULT,
    pub Lock: MutPtr<::core::ffi::c_void>,
    pub dwFlags: u32,
    pub fpProcess: PtrRepr,
}
impl ::core::marker::Copy for DD_LOCKDATA {}
impl ::core::clone::Clone for DD_LOCKDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_LOCKDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_LOCKDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("bHasRect", &self.bHasRect)
            .field("rArea", &self.rArea)
            .field("lpSurfData", &self.lpSurfData)
            .field("ddRVal", &self.ddRVal)
            .field("Lock", &self.Lock)
            .field("dwFlags", &self.dwFlags)
            .field("fpProcess", &self.fpProcess)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_LOCKDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.bHasRect == other.bHasRect
            && self.rArea == other.rArea
            && self.lpSurfData == other.lpSurfData
            && self.ddRVal == other.ddRVal
            && self.Lock == other.Lock
            && self.dwFlags == other.dwFlags
            && self.fpProcess == other.fpProcess
    }
}
impl ::core::cmp::Eq for DD_LOCKDATA {}
impl FromIntoMemory for DD_LOCKDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 48);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bHasRect = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_rArea =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        let f_lpSurfData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_Lock = <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_fpProcess = <PtrRepr as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            bHasRect: f_bHasRect,
            rArea: f_rArea,
            lpSurfData: f_lpSurfData,
            ddRVal: f_ddRVal,
            Lock: f_Lock,
            dwFlags: f_dwFlags,
            fpProcess: f_fpProcess,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 48);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bHasRect, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.rArea, &mut into[12..12 + 16]);
        FromIntoMemory::into_bytes(self.lpSurfData, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.Lock, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.fpProcess, &mut into[44..44 + 4]);
    }
    fn size() -> usize {
        48
    }
}
pub struct DD_MAPMEMORYDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub bMap: super::super::Foundation::BOOL,
    pub hProcess: super::super::Foundation::HANDLE,
    pub fpProcess: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_MAPMEMORYDATA {}
impl ::core::clone::Clone for DD_MAPMEMORYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_MAPMEMORYDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_MAPMEMORYDATA")
            .field("lpDD", &self.lpDD)
            .field("bMap", &self.bMap)
            .field("hProcess", &self.hProcess)
            .field("fpProcess", &self.fpProcess)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_MAPMEMORYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.bMap == other.bMap
            && self.hProcess == other.hProcess
            && self.fpProcess == other.fpProcess
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_MAPMEMORYDATA {}
impl FromIntoMemory for DD_MAPMEMORYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_bMap =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hProcess =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_fpProcess = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            bMap: f_bMap,
            hProcess: f_hProcess,
            fpProcess: f_fpProcess,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.bMap, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hProcess, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.fpProcess, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_MISCELLANEOUS2CALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub AlphaBlt: PDD_ALPHABLT,
    pub CreateSurfaceEx: PDD_CREATESURFACEEX,
    pub GetDriverState: PDD_GETDRIVERSTATE,
    pub DestroyDDLocal: PDD_DESTROYDDLOCAL,
}
impl ::core::marker::Copy for DD_MISCELLANEOUS2CALLBACKS {}
impl ::core::clone::Clone for DD_MISCELLANEOUS2CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_MISCELLANEOUS2CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_MISCELLANEOUS2CALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("AlphaBlt", &self.AlphaBlt)
            .field("CreateSurfaceEx", &self.CreateSurfaceEx)
            .field("GetDriverState", &self.GetDriverState)
            .field("DestroyDDLocal", &self.DestroyDDLocal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_MISCELLANEOUS2CALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.AlphaBlt == other.AlphaBlt
            && self.CreateSurfaceEx == other.CreateSurfaceEx
            && self.GetDriverState == other.GetDriverState
            && self.DestroyDDLocal == other.DestroyDDLocal
    }
}
impl ::core::cmp::Eq for DD_MISCELLANEOUS2CALLBACKS {}
impl FromIntoMemory for DD_MISCELLANEOUS2CALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_AlphaBlt = <PDD_ALPHABLT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateSurfaceEx =
            <PDD_CREATESURFACEEX as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_GetDriverState =
            <PDD_GETDRIVERSTATE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_DestroyDDLocal =
            <PDD_DESTROYDDLOCAL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            AlphaBlt: f_AlphaBlt,
            CreateSurfaceEx: f_CreateSurfaceEx,
            GetDriverState: f_GetDriverState,
            DestroyDDLocal: f_DestroyDDLocal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.AlphaBlt, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateSurfaceEx, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.GetDriverState, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.DestroyDDLocal, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_MISCELLANEOUSCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub GetAvailDriverMemory: PDD_GETAVAILDRIVERMEMORY,
}
impl ::core::marker::Copy for DD_MISCELLANEOUSCALLBACKS {}
impl ::core::clone::Clone for DD_MISCELLANEOUSCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_MISCELLANEOUSCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_MISCELLANEOUSCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("GetAvailDriverMemory", &self.GetAvailDriverMemory)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_MISCELLANEOUSCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.GetAvailDriverMemory == other.GetAvailDriverMemory
    }
}
impl ::core::cmp::Eq for DD_MISCELLANEOUSCALLBACKS {}
impl FromIntoMemory for DD_MISCELLANEOUSCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_GetAvailDriverMemory =
            <PDD_GETAVAILDRIVERMEMORY as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            GetAvailDriverMemory: f_GetAvailDriverMemory,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.GetAvailDriverMemory, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct DD_MORECAPS {
    pub dwSize: u32,
    pub dwAlphaCaps: u32,
    pub dwSVBAlphaCaps: u32,
    pub dwVSBAlphaCaps: u32,
    pub dwSSBAlphaCaps: u32,
    pub dwFilterCaps: u32,
    pub dwSVBFilterCaps: u32,
    pub dwVSBFilterCaps: u32,
    pub dwSSBFilterCaps: u32,
}
impl ::core::marker::Copy for DD_MORECAPS {}
impl ::core::clone::Clone for DD_MORECAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_MORECAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_MORECAPS")
            .field("dwSize", &self.dwSize)
            .field("dwAlphaCaps", &self.dwAlphaCaps)
            .field("dwSVBAlphaCaps", &self.dwSVBAlphaCaps)
            .field("dwVSBAlphaCaps", &self.dwVSBAlphaCaps)
            .field("dwSSBAlphaCaps", &self.dwSSBAlphaCaps)
            .field("dwFilterCaps", &self.dwFilterCaps)
            .field("dwSVBFilterCaps", &self.dwSVBFilterCaps)
            .field("dwVSBFilterCaps", &self.dwVSBFilterCaps)
            .field("dwSSBFilterCaps", &self.dwSSBFilterCaps)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_MORECAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwAlphaCaps == other.dwAlphaCaps
            && self.dwSVBAlphaCaps == other.dwSVBAlphaCaps
            && self.dwVSBAlphaCaps == other.dwVSBAlphaCaps
            && self.dwSSBAlphaCaps == other.dwSSBAlphaCaps
            && self.dwFilterCaps == other.dwFilterCaps
            && self.dwSVBFilterCaps == other.dwSVBFilterCaps
            && self.dwVSBFilterCaps == other.dwVSBFilterCaps
            && self.dwSSBFilterCaps == other.dwSSBFilterCaps
    }
}
impl ::core::cmp::Eq for DD_MORECAPS {}
impl FromIntoMemory for DD_MORECAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwSVBAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwVSBAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwSSBAlphaCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFilterCaps = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwSVBFilterCaps = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwVSBFilterCaps = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwSSBFilterCaps = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            dwSize: f_dwSize,
            dwAlphaCaps: f_dwAlphaCaps,
            dwSVBAlphaCaps: f_dwSVBAlphaCaps,
            dwVSBAlphaCaps: f_dwVSBAlphaCaps,
            dwSSBAlphaCaps: f_dwSSBAlphaCaps,
            dwFilterCaps: f_dwFilterCaps,
            dwSVBFilterCaps: f_dwSVBFilterCaps,
            dwVSBFilterCaps: f_dwVSBFilterCaps,
            dwSSBFilterCaps: f_dwSSBFilterCaps,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBAlphaCaps, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBAlphaCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBAlphaCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFilterCaps, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwSVBFilterCaps, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwVSBFilterCaps, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwSSBFilterCaps, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct DD_MORESURFACECAPS {
    pub dwSize: u32,
    pub ddsCapsMore: DDSCAPSEX,
    pub ddsExtendedHeapRestrictions: [DD_MORESURFACECAPS_0; 1],
}
impl ::core::marker::Copy for DD_MORESURFACECAPS {}
impl ::core::clone::Clone for DD_MORESURFACECAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_MORESURFACECAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.ddsCapsMore == other.ddsCapsMore
            && self.ddsExtendedHeapRestrictions == other.ddsExtendedHeapRestrictions
    }
}
impl ::core::cmp::Eq for DD_MORESURFACECAPS {}
impl FromIntoMemory for DD_MORESURFACECAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ddsCapsMore = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[4..4 + 12]);
        let f_ddsExtendedHeapRestrictions =
            <[DD_MORESURFACECAPS_0; 1] as FromIntoMemory>::from_bytes(&from[16..16 + 24]);
        Self {
            dwSize: f_dwSize,
            ddsCapsMore: f_ddsCapsMore,
            ddsExtendedHeapRestrictions: f_ddsExtendedHeapRestrictions,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsMore, &mut into[4..4 + 12]);
        FromIntoMemory::into_bytes(self.ddsExtendedHeapRestrictions, &mut into[16..16 + 24]);
    }
    fn size() -> usize {
        40
    }
}
pub struct DD_MORESURFACECAPS_0 {
    pub ddsCapsEx: DDSCAPSEX,
    pub ddsCapsExAlt: DDSCAPSEX,
}
impl ::core::marker::Copy for DD_MORESURFACECAPS_0 {}
impl ::core::clone::Clone for DD_MORESURFACECAPS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_MORESURFACECAPS_0 {
    fn eq(&self, other: &Self) -> bool {
        self.ddsCapsEx == other.ddsCapsEx && self.ddsCapsExAlt == other.ddsCapsExAlt
    }
}
impl ::core::cmp::Eq for DD_MORESURFACECAPS_0 {}
impl FromIntoMemory for DD_MORESURFACECAPS_0 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_ddsCapsEx = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[0..0 + 12]);
        let f_ddsCapsExAlt = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[12..12 + 12]);
        Self {
            ddsCapsEx: f_ddsCapsEx,
            ddsCapsExAlt: f_ddsCapsExAlt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.ddsCapsEx, &mut into[0..0 + 12]);
        FromIntoMemory::into_bytes(self.ddsCapsExAlt, &mut into[12..12 + 12]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_MOTIONCOMPCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub GetMoCompGuids: PDD_MOCOMPCB_GETGUIDS,
    pub GetMoCompFormats: PDD_MOCOMPCB_GETFORMATS,
    pub CreateMoComp: PDD_MOCOMPCB_CREATE,
    pub GetMoCompBuffInfo: PDD_MOCOMPCB_GETCOMPBUFFINFO,
    pub GetInternalMoCompInfo: PDD_MOCOMPCB_GETINTERNALINFO,
    pub BeginMoCompFrame: PDD_MOCOMPCB_BEGINFRAME,
    pub EndMoCompFrame: PDD_MOCOMPCB_ENDFRAME,
    pub RenderMoComp: PDD_MOCOMPCB_RENDER,
    pub QueryMoCompStatus: PDD_MOCOMPCB_QUERYSTATUS,
    pub DestroyMoComp: PDD_MOCOMPCB_DESTROY,
}
impl ::core::marker::Copy for DD_MOTIONCOMPCALLBACKS {}
impl ::core::clone::Clone for DD_MOTIONCOMPCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_MOTIONCOMPCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_MOTIONCOMPCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("GetMoCompGuids", &self.GetMoCompGuids)
            .field("GetMoCompFormats", &self.GetMoCompFormats)
            .field("CreateMoComp", &self.CreateMoComp)
            .field("GetMoCompBuffInfo", &self.GetMoCompBuffInfo)
            .field("GetInternalMoCompInfo", &self.GetInternalMoCompInfo)
            .field("BeginMoCompFrame", &self.BeginMoCompFrame)
            .field("EndMoCompFrame", &self.EndMoCompFrame)
            .field("RenderMoComp", &self.RenderMoComp)
            .field("QueryMoCompStatus", &self.QueryMoCompStatus)
            .field("DestroyMoComp", &self.DestroyMoComp)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_MOTIONCOMPCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.GetMoCompGuids == other.GetMoCompGuids
            && self.GetMoCompFormats == other.GetMoCompFormats
            && self.CreateMoComp == other.CreateMoComp
            && self.GetMoCompBuffInfo == other.GetMoCompBuffInfo
            && self.GetInternalMoCompInfo == other.GetInternalMoCompInfo
            && self.BeginMoCompFrame == other.BeginMoCompFrame
            && self.EndMoCompFrame == other.EndMoCompFrame
            && self.RenderMoComp == other.RenderMoComp
            && self.QueryMoCompStatus == other.QueryMoCompStatus
            && self.DestroyMoComp == other.DestroyMoComp
    }
}
impl ::core::cmp::Eq for DD_MOTIONCOMPCALLBACKS {}
impl FromIntoMemory for DD_MOTIONCOMPCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 48);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_GetMoCompGuids =
            <PDD_MOCOMPCB_GETGUIDS as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_GetMoCompFormats =
            <PDD_MOCOMPCB_GETFORMATS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_CreateMoComp = <PDD_MOCOMPCB_CREATE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetMoCompBuffInfo =
            <PDD_MOCOMPCB_GETCOMPBUFFINFO as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_GetInternalMoCompInfo =
            <PDD_MOCOMPCB_GETINTERNALINFO as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_BeginMoCompFrame =
            <PDD_MOCOMPCB_BEGINFRAME as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_EndMoCompFrame =
            <PDD_MOCOMPCB_ENDFRAME as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_RenderMoComp = <PDD_MOCOMPCB_RENDER as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_QueryMoCompStatus =
            <PDD_MOCOMPCB_QUERYSTATUS as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_DestroyMoComp =
            <PDD_MOCOMPCB_DESTROY as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            GetMoCompGuids: f_GetMoCompGuids,
            GetMoCompFormats: f_GetMoCompFormats,
            CreateMoComp: f_CreateMoComp,
            GetMoCompBuffInfo: f_GetMoCompBuffInfo,
            GetInternalMoCompInfo: f_GetInternalMoCompInfo,
            BeginMoCompFrame: f_BeginMoCompFrame,
            EndMoCompFrame: f_EndMoCompFrame,
            RenderMoComp: f_RenderMoComp,
            QueryMoCompStatus: f_QueryMoCompStatus,
            DestroyMoComp: f_DestroyMoComp,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 48);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompGuids, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompFormats, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.CreateMoComp, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetMoCompBuffInfo, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.GetInternalMoCompInfo, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.BeginMoCompFrame, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.EndMoCompFrame, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.RenderMoComp, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.QueryMoCompStatus, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.DestroyMoComp, &mut into[44..44 + 4]);
    }
    fn size() -> usize {
        48
    }
}
pub struct DD_MOTIONCOMP_LOCAL {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub guid: crate::core::GUID,
    pub dwUncompWidth: u32,
    pub dwUncompHeight: u32,
    pub ddUncompPixelFormat: DDPIXELFORMAT,
    pub dwDriverReserved1: u32,
    pub dwDriverReserved2: u32,
    pub dwDriverReserved3: u32,
    pub lpDriverReserved1: MutPtr<::core::ffi::c_void>,
    pub lpDriverReserved2: MutPtr<::core::ffi::c_void>,
    pub lpDriverReserved3: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_MOTIONCOMP_LOCAL {}
impl ::core::clone::Clone for DD_MOTIONCOMP_LOCAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_MOTIONCOMP_LOCAL {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.guid == other.guid
            && self.dwUncompWidth == other.dwUncompWidth
            && self.dwUncompHeight == other.dwUncompHeight
            && self.ddUncompPixelFormat == other.ddUncompPixelFormat
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
            && self.lpDriverReserved1 == other.lpDriverReserved1
            && self.lpDriverReserved2 == other.lpDriverReserved2
            && self.lpDriverReserved3 == other.lpDriverReserved3
    }
}
impl ::core::cmp::Eq for DD_MOTIONCOMP_LOCAL {}
impl FromIntoMemory for DD_MOTIONCOMP_LOCAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 84);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_guid = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        let f_dwUncompWidth = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwUncompHeight = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_ddUncompPixelFormat =
            <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[28..28 + 32]);
        let f_dwDriverReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwDriverReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwDriverReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_lpDriverReserved1 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_lpDriverReserved2 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_lpDriverReserved3 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        Self {
            lpDD: f_lpDD,
            guid: f_guid,
            dwUncompWidth: f_dwUncompWidth,
            dwUncompHeight: f_dwUncompHeight,
            ddUncompPixelFormat: f_ddUncompPixelFormat,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
            lpDriverReserved1: f_lpDriverReserved1,
            lpDriverReserved2: f_lpDriverReserved2,
            lpDriverReserved3: f_lpDriverReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 84);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.guid, &mut into[4..4 + 16]);
        FromIntoMemory::into_bytes(self.dwUncompWidth, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwUncompHeight, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.ddUncompPixelFormat, &mut into[28..28 + 32]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.lpDriverReserved1, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.lpDriverReserved2, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.lpDriverReserved3, &mut into[80..80 + 4]);
    }
    fn size() -> usize {
        84
    }
}
pub struct DD_NONLOCALVIDMEMCAPS {
    pub dwSize: u32,
    pub dwNLVBCaps: u32,
    pub dwNLVBCaps2: u32,
    pub dwNLVBCKeyCaps: u32,
    pub dwNLVBFXCaps: u32,
    pub dwNLVBRops: [u32; 8],
}
impl ::core::marker::Copy for DD_NONLOCALVIDMEMCAPS {}
impl ::core::clone::Clone for DD_NONLOCALVIDMEMCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_NONLOCALVIDMEMCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_NONLOCALVIDMEMCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwNLVBCaps", &self.dwNLVBCaps)
            .field("dwNLVBCaps2", &self.dwNLVBCaps2)
            .field("dwNLVBCKeyCaps", &self.dwNLVBCKeyCaps)
            .field("dwNLVBFXCaps", &self.dwNLVBFXCaps)
            .field("dwNLVBRops", &self.dwNLVBRops)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_NONLOCALVIDMEMCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwNLVBCaps == other.dwNLVBCaps
            && self.dwNLVBCaps2 == other.dwNLVBCaps2
            && self.dwNLVBCKeyCaps == other.dwNLVBCKeyCaps
            && self.dwNLVBFXCaps == other.dwNLVBFXCaps
            && self.dwNLVBRops == other.dwNLVBRops
    }
}
impl ::core::cmp::Eq for DD_NONLOCALVIDMEMCAPS {}
impl FromIntoMemory for DD_NONLOCALVIDMEMCAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 52);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwNLVBCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwNLVBCaps2 = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwNLVBCKeyCaps = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwNLVBFXCaps = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwNLVBRops = <[u32; 8] as FromIntoMemory>::from_bytes(&from[20..20 + 32]);
        Self {
            dwSize: f_dwSize,
            dwNLVBCaps: f_dwNLVBCaps,
            dwNLVBCaps2: f_dwNLVBCaps2,
            dwNLVBCKeyCaps: f_dwNLVBCKeyCaps,
            dwNLVBFXCaps: f_dwNLVBFXCaps,
            dwNLVBRops: f_dwNLVBRops,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 52);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCaps2, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBCKeyCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBFXCaps, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwNLVBRops, &mut into[20..20 + 32]);
    }
    fn size() -> usize {
        52
    }
}
pub struct DD_NTCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub FreeDriverMemory: PDD_FREEDRIVERMEMORY,
    pub SetExclusiveMode: PDD_SETEXCLUSIVEMODE,
    pub FlipToGDISurface: PDD_FLIPTOGDISURFACE,
}
impl ::core::marker::Copy for DD_NTCALLBACKS {}
impl ::core::clone::Clone for DD_NTCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_NTCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_NTCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("FreeDriverMemory", &self.FreeDriverMemory)
            .field("SetExclusiveMode", &self.SetExclusiveMode)
            .field("FlipToGDISurface", &self.FlipToGDISurface)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_NTCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.FreeDriverMemory == other.FreeDriverMemory
            && self.SetExclusiveMode == other.SetExclusiveMode
            && self.FlipToGDISurface == other.FlipToGDISurface
    }
}
impl ::core::cmp::Eq for DD_NTCALLBACKS {}
impl FromIntoMemory for DD_NTCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_FreeDriverMemory =
            <PDD_FREEDRIVERMEMORY as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SetExclusiveMode =
            <PDD_SETEXCLUSIVEMODE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_FlipToGDISurface =
            <PDD_FLIPTOGDISURFACE as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            FreeDriverMemory: f_FreeDriverMemory,
            SetExclusiveMode: f_SetExclusiveMode,
            FlipToGDISurface: f_FlipToGDISurface,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.FreeDriverMemory, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SetExclusiveMode, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.FlipToGDISurface, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_NTPRIVATEDRIVERCAPS {
    pub dwSize: u32,
    pub dwPrivateCaps: u32,
}
impl ::core::marker::Copy for DD_NTPRIVATEDRIVERCAPS {}
impl ::core::clone::Clone for DD_NTPRIVATEDRIVERCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_NTPRIVATEDRIVERCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_NTPRIVATEDRIVERCAPS")
            .field("dwSize", &self.dwSize)
            .field("dwPrivateCaps", &self.dwPrivateCaps)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_NTPRIVATEDRIVERCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwPrivateCaps == other.dwPrivateCaps
    }
}
impl ::core::cmp::Eq for DD_NTPRIVATEDRIVERCAPS {}
impl FromIntoMemory for DD_NTPRIVATEDRIVERCAPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwPrivateCaps = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            dwSize: f_dwSize,
            dwPrivateCaps: f_dwPrivateCaps,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwPrivateCaps, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub struct DD_PALETTECALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub DestroyPalette: PDD_PALCB_DESTROYPALETTE,
    pub SetEntries: PDD_PALCB_SETENTRIES,
}
impl ::core::marker::Copy for DD_PALETTECALLBACKS {}
impl ::core::clone::Clone for DD_PALETTECALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_PALETTECALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_PALETTECALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("DestroyPalette", &self.DestroyPalette)
            .field("SetEntries", &self.SetEntries)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_PALETTECALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.DestroyPalette == other.DestroyPalette
            && self.SetEntries == other.SetEntries
    }
}
impl ::core::cmp::Eq for DD_PALETTECALLBACKS {}
impl FromIntoMemory for DD_PALETTECALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DestroyPalette =
            <PDD_PALCB_DESTROYPALETTE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SetEntries = <PDD_PALCB_SETENTRIES as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            DestroyPalette: f_DestroyPalette,
            SetEntries: f_SetEntries,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DestroyPalette, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SetEntries, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_PALETTE_GLOBAL {
    pub dwReserved1: PtrRepr,
}
impl ::core::marker::Copy for DD_PALETTE_GLOBAL {}
impl ::core::clone::Clone for DD_PALETTE_GLOBAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_PALETTE_GLOBAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_PALETTE_GLOBAL")
            .field("dwReserved1", &self.dwReserved1)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_PALETTE_GLOBAL {
    fn eq(&self, other: &Self) -> bool {
        self.dwReserved1 == other.dwReserved1
    }
}
impl ::core::cmp::Eq for DD_PALETTE_GLOBAL {}
impl FromIntoMemory for DD_PALETTE_GLOBAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            dwReserved1: f_dwReserved1,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_PALETTE_LOCAL {
    pub dwReserved0: u32,
    pub dwReserved1: PtrRepr,
}
impl ::core::marker::Copy for DD_PALETTE_LOCAL {}
impl ::core::clone::Clone for DD_PALETTE_LOCAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_PALETTE_LOCAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_PALETTE_LOCAL")
            .field("dwReserved0", &self.dwReserved0)
            .field("dwReserved1", &self.dwReserved1)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_PALETTE_LOCAL {
    fn eq(&self, other: &Self) -> bool {
        self.dwReserved0 == other.dwReserved0 && self.dwReserved1 == other.dwReserved1
    }
}
impl ::core::cmp::Eq for DD_PALETTE_LOCAL {}
impl FromIntoMemory for DD_PALETTE_LOCAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_dwReserved0 = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            dwReserved0: f_dwReserved0,
            dwReserved1: f_dwReserved1,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.dwReserved0, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub struct DD_QUERYMOCOMPSTATUSDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpMoComp: MutPtr<DD_MOTIONCOMP_LOCAL>,
    pub lpSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwFlags: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_QUERYMOCOMPSTATUSDATA {}
impl ::core::clone::Clone for DD_QUERYMOCOMPSTATUSDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_QUERYMOCOMPSTATUSDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_QUERYMOCOMPSTATUSDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("lpSurface", &self.lpSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_QUERYMOCOMPSTATUSDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.lpSurface == other.lpSurface
            && self.dwFlags == other.dwFlags
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_QUERYMOCOMPSTATUSDATA {}
impl FromIntoMemory for DD_QUERYMOCOMPSTATUSDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DD_MOTIONCOMP_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpSurface = <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            lpSurface: f_lpSurface,
            dwFlags: f_dwFlags,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_RENDERMOCOMPDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpMoComp: MutPtr<DD_MOTIONCOMP_LOCAL>,
    pub dwNumBuffers: u32,
    pub lpBufferInfo: MutPtr<DDMOCOMPBUFFERINFO>,
    pub dwFunction: u32,
    pub lpInputData: MutPtr<::core::ffi::c_void>,
    pub dwInputDataSize: u32,
    pub lpOutputData: MutPtr<::core::ffi::c_void>,
    pub dwOutputDataSize: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_RENDERMOCOMPDATA {}
impl ::core::clone::Clone for DD_RENDERMOCOMPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_RENDERMOCOMPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_RENDERMOCOMPDATA")
            .field("lpDD", &self.lpDD)
            .field("lpMoComp", &self.lpMoComp)
            .field("dwNumBuffers", &self.dwNumBuffers)
            .field("lpBufferInfo", &self.lpBufferInfo)
            .field("dwFunction", &self.dwFunction)
            .field("lpInputData", &self.lpInputData)
            .field("dwInputDataSize", &self.dwInputDataSize)
            .field("lpOutputData", &self.lpOutputData)
            .field("dwOutputDataSize", &self.dwOutputDataSize)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_RENDERMOCOMPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpMoComp == other.lpMoComp
            && self.dwNumBuffers == other.dwNumBuffers
            && self.lpBufferInfo == other.lpBufferInfo
            && self.dwFunction == other.dwFunction
            && self.lpInputData == other.lpInputData
            && self.dwInputDataSize == other.dwInputDataSize
            && self.lpOutputData == other.lpOutputData
            && self.dwOutputDataSize == other.dwOutputDataSize
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_RENDERMOCOMPDATA {}
impl FromIntoMemory for DD_RENDERMOCOMPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpMoComp =
            <MutPtr<DD_MOTIONCOMP_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwNumBuffers = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpBufferInfo =
            <MutPtr<DDMOCOMPBUFFERINFO> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwFunction = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpInputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwInputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpOutputData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwOutputDataSize = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        Self {
            lpDD: f_lpDD,
            lpMoComp: f_lpMoComp,
            dwNumBuffers: f_dwNumBuffers,
            lpBufferInfo: f_lpBufferInfo,
            dwFunction: f_dwFunction,
            lpInputData: f_lpInputData,
            dwInputDataSize: f_dwInputDataSize,
            lpOutputData: f_lpOutputData,
            dwOutputDataSize: f_dwOutputDataSize,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpMoComp, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwNumBuffers, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpBufferInfo, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwFunction, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpInputData, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwInputDataSize, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpOutputData, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwOutputDataSize, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[36..36 + 4]);
    }
    fn size() -> usize {
        40
    }
}
pub const DD_RUNTIME_VERSION: i32 = 2306i32;
pub struct DD_SETCLIPLISTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub SetClipList: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_SETCLIPLISTDATA {}
impl ::core::clone::Clone for DD_SETCLIPLISTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SETCLIPLISTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SETCLIPLISTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("ddRVal", &self.ddRVal)
            .field("SetClipList", &self.SetClipList)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SETCLIPLISTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.ddRVal == other.ddRVal
            && self.SetClipList == other.SetClipList
    }
}
impl ::core::cmp::Eq for DD_SETCLIPLISTDATA {}
impl FromIntoMemory for DD_SETCLIPLISTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_SetClipList =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            ddRVal: f_ddRVal,
            SetClipList: f_SetClipList,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.SetClipList, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_SETCOLORKEYDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwFlags: u32,
    pub ckNew: DDCOLORKEY,
    pub ddRVal: crate::core::HRESULT,
    pub SetColorKey: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_SETCOLORKEYDATA {}
impl ::core::clone::Clone for DD_SETCOLORKEYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SETCOLORKEYDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SETCOLORKEYDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwFlags", &self.dwFlags)
            .field("ckNew", &self.ckNew)
            .field("ddRVal", &self.ddRVal)
            .field("SetColorKey", &self.SetColorKey)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SETCOLORKEYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwFlags == other.dwFlags
            && self.ckNew == other.ckNew
            && self.ddRVal == other.ddRVal
            && self.SetColorKey == other.SetColorKey
    }
}
impl ::core::cmp::Eq for DD_SETCOLORKEYDATA {}
impl FromIntoMemory for DD_SETCOLORKEYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ckNew = <DDCOLORKEY as FromIntoMemory>::from_bytes(&from[12..12 + 8]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_SetColorKey =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwFlags: f_dwFlags,
            ckNew: f_ckNew,
            ddRVal: f_ddRVal,
            SetColorKey: f_SetColorKey,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ckNew, &mut into[12..12 + 8]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DD_SETENTRIESDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDPalette: MutPtr<DD_PALETTE_GLOBAL>,
    pub dwBase: u32,
    pub dwNumEntries: u32,
    pub lpEntries: MutPtr<super::Gdi::PALETTEENTRY>,
    pub ddRVal: crate::core::HRESULT,
    pub SetEntries: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_SETENTRIESDATA {}
impl ::core::clone::Clone for DD_SETENTRIESDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SETENTRIESDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SETENTRIESDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("dwBase", &self.dwBase)
            .field("dwNumEntries", &self.dwNumEntries)
            .field("lpEntries", &self.lpEntries)
            .field("ddRVal", &self.ddRVal)
            .field("SetEntries", &self.SetEntries)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SETENTRIESDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDPalette == other.lpDDPalette
            && self.dwBase == other.dwBase
            && self.dwNumEntries == other.dwNumEntries
            && self.lpEntries == other.lpEntries
            && self.ddRVal == other.ddRVal
            && self.SetEntries == other.SetEntries
    }
}
impl ::core::cmp::Eq for DD_SETENTRIESDATA {}
impl FromIntoMemory for DD_SETENTRIESDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDPalette =
            <MutPtr<DD_PALETTE_GLOBAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwBase = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwNumEntries = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpEntries =
            <MutPtr<super::Gdi::PALETTEENTRY> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_SetEntries =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDPalette: f_lpDDPalette,
            dwBase: f_dwBase,
            dwNumEntries: f_dwNumEntries,
            lpEntries: f_lpEntries,
            ddRVal: f_ddRVal,
            SetEntries: f_SetEntries,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwBase, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwNumEntries, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpEntries, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.SetEntries, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DD_SETEXCLUSIVEMODEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub dwEnterExcl: u32,
    pub dwReserved: u32,
    pub ddRVal: crate::core::HRESULT,
    pub SetExclusiveMode: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_SETEXCLUSIVEMODEDATA {}
impl ::core::clone::Clone for DD_SETEXCLUSIVEMODEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SETEXCLUSIVEMODEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SETEXCLUSIVEMODEDATA")
            .field("lpDD", &self.lpDD)
            .field("dwEnterExcl", &self.dwEnterExcl)
            .field("dwReserved", &self.dwReserved)
            .field("ddRVal", &self.ddRVal)
            .field("SetExclusiveMode", &self.SetExclusiveMode)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SETEXCLUSIVEMODEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwEnterExcl == other.dwEnterExcl
            && self.dwReserved == other.dwReserved
            && self.ddRVal == other.ddRVal
            && self.SetExclusiveMode == other.SetExclusiveMode
    }
}
impl ::core::cmp::Eq for DD_SETEXCLUSIVEMODEDATA {}
impl FromIntoMemory for DD_SETEXCLUSIVEMODEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwEnterExcl = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetExclusiveMode =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpDD: f_lpDD,
            dwEnterExcl: f_dwEnterExcl,
            dwReserved: f_dwReserved,
            ddRVal: f_ddRVal,
            SetExclusiveMode: f_SetExclusiveMode,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwEnterExcl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetExclusiveMode, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DD_SETOVERLAYPOSITIONDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSrcSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub lpDDDestSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub lXPos: i32,
    pub lYPos: i32,
    pub ddRVal: crate::core::HRESULT,
    pub SetOverlayPosition: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_SETOVERLAYPOSITIONDATA {}
impl ::core::clone::Clone for DD_SETOVERLAYPOSITIONDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SETOVERLAYPOSITIONDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SETOVERLAYPOSITIONDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSrcSurface", &self.lpDDSrcSurface)
            .field("lpDDDestSurface", &self.lpDDDestSurface)
            .field("lXPos", &self.lXPos)
            .field("lYPos", &self.lYPos)
            .field("ddRVal", &self.ddRVal)
            .field("SetOverlayPosition", &self.SetOverlayPosition)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SETOVERLAYPOSITIONDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSrcSurface == other.lpDDSrcSurface
            && self.lpDDDestSurface == other.lpDDDestSurface
            && self.lXPos == other.lXPos
            && self.lYPos == other.lYPos
            && self.ddRVal == other.ddRVal
            && self.SetOverlayPosition == other.SetOverlayPosition
    }
}
impl ::core::cmp::Eq for DD_SETOVERLAYPOSITIONDATA {}
impl FromIntoMemory for DD_SETOVERLAYPOSITIONDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSrcSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDDestSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lXPos = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lYPos = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_SetOverlayPosition =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSrcSurface: f_lpDDSrcSurface,
            lpDDDestSurface: f_lpDDDestSurface,
            lXPos: f_lXPos,
            lYPos: f_lYPos,
            ddRVal: f_ddRVal,
            SetOverlayPosition: f_SetOverlayPosition,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSrcSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDDestSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lXPos, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lYPos, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.SetOverlayPosition, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DD_SETPALETTEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub lpDDPalette: MutPtr<DD_PALETTE_GLOBAL>,
    pub ddRVal: crate::core::HRESULT,
    pub SetPalette: MutPtr<::core::ffi::c_void>,
    pub Attach: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DD_SETPALETTEDATA {}
impl ::core::clone::Clone for DD_SETPALETTEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SETPALETTEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SETPALETTEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("lpDDPalette", &self.lpDDPalette)
            .field("ddRVal", &self.ddRVal)
            .field("SetPalette", &self.SetPalette)
            .field("Attach", &self.Attach)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SETPALETTEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.lpDDPalette == other.lpDDPalette
            && self.ddRVal == other.ddRVal
            && self.SetPalette == other.SetPalette
            && self.Attach == other.Attach
    }
}
impl ::core::cmp::Eq for DD_SETPALETTEDATA {}
impl FromIntoMemory for DD_SETPALETTEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpDDPalette =
            <MutPtr<DD_PALETTE_GLOBAL> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetPalette =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Attach =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            lpDDPalette: f_lpDDPalette,
            ddRVal: f_ddRVal,
            SetPalette: f_SetPalette,
            Attach: f_Attach,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpDDPalette, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetPalette, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Attach, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_STEREOMODE {
    pub dwSize: u32,
    pub dwHeight: u32,
    pub dwWidth: u32,
    pub dwBpp: u32,
    pub dwRefreshRate: u32,
    pub bSupported: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DD_STEREOMODE {}
impl ::core::clone::Clone for DD_STEREOMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_STEREOMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_STEREOMODE")
            .field("dwSize", &self.dwSize)
            .field("dwHeight", &self.dwHeight)
            .field("dwWidth", &self.dwWidth)
            .field("dwBpp", &self.dwBpp)
            .field("dwRefreshRate", &self.dwRefreshRate)
            .field("bSupported", &self.bSupported)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_STEREOMODE {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwHeight == other.dwHeight
            && self.dwWidth == other.dwWidth
            && self.dwBpp == other.dwBpp
            && self.dwRefreshRate == other.dwRefreshRate
            && self.bSupported == other.bSupported
    }
}
impl ::core::cmp::Eq for DD_STEREOMODE {}
impl FromIntoMemory for DD_STEREOMODE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwBpp = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwRefreshRate = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_bSupported =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwSize: f_dwSize,
            dwHeight: f_dwHeight,
            dwWidth: f_dwWidth,
            dwBpp: f_dwBpp,
            dwRefreshRate: f_dwRefreshRate,
            bSupported: f_bSupported,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwBpp, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwRefreshRate, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.bSupported, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_SURFACECALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub DestroySurface: PDD_SURFCB_DESTROYSURFACE,
    pub Flip: PDD_SURFCB_FLIP,
    pub SetClipList: PDD_SURFCB_SETCLIPLIST,
    pub Lock: PDD_SURFCB_LOCK,
    pub Unlock: PDD_SURFCB_UNLOCK,
    pub Blt: PDD_SURFCB_BLT,
    pub SetColorKey: PDD_SURFCB_SETCOLORKEY,
    pub AddAttachedSurface: PDD_SURFCB_ADDATTACHEDSURFACE,
    pub GetBltStatus: PDD_SURFCB_GETBLTSTATUS,
    pub GetFlipStatus: PDD_SURFCB_GETFLIPSTATUS,
    pub UpdateOverlay: PDD_SURFCB_UPDATEOVERLAY,
    pub SetOverlayPosition: PDD_SURFCB_SETOVERLAYPOSITION,
    pub reserved4: MutPtr<::core::ffi::c_void>,
    pub SetPalette: PDD_SURFCB_SETPALETTE,
}
impl ::core::marker::Copy for DD_SURFACECALLBACKS {}
impl ::core::clone::Clone for DD_SURFACECALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SURFACECALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SURFACECALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("DestroySurface", &self.DestroySurface)
            .field("Flip", &self.Flip)
            .field("SetClipList", &self.SetClipList)
            .field("Lock", &self.Lock)
            .field("Unlock", &self.Unlock)
            .field("Blt", &self.Blt)
            .field("SetColorKey", &self.SetColorKey)
            .field("AddAttachedSurface", &self.AddAttachedSurface)
            .field("GetBltStatus", &self.GetBltStatus)
            .field("GetFlipStatus", &self.GetFlipStatus)
            .field("UpdateOverlay", &self.UpdateOverlay)
            .field("SetOverlayPosition", &self.SetOverlayPosition)
            .field("reserved4", &self.reserved4)
            .field("SetPalette", &self.SetPalette)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SURFACECALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.DestroySurface == other.DestroySurface
            && self.Flip == other.Flip
            && self.SetClipList == other.SetClipList
            && self.Lock == other.Lock
            && self.Unlock == other.Unlock
            && self.Blt == other.Blt
            && self.SetColorKey == other.SetColorKey
            && self.AddAttachedSurface == other.AddAttachedSurface
            && self.GetBltStatus == other.GetBltStatus
            && self.GetFlipStatus == other.GetFlipStatus
            && self.UpdateOverlay == other.UpdateOverlay
            && self.SetOverlayPosition == other.SetOverlayPosition
            && self.reserved4 == other.reserved4
            && self.SetPalette == other.SetPalette
    }
}
impl ::core::cmp::Eq for DD_SURFACECALLBACKS {}
impl FromIntoMemory for DD_SURFACECALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 64);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_DestroySurface =
            <PDD_SURFCB_DESTROYSURFACE as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Flip = <PDD_SURFCB_FLIP as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_SetClipList =
            <PDD_SURFCB_SETCLIPLIST as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Lock = <PDD_SURFCB_LOCK as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_Unlock = <PDD_SURFCB_UNLOCK as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_Blt = <PDD_SURFCB_BLT as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_SetColorKey =
            <PDD_SURFCB_SETCOLORKEY as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_AddAttachedSurface =
            <PDD_SURFCB_ADDATTACHEDSURFACE as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_GetBltStatus =
            <PDD_SURFCB_GETBLTSTATUS as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_GetFlipStatus =
            <PDD_SURFCB_GETFLIPSTATUS as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_UpdateOverlay =
            <PDD_SURFCB_UPDATEOVERLAY as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_SetOverlayPosition =
            <PDD_SURFCB_SETOVERLAYPOSITION as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_reserved4 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_SetPalette = <PDD_SURFCB_SETPALETTE as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            DestroySurface: f_DestroySurface,
            Flip: f_Flip,
            SetClipList: f_SetClipList,
            Lock: f_Lock,
            Unlock: f_Unlock,
            Blt: f_Blt,
            SetColorKey: f_SetColorKey,
            AddAttachedSurface: f_AddAttachedSurface,
            GetBltStatus: f_GetBltStatus,
            GetFlipStatus: f_GetFlipStatus,
            UpdateOverlay: f_UpdateOverlay,
            SetOverlayPosition: f_SetOverlayPosition,
            reserved4: f_reserved4,
            SetPalette: f_SetPalette,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 64);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.DestroySurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Flip, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.SetClipList, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Lock, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.Unlock, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.Blt, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.SetColorKey, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.AddAttachedSurface, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.GetBltStatus, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.GetFlipStatus, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.UpdateOverlay, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.SetOverlayPosition, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.reserved4, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.SetPalette, &mut into[60..60 + 4]);
    }
    fn size() -> usize {
        64
    }
}
pub struct DD_SURFACE_GLOBAL {
    pub Anonymous1: DD_SURFACE_GLOBAL_0,
    pub Anonymous2: DD_SURFACE_GLOBAL_1,
    pub fpVidMem: PtrRepr,
    pub Anonymous3: DD_SURFACE_GLOBAL_2,
    pub yHint: i32,
    pub xHint: i32,
    pub wHeight: u32,
    pub wWidth: u32,
    pub dwReserved1: PtrRepr,
    pub ddpfSurface: DDPIXELFORMAT,
    pub fpHeapOffset: PtrRepr,
    pub hCreatorProcess: super::super::Foundation::HANDLE,
}
impl ::core::marker::Copy for DD_SURFACE_GLOBAL {}
impl ::core::clone::Clone for DD_SURFACE_GLOBAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_GLOBAL {
    fn eq(&self, other: &Self) -> bool {
        self.Anonymous1 == other.Anonymous1
            && self.Anonymous2 == other.Anonymous2
            && self.fpVidMem == other.fpVidMem
            && self.Anonymous3 == other.Anonymous3
            && self.yHint == other.yHint
            && self.xHint == other.xHint
            && self.wHeight == other.wHeight
            && self.wWidth == other.wWidth
            && self.dwReserved1 == other.dwReserved1
            && self.ddpfSurface == other.ddpfSurface
            && self.fpHeapOffset == other.fpHeapOffset
            && self.hCreatorProcess == other.hCreatorProcess
    }
}
impl ::core::cmp::Eq for DD_SURFACE_GLOBAL {}
impl FromIntoMemory for DD_SURFACE_GLOBAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 76);
        let f_Anonymous1 = <DD_SURFACE_GLOBAL_0 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_Anonymous2 = <DD_SURFACE_GLOBAL_1 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_fpVidMem = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Anonymous3 = <DD_SURFACE_GLOBAL_2 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_yHint = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_xHint = <i32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_wHeight = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_wWidth = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_ddpfSurface = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[36..36 + 32]);
        let f_fpHeapOffset = <PtrRepr as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_hCreatorProcess =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        Self {
            Anonymous1: f_Anonymous1,
            Anonymous2: f_Anonymous2,
            fpVidMem: f_fpVidMem,
            Anonymous3: f_Anonymous3,
            yHint: f_yHint,
            xHint: f_xHint,
            wHeight: f_wHeight,
            wWidth: f_wWidth,
            dwReserved1: f_dwReserved1,
            ddpfSurface: f_ddpfSurface,
            fpHeapOffset: f_fpHeapOffset,
            hCreatorProcess: f_hCreatorProcess,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 76);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.fpVidMem, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous3, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.yHint, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.xHint, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.wHeight, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.wWidth, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.ddpfSurface, &mut into[36..36 + 32]);
        FromIntoMemory::into_bytes(self.fpHeapOffset, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.hCreatorProcess, &mut into[72..72 + 4]);
    }
    fn size() -> usize {
        76
    }
}
pub struct DD_SURFACE_GLOBAL_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DD_SURFACE_GLOBAL_0 {}
impl ::core::clone::Clone for DD_SURFACE_GLOBAL_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_GLOBAL_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DD_SURFACE_GLOBAL_0 {}
impl FromIntoMemory for DD_SURFACE_GLOBAL_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_SURFACE_GLOBAL_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DD_SURFACE_GLOBAL_1 {}
impl ::core::clone::Clone for DD_SURFACE_GLOBAL_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_GLOBAL_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DD_SURFACE_GLOBAL_1 {}
impl FromIntoMemory for DD_SURFACE_GLOBAL_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_SURFACE_GLOBAL_2 {
    data: [u8; 4],
}
impl ::core::marker::Copy for DD_SURFACE_GLOBAL_2 {}
impl ::core::clone::Clone for DD_SURFACE_GLOBAL_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_GLOBAL_2 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DD_SURFACE_GLOBAL_2 {}
impl FromIntoMemory for DD_SURFACE_GLOBAL_2 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_SURFACE_INT {
    pub lpLcl: MutPtr<DD_SURFACE_LOCAL>,
}
impl ::core::marker::Copy for DD_SURFACE_INT {}
impl ::core::clone::Clone for DD_SURFACE_INT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SURFACE_INT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SURFACE_INT")
            .field("lpLcl", &self.lpLcl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_INT {
    fn eq(&self, other: &Self) -> bool {
        self.lpLcl == other.lpLcl
    }
}
impl ::core::cmp::Eq for DD_SURFACE_INT {}
impl FromIntoMemory for DD_SURFACE_INT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_lpLcl = <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self { lpLcl: f_lpLcl }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.lpLcl, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct DD_SURFACE_LOCAL {
    pub lpGbl: MutPtr<DD_SURFACE_GLOBAL>,
    pub dwFlags: u32,
    pub ddsCaps: DDSCAPS,
    pub dwReserved1: PtrRepr,
    pub Anonymous1: DD_SURFACE_LOCAL_0,
    pub Anonymous2: DD_SURFACE_LOCAL_1,
    pub lpSurfMore: MutPtr<DD_SURFACE_MORE>,
    pub lpAttachList: MutPtr<DD_ATTACHLIST>,
    pub lpAttachListFrom: MutPtr<DD_ATTACHLIST>,
    pub rcOverlaySrc: super::super::Foundation::RECT,
}
impl ::core::marker::Copy for DD_SURFACE_LOCAL {}
impl ::core::clone::Clone for DD_SURFACE_LOCAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_LOCAL {
    fn eq(&self, other: &Self) -> bool {
        self.lpGbl == other.lpGbl
            && self.dwFlags == other.dwFlags
            && self.ddsCaps == other.ddsCaps
            && self.dwReserved1 == other.dwReserved1
            && self.Anonymous1 == other.Anonymous1
            && self.Anonymous2 == other.Anonymous2
            && self.lpSurfMore == other.lpSurfMore
            && self.lpAttachList == other.lpAttachList
            && self.lpAttachListFrom == other.lpAttachListFrom
            && self.rcOverlaySrc == other.rcOverlaySrc
    }
}
impl ::core::cmp::Eq for DD_SURFACE_LOCAL {}
impl FromIntoMemory for DD_SURFACE_LOCAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_lpGbl = <MutPtr<DD_SURFACE_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_Anonymous1 = <DD_SURFACE_LOCAL_0 as FromIntoMemory>::from_bytes(&from[16..16 + 8]);
        let f_Anonymous2 = <DD_SURFACE_LOCAL_1 as FromIntoMemory>::from_bytes(&from[24..24 + 8]);
        let f_lpSurfMore =
            <MutPtr<DD_SURFACE_MORE> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpAttachList =
            <MutPtr<DD_ATTACHLIST> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpAttachListFrom =
            <MutPtr<DD_ATTACHLIST> as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_rcOverlaySrc =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[44..44 + 16]);
        Self {
            lpGbl: f_lpGbl,
            dwFlags: f_dwFlags,
            ddsCaps: f_ddsCaps,
            dwReserved1: f_dwReserved1,
            Anonymous1: f_Anonymous1,
            Anonymous2: f_Anonymous2,
            lpSurfMore: f_lpSurfMore,
            lpAttachList: f_lpAttachList,
            lpAttachListFrom: f_lpAttachListFrom,
            rcOverlaySrc: f_rcOverlaySrc,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.lpGbl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[16..16 + 8]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[24..24 + 8]);
        FromIntoMemory::into_bytes(self.lpSurfMore, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpAttachList, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpAttachListFrom, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.rcOverlaySrc, &mut into[44..44 + 16]);
    }
    fn size() -> usize {
        60
    }
}
pub struct DD_SURFACE_LOCAL_0 {
    data: [u8; 8],
}
impl ::core::marker::Copy for DD_SURFACE_LOCAL_0 {}
impl ::core::clone::Clone for DD_SURFACE_LOCAL_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_LOCAL_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DD_SURFACE_LOCAL_0 {}
impl FromIntoMemory for DD_SURFACE_LOCAL_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 8];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        8
    }
}
pub struct DD_SURFACE_LOCAL_1 {
    data: [u8; 8],
}
impl ::core::marker::Copy for DD_SURFACE_LOCAL_1 {}
impl ::core::clone::Clone for DD_SURFACE_LOCAL_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_LOCAL_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for DD_SURFACE_LOCAL_1 {}
impl FromIntoMemory for DD_SURFACE_LOCAL_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 8];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        8
    }
}
pub struct DD_SURFACE_MORE {
    pub dwMipMapCount: u32,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwOverlayFlags: u32,
    pub ddsCapsEx: DDSCAPSEX,
    pub dwSurfaceHandle: u32,
}
impl ::core::marker::Copy for DD_SURFACE_MORE {}
impl ::core::clone::Clone for DD_SURFACE_MORE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_SURFACE_MORE {
    fn eq(&self, other: &Self) -> bool {
        self.dwMipMapCount == other.dwMipMapCount
            && self.lpVideoPort == other.lpVideoPort
            && self.dwOverlayFlags == other.dwOverlayFlags
            && self.ddsCapsEx == other.ddsCapsEx
            && self.dwSurfaceHandle == other.dwSurfaceHandle
    }
}
impl ::core::cmp::Eq for DD_SURFACE_MORE {}
impl FromIntoMemory for DD_SURFACE_MORE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_dwMipMapCount = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwOverlayFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddsCapsEx = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[12..12 + 12]);
        let f_dwSurfaceHandle = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            dwMipMapCount: f_dwMipMapCount,
            lpVideoPort: f_lpVideoPort,
            dwOverlayFlags: f_dwOverlayFlags,
            ddsCapsEx: f_ddsCapsEx,
            dwSurfaceHandle: f_dwSurfaceHandle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.dwMipMapCount, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsEx, &mut into[12..12 + 12]);
        FromIntoMemory::into_bytes(self.dwSurfaceHandle, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DD_SYNCSURFACEDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub dwSurfaceOffset: u32,
    pub fpLockPtr: PtrRepr,
    pub lPitch: i32,
    pub dwOverlayOffset: u32,
    pub dwDriverReserved1: u32,
    pub dwDriverReserved2: u32,
    pub dwDriverReserved3: u32,
    pub dwDriverReserved4: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_SYNCSURFACEDATA {}
impl ::core::clone::Clone for DD_SYNCSURFACEDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SYNCSURFACEDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SYNCSURFACEDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("dwSurfaceOffset", &self.dwSurfaceOffset)
            .field("fpLockPtr", &self.fpLockPtr)
            .field("lPitch", &self.lPitch)
            .field("dwOverlayOffset", &self.dwOverlayOffset)
            .field("dwDriverReserved1", &self.dwDriverReserved1)
            .field("dwDriverReserved2", &self.dwDriverReserved2)
            .field("dwDriverReserved3", &self.dwDriverReserved3)
            .field("dwDriverReserved4", &self.dwDriverReserved4)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SYNCSURFACEDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.dwSurfaceOffset == other.dwSurfaceOffset
            && self.fpLockPtr == other.fpLockPtr
            && self.lPitch == other.lPitch
            && self.dwOverlayOffset == other.dwOverlayOffset
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
            && self.dwDriverReserved4 == other.dwDriverReserved4
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_SYNCSURFACEDATA {}
impl FromIntoMemory for DD_SYNCSURFACEDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwSurfaceOffset = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_fpLockPtr = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lPitch = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwOverlayOffset = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwDriverReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwDriverReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwDriverReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwDriverReserved4 = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            dwSurfaceOffset: f_dwSurfaceOffset,
            fpLockPtr: f_fpLockPtr,
            lPitch: f_lPitch,
            dwOverlayOffset: f_dwOverlayOffset,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
            dwDriverReserved4: f_dwDriverReserved4,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwSurfaceOffset, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.fpLockPtr, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lPitch, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayOffset, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved4, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[40..40 + 4]);
    }
    fn size() -> usize {
        44
    }
}
pub struct DD_SYNCVIDEOPORTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwOriginOffset: u32,
    pub dwHeight: u32,
    pub dwVBIHeight: u32,
    pub dwDriverReserved1: u32,
    pub dwDriverReserved2: u32,
    pub dwDriverReserved3: u32,
    pub ddRVal: crate::core::HRESULT,
}
impl ::core::marker::Copy for DD_SYNCVIDEOPORTDATA {}
impl ::core::clone::Clone for DD_SYNCVIDEOPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_SYNCVIDEOPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_SYNCVIDEOPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwOriginOffset", &self.dwOriginOffset)
            .field("dwHeight", &self.dwHeight)
            .field("dwVBIHeight", &self.dwVBIHeight)
            .field("dwDriverReserved1", &self.dwDriverReserved1)
            .field("dwDriverReserved2", &self.dwDriverReserved2)
            .field("dwDriverReserved3", &self.dwDriverReserved3)
            .field("ddRVal", &self.ddRVal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_SYNCVIDEOPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwOriginOffset == other.dwOriginOffset
            && self.dwHeight == other.dwHeight
            && self.dwVBIHeight == other.dwVBIHeight
            && self.dwDriverReserved1 == other.dwDriverReserved1
            && self.dwDriverReserved2 == other.dwDriverReserved2
            && self.dwDriverReserved3 == other.dwDriverReserved3
            && self.ddRVal == other.ddRVal
    }
}
impl ::core::cmp::Eq for DD_SYNCVIDEOPORTDATA {}
impl FromIntoMemory for DD_SYNCVIDEOPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwOriginOffset = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwVBIHeight = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwDriverReserved1 = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwDriverReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwDriverReserved3 = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwOriginOffset: f_dwOriginOffset,
            dwHeight: f_dwHeight,
            dwVBIHeight: f_dwVBIHeight,
            dwDriverReserved1: f_dwDriverReserved1,
            dwDriverReserved2: f_dwDriverReserved2,
            dwDriverReserved3: f_dwDriverReserved3,
            ddRVal: f_ddRVal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwOriginOffset, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwVBIHeight, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved1, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved2, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwDriverReserved3, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct DD_UNLOCKDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub ddRVal: crate::core::HRESULT,
    pub Unlock: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_UNLOCKDATA {}
impl ::core::clone::Clone for DD_UNLOCKDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_UNLOCKDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_UNLOCKDATA")
            .field("lpDD", &self.lpDD)
            .field("lpDDSurface", &self.lpDDSurface)
            .field("ddRVal", &self.ddRVal)
            .field("Unlock", &self.Unlock)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_UNLOCKDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDSurface == other.lpDDSurface
            && self.ddRVal == other.ddRVal
            && self.Unlock == other.Unlock
    }
}
impl ::core::cmp::Eq for DD_UNLOCKDATA {}
impl FromIntoMemory for DD_UNLOCKDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_Unlock =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDSurface: f_lpDDSurface,
            ddRVal: f_ddRVal,
            Unlock: f_Unlock,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.Unlock, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct DD_UPDATENONLOCALHEAPDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub dwHeap: u32,
    pub fpGARTLin: PtrRepr,
    pub fpGARTDev: PtrRepr,
    pub ulPolicyMaxBytes: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
    pub UpdateNonLocalHeap: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_UPDATENONLOCALHEAPDATA {}
impl ::core::clone::Clone for DD_UPDATENONLOCALHEAPDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_UPDATENONLOCALHEAPDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_UPDATENONLOCALHEAPDATA")
            .field("lpDD", &self.lpDD)
            .field("dwHeap", &self.dwHeap)
            .field("fpGARTLin", &self.fpGARTLin)
            .field("fpGARTDev", &self.fpGARTDev)
            .field("ulPolicyMaxBytes", &self.ulPolicyMaxBytes)
            .field("ddRVal", &self.ddRVal)
            .field("UpdateNonLocalHeap", &self.UpdateNonLocalHeap)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_UPDATENONLOCALHEAPDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwHeap == other.dwHeap
            && self.fpGARTLin == other.fpGARTLin
            && self.fpGARTDev == other.fpGARTDev
            && self.ulPolicyMaxBytes == other.ulPolicyMaxBytes
            && self.ddRVal == other.ddRVal
            && self.UpdateNonLocalHeap == other.UpdateNonLocalHeap
    }
}
impl ::core::cmp::Eq for DD_UPDATENONLOCALHEAPDATA {}
impl FromIntoMemory for DD_UPDATENONLOCALHEAPDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwHeap = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_fpGARTLin = <PtrRepr as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_fpGARTDev = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ulPolicyMaxBytes = <PtrRepr as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_UpdateNonLocalHeap =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            dwHeap: f_dwHeap,
            fpGARTLin: f_fpGARTLin,
            fpGARTDev: f_fpGARTDev,
            ulPolicyMaxBytes: f_ulPolicyMaxBytes,
            ddRVal: f_ddRVal,
            UpdateNonLocalHeap: f_UpdateNonLocalHeap,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwHeap, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.fpGARTLin, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.fpGARTDev, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ulPolicyMaxBytes, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.UpdateNonLocalHeap, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct DD_UPDATEOVERLAYDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub lpDDDestSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub rDest: super::super::Foundation::RECTL,
    pub lpDDSrcSurface: MutPtr<DD_SURFACE_LOCAL>,
    pub rSrc: super::super::Foundation::RECTL,
    pub dwFlags: u32,
    pub overlayFX: DDOVERLAYFX,
    pub ddRVal: crate::core::HRESULT,
    pub UpdateOverlay: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_UPDATEOVERLAYDATA {}
impl ::core::clone::Clone for DD_UPDATEOVERLAYDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for DD_UPDATEOVERLAYDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpDDDestSurface == other.lpDDDestSurface
            && self.rDest == other.rDest
            && self.lpDDSrcSurface == other.lpDDSrcSurface
            && self.rSrc == other.rSrc
            && self.dwFlags == other.dwFlags
            && self.overlayFX == other.overlayFX
            && self.ddRVal == other.ddRVal
            && self.UpdateOverlay == other.UpdateOverlay
    }
}
impl ::core::cmp::Eq for DD_UPDATEOVERLAYDATA {}
impl FromIntoMemory for DD_UPDATEOVERLAYDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 112);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpDDDestSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_rDest =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_lpDDSrcSurface =
            <MutPtr<DD_SURFACE_LOCAL> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_rSrc =
            <super::super::Foundation::RECTL as FromIntoMemory>::from_bytes(&from[28..28 + 16]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_overlayFX = <DDOVERLAYFX as FromIntoMemory>::from_bytes(&from[48..48 + 56]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[104..104 + 4]);
        let f_UpdateOverlay =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[108..108 + 4]);
        Self {
            lpDD: f_lpDD,
            lpDDDestSurface: f_lpDDDestSurface,
            rDest: f_rDest,
            lpDDSrcSurface: f_lpDDSrcSurface,
            rSrc: f_rSrc,
            dwFlags: f_dwFlags,
            overlayFX: f_overlayFX,
            ddRVal: f_ddRVal,
            UpdateOverlay: f_UpdateOverlay,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 112);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpDDDestSurface, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.rDest, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.lpDDSrcSurface, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.rSrc, &mut into[28..28 + 16]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.overlayFX, &mut into[48..48 + 56]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[104..104 + 4]);
        FromIntoMemory::into_bytes(self.UpdateOverlay, &mut into[108..108 + 4]);
    }
    fn size() -> usize {
        112
    }
}
pub struct DD_UPDATEVPORTDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub lplpDDSurface: MutPtr<ConstPtr<DD_SURFACE_INT>>,
    pub lplpDDVBISurface: MutPtr<ConstPtr<DD_SURFACE_INT>>,
    pub lpVideoInfo: MutPtr<DDVIDEOPORTINFO>,
    pub dwFlags: u32,
    pub dwNumAutoflip: u32,
    pub dwNumVBIAutoflip: u32,
    pub ddRVal: crate::core::HRESULT,
    pub UpdateVideoPort: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_UPDATEVPORTDATA {}
impl ::core::clone::Clone for DD_UPDATEVPORTDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_UPDATEVPORTDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_UPDATEVPORTDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("lplpDDSurface", &self.lplpDDSurface)
            .field("lplpDDVBISurface", &self.lplpDDVBISurface)
            .field("lpVideoInfo", &self.lpVideoInfo)
            .field("dwFlags", &self.dwFlags)
            .field("dwNumAutoflip", &self.dwNumAutoflip)
            .field("dwNumVBIAutoflip", &self.dwNumVBIAutoflip)
            .field("ddRVal", &self.ddRVal)
            .field("UpdateVideoPort", &self.UpdateVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_UPDATEVPORTDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.lplpDDSurface == other.lplpDDSurface
            && self.lplpDDVBISurface == other.lplpDDVBISurface
            && self.lpVideoInfo == other.lpVideoInfo
            && self.dwFlags == other.dwFlags
            && self.dwNumAutoflip == other.dwNumAutoflip
            && self.dwNumVBIAutoflip == other.dwNumVBIAutoflip
            && self.ddRVal == other.ddRVal
            && self.UpdateVideoPort == other.UpdateVideoPort
    }
}
impl ::core::cmp::Eq for DD_UPDATEVPORTDATA {}
impl FromIntoMemory for DD_UPDATEVPORTDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 40);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lplpDDSurface =
            <MutPtr<ConstPtr<DD_SURFACE_INT>> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lplpDDVBISurface =
            <MutPtr<ConstPtr<DD_SURFACE_INT>> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpVideoInfo =
            <MutPtr<DDVIDEOPORTINFO> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_dwNumAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwNumVBIAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_UpdateVideoPort =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            lplpDDSurface: f_lplpDDSurface,
            lplpDDVBISurface: f_lplpDDVBISurface,
            lpVideoInfo: f_lpVideoInfo,
            dwFlags: f_dwFlags,
            dwNumAutoflip: f_dwNumAutoflip,
            dwNumVBIAutoflip: f_dwNumVBIAutoflip,
            ddRVal: f_ddRVal,
            UpdateVideoPort: f_UpdateVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 40);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lplpDDSurface, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lplpDDVBISurface, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoInfo, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.dwNumAutoflip, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwNumVBIAutoflip, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.UpdateVideoPort, &mut into[36..36 + 4]);
    }
    fn size() -> usize {
        40
    }
}
pub const DD_VERSION: i32 = 512i32;
pub struct DD_VIDEOPORTCALLBACKS {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub CanCreateVideoPort: PDD_VPORTCB_CANCREATEVIDEOPORT,
    pub CreateVideoPort: PDD_VPORTCB_CREATEVIDEOPORT,
    pub FlipVideoPort: PDD_VPORTCB_FLIP,
    pub GetVideoPortBandwidth: PDD_VPORTCB_GETBANDWIDTH,
    pub GetVideoPortInputFormats: PDD_VPORTCB_GETINPUTFORMATS,
    pub GetVideoPortOutputFormats: PDD_VPORTCB_GETOUTPUTFORMATS,
    pub lpReserved1: MutPtr<::core::ffi::c_void>,
    pub GetVideoPortField: PDD_VPORTCB_GETFIELD,
    pub GetVideoPortLine: PDD_VPORTCB_GETLINE,
    pub GetVideoPortConnectInfo: PDD_VPORTCB_GETVPORTCONNECT,
    pub DestroyVideoPort: PDD_VPORTCB_DESTROYVPORT,
    pub GetVideoPortFlipStatus: PDD_VPORTCB_GETFLIPSTATUS,
    pub UpdateVideoPort: PDD_VPORTCB_UPDATE,
    pub WaitForVideoPortSync: PDD_VPORTCB_WAITFORSYNC,
    pub GetVideoSignalStatus: PDD_VPORTCB_GETSIGNALSTATUS,
    pub ColorControl: PDD_VPORTCB_COLORCONTROL,
}
impl ::core::marker::Copy for DD_VIDEOPORTCALLBACKS {}
impl ::core::clone::Clone for DD_VIDEOPORTCALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_VIDEOPORTCALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_VIDEOPORTCALLBACKS")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("CanCreateVideoPort", &self.CanCreateVideoPort)
            .field("CreateVideoPort", &self.CreateVideoPort)
            .field("FlipVideoPort", &self.FlipVideoPort)
            .field("GetVideoPortBandwidth", &self.GetVideoPortBandwidth)
            .field("GetVideoPortInputFormats", &self.GetVideoPortInputFormats)
            .field("GetVideoPortOutputFormats", &self.GetVideoPortOutputFormats)
            .field("lpReserved1", &self.lpReserved1)
            .field("GetVideoPortField", &self.GetVideoPortField)
            .field("GetVideoPortLine", &self.GetVideoPortLine)
            .field("GetVideoPortConnectInfo", &self.GetVideoPortConnectInfo)
            .field("DestroyVideoPort", &self.DestroyVideoPort)
            .field("GetVideoPortFlipStatus", &self.GetVideoPortFlipStatus)
            .field("UpdateVideoPort", &self.UpdateVideoPort)
            .field("WaitForVideoPortSync", &self.WaitForVideoPortSync)
            .field("GetVideoSignalStatus", &self.GetVideoSignalStatus)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_VIDEOPORTCALLBACKS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.CanCreateVideoPort == other.CanCreateVideoPort
            && self.CreateVideoPort == other.CreateVideoPort
            && self.FlipVideoPort == other.FlipVideoPort
            && self.GetVideoPortBandwidth == other.GetVideoPortBandwidth
            && self.GetVideoPortInputFormats == other.GetVideoPortInputFormats
            && self.GetVideoPortOutputFormats == other.GetVideoPortOutputFormats
            && self.lpReserved1 == other.lpReserved1
            && self.GetVideoPortField == other.GetVideoPortField
            && self.GetVideoPortLine == other.GetVideoPortLine
            && self.GetVideoPortConnectInfo == other.GetVideoPortConnectInfo
            && self.DestroyVideoPort == other.DestroyVideoPort
            && self.GetVideoPortFlipStatus == other.GetVideoPortFlipStatus
            && self.UpdateVideoPort == other.UpdateVideoPort
            && self.WaitForVideoPortSync == other.WaitForVideoPortSync
            && self.GetVideoSignalStatus == other.GetVideoSignalStatus
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DD_VIDEOPORTCALLBACKS {}
impl FromIntoMemory for DD_VIDEOPORTCALLBACKS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 72);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_CanCreateVideoPort =
            <PDD_VPORTCB_CANCREATEVIDEOPORT as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_CreateVideoPort =
            <PDD_VPORTCB_CREATEVIDEOPORT as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_FlipVideoPort = <PDD_VPORTCB_FLIP as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_GetVideoPortBandwidth =
            <PDD_VPORTCB_GETBANDWIDTH as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_GetVideoPortInputFormats =
            <PDD_VPORTCB_GETINPUTFORMATS as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_GetVideoPortOutputFormats =
            <PDD_VPORTCB_GETOUTPUTFORMATS as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_lpReserved1 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_GetVideoPortField =
            <PDD_VPORTCB_GETFIELD as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_GetVideoPortLine =
            <PDD_VPORTCB_GETLINE as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_GetVideoPortConnectInfo =
            <PDD_VPORTCB_GETVPORTCONNECT as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_DestroyVideoPort =
            <PDD_VPORTCB_DESTROYVPORT as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_GetVideoPortFlipStatus =
            <PDD_VPORTCB_GETFLIPSTATUS as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_UpdateVideoPort =
            <PDD_VPORTCB_UPDATE as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_WaitForVideoPortSync =
            <PDD_VPORTCB_WAITFORSYNC as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_GetVideoSignalStatus =
            <PDD_VPORTCB_GETSIGNALSTATUS as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_ColorControl =
            <PDD_VPORTCB_COLORCONTROL as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            CanCreateVideoPort: f_CanCreateVideoPort,
            CreateVideoPort: f_CreateVideoPort,
            FlipVideoPort: f_FlipVideoPort,
            GetVideoPortBandwidth: f_GetVideoPortBandwidth,
            GetVideoPortInputFormats: f_GetVideoPortInputFormats,
            GetVideoPortOutputFormats: f_GetVideoPortOutputFormats,
            lpReserved1: f_lpReserved1,
            GetVideoPortField: f_GetVideoPortField,
            GetVideoPortLine: f_GetVideoPortLine,
            GetVideoPortConnectInfo: f_GetVideoPortConnectInfo,
            DestroyVideoPort: f_DestroyVideoPort,
            GetVideoPortFlipStatus: f_GetVideoPortFlipStatus,
            UpdateVideoPort: f_UpdateVideoPort,
            WaitForVideoPortSync: f_WaitForVideoPortSync,
            GetVideoSignalStatus: f_GetVideoSignalStatus,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 72);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.CanCreateVideoPort, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.CreateVideoPort, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.FlipVideoPort, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortBandwidth, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortInputFormats, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortOutputFormats, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpReserved1, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortField, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortLine, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortConnectInfo, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.DestroyVideoPort, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoPortFlipStatus, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.UpdateVideoPort, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.WaitForVideoPortSync, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.GetVideoSignalStatus, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[68..68 + 4]);
    }
    fn size() -> usize {
        72
    }
}
pub struct DD_VIDEOPORT_LOCAL {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub ddvpDesc: DDVIDEOPORTDESC,
    pub ddvpInfo: DDVIDEOPORTINFO,
    pub lpSurface: MutPtr<DD_SURFACE_INT>,
    pub lpVBISurface: MutPtr<DD_SURFACE_INT>,
    pub dwNumAutoflip: u32,
    pub dwNumVBIAutoflip: u32,
    pub dwReserved1: PtrRepr,
    pub dwReserved2: PtrRepr,
    pub dwReserved3: PtrRepr,
}
impl ::core::marker::Copy for DD_VIDEOPORT_LOCAL {}
impl ::core::clone::Clone for DD_VIDEOPORT_LOCAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_VIDEOPORT_LOCAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_VIDEOPORT_LOCAL")
            .field("lpDD", &self.lpDD)
            .field("ddvpDesc", &self.ddvpDesc)
            .field("ddvpInfo", &self.ddvpInfo)
            .field("lpSurface", &self.lpSurface)
            .field("lpVBISurface", &self.lpVBISurface)
            .field("dwNumAutoflip", &self.dwNumAutoflip)
            .field("dwNumVBIAutoflip", &self.dwNumVBIAutoflip)
            .field("dwReserved1", &self.dwReserved1)
            .field("dwReserved2", &self.dwReserved2)
            .field("dwReserved3", &self.dwReserved3)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_VIDEOPORT_LOCAL {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.ddvpDesc == other.ddvpDesc
            && self.ddvpInfo == other.ddvpInfo
            && self.lpSurface == other.lpSurface
            && self.lpVBISurface == other.lpVBISurface
            && self.dwNumAutoflip == other.dwNumAutoflip
            && self.dwNumVBIAutoflip == other.dwNumVBIAutoflip
            && self.dwReserved1 == other.dwReserved1
            && self.dwReserved2 == other.dwReserved2
            && self.dwReserved3 == other.dwReserved3
    }
}
impl ::core::cmp::Eq for DD_VIDEOPORT_LOCAL {}
impl FromIntoMemory for DD_VIDEOPORT_LOCAL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 168);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ddvpDesc = <DDVIDEOPORTDESC as FromIntoMemory>::from_bytes(&from[4..4 + 72]);
        let f_ddvpInfo = <DDVIDEOPORTINFO as FromIntoMemory>::from_bytes(&from[76..76 + 64]);
        let f_lpSurface =
            <MutPtr<DD_SURFACE_INT> as FromIntoMemory>::from_bytes(&from[140..140 + 4]);
        let f_lpVBISurface =
            <MutPtr<DD_SURFACE_INT> as FromIntoMemory>::from_bytes(&from[144..144 + 4]);
        let f_dwNumAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[148..148 + 4]);
        let f_dwNumVBIAutoflip = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwReserved1 = <PtrRepr as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_dwReserved2 = <PtrRepr as FromIntoMemory>::from_bytes(&from[160..160 + 4]);
        let f_dwReserved3 = <PtrRepr as FromIntoMemory>::from_bytes(&from[164..164 + 4]);
        Self {
            lpDD: f_lpDD,
            ddvpDesc: f_ddvpDesc,
            ddvpInfo: f_ddvpInfo,
            lpSurface: f_lpSurface,
            lpVBISurface: f_lpVBISurface,
            dwNumAutoflip: f_dwNumAutoflip,
            dwNumVBIAutoflip: f_dwNumVBIAutoflip,
            dwReserved1: f_dwReserved1,
            dwReserved2: f_dwReserved2,
            dwReserved3: f_dwReserved3,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 168);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ddvpDesc, &mut into[4..4 + 72]);
        FromIntoMemory::into_bytes(self.ddvpInfo, &mut into[76..76 + 64]);
        FromIntoMemory::into_bytes(self.lpSurface, &mut into[140..140 + 4]);
        FromIntoMemory::into_bytes(self.lpVBISurface, &mut into[144..144 + 4]);
        FromIntoMemory::into_bytes(self.dwNumAutoflip, &mut into[148..148 + 4]);
        FromIntoMemory::into_bytes(self.dwNumVBIAutoflip, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved1, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[160..160 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved3, &mut into[164..164 + 4]);
    }
    fn size() -> usize {
        168
    }
}
pub struct DD_VPORTCOLORDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwFlags: u32,
    pub lpColorData: MutPtr<DDCOLORCONTROL>,
    pub ddRVal: crate::core::HRESULT,
    pub ColorControl: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_VPORTCOLORDATA {}
impl ::core::clone::Clone for DD_VPORTCOLORDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_VPORTCOLORDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_VPORTCOLORDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("lpColorData", &self.lpColorData)
            .field("ddRVal", &self.ddRVal)
            .field("ColorControl", &self.ColorControl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_VPORTCOLORDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.lpColorData == other.lpColorData
            && self.ddRVal == other.ddRVal
            && self.ColorControl == other.ColorControl
    }
}
impl ::core::cmp::Eq for DD_VPORTCOLORDATA {}
impl FromIntoMemory for DD_VPORTCOLORDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpColorData =
            <MutPtr<DDCOLORCONTROL> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ColorControl =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            lpColorData: f_lpColorData,
            ddRVal: f_ddRVal,
            ColorControl: f_ColorControl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpColorData, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ColorControl, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_WAITFORVERTICALBLANKDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_GLOBAL>,
    pub dwFlags: u32,
    pub bIsInVB: u32,
    pub hEvent: PtrRepr,
    pub ddRVal: crate::core::HRESULT,
    pub WaitForVerticalBlank: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_WAITFORVERTICALBLANKDATA {}
impl ::core::clone::Clone for DD_WAITFORVERTICALBLANKDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_WAITFORVERTICALBLANKDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_WAITFORVERTICALBLANKDATA")
            .field("lpDD", &self.lpDD)
            .field("dwFlags", &self.dwFlags)
            .field("bIsInVB", &self.bIsInVB)
            .field("hEvent", &self.hEvent)
            .field("ddRVal", &self.ddRVal)
            .field("WaitForVerticalBlank", &self.WaitForVerticalBlank)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_WAITFORVERTICALBLANKDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.dwFlags == other.dwFlags
            && self.bIsInVB == other.bIsInVB
            && self.hEvent == other.hEvent
            && self.ddRVal == other.ddRVal
            && self.WaitForVerticalBlank == other.WaitForVerticalBlank
    }
}
impl ::core::cmp::Eq for DD_WAITFORVERTICALBLANKDATA {}
impl FromIntoMemory for DD_WAITFORVERTICALBLANKDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_GLOBAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bIsInVB = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_hEvent = <PtrRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_WaitForVerticalBlank =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            lpDD: f_lpDD,
            dwFlags: f_dwFlags,
            bIsInVB: f_bIsInVB,
            hEvent: f_hEvent,
            ddRVal: f_ddRVal,
            WaitForVerticalBlank: f_WaitForVerticalBlank,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bIsInVB, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.hEvent, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.WaitForVerticalBlank, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DD_WAITFORVPORTSYNCDATA {
    pub lpDD: MutPtr<DD_DIRECTDRAW_LOCAL>,
    pub lpVideoPort: MutPtr<DD_VIDEOPORT_LOCAL>,
    pub dwFlags: u32,
    pub dwLine: u32,
    pub dwTimeOut: u32,
    pub ddRVal: crate::core::HRESULT,
    pub UpdateVideoPort: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for DD_WAITFORVPORTSYNCDATA {}
impl ::core::clone::Clone for DD_WAITFORVPORTSYNCDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DD_WAITFORVPORTSYNCDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DD_WAITFORVPORTSYNCDATA")
            .field("lpDD", &self.lpDD)
            .field("lpVideoPort", &self.lpVideoPort)
            .field("dwFlags", &self.dwFlags)
            .field("dwLine", &self.dwLine)
            .field("dwTimeOut", &self.dwTimeOut)
            .field("ddRVal", &self.ddRVal)
            .field("UpdateVideoPort", &self.UpdateVideoPort)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DD_WAITFORVPORTSYNCDATA {
    fn eq(&self, other: &Self) -> bool {
        self.lpDD == other.lpDD
            && self.lpVideoPort == other.lpVideoPort
            && self.dwFlags == other.dwFlags
            && self.dwLine == other.dwLine
            && self.dwTimeOut == other.dwTimeOut
            && self.ddRVal == other.ddRVal
            && self.UpdateVideoPort == other.UpdateVideoPort
    }
}
impl ::core::cmp::Eq for DD_WAITFORVPORTSYNCDATA {}
impl FromIntoMemory for DD_WAITFORVPORTSYNCDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_lpDD = <MutPtr<DD_DIRECTDRAW_LOCAL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpVideoPort =
            <MutPtr<DD_VIDEOPORT_LOCAL> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwLine = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwTimeOut = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddRVal = <crate::core::HRESULT as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_UpdateVideoPort =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            lpDD: f_lpDD,
            lpVideoPort: f_lpVideoPort,
            dwFlags: f_dwFlags,
            dwLine: f_dwLine,
            dwTimeOut: f_dwTimeOut,
            ddRVal: f_ddRVal,
            UpdateVideoPort: f_UpdateVideoPort,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.lpDD, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpVideoPort, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwLine, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwTimeOut, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddRVal, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.UpdateVideoPort, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub const DELETED_LASTONE: u32 = 1u32;
pub const DELETED_NOTFOUND: u32 = 2u32;
pub const DELETED_OK: u32 = 0u32;
pub const DIRECTDRAW_VERSION: u32 = 1792u32;
pub const DXAPI_HALVERSION: u32 = 1u32;
pub struct DXAPI_INTERFACE {
    pub Size: u16,
    pub Version: u16,
    pub Context: MutPtr<::core::ffi::c_void>,
    pub InterfaceReference: MutPtr<::core::ffi::c_void>,
    pub InterfaceDereference: MutPtr<::core::ffi::c_void>,
    pub DxGetIrqInfo: PDX_GETIRQINFO,
    pub DxEnableIrq: PDX_ENABLEIRQ,
    pub DxSkipNextField: PDX_SKIPNEXTFIELD,
    pub DxBobNextField: PDX_BOBNEXTFIELD,
    pub DxSetState: PDX_SETSTATE,
    pub DxLock: PDX_LOCK,
    pub DxFlipOverlay: PDX_FLIPOVERLAY,
    pub DxFlipVideoPort: PDX_FLIPVIDEOPORT,
    pub DxGetPolarity: PDX_GETPOLARITY,
    pub DxGetCurrentAutoflip: PDX_GETCURRENTAUTOFLIP,
    pub DxGetPreviousAutoflip: PDX_GETPREVIOUSAUTOFLIP,
    pub DxTransfer: PDX_TRANSFER,
    pub DxGetTransferStatus: PDX_GETTRANSFERSTATUS,
}
impl ::core::marker::Copy for DXAPI_INTERFACE {}
impl ::core::clone::Clone for DXAPI_INTERFACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXAPI_INTERFACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXAPI_INTERFACE")
            .field("Size", &self.Size)
            .field("Version", &self.Version)
            .field("Context", &self.Context)
            .field("InterfaceReference", &self.InterfaceReference)
            .field("InterfaceDereference", &self.InterfaceDereference)
            .field("DxGetIrqInfo", &self.DxGetIrqInfo)
            .field("DxEnableIrq", &self.DxEnableIrq)
            .field("DxSkipNextField", &self.DxSkipNextField)
            .field("DxBobNextField", &self.DxBobNextField)
            .field("DxSetState", &self.DxSetState)
            .field("DxLock", &self.DxLock)
            .field("DxFlipOverlay", &self.DxFlipOverlay)
            .field("DxFlipVideoPort", &self.DxFlipVideoPort)
            .field("DxGetPolarity", &self.DxGetPolarity)
            .field("DxGetCurrentAutoflip", &self.DxGetCurrentAutoflip)
            .field("DxGetPreviousAutoflip", &self.DxGetPreviousAutoflip)
            .field("DxTransfer", &self.DxTransfer)
            .field("DxGetTransferStatus", &self.DxGetTransferStatus)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DXAPI_INTERFACE {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Version == other.Version
            && self.Context == other.Context
            && self.InterfaceReference == other.InterfaceReference
            && self.InterfaceDereference == other.InterfaceDereference
            && self.DxGetIrqInfo == other.DxGetIrqInfo
            && self.DxEnableIrq == other.DxEnableIrq
            && self.DxSkipNextField == other.DxSkipNextField
            && self.DxBobNextField == other.DxBobNextField
            && self.DxSetState == other.DxSetState
            && self.DxLock == other.DxLock
            && self.DxFlipOverlay == other.DxFlipOverlay
            && self.DxFlipVideoPort == other.DxFlipVideoPort
            && self.DxGetPolarity == other.DxGetPolarity
            && self.DxGetCurrentAutoflip == other.DxGetCurrentAutoflip
            && self.DxGetPreviousAutoflip == other.DxGetPreviousAutoflip
            && self.DxTransfer == other.DxTransfer
            && self.DxGetTransferStatus == other.DxGetTransferStatus
    }
}
impl ::core::cmp::Eq for DXAPI_INTERFACE {}
impl FromIntoMemory for DXAPI_INTERFACE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 68);
        let f_Size = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_Version = <u16 as FromIntoMemory>::from_bytes(&from[2..2 + 2]);
        let f_Context =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_InterfaceReference =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_InterfaceDereference =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_DxGetIrqInfo = <PDX_GETIRQINFO as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_DxEnableIrq = <PDX_ENABLEIRQ as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_DxSkipNextField =
            <PDX_SKIPNEXTFIELD as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_DxBobNextField = <PDX_BOBNEXTFIELD as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_DxSetState = <PDX_SETSTATE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_DxLock = <PDX_LOCK as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_DxFlipOverlay = <PDX_FLIPOVERLAY as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_DxFlipVideoPort =
            <PDX_FLIPVIDEOPORT as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_DxGetPolarity = <PDX_GETPOLARITY as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_DxGetCurrentAutoflip =
            <PDX_GETCURRENTAUTOFLIP as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_DxGetPreviousAutoflip =
            <PDX_GETPREVIOUSAUTOFLIP as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_DxTransfer = <PDX_TRANSFER as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_DxGetTransferStatus =
            <PDX_GETTRANSFERSTATUS as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        Self {
            Size: f_Size,
            Version: f_Version,
            Context: f_Context,
            InterfaceReference: f_InterfaceReference,
            InterfaceDereference: f_InterfaceDereference,
            DxGetIrqInfo: f_DxGetIrqInfo,
            DxEnableIrq: f_DxEnableIrq,
            DxSkipNextField: f_DxSkipNextField,
            DxBobNextField: f_DxBobNextField,
            DxSetState: f_DxSetState,
            DxLock: f_DxLock,
            DxFlipOverlay: f_DxFlipOverlay,
            DxFlipVideoPort: f_DxFlipVideoPort,
            DxGetPolarity: f_DxGetPolarity,
            DxGetCurrentAutoflip: f_DxGetCurrentAutoflip,
            DxGetPreviousAutoflip: f_DxGetPreviousAutoflip,
            DxTransfer: f_DxTransfer,
            DxGetTransferStatus: f_DxGetTransferStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 68);
        FromIntoMemory::into_bytes(self.Size, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.Version, &mut into[2..2 + 2]);
        FromIntoMemory::into_bytes(self.Context, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.InterfaceReference, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.InterfaceDereference, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.DxGetIrqInfo, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.DxEnableIrq, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.DxSkipNextField, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.DxBobNextField, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.DxSetState, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.DxLock, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.DxFlipOverlay, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.DxFlipVideoPort, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.DxGetPolarity, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.DxGetCurrentAutoflip, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.DxGetPreviousAutoflip, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.DxTransfer, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.DxGetTransferStatus, &mut into[64..64 + 4]);
    }
    fn size() -> usize {
        68
    }
}
pub const DXERR_GENERIC: u32 = 2147500037u32;
pub const DXERR_OUTOFCAPS: u32 = 2289434984u32;
pub const DXERR_UNSUPPORTED: u32 = 2147500033u32;
pub struct DX_IRQDATA {
    pub dwIrqFlags: u32,
}
impl ::core::marker::Copy for DX_IRQDATA {}
impl ::core::clone::Clone for DX_IRQDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DX_IRQDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DX_IRQDATA")
            .field("dwIrqFlags", &self.dwIrqFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DX_IRQDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwIrqFlags == other.dwIrqFlags
    }
}
impl ::core::cmp::Eq for DX_IRQDATA {}
impl FromIntoMemory for DX_IRQDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f_dwIrqFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            dwIrqFlags: f_dwIrqFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self.dwIrqFlags, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub const DX_OK: u32 = 0u32;
pub const GUID_ColorControlCallbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0xefd60cc2_49e7_11d0_889d_00aa00bbb76a);
pub const GUID_D3DCallbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0x7bf06990_8794_11d0_9139_080036d2ef02);
pub const GUID_D3DCallbacks2: crate::core::GUID =
    crate::core::GUID::from_u128(0x0ba584e1_70b6_11d0_889d_00aa00bbb76a);
pub const GUID_D3DCallbacks3: crate::core::GUID =
    crate::core::GUID::from_u128(0xddf41230_ec0a_11d0_a9b6_00aa00c0993e);
pub const GUID_D3DCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0x7bf06991_8794_11d0_9139_080036d2ef02);
pub const GUID_D3DExtendedCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0x7de41f80_9d93_11d0_89ab_00a0c9054129);
pub const GUID_D3DParseUnknownCommandCallback: crate::core::GUID =
    crate::core::GUID::from_u128(0x2e04ffa0_98e4_11d1_8ce1_00a0c90629a8);
pub const GUID_DDMoreCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0x880baf30_b030_11d0_8ea7_00609797ea5b);
pub const GUID_DDMoreSurfaceCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0x3b8a0466_f269_11d1_880b_00c04fd930c5);
pub const GUID_DDStereoMode: crate::core::GUID =
    crate::core::GUID::from_u128(0xf828169c_a8e8_11d2_a1f2_00a0c983eaf6);
pub const GUID_DxApi: crate::core::GUID =
    crate::core::GUID::from_u128(0x8a79bef0_b915_11d0_9144_080036d2ef02);
pub const GUID_GetHeapAlignment: crate::core::GUID =
    crate::core::GUID::from_u128(0x42e02f16_7b41_11d2_8bff_00a0c983eaf6);
pub const GUID_KernelCallbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0x80863800_6b06_11d0_9b06_00a0c903a3b8);
pub const GUID_KernelCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0xffaa7540_7aa8_11d0_9b06_00a0c903a3b8);
pub const GUID_Miscellaneous2Callbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0x406b2f00_3e5a_11d1_b640_00aa00a1f96a);
pub const GUID_MiscellaneousCallbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0xefd60cc0_49e7_11d0_889d_00aa00bbb76a);
pub const GUID_MotionCompCallbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0xb1122b40_5da5_11d1_8fcf_00c04fc29b4e);
pub const GUID_NTCallbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0x6fe9ecde_df89_11d1_9db0_0060082771ba);
pub const GUID_NTPrivateDriverCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0xfad16a23_7b66_11d2_83d7_00c04f7ce58c);
pub const GUID_NonLocalVidMemCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0x86c4fa80_8d84_11d0_94e8_00c04fc34137);
pub const GUID_OptSurfaceKmodeInfo: crate::core::GUID =
    crate::core::GUID::from_u128(0xe05c8472_51d4_11d1_8cce_00a0c90629a8);
pub const GUID_OptSurfaceUmodeInfo: crate::core::GUID =
    crate::core::GUID::from_u128(0x9d792804_5fa8_11d1_8cd0_00a0c90629a8);
pub const GUID_UpdateNonLocalHeap: crate::core::GUID =
    crate::core::GUID::from_u128(0x42e02f17_7b41_11d2_8bff_00a0c983eaf6);
pub const GUID_UserModeDriverInfo: crate::core::GUID =
    crate::core::GUID::from_u128(0xf0b0e8e2_5f97_11d1_8cd0_00a0c90629a8);
pub const GUID_UserModeDriverPassword: crate::core::GUID =
    crate::core::GUID::from_u128(0x97f861b6_60a1_11d1_8cd0_00a0c90629a8);
pub const GUID_VPE2Callbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0x52882147_2d47_469a_a0d1_03455890f6c8);
pub const GUID_VideoPortCallbacks: crate::core::GUID =
    crate::core::GUID::from_u128(0xefd60cc1_49e7_11d0_889d_00aa00bbb76a);
pub const GUID_VideoPortCaps: crate::core::GUID =
    crate::core::GUID::from_u128(0xefd60cc3_49e7_11d0_889d_00aa00bbb76a);
pub const GUID_ZPixelFormats: crate::core::GUID =
    crate::core::GUID::from_u128(0x93869880_36cf_11d1_9b1b_00aa00bbb8ae);
pub struct HEAPALIAS {
    pub fpVidMem: PtrRepr,
    pub lpAlias: MutPtr<::core::ffi::c_void>,
    pub dwAliasSize: u32,
}
impl ::core::marker::Copy for HEAPALIAS {}
impl ::core::clone::Clone for HEAPALIAS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HEAPALIAS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HEAPALIAS")
            .field("fpVidMem", &self.fpVidMem)
            .field("lpAlias", &self.lpAlias)
            .field("dwAliasSize", &self.dwAliasSize)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HEAPALIAS {
    fn eq(&self, other: &Self) -> bool {
        self.fpVidMem == other.fpVidMem
            && self.lpAlias == other.lpAlias
            && self.dwAliasSize == other.dwAliasSize
    }
}
impl ::core::cmp::Eq for HEAPALIAS {}
impl FromIntoMemory for HEAPALIAS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_fpVidMem = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpAlias =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwAliasSize = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            fpVidMem: f_fpVidMem,
            lpAlias: f_lpAlias,
            dwAliasSize: f_dwAliasSize,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.fpVidMem, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpAlias, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwAliasSize, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct HEAPALIASINFO {
    pub dwRefCnt: u32,
    pub dwFlags: u32,
    pub dwNumHeaps: u32,
    pub lpAliases: MutPtr<HEAPALIAS>,
}
impl ::core::marker::Copy for HEAPALIASINFO {}
impl ::core::clone::Clone for HEAPALIASINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HEAPALIASINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HEAPALIASINFO")
            .field("dwRefCnt", &self.dwRefCnt)
            .field("dwFlags", &self.dwFlags)
            .field("dwNumHeaps", &self.dwNumHeaps)
            .field("lpAliases", &self.lpAliases)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HEAPALIASINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwRefCnt == other.dwRefCnt
            && self.dwFlags == other.dwFlags
            && self.dwNumHeaps == other.dwNumHeaps
            && self.lpAliases == other.lpAliases
    }
}
impl ::core::cmp::Eq for HEAPALIASINFO {}
impl FromIntoMemory for HEAPALIASINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwNumHeaps = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpAliases = <MutPtr<HEAPALIAS> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwRefCnt: f_dwRefCnt,
            dwFlags: f_dwFlags,
            dwNumHeaps: f_dwNumHeaps,
            lpAliases: f_lpAliases,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwNumHeaps, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpAliases, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const HEAPALIASINFO_MAPPEDDUMMY: i32 = 2i32;
pub const HEAPALIASINFO_MAPPEDREAL: i32 = 1i32;
pub struct HEAPALIGNMENT {
    pub dwSize: u32,
    pub ddsCaps: DDSCAPS,
    pub dwReserved: u32,
    pub ExecuteBuffer: SURFACEALIGNMENT,
    pub Overlay: SURFACEALIGNMENT,
    pub Texture: SURFACEALIGNMENT,
    pub ZBuffer: SURFACEALIGNMENT,
    pub AlphaBuffer: SURFACEALIGNMENT,
    pub Offscreen: SURFACEALIGNMENT,
    pub FlipTarget: SURFACEALIGNMENT,
}
impl ::core::marker::Copy for HEAPALIGNMENT {}
impl ::core::clone::Clone for HEAPALIGNMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for HEAPALIGNMENT {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.ddsCaps == other.ddsCaps
            && self.dwReserved == other.dwReserved
            && self.ExecuteBuffer == other.ExecuteBuffer
            && self.Overlay == other.Overlay
            && self.Texture == other.Texture
            && self.ZBuffer == other.ZBuffer
            && self.AlphaBuffer == other.AlphaBuffer
            && self.Offscreen == other.Offscreen
            && self.FlipTarget == other.FlipTarget
    }
}
impl ::core::cmp::Eq for HEAPALIGNMENT {}
impl FromIntoMemory for HEAPALIGNMENT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 124);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ExecuteBuffer = <SURFACEALIGNMENT as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        let f_Overlay = <SURFACEALIGNMENT as FromIntoMemory>::from_bytes(&from[28..28 + 16]);
        let f_Texture = <SURFACEALIGNMENT as FromIntoMemory>::from_bytes(&from[44..44 + 16]);
        let f_ZBuffer = <SURFACEALIGNMENT as FromIntoMemory>::from_bytes(&from[60..60 + 16]);
        let f_AlphaBuffer = <SURFACEALIGNMENT as FromIntoMemory>::from_bytes(&from[76..76 + 16]);
        let f_Offscreen = <SURFACEALIGNMENT as FromIntoMemory>::from_bytes(&from[92..92 + 16]);
        let f_FlipTarget = <SURFACEALIGNMENT as FromIntoMemory>::from_bytes(&from[108..108 + 16]);
        Self {
            dwSize: f_dwSize,
            ddsCaps: f_ddsCaps,
            dwReserved: f_dwReserved,
            ExecuteBuffer: f_ExecuteBuffer,
            Overlay: f_Overlay,
            Texture: f_Texture,
            ZBuffer: f_ZBuffer,
            AlphaBuffer: f_AlphaBuffer,
            Offscreen: f_Offscreen,
            FlipTarget: f_FlipTarget,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 124);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ExecuteBuffer, &mut into[12..12 + 16]);
        FromIntoMemory::into_bytes(self.Overlay, &mut into[28..28 + 16]);
        FromIntoMemory::into_bytes(self.Texture, &mut into[44..44 + 16]);
        FromIntoMemory::into_bytes(self.ZBuffer, &mut into[60..60 + 16]);
        FromIntoMemory::into_bytes(self.AlphaBuffer, &mut into[76..76 + 16]);
        FromIntoMemory::into_bytes(self.Offscreen, &mut into[92..92 + 16]);
        FromIntoMemory::into_bytes(self.FlipTarget, &mut into[108..108 + 16]);
    }
    fn size() -> usize {
        124
    }
}
pub struct IDDVideoPortContainer(pub crate::core::IUnknown);
pub trait IDDVideoPortContainer_Trait: crate::core::IUnknown_Trait {
    fn CreateVideoPort(
        &self,
        param_0: u32,
        param_1: MutPtr<DDVIDEOPORTDESC>,
        param_2: MutPtr<IDirectDrawVideoPort>,
        param_3: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateVideoPort")
    }
    fn EnumVideoPorts(
        &self,
        param_0: u32,
        param_1: MutPtr<DDVIDEOPORTCAPS>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMVIDEOCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumVideoPorts")
    }
    fn GetVideoPortConnectInfo(
        &self,
        param_0: u32,
        pc_info: MutPtr<u32>,
        param_2: MutPtr<DDVIDEOPORTCONNECT>,
    ) -> crate::core::HRESULT {
        todo!("GetVideoPortConnectInfo")
    }
    fn QueryVideoPortStatus(
        &self,
        param_0: u32,
        param_1: MutPtr<DDVIDEOPORTSTATUS>,
    ) -> crate::core::HRESULT {
        todo!("QueryVideoPortStatus")
    }
}
impl ::core::clone::Clone for IDDVideoPortContainer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDDVideoPortContainer {}
impl ::core::cmp::PartialEq for IDDVideoPortContainer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDDVideoPortContainer {}
impl ::core::fmt::Debug for IDDVideoPortContainer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDDVideoPortContainer")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDDVideoPortContainer {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDDVideoPortContainer {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6c142760_a733_11ce_a521_0020af0be560);
}
pub struct IDirectDraw(pub crate::core::IUnknown);
pub trait IDirectDraw_Trait: crate::core::IUnknown_Trait {
    fn Compact(&self) -> crate::core::HRESULT {
        todo!("Compact")
    }
    fn CreateClipper(
        &self,
        param_0: u32,
        param_1: MutPtr<IDirectDrawClipper>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateClipper")
    }
    fn CreatePalette(
        &self,
        param_0: u32,
        param_1: MutPtr<super::Gdi::PALETTEENTRY>,
        param_2: MutPtr<IDirectDrawPalette>,
        param_3: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreatePalette")
    }
    fn CreateSurface(
        &self,
        param_0: MutPtr<DDSURFACEDESC>,
        param_1: MutPtr<IDirectDrawSurface>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateSurface")
    }
    fn DuplicateSurface(
        &self,
        param_0: IDirectDrawSurface,
        param_1: MutPtr<IDirectDrawSurface>,
    ) -> crate::core::HRESULT {
        todo!("DuplicateSurface")
    }
    fn EnumDisplayModes(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMMODESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumDisplayModes")
    }
    fn EnumSurfaces(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumSurfaces")
    }
    fn FlipToGDISurface(&self) -> crate::core::HRESULT {
        todo!("FlipToGDISurface")
    }
    fn GetCaps(
        &self,
        param_0: MutPtr<DDCAPS_DX7>,
        param_1: MutPtr<DDCAPS_DX7>,
    ) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetDisplayMode(&self, param_0: MutPtr<DDSURFACEDESC>) -> crate::core::HRESULT {
        todo!("GetDisplayMode")
    }
    fn GetFourCCCodes(&self, param_0: MutPtr<u32>, param_1: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFourCCCodes")
    }
    fn GetGDISurface(&self, param_0: MutPtr<IDirectDrawSurface>) -> crate::core::HRESULT {
        todo!("GetGDISurface")
    }
    fn GetMonitorFrequency(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetMonitorFrequency")
    }
    fn GetScanLine(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetScanLine")
    }
    fn GetVerticalBlankStatus(&self, param_0: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetVerticalBlankStatus")
    }
    fn Initialize(&self, param_0: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn RestoreDisplayMode(&self) -> crate::core::HRESULT {
        todo!("RestoreDisplayMode")
    }
    fn SetCooperativeLevel(
        &self,
        param_0: super::super::Foundation::HWND,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("SetCooperativeLevel")
    }
    fn SetDisplayMode(&self, param_0: u32, param_1: u32, param_2: u32) -> crate::core::HRESULT {
        todo!("SetDisplayMode")
    }
    fn WaitForVerticalBlank(
        &self,
        param_0: u32,
        param_1: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("WaitForVerticalBlank")
    }
}
impl ::core::clone::Clone for IDirectDraw {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDraw {}
impl ::core::cmp::PartialEq for IDirectDraw {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDraw {}
impl ::core::fmt::Debug for IDirectDraw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDraw").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDraw {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDraw {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6c14db80_a733_11ce_a521_0020af0be560);
}
pub struct IDirectDraw2(pub crate::core::IUnknown);
pub trait IDirectDraw2_Trait: crate::core::IUnknown_Trait {
    fn Compact(&self) -> crate::core::HRESULT {
        todo!("Compact")
    }
    fn CreateClipper(
        &self,
        param_0: u32,
        param_1: MutPtr<IDirectDrawClipper>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateClipper")
    }
    fn CreatePalette(
        &self,
        param_0: u32,
        param_1: MutPtr<super::Gdi::PALETTEENTRY>,
        param_2: MutPtr<IDirectDrawPalette>,
        param_3: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreatePalette")
    }
    fn CreateSurface(
        &self,
        param_0: MutPtr<DDSURFACEDESC>,
        param_1: MutPtr<IDirectDrawSurface>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateSurface")
    }
    fn DuplicateSurface(
        &self,
        param_0: IDirectDrawSurface,
        param_1: MutPtr<IDirectDrawSurface>,
    ) -> crate::core::HRESULT {
        todo!("DuplicateSurface")
    }
    fn EnumDisplayModes(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMMODESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumDisplayModes")
    }
    fn EnumSurfaces(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumSurfaces")
    }
    fn FlipToGDISurface(&self) -> crate::core::HRESULT {
        todo!("FlipToGDISurface")
    }
    fn GetCaps(
        &self,
        param_0: MutPtr<DDCAPS_DX7>,
        param_1: MutPtr<DDCAPS_DX7>,
    ) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetDisplayMode(&self, param_0: MutPtr<DDSURFACEDESC>) -> crate::core::HRESULT {
        todo!("GetDisplayMode")
    }
    fn GetFourCCCodes(&self, param_0: MutPtr<u32>, param_1: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFourCCCodes")
    }
    fn GetGDISurface(&self, param_0: MutPtr<IDirectDrawSurface>) -> crate::core::HRESULT {
        todo!("GetGDISurface")
    }
    fn GetMonitorFrequency(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetMonitorFrequency")
    }
    fn GetScanLine(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetScanLine")
    }
    fn GetVerticalBlankStatus(&self, param_0: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetVerticalBlankStatus")
    }
    fn Initialize(&self, param_0: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn RestoreDisplayMode(&self) -> crate::core::HRESULT {
        todo!("RestoreDisplayMode")
    }
    fn SetCooperativeLevel(
        &self,
        param_0: super::super::Foundation::HWND,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("SetCooperativeLevel")
    }
    fn SetDisplayMode(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: u32,
        param_3: u32,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("SetDisplayMode")
    }
    fn WaitForVerticalBlank(
        &self,
        param_0: u32,
        param_1: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("WaitForVerticalBlank")
    }
    fn GetAvailableVidMem(
        &self,
        param_0: MutPtr<DDSCAPS>,
        param_1: MutPtr<u32>,
        param_2: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetAvailableVidMem")
    }
}
impl ::core::clone::Clone for IDirectDraw2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDraw2 {}
impl ::core::cmp::PartialEq for IDirectDraw2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDraw2 {}
impl ::core::fmt::Debug for IDirectDraw2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDraw2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDraw2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDraw2 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb3a6f3e0_2b43_11cf_a2de_00aa00b93356);
}
pub struct IDirectDraw4(pub crate::core::IUnknown);
pub trait IDirectDraw4_Trait: crate::core::IUnknown_Trait {
    fn Compact(&self) -> crate::core::HRESULT {
        todo!("Compact")
    }
    fn CreateClipper(
        &self,
        param_0: u32,
        param_1: MutPtr<IDirectDrawClipper>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateClipper")
    }
    fn CreatePalette(
        &self,
        param_0: u32,
        param_1: MutPtr<super::Gdi::PALETTEENTRY>,
        param_2: MutPtr<IDirectDrawPalette>,
        param_3: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreatePalette")
    }
    fn CreateSurface(
        &self,
        param_0: MutPtr<DDSURFACEDESC2>,
        param_1: MutPtr<IDirectDrawSurface4>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateSurface")
    }
    fn DuplicateSurface(
        &self,
        param_0: IDirectDrawSurface4,
        param_1: MutPtr<IDirectDrawSurface4>,
    ) -> crate::core::HRESULT {
        todo!("DuplicateSurface")
    }
    fn EnumDisplayModes(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC2>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMMODESCALLBACK2,
    ) -> crate::core::HRESULT {
        todo!("EnumDisplayModes")
    }
    fn EnumSurfaces(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC2>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMSURFACESCALLBACK2,
    ) -> crate::core::HRESULT {
        todo!("EnumSurfaces")
    }
    fn FlipToGDISurface(&self) -> crate::core::HRESULT {
        todo!("FlipToGDISurface")
    }
    fn GetCaps(
        &self,
        param_0: MutPtr<DDCAPS_DX7>,
        param_1: MutPtr<DDCAPS_DX7>,
    ) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetDisplayMode(&self, param_0: MutPtr<DDSURFACEDESC2>) -> crate::core::HRESULT {
        todo!("GetDisplayMode")
    }
    fn GetFourCCCodes(&self, param_0: MutPtr<u32>, param_1: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFourCCCodes")
    }
    fn GetGDISurface(&self, param_0: MutPtr<IDirectDrawSurface4>) -> crate::core::HRESULT {
        todo!("GetGDISurface")
    }
    fn GetMonitorFrequency(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetMonitorFrequency")
    }
    fn GetScanLine(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetScanLine")
    }
    fn GetVerticalBlankStatus(&self, param_0: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetVerticalBlankStatus")
    }
    fn Initialize(&self, param_0: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn RestoreDisplayMode(&self) -> crate::core::HRESULT {
        todo!("RestoreDisplayMode")
    }
    fn SetCooperativeLevel(
        &self,
        param_0: super::super::Foundation::HWND,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("SetCooperativeLevel")
    }
    fn SetDisplayMode(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: u32,
        param_3: u32,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("SetDisplayMode")
    }
    fn WaitForVerticalBlank(
        &self,
        param_0: u32,
        param_1: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("WaitForVerticalBlank")
    }
    fn GetAvailableVidMem(
        &self,
        param_0: MutPtr<DDSCAPS2>,
        param_1: MutPtr<u32>,
        param_2: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetAvailableVidMem")
    }
    fn GetSurfaceFromDC(
        &self,
        param_0: super::Gdi::HDC,
        param_1: MutPtr<IDirectDrawSurface4>,
    ) -> crate::core::HRESULT {
        todo!("GetSurfaceFromDC")
    }
    fn RestoreAllSurfaces(&self) -> crate::core::HRESULT {
        todo!("RestoreAllSurfaces")
    }
    fn TestCooperativeLevel(&self) -> crate::core::HRESULT {
        todo!("TestCooperativeLevel")
    }
    fn GetDeviceIdentifier(
        &self,
        param_0: MutPtr<DDDEVICEIDENTIFIER>,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("GetDeviceIdentifier")
    }
}
impl ::core::clone::Clone for IDirectDraw4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDraw4 {}
impl ::core::cmp::PartialEq for IDirectDraw4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDraw4 {}
impl ::core::fmt::Debug for IDirectDraw4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDraw4").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDraw4 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDraw4 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9c59509a_39bd_11d1_8c4a_00c04fd930c5);
}
pub struct IDirectDraw7(pub crate::core::IUnknown);
pub trait IDirectDraw7_Trait: crate::core::IUnknown_Trait {
    fn Compact(&self) -> crate::core::HRESULT {
        todo!("Compact")
    }
    fn CreateClipper(
        &self,
        param_0: u32,
        param_1: MutPtr<IDirectDrawClipper>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateClipper")
    }
    fn CreatePalette(
        &self,
        param_0: u32,
        param_1: MutPtr<super::Gdi::PALETTEENTRY>,
        param_2: MutPtr<IDirectDrawPalette>,
        param_3: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreatePalette")
    }
    fn CreateSurface(
        &self,
        param_0: MutPtr<DDSURFACEDESC2>,
        param_1: MutPtr<IDirectDrawSurface7>,
        param_2: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("CreateSurface")
    }
    fn DuplicateSurface(
        &self,
        param_0: IDirectDrawSurface7,
        param_1: MutPtr<IDirectDrawSurface7>,
    ) -> crate::core::HRESULT {
        todo!("DuplicateSurface")
    }
    fn EnumDisplayModes(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC2>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMMODESCALLBACK2,
    ) -> crate::core::HRESULT {
        todo!("EnumDisplayModes")
    }
    fn EnumSurfaces(
        &self,
        param_0: u32,
        param_1: MutPtr<DDSURFACEDESC2>,
        param_2: MutPtr<::core::ffi::c_void>,
        param_3: LPDDENUMSURFACESCALLBACK7,
    ) -> crate::core::HRESULT {
        todo!("EnumSurfaces")
    }
    fn FlipToGDISurface(&self) -> crate::core::HRESULT {
        todo!("FlipToGDISurface")
    }
    fn GetCaps(
        &self,
        param_0: MutPtr<DDCAPS_DX7>,
        param_1: MutPtr<DDCAPS_DX7>,
    ) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetDisplayMode(&self, param_0: MutPtr<DDSURFACEDESC2>) -> crate::core::HRESULT {
        todo!("GetDisplayMode")
    }
    fn GetFourCCCodes(&self, param_0: MutPtr<u32>, param_1: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFourCCCodes")
    }
    fn GetGDISurface(&self, param_0: MutPtr<IDirectDrawSurface7>) -> crate::core::HRESULT {
        todo!("GetGDISurface")
    }
    fn GetMonitorFrequency(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetMonitorFrequency")
    }
    fn GetScanLine(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetScanLine")
    }
    fn GetVerticalBlankStatus(&self, param_0: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetVerticalBlankStatus")
    }
    fn Initialize(&self, param_0: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn RestoreDisplayMode(&self) -> crate::core::HRESULT {
        todo!("RestoreDisplayMode")
    }
    fn SetCooperativeLevel(
        &self,
        param_0: super::super::Foundation::HWND,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("SetCooperativeLevel")
    }
    fn SetDisplayMode(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: u32,
        param_3: u32,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("SetDisplayMode")
    }
    fn WaitForVerticalBlank(
        &self,
        param_0: u32,
        param_1: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("WaitForVerticalBlank")
    }
    fn GetAvailableVidMem(
        &self,
        param_0: MutPtr<DDSCAPS2>,
        param_1: MutPtr<u32>,
        param_2: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetAvailableVidMem")
    }
    fn GetSurfaceFromDC(
        &self,
        param_0: super::Gdi::HDC,
        param_1: MutPtr<IDirectDrawSurface7>,
    ) -> crate::core::HRESULT {
        todo!("GetSurfaceFromDC")
    }
    fn RestoreAllSurfaces(&self) -> crate::core::HRESULT {
        todo!("RestoreAllSurfaces")
    }
    fn TestCooperativeLevel(&self) -> crate::core::HRESULT {
        todo!("TestCooperativeLevel")
    }
    fn GetDeviceIdentifier(
        &self,
        param_0: MutPtr<DDDEVICEIDENTIFIER2>,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("GetDeviceIdentifier")
    }
    fn StartModeTest(
        &self,
        param_0: MutPtr<super::super::Foundation::SIZE>,
        param_1: u32,
        param_2: u32,
    ) -> crate::core::HRESULT {
        todo!("StartModeTest")
    }
    fn EvaluateMode(&self, param_0: u32, param_1: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("EvaluateMode")
    }
}
impl ::core::clone::Clone for IDirectDraw7 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDraw7 {}
impl ::core::cmp::PartialEq for IDirectDraw7 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDraw7 {}
impl ::core::fmt::Debug for IDirectDraw7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDraw7").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDraw7 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDraw7 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x15e65ec0_3b9c_11d2_b92f_00609797ea5b);
}
pub struct IDirectDrawClipper(pub crate::core::IUnknown);
pub trait IDirectDrawClipper_Trait: crate::core::IUnknown_Trait {
    fn GetClipList(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: MutPtr<super::Gdi::RGNDATA>,
        param_2: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetClipList")
    }
    fn GetHWnd(&self, param_0: MutPtr<super::super::Foundation::HWND>) -> crate::core::HRESULT {
        todo!("GetHWnd")
    }
    fn Initialize(&self, param_0: IDirectDraw, param_1: u32) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn IsClipListChanged(
        &self,
        param_0: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("IsClipListChanged")
    }
    fn SetClipList(
        &self,
        param_0: MutPtr<super::Gdi::RGNDATA>,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("SetClipList")
    }
    fn SetHWnd(
        &self,
        param_0: u32,
        param_1: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("SetHWnd")
    }
}
impl ::core::clone::Clone for IDirectDrawClipper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawClipper {}
impl ::core::cmp::PartialEq for IDirectDrawClipper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawClipper {}
impl ::core::fmt::Debug for IDirectDrawClipper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawClipper").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawClipper {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawClipper {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6c14db85_a733_11ce_a521_0020af0be560);
}
pub struct IDirectDrawColorControl(pub crate::core::IUnknown);
pub trait IDirectDrawColorControl_Trait: crate::core::IUnknown_Trait {
    fn GetColorControls(&self, param_0: MutPtr<DDCOLORCONTROL>) -> crate::core::HRESULT {
        todo!("GetColorControls")
    }
    fn SetColorControls(&self, param_0: MutPtr<DDCOLORCONTROL>) -> crate::core::HRESULT {
        todo!("SetColorControls")
    }
}
impl ::core::clone::Clone for IDirectDrawColorControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawColorControl {}
impl ::core::cmp::PartialEq for IDirectDrawColorControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawColorControl {}
impl ::core::fmt::Debug for IDirectDrawColorControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawColorControl")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDirectDrawColorControl {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawColorControl {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4b9f0ee0_0d7e_11d0_9b06_00a0c903a3b8);
}
pub struct IDirectDrawGammaControl(pub crate::core::IUnknown);
pub trait IDirectDrawGammaControl_Trait: crate::core::IUnknown_Trait {
    fn GetGammaRamp(&self, param_0: u32, param_1: MutPtr<DDGAMMARAMP>) -> crate::core::HRESULT {
        todo!("GetGammaRamp")
    }
    fn SetGammaRamp(&self, param_0: u32, param_1: MutPtr<DDGAMMARAMP>) -> crate::core::HRESULT {
        todo!("SetGammaRamp")
    }
}
impl ::core::clone::Clone for IDirectDrawGammaControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawGammaControl {}
impl ::core::cmp::PartialEq for IDirectDrawGammaControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawGammaControl {}
impl ::core::fmt::Debug for IDirectDrawGammaControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawGammaControl")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDirectDrawGammaControl {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawGammaControl {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x69c11c3e_b46b_11d1_ad7a_00c04fc29b4e);
}
pub struct IDirectDrawKernel(pub crate::core::IUnknown);
pub trait IDirectDrawKernel_Trait: crate::core::IUnknown_Trait {
    fn GetCaps(&self, param_0: MutPtr<DDKERNELCAPS>) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetKernelHandle(&self, param_0: MutPtr<PtrRepr>) -> crate::core::HRESULT {
        todo!("GetKernelHandle")
    }
    fn ReleaseKernelHandle(&self) -> crate::core::HRESULT {
        todo!("ReleaseKernelHandle")
    }
}
impl ::core::clone::Clone for IDirectDrawKernel {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawKernel {}
impl ::core::cmp::PartialEq for IDirectDrawKernel {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawKernel {}
impl ::core::fmt::Debug for IDirectDrawKernel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawKernel").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawKernel {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawKernel {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8d56c120_6a08_11d0_9b06_00a0c903a3b8);
}
pub struct IDirectDrawPalette(pub crate::core::IUnknown);
pub trait IDirectDrawPalette_Trait: crate::core::IUnknown_Trait {
    fn GetCaps(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetEntries(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: u32,
        param_3: MutPtr<super::Gdi::PALETTEENTRY>,
    ) -> crate::core::HRESULT {
        todo!("GetEntries")
    }
    fn Initialize(
        &self,
        param_0: IDirectDraw,
        param_1: u32,
        param_2: MutPtr<super::Gdi::PALETTEENTRY>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn SetEntries(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: u32,
        param_3: MutPtr<super::Gdi::PALETTEENTRY>,
    ) -> crate::core::HRESULT {
        todo!("SetEntries")
    }
}
impl ::core::clone::Clone for IDirectDrawPalette {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawPalette {}
impl ::core::cmp::PartialEq for IDirectDrawPalette {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawPalette {}
impl ::core::fmt::Debug for IDirectDrawPalette {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawPalette").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawPalette {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawPalette {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6c14db84_a733_11ce_a521_0020af0be560);
}
pub struct IDirectDrawSurface(pub crate::core::IUnknown);
pub trait IDirectDrawSurface_Trait: crate::core::IUnknown_Trait {
    fn AddAttachedSurface(&self, param_0: IDirectDrawSurface) -> crate::core::HRESULT {
        todo!("AddAttachedSurface")
    }
    fn AddOverlayDirtyRect(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("AddOverlayDirtyRect")
    }
    fn Blt(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDBLTFX>,
    ) -> crate::core::HRESULT {
        todo!("Blt")
    }
    fn BltBatch(
        &self,
        param_0: MutPtr<DDBLTBATCH>,
        param_1: u32,
        param_2: u32,
    ) -> crate::core::HRESULT {
        todo!("BltBatch")
    }
    fn BltFast(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: IDirectDrawSurface,
        param_3: MutPtr<super::super::Foundation::RECT>,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("BltFast")
    }
    fn DeleteAttachedSurface(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface,
    ) -> crate::core::HRESULT {
        todo!("DeleteAttachedSurface")
    }
    fn EnumAttachedSurfaces(
        &self,
        param_0: MutPtr<::core::ffi::c_void>,
        param_1: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumAttachedSurfaces")
    }
    fn EnumOverlayZOrders(
        &self,
        param_0: u32,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumOverlayZOrders")
    }
    fn Flip(&self, param_0: IDirectDrawSurface, param_1: u32) -> crate::core::HRESULT {
        todo!("Flip")
    }
    fn GetAttachedSurface(
        &self,
        param_0: MutPtr<DDSCAPS>,
        param_1: MutPtr<IDirectDrawSurface>,
    ) -> crate::core::HRESULT {
        todo!("GetAttachedSurface")
    }
    fn GetBltStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetBltStatus")
    }
    fn GetCaps(&self, param_0: MutPtr<DDSCAPS>) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetClipper(&self, param_0: MutPtr<IDirectDrawClipper>) -> crate::core::HRESULT {
        todo!("GetClipper")
    }
    fn GetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("GetColorKey")
    }
    fn GetDC(&self, param_0: MutPtr<super::Gdi::HDC>) -> crate::core::HRESULT {
        todo!("GetDC")
    }
    fn GetFlipStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetFlipStatus")
    }
    fn GetOverlayPosition(
        &self,
        param_0: MutPtr<i32>,
        param_1: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayPosition")
    }
    fn GetPalette(&self, param_0: MutPtr<IDirectDrawPalette>) -> crate::core::HRESULT {
        todo!("GetPalette")
    }
    fn GetPixelFormat(&self, param_0: MutPtr<DDPIXELFORMAT>) -> crate::core::HRESULT {
        todo!("GetPixelFormat")
    }
    fn GetSurfaceDesc(&self, param_0: MutPtr<DDSURFACEDESC>) -> crate::core::HRESULT {
        todo!("GetSurfaceDesc")
    }
    fn Initialize(
        &self,
        param_0: IDirectDraw,
        param_1: MutPtr<DDSURFACEDESC>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn IsLost(&self) -> crate::core::HRESULT {
        todo!("IsLost")
    }
    fn Lock(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: MutPtr<DDSURFACEDESC>,
        param_2: u32,
        param_3: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("Lock")
    }
    fn ReleaseDC(&self, param_0: super::Gdi::HDC) -> crate::core::HRESULT {
        todo!("ReleaseDC")
    }
    fn Restore(&self) -> crate::core::HRESULT {
        todo!("Restore")
    }
    fn SetClipper(&self, param_0: IDirectDrawClipper) -> crate::core::HRESULT {
        todo!("SetClipper")
    }
    fn SetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("SetColorKey")
    }
    fn SetOverlayPosition(&self, param_0: i32, param_1: i32) -> crate::core::HRESULT {
        todo!("SetOverlayPosition")
    }
    fn SetPalette(&self, param_0: IDirectDrawPalette) -> crate::core::HRESULT {
        todo!("SetPalette")
    }
    fn Unlock(&self, param_0: MutPtr<::core::ffi::c_void>) -> crate::core::HRESULT {
        todo!("Unlock")
    }
    fn UpdateOverlay(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDOVERLAYFX>,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlay")
    }
    fn UpdateOverlayDisplay(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("UpdateOverlayDisplay")
    }
    fn UpdateOverlayZOrder(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlayZOrder")
    }
}
impl ::core::clone::Clone for IDirectDrawSurface {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawSurface {}
impl ::core::cmp::PartialEq for IDirectDrawSurface {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawSurface {}
impl ::core::fmt::Debug for IDirectDrawSurface {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawSurface").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawSurface {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawSurface {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6c14db81_a733_11ce_a521_0020af0be560);
}
pub struct IDirectDrawSurface2(pub crate::core::IUnknown);
pub trait IDirectDrawSurface2_Trait: crate::core::IUnknown_Trait {
    fn AddAttachedSurface(&self, param_0: IDirectDrawSurface2) -> crate::core::HRESULT {
        todo!("AddAttachedSurface")
    }
    fn AddOverlayDirtyRect(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("AddOverlayDirtyRect")
    }
    fn Blt(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface2,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDBLTFX>,
    ) -> crate::core::HRESULT {
        todo!("Blt")
    }
    fn BltBatch(
        &self,
        param_0: MutPtr<DDBLTBATCH>,
        param_1: u32,
        param_2: u32,
    ) -> crate::core::HRESULT {
        todo!("BltBatch")
    }
    fn BltFast(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: IDirectDrawSurface2,
        param_3: MutPtr<super::super::Foundation::RECT>,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("BltFast")
    }
    fn DeleteAttachedSurface(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface2,
    ) -> crate::core::HRESULT {
        todo!("DeleteAttachedSurface")
    }
    fn EnumAttachedSurfaces(
        &self,
        param_0: MutPtr<::core::ffi::c_void>,
        param_1: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumAttachedSurfaces")
    }
    fn EnumOverlayZOrders(
        &self,
        param_0: u32,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumOverlayZOrders")
    }
    fn Flip(&self, param_0: IDirectDrawSurface2, param_1: u32) -> crate::core::HRESULT {
        todo!("Flip")
    }
    fn GetAttachedSurface(
        &self,
        param_0: MutPtr<DDSCAPS>,
        param_1: MutPtr<IDirectDrawSurface2>,
    ) -> crate::core::HRESULT {
        todo!("GetAttachedSurface")
    }
    fn GetBltStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetBltStatus")
    }
    fn GetCaps(&self, param_0: MutPtr<DDSCAPS>) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetClipper(&self, param_0: MutPtr<IDirectDrawClipper>) -> crate::core::HRESULT {
        todo!("GetClipper")
    }
    fn GetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("GetColorKey")
    }
    fn GetDC(&self, param_0: MutPtr<super::Gdi::HDC>) -> crate::core::HRESULT {
        todo!("GetDC")
    }
    fn GetFlipStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetFlipStatus")
    }
    fn GetOverlayPosition(
        &self,
        param_0: MutPtr<i32>,
        param_1: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayPosition")
    }
    fn GetPalette(&self, param_0: MutPtr<IDirectDrawPalette>) -> crate::core::HRESULT {
        todo!("GetPalette")
    }
    fn GetPixelFormat(&self, param_0: MutPtr<DDPIXELFORMAT>) -> crate::core::HRESULT {
        todo!("GetPixelFormat")
    }
    fn GetSurfaceDesc(&self, param_0: MutPtr<DDSURFACEDESC>) -> crate::core::HRESULT {
        todo!("GetSurfaceDesc")
    }
    fn Initialize(
        &self,
        param_0: IDirectDraw,
        param_1: MutPtr<DDSURFACEDESC>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn IsLost(&self) -> crate::core::HRESULT {
        todo!("IsLost")
    }
    fn Lock(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: MutPtr<DDSURFACEDESC>,
        param_2: u32,
        param_3: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("Lock")
    }
    fn ReleaseDC(&self, param_0: super::Gdi::HDC) -> crate::core::HRESULT {
        todo!("ReleaseDC")
    }
    fn Restore(&self) -> crate::core::HRESULT {
        todo!("Restore")
    }
    fn SetClipper(&self, param_0: IDirectDrawClipper) -> crate::core::HRESULT {
        todo!("SetClipper")
    }
    fn SetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("SetColorKey")
    }
    fn SetOverlayPosition(&self, param_0: i32, param_1: i32) -> crate::core::HRESULT {
        todo!("SetOverlayPosition")
    }
    fn SetPalette(&self, param_0: IDirectDrawPalette) -> crate::core::HRESULT {
        todo!("SetPalette")
    }
    fn Unlock(&self, param_0: MutPtr<::core::ffi::c_void>) -> crate::core::HRESULT {
        todo!("Unlock")
    }
    fn UpdateOverlay(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface2,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDOVERLAYFX>,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlay")
    }
    fn UpdateOverlayDisplay(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("UpdateOverlayDisplay")
    }
    fn UpdateOverlayZOrder(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface2,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlayZOrder")
    }
    fn GetDDInterface(
        &self,
        param_0: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetDDInterface")
    }
    fn PageLock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageLock")
    }
    fn PageUnlock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageUnlock")
    }
}
impl ::core::clone::Clone for IDirectDrawSurface2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawSurface2 {}
impl ::core::cmp::PartialEq for IDirectDrawSurface2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawSurface2 {}
impl ::core::fmt::Debug for IDirectDrawSurface2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawSurface2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawSurface2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawSurface2 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x57805885_6eec_11cf_9441_a82303c10e27);
}
pub struct IDirectDrawSurface3(pub crate::core::IUnknown);
pub trait IDirectDrawSurface3_Trait: crate::core::IUnknown_Trait {
    fn AddAttachedSurface(&self, param_0: IDirectDrawSurface3) -> crate::core::HRESULT {
        todo!("AddAttachedSurface")
    }
    fn AddOverlayDirtyRect(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("AddOverlayDirtyRect")
    }
    fn Blt(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface3,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDBLTFX>,
    ) -> crate::core::HRESULT {
        todo!("Blt")
    }
    fn BltBatch(
        &self,
        param_0: MutPtr<DDBLTBATCH>,
        param_1: u32,
        param_2: u32,
    ) -> crate::core::HRESULT {
        todo!("BltBatch")
    }
    fn BltFast(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: IDirectDrawSurface3,
        param_3: MutPtr<super::super::Foundation::RECT>,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("BltFast")
    }
    fn DeleteAttachedSurface(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface3,
    ) -> crate::core::HRESULT {
        todo!("DeleteAttachedSurface")
    }
    fn EnumAttachedSurfaces(
        &self,
        param_0: MutPtr<::core::ffi::c_void>,
        param_1: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumAttachedSurfaces")
    }
    fn EnumOverlayZOrders(
        &self,
        param_0: u32,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: LPDDENUMSURFACESCALLBACK,
    ) -> crate::core::HRESULT {
        todo!("EnumOverlayZOrders")
    }
    fn Flip(&self, param_0: IDirectDrawSurface3, param_1: u32) -> crate::core::HRESULT {
        todo!("Flip")
    }
    fn GetAttachedSurface(
        &self,
        param_0: MutPtr<DDSCAPS>,
        param_1: MutPtr<IDirectDrawSurface3>,
    ) -> crate::core::HRESULT {
        todo!("GetAttachedSurface")
    }
    fn GetBltStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetBltStatus")
    }
    fn GetCaps(&self, param_0: MutPtr<DDSCAPS>) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetClipper(&self, param_0: MutPtr<IDirectDrawClipper>) -> crate::core::HRESULT {
        todo!("GetClipper")
    }
    fn GetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("GetColorKey")
    }
    fn GetDC(&self, param_0: MutPtr<super::Gdi::HDC>) -> crate::core::HRESULT {
        todo!("GetDC")
    }
    fn GetFlipStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetFlipStatus")
    }
    fn GetOverlayPosition(
        &self,
        param_0: MutPtr<i32>,
        param_1: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayPosition")
    }
    fn GetPalette(&self, param_0: MutPtr<IDirectDrawPalette>) -> crate::core::HRESULT {
        todo!("GetPalette")
    }
    fn GetPixelFormat(&self, param_0: MutPtr<DDPIXELFORMAT>) -> crate::core::HRESULT {
        todo!("GetPixelFormat")
    }
    fn GetSurfaceDesc(&self, param_0: MutPtr<DDSURFACEDESC>) -> crate::core::HRESULT {
        todo!("GetSurfaceDesc")
    }
    fn Initialize(
        &self,
        param_0: IDirectDraw,
        param_1: MutPtr<DDSURFACEDESC>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn IsLost(&self) -> crate::core::HRESULT {
        todo!("IsLost")
    }
    fn Lock(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: MutPtr<DDSURFACEDESC>,
        param_2: u32,
        param_3: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("Lock")
    }
    fn ReleaseDC(&self, param_0: super::Gdi::HDC) -> crate::core::HRESULT {
        todo!("ReleaseDC")
    }
    fn Restore(&self) -> crate::core::HRESULT {
        todo!("Restore")
    }
    fn SetClipper(&self, param_0: IDirectDrawClipper) -> crate::core::HRESULT {
        todo!("SetClipper")
    }
    fn SetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("SetColorKey")
    }
    fn SetOverlayPosition(&self, param_0: i32, param_1: i32) -> crate::core::HRESULT {
        todo!("SetOverlayPosition")
    }
    fn SetPalette(&self, param_0: IDirectDrawPalette) -> crate::core::HRESULT {
        todo!("SetPalette")
    }
    fn Unlock(&self, param_0: MutPtr<::core::ffi::c_void>) -> crate::core::HRESULT {
        todo!("Unlock")
    }
    fn UpdateOverlay(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface3,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDOVERLAYFX>,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlay")
    }
    fn UpdateOverlayDisplay(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("UpdateOverlayDisplay")
    }
    fn UpdateOverlayZOrder(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface3,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlayZOrder")
    }
    fn GetDDInterface(
        &self,
        param_0: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetDDInterface")
    }
    fn PageLock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageLock")
    }
    fn PageUnlock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageUnlock")
    }
    fn SetSurfaceDesc(&self, param_0: MutPtr<DDSURFACEDESC>, param_1: u32) -> crate::core::HRESULT {
        todo!("SetSurfaceDesc")
    }
}
impl ::core::clone::Clone for IDirectDrawSurface3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawSurface3 {}
impl ::core::cmp::PartialEq for IDirectDrawSurface3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawSurface3 {}
impl ::core::fmt::Debug for IDirectDrawSurface3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawSurface3").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawSurface3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawSurface3 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xda044e00_69b2_11d0_a1d5_00aa00b8dfbb);
}
pub struct IDirectDrawSurface4(pub crate::core::IUnknown);
pub trait IDirectDrawSurface4_Trait: crate::core::IUnknown_Trait {
    fn AddAttachedSurface(&self, param_0: IDirectDrawSurface4) -> crate::core::HRESULT {
        todo!("AddAttachedSurface")
    }
    fn AddOverlayDirtyRect(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("AddOverlayDirtyRect")
    }
    fn Blt(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface4,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDBLTFX>,
    ) -> crate::core::HRESULT {
        todo!("Blt")
    }
    fn BltBatch(
        &self,
        param_0: MutPtr<DDBLTBATCH>,
        param_1: u32,
        param_2: u32,
    ) -> crate::core::HRESULT {
        todo!("BltBatch")
    }
    fn BltFast(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: IDirectDrawSurface4,
        param_3: MutPtr<super::super::Foundation::RECT>,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("BltFast")
    }
    fn DeleteAttachedSurface(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface4,
    ) -> crate::core::HRESULT {
        todo!("DeleteAttachedSurface")
    }
    fn EnumAttachedSurfaces(
        &self,
        param_0: MutPtr<::core::ffi::c_void>,
        param_1: LPDDENUMSURFACESCALLBACK2,
    ) -> crate::core::HRESULT {
        todo!("EnumAttachedSurfaces")
    }
    fn EnumOverlayZOrders(
        &self,
        param_0: u32,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: LPDDENUMSURFACESCALLBACK2,
    ) -> crate::core::HRESULT {
        todo!("EnumOverlayZOrders")
    }
    fn Flip(&self, param_0: IDirectDrawSurface4, param_1: u32) -> crate::core::HRESULT {
        todo!("Flip")
    }
    fn GetAttachedSurface(
        &self,
        param_0: MutPtr<DDSCAPS2>,
        param_1: MutPtr<IDirectDrawSurface4>,
    ) -> crate::core::HRESULT {
        todo!("GetAttachedSurface")
    }
    fn GetBltStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetBltStatus")
    }
    fn GetCaps(&self, param_0: MutPtr<DDSCAPS2>) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetClipper(&self, param_0: MutPtr<IDirectDrawClipper>) -> crate::core::HRESULT {
        todo!("GetClipper")
    }
    fn GetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("GetColorKey")
    }
    fn GetDC(&self, param_0: MutPtr<super::Gdi::HDC>) -> crate::core::HRESULT {
        todo!("GetDC")
    }
    fn GetFlipStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetFlipStatus")
    }
    fn GetOverlayPosition(
        &self,
        param_0: MutPtr<i32>,
        param_1: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayPosition")
    }
    fn GetPalette(&self, param_0: MutPtr<IDirectDrawPalette>) -> crate::core::HRESULT {
        todo!("GetPalette")
    }
    fn GetPixelFormat(&self, param_0: MutPtr<DDPIXELFORMAT>) -> crate::core::HRESULT {
        todo!("GetPixelFormat")
    }
    fn GetSurfaceDesc(&self, param_0: MutPtr<DDSURFACEDESC2>) -> crate::core::HRESULT {
        todo!("GetSurfaceDesc")
    }
    fn Initialize(
        &self,
        param_0: IDirectDraw,
        param_1: MutPtr<DDSURFACEDESC2>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn IsLost(&self) -> crate::core::HRESULT {
        todo!("IsLost")
    }
    fn Lock(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: MutPtr<DDSURFACEDESC2>,
        param_2: u32,
        param_3: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("Lock")
    }
    fn ReleaseDC(&self, param_0: super::Gdi::HDC) -> crate::core::HRESULT {
        todo!("ReleaseDC")
    }
    fn Restore(&self) -> crate::core::HRESULT {
        todo!("Restore")
    }
    fn SetClipper(&self, param_0: IDirectDrawClipper) -> crate::core::HRESULT {
        todo!("SetClipper")
    }
    fn SetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("SetColorKey")
    }
    fn SetOverlayPosition(&self, param_0: i32, param_1: i32) -> crate::core::HRESULT {
        todo!("SetOverlayPosition")
    }
    fn SetPalette(&self, param_0: IDirectDrawPalette) -> crate::core::HRESULT {
        todo!("SetPalette")
    }
    fn Unlock(&self, param_0: MutPtr<super::super::Foundation::RECT>) -> crate::core::HRESULT {
        todo!("Unlock")
    }
    fn UpdateOverlay(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface4,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDOVERLAYFX>,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlay")
    }
    fn UpdateOverlayDisplay(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("UpdateOverlayDisplay")
    }
    fn UpdateOverlayZOrder(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface4,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlayZOrder")
    }
    fn GetDDInterface(
        &self,
        param_0: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetDDInterface")
    }
    fn PageLock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageLock")
    }
    fn PageUnlock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageUnlock")
    }
    fn SetSurfaceDesc(
        &self,
        param_0: MutPtr<DDSURFACEDESC2>,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("SetSurfaceDesc")
    }
    fn SetPrivateData(
        &self,
        param_0: ConstPtr<crate::core::GUID>,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: u32,
        param_3: u32,
    ) -> crate::core::HRESULT {
        todo!("SetPrivateData")
    }
    fn GetPrivateData(
        &self,
        param_0: ConstPtr<crate::core::GUID>,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetPrivateData")
    }
    fn FreePrivateData(&self, param_0: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("FreePrivateData")
    }
    fn GetUniquenessValue(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetUniquenessValue")
    }
    fn ChangeUniquenessValue(&self) -> crate::core::HRESULT {
        todo!("ChangeUniquenessValue")
    }
}
impl ::core::clone::Clone for IDirectDrawSurface4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawSurface4 {}
impl ::core::cmp::PartialEq for IDirectDrawSurface4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawSurface4 {}
impl ::core::fmt::Debug for IDirectDrawSurface4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawSurface4").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawSurface4 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawSurface4 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0b2b8630_ad35_11d0_8ea6_00609797ea5b);
}
pub struct IDirectDrawSurface7(pub crate::core::IUnknown);
pub trait IDirectDrawSurface7_Trait: crate::core::IUnknown_Trait {
    fn AddAttachedSurface(&self, param_0: IDirectDrawSurface7) -> crate::core::HRESULT {
        todo!("AddAttachedSurface")
    }
    fn AddOverlayDirtyRect(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("AddOverlayDirtyRect")
    }
    fn Blt(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface7,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDBLTFX>,
    ) -> crate::core::HRESULT {
        todo!("Blt")
    }
    fn BltBatch(
        &self,
        param_0: MutPtr<DDBLTBATCH>,
        param_1: u32,
        param_2: u32,
    ) -> crate::core::HRESULT {
        todo!("BltBatch")
    }
    fn BltFast(
        &self,
        param_0: u32,
        param_1: u32,
        param_2: IDirectDrawSurface7,
        param_3: MutPtr<super::super::Foundation::RECT>,
        param_4: u32,
    ) -> crate::core::HRESULT {
        todo!("BltFast")
    }
    fn DeleteAttachedSurface(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface7,
    ) -> crate::core::HRESULT {
        todo!("DeleteAttachedSurface")
    }
    fn EnumAttachedSurfaces(
        &self,
        param_0: MutPtr<::core::ffi::c_void>,
        param_1: LPDDENUMSURFACESCALLBACK7,
    ) -> crate::core::HRESULT {
        todo!("EnumAttachedSurfaces")
    }
    fn EnumOverlayZOrders(
        &self,
        param_0: u32,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: LPDDENUMSURFACESCALLBACK7,
    ) -> crate::core::HRESULT {
        todo!("EnumOverlayZOrders")
    }
    fn Flip(&self, param_0: IDirectDrawSurface7, param_1: u32) -> crate::core::HRESULT {
        todo!("Flip")
    }
    fn GetAttachedSurface(
        &self,
        param_0: MutPtr<DDSCAPS2>,
        param_1: MutPtr<IDirectDrawSurface7>,
    ) -> crate::core::HRESULT {
        todo!("GetAttachedSurface")
    }
    fn GetBltStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetBltStatus")
    }
    fn GetCaps(&self, param_0: MutPtr<DDSCAPS2>) -> crate::core::HRESULT {
        todo!("GetCaps")
    }
    fn GetClipper(&self, param_0: MutPtr<IDirectDrawClipper>) -> crate::core::HRESULT {
        todo!("GetClipper")
    }
    fn GetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("GetColorKey")
    }
    fn GetDC(&self, param_0: MutPtr<super::Gdi::HDC>) -> crate::core::HRESULT {
        todo!("GetDC")
    }
    fn GetFlipStatus(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("GetFlipStatus")
    }
    fn GetOverlayPosition(
        &self,
        param_0: MutPtr<i32>,
        param_1: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayPosition")
    }
    fn GetPalette(&self, param_0: MutPtr<IDirectDrawPalette>) -> crate::core::HRESULT {
        todo!("GetPalette")
    }
    fn GetPixelFormat(&self, param_0: MutPtr<DDPIXELFORMAT>) -> crate::core::HRESULT {
        todo!("GetPixelFormat")
    }
    fn GetSurfaceDesc(&self, param_0: MutPtr<DDSURFACEDESC2>) -> crate::core::HRESULT {
        todo!("GetSurfaceDesc")
    }
    fn Initialize(
        &self,
        param_0: IDirectDraw,
        param_1: MutPtr<DDSURFACEDESC2>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn IsLost(&self) -> crate::core::HRESULT {
        todo!("IsLost")
    }
    fn Lock(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: MutPtr<DDSURFACEDESC2>,
        param_2: u32,
        param_3: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("Lock")
    }
    fn ReleaseDC(&self, param_0: super::Gdi::HDC) -> crate::core::HRESULT {
        todo!("ReleaseDC")
    }
    fn Restore(&self) -> crate::core::HRESULT {
        todo!("Restore")
    }
    fn SetClipper(&self, param_0: IDirectDrawClipper) -> crate::core::HRESULT {
        todo!("SetClipper")
    }
    fn SetColorKey(&self, param_0: u32, param_1: MutPtr<DDCOLORKEY>) -> crate::core::HRESULT {
        todo!("SetColorKey")
    }
    fn SetOverlayPosition(&self, param_0: i32, param_1: i32) -> crate::core::HRESULT {
        todo!("SetOverlayPosition")
    }
    fn SetPalette(&self, param_0: IDirectDrawPalette) -> crate::core::HRESULT {
        todo!("SetPalette")
    }
    fn Unlock(&self, param_0: MutPtr<super::super::Foundation::RECT>) -> crate::core::HRESULT {
        todo!("Unlock")
    }
    fn UpdateOverlay(
        &self,
        param_0: MutPtr<super::super::Foundation::RECT>,
        param_1: IDirectDrawSurface7,
        param_2: MutPtr<super::super::Foundation::RECT>,
        param_3: u32,
        param_4: MutPtr<DDOVERLAYFX>,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlay")
    }
    fn UpdateOverlayDisplay(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("UpdateOverlayDisplay")
    }
    fn UpdateOverlayZOrder(
        &self,
        param_0: u32,
        param_1: IDirectDrawSurface7,
    ) -> crate::core::HRESULT {
        todo!("UpdateOverlayZOrder")
    }
    fn GetDDInterface(
        &self,
        param_0: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetDDInterface")
    }
    fn PageLock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageLock")
    }
    fn PageUnlock(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("PageUnlock")
    }
    fn SetSurfaceDesc(
        &self,
        param_0: MutPtr<DDSURFACEDESC2>,
        param_1: u32,
    ) -> crate::core::HRESULT {
        todo!("SetSurfaceDesc")
    }
    fn SetPrivateData(
        &self,
        param_0: ConstPtr<crate::core::GUID>,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: u32,
        param_3: u32,
    ) -> crate::core::HRESULT {
        todo!("SetPrivateData")
    }
    fn GetPrivateData(
        &self,
        param_0: ConstPtr<crate::core::GUID>,
        param_1: MutPtr<::core::ffi::c_void>,
        param_2: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetPrivateData")
    }
    fn FreePrivateData(&self, param_0: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("FreePrivateData")
    }
    fn GetUniquenessValue(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetUniquenessValue")
    }
    fn ChangeUniquenessValue(&self) -> crate::core::HRESULT {
        todo!("ChangeUniquenessValue")
    }
    fn SetPriority(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("SetPriority")
    }
    fn GetPriority(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetPriority")
    }
    fn SetLOD(&self, param_0: u32) -> crate::core::HRESULT {
        todo!("SetLOD")
    }
    fn GetLOD(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetLOD")
    }
}
impl ::core::clone::Clone for IDirectDrawSurface7 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawSurface7 {}
impl ::core::cmp::PartialEq for IDirectDrawSurface7 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawSurface7 {}
impl ::core::fmt::Debug for IDirectDrawSurface7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawSurface7").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDirectDrawSurface7 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawSurface7 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x06675a80_3b9b_11d2_b92f_00609797ea5b);
}
pub struct IDirectDrawSurfaceKernel(pub crate::core::IUnknown);
pub trait IDirectDrawSurfaceKernel_Trait: crate::core::IUnknown_Trait {
    fn GetKernelHandle(&self, param_0: MutPtr<PtrRepr>) -> crate::core::HRESULT {
        todo!("GetKernelHandle")
    }
    fn ReleaseKernelHandle(&self) -> crate::core::HRESULT {
        todo!("ReleaseKernelHandle")
    }
}
impl ::core::clone::Clone for IDirectDrawSurfaceKernel {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawSurfaceKernel {}
impl ::core::cmp::PartialEq for IDirectDrawSurfaceKernel {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawSurfaceKernel {}
impl ::core::fmt::Debug for IDirectDrawSurfaceKernel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawSurfaceKernel")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDirectDrawSurfaceKernel {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawSurfaceKernel {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x60755da0_6a40_11d0_9b06_00a0c903a3b8);
}
pub struct IDirectDrawVideoPort(pub crate::core::IUnknown);
pub trait IDirectDrawVideoPort_Trait: crate::core::IUnknown_Trait {
    fn Flip(&self, param_0: IDirectDrawSurface, param_1: u32) -> crate::core::HRESULT {
        todo!("Flip")
    }
    fn GetBandwidthInfo(
        &self,
        param_0: MutPtr<DDPIXELFORMAT>,
        param_1: u32,
        param_2: u32,
        param_3: u32,
        param_4: MutPtr<DDVIDEOPORTBANDWIDTH>,
    ) -> crate::core::HRESULT {
        todo!("GetBandwidthInfo")
    }
    fn GetColorControls(&self, param_0: MutPtr<DDCOLORCONTROL>) -> crate::core::HRESULT {
        todo!("GetColorControls")
    }
    fn GetInputFormats(
        &self,
        lp_num_formats: MutPtr<u32>,
        param_1: MutPtr<DDPIXELFORMAT>,
        param_2: u32,
    ) -> crate::core::HRESULT {
        todo!("GetInputFormats")
    }
    fn GetOutputFormats(
        &self,
        param_0: MutPtr<DDPIXELFORMAT>,
        lp_num_formats: MutPtr<u32>,
        param_2: MutPtr<DDPIXELFORMAT>,
        param_3: u32,
    ) -> crate::core::HRESULT {
        todo!("GetOutputFormats")
    }
    fn GetFieldPolarity(&self, param_0: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetFieldPolarity")
    }
    fn GetVideoLine(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetVideoLine")
    }
    fn GetVideoSignalStatus(&self, param_0: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetVideoSignalStatus")
    }
    fn SetColorControls(&self, param_0: MutPtr<DDCOLORCONTROL>) -> crate::core::HRESULT {
        todo!("SetColorControls")
    }
    fn SetTargetSurface(&self, param_0: IDirectDrawSurface, param_1: u32) -> crate::core::HRESULT {
        todo!("SetTargetSurface")
    }
    fn StartVideo(&self, param_0: MutPtr<DDVIDEOPORTINFO>) -> crate::core::HRESULT {
        todo!("StartVideo")
    }
    fn StopVideo(&self) -> crate::core::HRESULT {
        todo!("StopVideo")
    }
    fn UpdateVideo(&self, param_0: MutPtr<DDVIDEOPORTINFO>) -> crate::core::HRESULT {
        todo!("UpdateVideo")
    }
    fn WaitForSync(&self, param_0: u32, param_1: u32, param_2: u32) -> crate::core::HRESULT {
        todo!("WaitForSync")
    }
}
impl ::core::clone::Clone for IDirectDrawVideoPort {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawVideoPort {}
impl ::core::cmp::PartialEq for IDirectDrawVideoPort {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawVideoPort {}
impl ::core::fmt::Debug for IDirectDrawVideoPort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawVideoPort")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDirectDrawVideoPort {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawVideoPort {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb36d93e0_2b43_11cf_a2de_00aa00b93356);
}
pub struct IDirectDrawVideoPortNotify(pub crate::core::IUnknown);
pub trait IDirectDrawVideoPortNotify_Trait: crate::core::IUnknown_Trait {
    fn AcquireNotification(
        &self,
        param_0: MutPtr<super::super::Foundation::HANDLE>,
        param_1: MutPtr<DDVIDEOPORTNOTIFY>,
    ) -> crate::core::HRESULT {
        todo!("AcquireNotification")
    }
    fn ReleaseNotification(
        &self,
        param_0: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("ReleaseNotification")
    }
}
impl ::core::clone::Clone for IDirectDrawVideoPortNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDirectDrawVideoPortNotify {}
impl ::core::cmp::PartialEq for IDirectDrawVideoPortNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectDrawVideoPortNotify {}
impl ::core::fmt::Debug for IDirectDrawVideoPortNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectDrawVideoPortNotify")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDirectDrawVideoPortNotify {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDirectDrawVideoPortNotify {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa655fb94_0589_4e57_b333_567a89468c88);
}
pub const IRQINFO_HANDLED: u32 = 1u32;
pub const IRQINFO_NOTHANDLED: u32 = 2u32;
pub struct IUNKNOWN_LIST {
    pub lpLink: MutPtr<IUNKNOWN_LIST>,
    pub lpGuid: MutPtr<crate::core::GUID>,
    pub lpIUnknown: crate::core::IUnknown,
}
impl ::core::marker::Copy for IUNKNOWN_LIST {}
impl ::core::clone::Clone for IUNKNOWN_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for IUNKNOWN_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("IUNKNOWN_LIST")
            .field("lpLink", &self.lpLink)
            .field("lpGuid", &self.lpGuid)
            .field("lpIUnknown", &self.lpIUnknown)
            .finish()
    }
}
impl ::core::cmp::PartialEq for IUNKNOWN_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.lpLink == other.lpLink
            && self.lpGuid == other.lpGuid
            && self.lpIUnknown == other.lpIUnknown
    }
}
impl ::core::cmp::Eq for IUNKNOWN_LIST {}
impl FromIntoMemory for IUNKNOWN_LIST {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_lpLink = <MutPtr<IUNKNOWN_LIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_lpGuid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpIUnknown = <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            lpLink: f_lpLink,
            lpGuid: f_lpGuid,
            lpIUnknown: f_lpIUnknown,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.lpGuid, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpIUnknown, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub type LPCLIPPERCALLBACK = StdCallFnPtr<
    (
        IDirectDrawClipper,
        super::super::Foundation::HWND,
        u32,
        MutPtr<::core::ffi::c_void>,
    ),
    u32,
>;
pub type LPDD32BITDRIVERINIT = StdCallFnPtr<(u32,), u32>;
pub type LPDDENUMCALLBACKA = StdCallFnPtr<
    (
        MutPtr<crate::core::GUID>,
        PCSTR,
        PCSTR,
        MutPtr<::core::ffi::c_void>,
    ),
    super::super::Foundation::BOOL,
>;
pub type LPDDENUMCALLBACKEXA = StdCallFnPtr<
    (
        MutPtr<crate::core::GUID>,
        PCSTR,
        PCSTR,
        MutPtr<::core::ffi::c_void>,
        super::Gdi::HMONITOR,
    ),
    super::super::Foundation::BOOL,
>;
pub type LPDDENUMCALLBACKEXW = StdCallFnPtr<
    (
        MutPtr<crate::core::GUID>,
        PCWSTR,
        PCWSTR,
        MutPtr<::core::ffi::c_void>,
        super::Gdi::HMONITOR,
    ),
    super::super::Foundation::BOOL,
>;
pub type LPDDENUMCALLBACKW = StdCallFnPtr<
    (
        MutPtr<crate::core::GUID>,
        PCWSTR,
        PCWSTR,
        MutPtr<::core::ffi::c_void>,
    ),
    super::super::Foundation::BOOL,
>;
pub type LPDDENUMMODESCALLBACK =
    StdCallFnPtr<(MutPtr<DDSURFACEDESC>, MutPtr<::core::ffi::c_void>), crate::core::HRESULT>;
pub type LPDDENUMMODESCALLBACK2 =
    StdCallFnPtr<(MutPtr<DDSURFACEDESC2>, MutPtr<::core::ffi::c_void>), crate::core::HRESULT>;
pub type LPDDENUMSURFACESCALLBACK = StdCallFnPtr<
    (
        IDirectDrawSurface,
        MutPtr<DDSURFACEDESC>,
        MutPtr<::core::ffi::c_void>,
    ),
    crate::core::HRESULT,
>;
pub type LPDDENUMSURFACESCALLBACK2 = StdCallFnPtr<
    (
        IDirectDrawSurface4,
        MutPtr<DDSURFACEDESC2>,
        MutPtr<::core::ffi::c_void>,
    ),
    crate::core::HRESULT,
>;
pub type LPDDENUMSURFACESCALLBACK7 = StdCallFnPtr<
    (
        IDirectDrawSurface7,
        MutPtr<DDSURFACEDESC2>,
        MutPtr<::core::ffi::c_void>,
    ),
    crate::core::HRESULT,
>;
pub type LPDDENUMVIDEOCALLBACK =
    StdCallFnPtr<(MutPtr<DDVIDEOPORTCAPS>, MutPtr<::core::ffi::c_void>), crate::core::HRESULT>;
pub type LPDDGAMMACALIBRATORPROC =
    StdCallFnPtr<(MutPtr<DDGAMMARAMP>, MutPtr<u8>), crate::core::HRESULT>;
pub type LPDDHALCOLORCB_COLORCONTROL = StdCallFnPtr<(MutPtr<DDHAL_COLORCONTROLDATA>,), u32>;
pub type LPDDHALEXEBUFCB_CANCREATEEXEBUF = StdCallFnPtr<(MutPtr<DDHAL_CANCREATESURFACEDATA>,), u32>;
pub type LPDDHALEXEBUFCB_CREATEEXEBUF = StdCallFnPtr<(MutPtr<DDHAL_CREATESURFACEDATA>,), u32>;
pub type LPDDHALEXEBUFCB_DESTROYEXEBUF = StdCallFnPtr<(MutPtr<DDHAL_DESTROYSURFACEDATA>,), u32>;
pub type LPDDHALEXEBUFCB_LOCKEXEBUF = StdCallFnPtr<(MutPtr<DDHAL_LOCKDATA>,), u32>;
pub type LPDDHALEXEBUFCB_UNLOCKEXEBUF = StdCallFnPtr<(MutPtr<DDHAL_UNLOCKDATA>,), u32>;
pub type LPDDHALKERNELCB_SYNCSURFACE = StdCallFnPtr<(MutPtr<DDHAL_SYNCSURFACEDATA>,), u32>;
pub type LPDDHALKERNELCB_SYNCVIDEOPORT = StdCallFnPtr<(MutPtr<DDHAL_SYNCVIDEOPORTDATA>,), u32>;
pub type LPDDHALMOCOMPCB_BEGINFRAME = StdCallFnPtr<(MutPtr<DDHAL_BEGINMOCOMPFRAMEDATA>,), u32>;
pub type LPDDHALMOCOMPCB_CREATE = StdCallFnPtr<(MutPtr<DDHAL_CREATEMOCOMPDATA>,), u32>;
pub type LPDDHALMOCOMPCB_DESTROY = StdCallFnPtr<(MutPtr<DDHAL_DESTROYMOCOMPDATA>,), u32>;
pub type LPDDHALMOCOMPCB_ENDFRAME = StdCallFnPtr<(MutPtr<DDHAL_ENDMOCOMPFRAMEDATA>,), u32>;
pub type LPDDHALMOCOMPCB_GETCOMPBUFFINFO =
    StdCallFnPtr<(MutPtr<DDHAL_GETMOCOMPCOMPBUFFDATA>,), u32>;
pub type LPDDHALMOCOMPCB_GETFORMATS = StdCallFnPtr<(MutPtr<DDHAL_GETMOCOMPFORMATSDATA>,), u32>;
pub type LPDDHALMOCOMPCB_GETGUIDS = StdCallFnPtr<(MutPtr<DDHAL_GETMOCOMPGUIDSDATA>,), u32>;
pub type LPDDHALMOCOMPCB_GETINTERNALINFO =
    StdCallFnPtr<(MutPtr<DDHAL_GETINTERNALMOCOMPDATA>,), u32>;
pub type LPDDHALMOCOMPCB_QUERYSTATUS = StdCallFnPtr<(MutPtr<DDHAL_QUERYMOCOMPSTATUSDATA>,), u32>;
pub type LPDDHALMOCOMPCB_RENDER = StdCallFnPtr<(MutPtr<DDHAL_RENDERMOCOMPDATA>,), u32>;
pub type LPDDHALPALCB_DESTROYPALETTE = StdCallFnPtr<(MutPtr<DDHAL_DESTROYPALETTEDATA>,), u32>;
pub type LPDDHALPALCB_SETENTRIES = StdCallFnPtr<(MutPtr<DDHAL_SETENTRIESDATA>,), u32>;
pub type LPDDHALSURFCB_ADDATTACHEDSURFACE =
    StdCallFnPtr<(MutPtr<DDHAL_ADDATTACHEDSURFACEDATA>,), u32>;
pub type LPDDHALSURFCB_BLT = StdCallFnPtr<(MutPtr<DDHAL_BLTDATA>,), u32>;
pub type LPDDHALSURFCB_DESTROYSURFACE = StdCallFnPtr<(MutPtr<DDHAL_DESTROYSURFACEDATA>,), u32>;
pub type LPDDHALSURFCB_FLIP = StdCallFnPtr<(MutPtr<DDHAL_FLIPDATA>,), u32>;
pub type LPDDHALSURFCB_GETBLTSTATUS = StdCallFnPtr<(MutPtr<DDHAL_GETBLTSTATUSDATA>,), u32>;
pub type LPDDHALSURFCB_GETFLIPSTATUS = StdCallFnPtr<(MutPtr<DDHAL_GETFLIPSTATUSDATA>,), u32>;
pub type LPDDHALSURFCB_LOCK = StdCallFnPtr<(MutPtr<DDHAL_LOCKDATA>,), u32>;
pub type LPDDHALSURFCB_SETCLIPLIST = StdCallFnPtr<(MutPtr<DDHAL_SETCLIPLISTDATA>,), u32>;
pub type LPDDHALSURFCB_SETCOLORKEY = StdCallFnPtr<(MutPtr<DDHAL_SETCOLORKEYDATA>,), u32>;
pub type LPDDHALSURFCB_SETOVERLAYPOSITION =
    StdCallFnPtr<(MutPtr<DDHAL_SETOVERLAYPOSITIONDATA>,), u32>;
pub type LPDDHALSURFCB_SETPALETTE = StdCallFnPtr<(MutPtr<DDHAL_SETPALETTEDATA>,), u32>;
pub type LPDDHALSURFCB_UNLOCK = StdCallFnPtr<(MutPtr<DDHAL_UNLOCKDATA>,), u32>;
pub type LPDDHALSURFCB_UPDATEOVERLAY = StdCallFnPtr<(MutPtr<DDHAL_UPDATEOVERLAYDATA>,), u32>;
pub type LPDDHALVPORTCB_CANCREATEVIDEOPORT = StdCallFnPtr<(MutPtr<DDHAL_CANCREATEVPORTDATA>,), u32>;
pub type LPDDHALVPORTCB_COLORCONTROL = StdCallFnPtr<(MutPtr<DDHAL_VPORTCOLORDATA>,), u32>;
pub type LPDDHALVPORTCB_CREATEVIDEOPORT = StdCallFnPtr<(MutPtr<DDHAL_CREATEVPORTDATA>,), u32>;
pub type LPDDHALVPORTCB_DESTROYVPORT = StdCallFnPtr<(MutPtr<DDHAL_DESTROYVPORTDATA>,), u32>;
pub type LPDDHALVPORTCB_FLIP = StdCallFnPtr<(MutPtr<DDHAL_FLIPVPORTDATA>,), u32>;
pub type LPDDHALVPORTCB_GETBANDWIDTH = StdCallFnPtr<(MutPtr<DDHAL_GETVPORTBANDWIDTHDATA>,), u32>;
pub type LPDDHALVPORTCB_GETFIELD = StdCallFnPtr<(MutPtr<DDHAL_GETVPORTFIELDDATA>,), u32>;
pub type LPDDHALVPORTCB_GETFLIPSTATUS = StdCallFnPtr<(MutPtr<DDHAL_GETVPORTFLIPSTATUSDATA>,), u32>;
pub type LPDDHALVPORTCB_GETINPUTFORMATS =
    StdCallFnPtr<(MutPtr<DDHAL_GETVPORTINPUTFORMATDATA>,), u32>;
pub type LPDDHALVPORTCB_GETLINE = StdCallFnPtr<(MutPtr<DDHAL_GETVPORTLINEDATA>,), u32>;
pub type LPDDHALVPORTCB_GETOUTPUTFORMATS =
    StdCallFnPtr<(MutPtr<DDHAL_GETVPORTOUTPUTFORMATDATA>,), u32>;
pub type LPDDHALVPORTCB_GETSIGNALSTATUS = StdCallFnPtr<(MutPtr<DDHAL_GETVPORTSIGNALDATA>,), u32>;
pub type LPDDHALVPORTCB_GETVPORTCONNECT = StdCallFnPtr<(MutPtr<DDHAL_GETVPORTCONNECTDATA>,), u32>;
pub type LPDDHALVPORTCB_UPDATE = StdCallFnPtr<(MutPtr<DDHAL_UPDATEVPORTDATA>,), u32>;
pub type LPDDHALVPORTCB_WAITFORSYNC = StdCallFnPtr<(MutPtr<DDHAL_WAITFORVPORTSYNCDATA>,), u32>;
pub type LPDDHAL_CANCREATESURFACE = StdCallFnPtr<(MutPtr<DDHAL_CANCREATESURFACEDATA>,), u32>;
pub type LPDDHAL_CREATEPALETTE = StdCallFnPtr<(MutPtr<DDHAL_CREATEPALETTEDATA>,), u32>;
pub type LPDDHAL_CREATESURFACE = StdCallFnPtr<(MutPtr<DDHAL_CREATESURFACEDATA>,), u32>;
pub type LPDDHAL_CREATESURFACEEX = StdCallFnPtr<(MutPtr<DDHAL_CREATESURFACEEXDATA>,), u32>;
pub type LPDDHAL_DESTROYDDLOCAL = StdCallFnPtr<(MutPtr<DDHAL_DESTROYDDLOCALDATA>,), u32>;
pub type LPDDHAL_DESTROYDRIVER = StdCallFnPtr<(MutPtr<DDHAL_DESTROYDRIVERDATA>,), u32>;
pub type LPDDHAL_FLIPTOGDISURFACE = StdCallFnPtr<(MutPtr<DDHAL_FLIPTOGDISURFACEDATA>,), u32>;
pub type LPDDHAL_GETAVAILDRIVERMEMORY =
    StdCallFnPtr<(MutPtr<DDHAL_GETAVAILDRIVERMEMORYDATA>,), u32>;
pub type LPDDHAL_GETDRIVERINFO = StdCallFnPtr<(MutPtr<DDHAL_GETDRIVERINFODATA>,), u32>;
pub type LPDDHAL_GETDRIVERSTATE = StdCallFnPtr<(MutPtr<DDHAL_GETDRIVERSTATEDATA>,), u32>;
pub type LPDDHAL_GETHEAPALIGNMENT = StdCallFnPtr<(MutPtr<DDHAL_GETHEAPALIGNMENTDATA>,), u32>;
pub type LPDDHAL_GETSCANLINE = StdCallFnPtr<(MutPtr<DDHAL_GETSCANLINEDATA>,), u32>;
pub type LPDDHAL_SETCOLORKEY = StdCallFnPtr<(MutPtr<DDHAL_DRVSETCOLORKEYDATA>,), u32>;
pub type LPDDHAL_SETEXCLUSIVEMODE = StdCallFnPtr<(MutPtr<DDHAL_SETEXCLUSIVEMODEDATA>,), u32>;
pub type LPDDHAL_SETINFO = StdCallFnPtr<
    (MutPtr<DDHALINFO>, super::super::Foundation::BOOL),
    super::super::Foundation::BOOL,
>;
pub type LPDDHAL_SETMODE = StdCallFnPtr<(MutPtr<DDHAL_SETMODEDATA>,), u32>;
pub type LPDDHAL_UPDATENONLOCALHEAP = StdCallFnPtr<(MutPtr<DDHAL_UPDATENONLOCALHEAPDATA>,), u32>;
pub type LPDDHAL_VIDMEMALLOC =
    StdCallFnPtr<(MutPtr<DDRAWI_DIRECTDRAW_GBL>, i32, u32, u32), PtrRepr>;
pub type LPDDHAL_VIDMEMFREE = StdCallFnPtr<(MutPtr<DDRAWI_DIRECTDRAW_GBL>, i32, PtrRepr), ()>;
pub type LPDDHAL_WAITFORVERTICALBLANK =
    StdCallFnPtr<(MutPtr<DDHAL_WAITFORVERTICALBLANKDATA>,), u32>;
pub type LPDDHEL_INIT = StdCallFnPtr<
    (
        MutPtr<DDRAWI_DIRECTDRAW_GBL>,
        super::super::Foundation::BOOL,
    ),
    super::super::Foundation::BOOL,
>;
pub type LPDIRECTDRAWENUMERATEEXA =
    StdCallFnPtr<(LPDDENUMCALLBACKEXA, MutPtr<::core::ffi::c_void>, u32), crate::core::HRESULT>;
pub type LPDIRECTDRAWENUMERATEEXW =
    StdCallFnPtr<(LPDDENUMCALLBACKEXW, MutPtr<::core::ffi::c_void>, u32), crate::core::HRESULT>;
pub const MAX_AUTOFLIP_BUFFERS: u32 = 10u32;
pub const MAX_DDDEVICEID_STRING: u32 = 512u32;
pub const MAX_DRIVER_NAME: u32 = 32u32;
pub const MAX_PALETTE_SIZE: u32 = 256u32;
pub struct MDL {
    pub MdlNext: MutPtr<MDL>,
    pub MdlSize: i16,
    pub MdlFlags: i16,
    pub Process: MutPtr<MDL_0>,
    pub lpMappedSystemVa: MutPtr<u32>,
    pub lpStartVa: MutPtr<u32>,
    pub ByteCount: u32,
    pub ByteOffset: u32,
}
impl ::core::marker::Copy for MDL {}
impl ::core::clone::Clone for MDL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MDL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MDL")
            .field("MdlNext", &self.MdlNext)
            .field("MdlSize", &self.MdlSize)
            .field("MdlFlags", &self.MdlFlags)
            .field("Process", &self.Process)
            .field("lpMappedSystemVa", &self.lpMappedSystemVa)
            .field("lpStartVa", &self.lpStartVa)
            .field("ByteCount", &self.ByteCount)
            .field("ByteOffset", &self.ByteOffset)
            .finish()
    }
}
impl ::core::cmp::PartialEq for MDL {
    fn eq(&self, other: &Self) -> bool {
        self.MdlNext == other.MdlNext
            && self.MdlSize == other.MdlSize
            && self.MdlFlags == other.MdlFlags
            && self.Process == other.Process
            && self.lpMappedSystemVa == other.lpMappedSystemVa
            && self.lpStartVa == other.lpStartVa
            && self.ByteCount == other.ByteCount
            && self.ByteOffset == other.ByteOffset
    }
}
impl ::core::cmp::Eq for MDL {}
impl FromIntoMemory for MDL {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_MdlNext = <MutPtr<MDL> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_MdlSize = <i16 as FromIntoMemory>::from_bytes(&from[4..4 + 2]);
        let f_MdlFlags = <i16 as FromIntoMemory>::from_bytes(&from[6..6 + 2]);
        let f_Process = <MutPtr<MDL_0> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpMappedSystemVa = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpStartVa = <MutPtr<u32> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ByteCount = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_ByteOffset = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            MdlNext: f_MdlNext,
            MdlSize: f_MdlSize,
            MdlFlags: f_MdlFlags,
            Process: f_Process,
            lpMappedSystemVa: f_lpMappedSystemVa,
            lpStartVa: f_lpStartVa,
            ByteCount: f_ByteCount,
            ByteOffset: f_ByteOffset,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.MdlNext, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.MdlSize, &mut into[4..4 + 2]);
        FromIntoMemory::into_bytes(self.MdlFlags, &mut into[6..6 + 2]);
        FromIntoMemory::into_bytes(self.Process, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpMappedSystemVa, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpStartVa, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ByteCount, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.ByteOffset, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct MDL_0(pub u8);
pub const MDL_64_BIT_VA: u32 = 32768u32;
pub const MDL_ALLOCATED_FIXED_SIZE: u32 = 8u32;
pub const MDL_ALLOCATED_MUST_SUCCEED: u32 = 16384u32;
pub const MDL_IO_PAGE_READ: u32 = 64u32;
pub const MDL_IO_SPACE: u32 = 2048u32;
pub const MDL_LOCK_HELD: u32 = 512u32;
pub const MDL_MAPPED_TO_SYSTEM_VA: u32 = 1u32;
pub const MDL_MAPPING_CAN_FAIL: u32 = 8192u32;
pub const MDL_NETWORK_HEADER: u32 = 4096u32;
pub const MDL_PAGES_LOCKED: u32 = 2u32;
pub const MDL_PARENT_MAPPED_SYSTEM_VA: u32 = 256u32;
pub const MDL_PARTIAL: u32 = 16u32;
pub const MDL_PARTIAL_HAS_BEEN_MAPPED: u32 = 32u32;
pub const MDL_SCATTER_GATHER_VA: u32 = 1024u32;
pub const MDL_SOURCE_IS_NONPAGED_POOL: u32 = 4u32;
pub const MDL_WRITE_OPERATION: u32 = 128u32;
pub const OBJECT_ISROOT: i32 = -2147483648i32;
pub type PDD_ALPHABLT = StdCallFnPtr<(MutPtr<DD_BLTDATA>,), u32>;
pub type PDD_CANCREATESURFACE = StdCallFnPtr<(MutPtr<DD_CANCREATESURFACEDATA>,), u32>;
pub type PDD_COLORCB_COLORCONTROL = StdCallFnPtr<(MutPtr<DD_COLORCONTROLDATA>,), u32>;
pub type PDD_CREATEPALETTE = StdCallFnPtr<(MutPtr<DD_CREATEPALETTEDATA>,), u32>;
pub type PDD_CREATESURFACE = StdCallFnPtr<(MutPtr<DD_CREATESURFACEDATA>,), u32>;
pub type PDD_CREATESURFACEEX = StdCallFnPtr<(MutPtr<DD_CREATESURFACEEXDATA>,), u32>;
pub type PDD_DESTROYDDLOCAL = StdCallFnPtr<(MutPtr<DD_DESTROYDDLOCALDATA>,), u32>;
pub type PDD_DESTROYDRIVER = StdCallFnPtr<(MutPtr<_DD_DESTROYDRIVERDATA>,), u32>;
pub type PDD_FLIPTOGDISURFACE = StdCallFnPtr<(MutPtr<DD_FLIPTOGDISURFACEDATA>,), u32>;
pub type PDD_FREEDRIVERMEMORY = StdCallFnPtr<(MutPtr<DD_FREEDRIVERMEMORYDATA>,), u32>;
pub type PDD_GETAVAILDRIVERMEMORY = StdCallFnPtr<(MutPtr<DD_GETAVAILDRIVERMEMORYDATA>,), u32>;
pub type PDD_GETDRIVERINFO = StdCallFnPtr<(MutPtr<DD_GETDRIVERINFODATA>,), u32>;
pub type PDD_GETDRIVERSTATE = StdCallFnPtr<(MutPtr<DD_GETDRIVERSTATEDATA>,), u32>;
pub type PDD_GETSCANLINE = StdCallFnPtr<(MutPtr<DD_GETSCANLINEDATA>,), u32>;
pub type PDD_KERNELCB_SYNCSURFACE = StdCallFnPtr<(MutPtr<DD_SYNCSURFACEDATA>,), u32>;
pub type PDD_KERNELCB_SYNCVIDEOPORT = StdCallFnPtr<(MutPtr<DD_SYNCVIDEOPORTDATA>,), u32>;
pub type PDD_MAPMEMORY = StdCallFnPtr<(MutPtr<DD_MAPMEMORYDATA>,), u32>;
pub type PDD_MOCOMPCB_BEGINFRAME = StdCallFnPtr<(MutPtr<DD_BEGINMOCOMPFRAMEDATA>,), u32>;
pub type PDD_MOCOMPCB_CREATE = StdCallFnPtr<(MutPtr<DD_CREATEMOCOMPDATA>,), u32>;
pub type PDD_MOCOMPCB_DESTROY = StdCallFnPtr<(MutPtr<DD_DESTROYMOCOMPDATA>,), u32>;
pub type PDD_MOCOMPCB_ENDFRAME = StdCallFnPtr<(MutPtr<DD_ENDMOCOMPFRAMEDATA>,), u32>;
pub type PDD_MOCOMPCB_GETCOMPBUFFINFO = StdCallFnPtr<(MutPtr<DD_GETMOCOMPCOMPBUFFDATA>,), u32>;
pub type PDD_MOCOMPCB_GETFORMATS = StdCallFnPtr<(MutPtr<DD_GETMOCOMPFORMATSDATA>,), u32>;
pub type PDD_MOCOMPCB_GETGUIDS = StdCallFnPtr<(MutPtr<DD_GETMOCOMPGUIDSDATA>,), u32>;
pub type PDD_MOCOMPCB_GETINTERNALINFO = StdCallFnPtr<(MutPtr<DD_GETINTERNALMOCOMPDATA>,), u32>;
pub type PDD_MOCOMPCB_QUERYSTATUS = StdCallFnPtr<(MutPtr<DD_QUERYMOCOMPSTATUSDATA>,), u32>;
pub type PDD_MOCOMPCB_RENDER = StdCallFnPtr<(MutPtr<DD_RENDERMOCOMPDATA>,), u32>;
pub type PDD_PALCB_DESTROYPALETTE = StdCallFnPtr<(MutPtr<DD_DESTROYPALETTEDATA>,), u32>;
pub type PDD_PALCB_SETENTRIES = StdCallFnPtr<(MutPtr<DD_SETENTRIESDATA>,), u32>;
pub type PDD_SETCOLORKEY = StdCallFnPtr<(MutPtr<DD_DRVSETCOLORKEYDATA>,), u32>;
pub type PDD_SETEXCLUSIVEMODE = StdCallFnPtr<(MutPtr<DD_SETEXCLUSIVEMODEDATA>,), u32>;
pub type PDD_SETMODE = StdCallFnPtr<(MutPtr<_DD_SETMODEDATA>,), u32>;
pub type PDD_SURFCB_ADDATTACHEDSURFACE = StdCallFnPtr<(MutPtr<DD_ADDATTACHEDSURFACEDATA>,), u32>;
pub type PDD_SURFCB_BLT = StdCallFnPtr<(MutPtr<DD_BLTDATA>,), u32>;
pub type PDD_SURFCB_DESTROYSURFACE = StdCallFnPtr<(MutPtr<DD_DESTROYSURFACEDATA>,), u32>;
pub type PDD_SURFCB_FLIP = StdCallFnPtr<(MutPtr<DD_FLIPDATA>,), u32>;
pub type PDD_SURFCB_GETBLTSTATUS = StdCallFnPtr<(MutPtr<DD_GETBLTSTATUSDATA>,), u32>;
pub type PDD_SURFCB_GETFLIPSTATUS = StdCallFnPtr<(MutPtr<DD_GETFLIPSTATUSDATA>,), u32>;
pub type PDD_SURFCB_LOCK = StdCallFnPtr<(MutPtr<DD_LOCKDATA>,), u32>;
pub type PDD_SURFCB_SETCLIPLIST = StdCallFnPtr<(MutPtr<DD_SETCLIPLISTDATA>,), u32>;
pub type PDD_SURFCB_SETCOLORKEY = StdCallFnPtr<(MutPtr<DD_SETCOLORKEYDATA>,), u32>;
pub type PDD_SURFCB_SETOVERLAYPOSITION = StdCallFnPtr<(MutPtr<DD_SETOVERLAYPOSITIONDATA>,), u32>;
pub type PDD_SURFCB_SETPALETTE = StdCallFnPtr<(MutPtr<DD_SETPALETTEDATA>,), u32>;
pub type PDD_SURFCB_UNLOCK = StdCallFnPtr<(MutPtr<DD_UNLOCKDATA>,), u32>;
pub type PDD_SURFCB_UPDATEOVERLAY = StdCallFnPtr<(MutPtr<DD_UPDATEOVERLAYDATA>,), u32>;
pub type PDD_VPORTCB_CANCREATEVIDEOPORT = StdCallFnPtr<(MutPtr<DD_CANCREATEVPORTDATA>,), u32>;
pub type PDD_VPORTCB_COLORCONTROL = StdCallFnPtr<(MutPtr<DD_VPORTCOLORDATA>,), u32>;
pub type PDD_VPORTCB_CREATEVIDEOPORT = StdCallFnPtr<(MutPtr<DD_CREATEVPORTDATA>,), u32>;
pub type PDD_VPORTCB_DESTROYVPORT = StdCallFnPtr<(MutPtr<DD_DESTROYVPORTDATA>,), u32>;
pub type PDD_VPORTCB_FLIP = StdCallFnPtr<(MutPtr<DD_FLIPVPORTDATA>,), u32>;
pub type PDD_VPORTCB_GETAUTOFLIPSURF =
    StdCallFnPtr<(MutPtr<_DD_GETVPORTAUTOFLIPSURFACEDATA>,), u32>;
pub type PDD_VPORTCB_GETBANDWIDTH = StdCallFnPtr<(MutPtr<DD_GETVPORTBANDWIDTHDATA>,), u32>;
pub type PDD_VPORTCB_GETFIELD = StdCallFnPtr<(MutPtr<DD_GETVPORTFIELDDATA>,), u32>;
pub type PDD_VPORTCB_GETFLIPSTATUS = StdCallFnPtr<(MutPtr<DD_GETVPORTFLIPSTATUSDATA>,), u32>;
pub type PDD_VPORTCB_GETINPUTFORMATS = StdCallFnPtr<(MutPtr<DD_GETVPORTINPUTFORMATDATA>,), u32>;
pub type PDD_VPORTCB_GETLINE = StdCallFnPtr<(MutPtr<DD_GETVPORTLINEDATA>,), u32>;
pub type PDD_VPORTCB_GETOUTPUTFORMATS = StdCallFnPtr<(MutPtr<DD_GETVPORTOUTPUTFORMATDATA>,), u32>;
pub type PDD_VPORTCB_GETSIGNALSTATUS = StdCallFnPtr<(MutPtr<DD_GETVPORTSIGNALDATA>,), u32>;
pub type PDD_VPORTCB_GETVPORTCONNECT = StdCallFnPtr<(MutPtr<DD_GETVPORTCONNECTDATA>,), u32>;
pub type PDD_VPORTCB_UPDATE = StdCallFnPtr<(MutPtr<DD_UPDATEVPORTDATA>,), u32>;
pub type PDD_VPORTCB_WAITFORSYNC = StdCallFnPtr<(MutPtr<DD_WAITFORVPORTSYNCDATA>,), u32>;
pub type PDD_WAITFORVERTICALBLANK = StdCallFnPtr<(MutPtr<DD_WAITFORVERTICALBLANKDATA>,), u32>;
pub type PDX_BOBNEXTFIELD = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDBOBNEXTFIELDINFO>,
        MutPtr<::core::ffi::c_void>,
    ),
    u32,
>;
pub type PDX_ENABLEIRQ = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDENABLEIRQINFO>,
        MutPtr<::core::ffi::c_void>,
    ),
    u32,
>;
pub type PDX_FLIPOVERLAY = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDFLIPOVERLAYINFO>,
        MutPtr<::core::ffi::c_void>,
    ),
    u32,
>;
pub type PDX_FLIPVIDEOPORT = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDFLIPVIDEOPORTINFO>,
        MutPtr<::core::ffi::c_void>,
    ),
    u32,
>;
pub type PDX_GETCURRENTAUTOFLIP = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDGETCURRENTAUTOFLIPININFO>,
        MutPtr<DDGETCURRENTAUTOFLIPOUTINFO>,
    ),
    u32,
>;
pub type PDX_GETIRQINFO = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDGETIRQINFO>,
    ),
    u32,
>;
pub type PDX_GETPOLARITY = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDGETPOLARITYININFO>,
        MutPtr<DDGETPOLARITYOUTINFO>,
    ),
    u32,
>;
pub type PDX_GETPREVIOUSAUTOFLIP = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDGETPREVIOUSAUTOFLIPININFO>,
        MutPtr<DDGETPREVIOUSAUTOFLIPOUTINFO>,
    ),
    u32,
>;
pub type PDX_GETTRANSFERSTATUS = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDGETTRANSFERSTATUSOUTINFO>,
    ),
    u32,
>;
pub type PDX_IRQCALLBACK = StdCallFnPtr<(MutPtr<DX_IRQDATA>,), ()>;
pub type PDX_LOCK = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDLOCKININFO>,
        MutPtr<DDLOCKOUTINFO>,
    ),
    u32,
>;
pub type PDX_SETSTATE = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDSETSTATEININFO>,
        MutPtr<DDSETSTATEOUTINFO>,
    ),
    u32,
>;
pub type PDX_SKIPNEXTFIELD = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDSKIPNEXTFIELDINFO>,
        MutPtr<::core::ffi::c_void>,
    ),
    u32,
>;
pub type PDX_TRANSFER = StdCallFnPtr<
    (
        MutPtr<::core::ffi::c_void>,
        MutPtr<DDTRANSFERININFO>,
        MutPtr<DDTRANSFEROUTINFO>,
    ),
    u32,
>;
pub const PFINDEX_UNINITIALIZED: u32 = 0u32;
pub struct PROCESS_LIST {
    pub lpLink: MutPtr<PROCESS_LIST>,
    pub dwProcessId: u32,
    pub dwRefCnt: u32,
    pub dwAlphaDepth: u32,
    pub dwZDepth: u32,
}
impl ::core::marker::Copy for PROCESS_LIST {}
impl ::core::clone::Clone for PROCESS_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PROCESS_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PROCESS_LIST")
            .field("lpLink", &self.lpLink)
            .field("dwProcessId", &self.dwProcessId)
            .field("dwRefCnt", &self.dwRefCnt)
            .field("dwAlphaDepth", &self.dwAlphaDepth)
            .field("dwZDepth", &self.dwZDepth)
            .finish()
    }
}
impl ::core::cmp::PartialEq for PROCESS_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.lpLink == other.lpLink
            && self.dwProcessId == other.dwProcessId
            && self.dwRefCnt == other.dwRefCnt
            && self.dwAlphaDepth == other.dwAlphaDepth
            && self.dwZDepth == other.dwZDepth
    }
}
impl ::core::cmp::Eq for PROCESS_LIST {}
impl FromIntoMemory for PROCESS_LIST {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpLink = <MutPtr<PROCESS_LIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwProcessId = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwRefCnt = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwAlphaDepth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwZDepth = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpLink: f_lpLink,
            dwProcessId: f_dwProcessId,
            dwRefCnt: f_dwRefCnt,
            dwAlphaDepth: f_dwAlphaDepth,
            dwZDepth: f_dwZDepth,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpLink, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessId, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwRefCnt, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaDepth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwZDepth, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub const REGSTR_KEY_DDHW_DESCRIPTION: &'static str = "Description";
pub const REGSTR_KEY_DDHW_DRIVERNAME: &'static str = "DriverName";
pub const REGSTR_PATH_DDHW: &'static str = "Hardware\\DirectDrawDrivers";
pub const ROP_HAS_PATTERN: i32 = 2i32;
pub const ROP_HAS_SOURCE: i32 = 1i32;
pub struct SURFACEALIGNMENT {
    pub Anonymous: SURFACEALIGNMENT_0,
}
impl ::core::marker::Copy for SURFACEALIGNMENT {}
impl ::core::clone::Clone for SURFACEALIGNMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for SURFACEALIGNMENT {
    fn eq(&self, other: &Self) -> bool {
        self.Anonymous == other.Anonymous
    }
}
impl ::core::cmp::Eq for SURFACEALIGNMENT {}
impl FromIntoMemory for SURFACEALIGNMENT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_Anonymous = <SURFACEALIGNMENT_0 as FromIntoMemory>::from_bytes(&from[0..0 + 16]);
        Self {
            Anonymous: f_Anonymous,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[0..0 + 16]);
    }
    fn size() -> usize {
        16
    }
}
pub struct SURFACEALIGNMENT_0 {
    data: [u8; 16],
}
impl ::core::marker::Copy for SURFACEALIGNMENT_0 {}
impl ::core::clone::Clone for SURFACEALIGNMENT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for SURFACEALIGNMENT_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for SURFACEALIGNMENT_0 {}
impl FromIntoMemory for SURFACEALIGNMENT_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 16];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        16
    }
}
pub struct SURFACEALIGNMENT_0_0 {
    pub dwStartAlignment: u32,
    pub dwPitchAlignment: u32,
    pub dwFlags: u32,
    pub dwReserved2: u32,
}
impl ::core::marker::Copy for SURFACEALIGNMENT_0_0 {}
impl ::core::clone::Clone for SURFACEALIGNMENT_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SURFACEALIGNMENT_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SURFACEALIGNMENT_0_0")
            .field("dwStartAlignment", &self.dwStartAlignment)
            .field("dwPitchAlignment", &self.dwPitchAlignment)
            .field("dwFlags", &self.dwFlags)
            .field("dwReserved2", &self.dwReserved2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SURFACEALIGNMENT_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.dwStartAlignment == other.dwStartAlignment
            && self.dwPitchAlignment == other.dwPitchAlignment
            && self.dwFlags == other.dwFlags
            && self.dwReserved2 == other.dwReserved2
    }
}
impl ::core::cmp::Eq for SURFACEALIGNMENT_0_0 {}
impl FromIntoMemory for SURFACEALIGNMENT_0_0 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwStartAlignment = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwPitchAlignment = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwStartAlignment: f_dwStartAlignment,
            dwPitchAlignment: f_dwPitchAlignment,
            dwFlags: f_dwFlags,
            dwReserved2: f_dwReserved2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwStartAlignment, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwPitchAlignment, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct SURFACEALIGNMENT_0_1 {
    pub dwXAlignment: u32,
    pub dwYAlignment: u32,
    pub dwFlags: u32,
    pub dwReserved2: u32,
}
impl ::core::marker::Copy for SURFACEALIGNMENT_0_1 {}
impl ::core::clone::Clone for SURFACEALIGNMENT_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SURFACEALIGNMENT_0_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SURFACEALIGNMENT_0_1")
            .field("dwXAlignment", &self.dwXAlignment)
            .field("dwYAlignment", &self.dwYAlignment)
            .field("dwFlags", &self.dwFlags)
            .field("dwReserved2", &self.dwReserved2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SURFACEALIGNMENT_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.dwXAlignment == other.dwXAlignment
            && self.dwYAlignment == other.dwYAlignment
            && self.dwFlags == other.dwFlags
            && self.dwReserved2 == other.dwReserved2
    }
}
impl ::core::cmp::Eq for SURFACEALIGNMENT_0_1 {}
impl FromIntoMemory for SURFACEALIGNMENT_0_1 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwXAlignment = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwYAlignment = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwReserved2 = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwXAlignment: f_dwXAlignment,
            dwYAlignment: f_dwYAlignment,
            dwFlags: f_dwFlags,
            dwReserved2: f_dwReserved2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwXAlignment, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwYAlignment, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved2, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const SURFACEALIGN_DISCARDABLE: i32 = 1i32;
pub struct VIDEOMEMORY {
    pub dwFlags: u32,
    pub fpStart: PtrRepr,
    pub Anonymous1: VIDEOMEMORY_0,
    pub ddsCaps: DDSCAPS,
    pub ddsCapsAlt: DDSCAPS,
    pub Anonymous2: VIDEOMEMORY_1,
}
impl ::core::marker::Copy for VIDEOMEMORY {}
impl ::core::clone::Clone for VIDEOMEMORY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDEOMEMORY {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.fpStart == other.fpStart
            && self.Anonymous1 == other.Anonymous1
            && self.ddsCaps == other.ddsCaps
            && self.ddsCapsAlt == other.ddsCapsAlt
            && self.Anonymous2 == other.Anonymous2
    }
}
impl ::core::cmp::Eq for VIDEOMEMORY {}
impl FromIntoMemory for VIDEOMEMORY {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fpStart = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_Anonymous1 = <VIDEOMEMORY_0 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddsCapsAlt = <DDSCAPS as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Anonymous2 = <VIDEOMEMORY_1 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwFlags: f_dwFlags,
            fpStart: f_fpStart,
            Anonymous1: f_Anonymous1,
            ddsCaps: f_ddsCaps,
            ddsCapsAlt: f_ddsCapsAlt,
            Anonymous2: f_Anonymous2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fpStart, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsAlt, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct VIDEOMEMORY_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for VIDEOMEMORY_0 {}
impl ::core::clone::Clone for VIDEOMEMORY_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDEOMEMORY_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for VIDEOMEMORY_0 {}
impl FromIntoMemory for VIDEOMEMORY_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct VIDEOMEMORY_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for VIDEOMEMORY_1 {}
impl ::core::clone::Clone for VIDEOMEMORY_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDEOMEMORY_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for VIDEOMEMORY_1 {}
impl FromIntoMemory for VIDEOMEMORY_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct VIDEOMEMORYINFO {
    pub fpPrimary: PtrRepr,
    pub dwFlags: u32,
    pub dwDisplayWidth: u32,
    pub dwDisplayHeight: u32,
    pub lDisplayPitch: i32,
    pub ddpfDisplay: DDPIXELFORMAT,
    pub dwOffscreenAlign: u32,
    pub dwOverlayAlign: u32,
    pub dwTextureAlign: u32,
    pub dwZBufferAlign: u32,
    pub dwAlphaAlign: u32,
    pub pvPrimary: MutPtr<::core::ffi::c_void>,
}
impl ::core::marker::Copy for VIDEOMEMORYINFO {}
impl ::core::clone::Clone for VIDEOMEMORYINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDEOMEMORYINFO {
    fn eq(&self, other: &Self) -> bool {
        self.fpPrimary == other.fpPrimary
            && self.dwFlags == other.dwFlags
            && self.dwDisplayWidth == other.dwDisplayWidth
            && self.dwDisplayHeight == other.dwDisplayHeight
            && self.lDisplayPitch == other.lDisplayPitch
            && self.ddpfDisplay == other.ddpfDisplay
            && self.dwOffscreenAlign == other.dwOffscreenAlign
            && self.dwOverlayAlign == other.dwOverlayAlign
            && self.dwTextureAlign == other.dwTextureAlign
            && self.dwZBufferAlign == other.dwZBufferAlign
            && self.dwAlphaAlign == other.dwAlphaAlign
            && self.pvPrimary == other.pvPrimary
    }
}
impl ::core::cmp::Eq for VIDEOMEMORYINFO {}
impl FromIntoMemory for VIDEOMEMORYINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 76);
        let f_fpPrimary = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwDisplayWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwDisplayHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lDisplayPitch = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddpfDisplay = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[20..20 + 32]);
        let f_dwOffscreenAlign = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwOverlayAlign = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwTextureAlign = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwZBufferAlign = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwAlphaAlign = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_pvPrimary =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        Self {
            fpPrimary: f_fpPrimary,
            dwFlags: f_dwFlags,
            dwDisplayWidth: f_dwDisplayWidth,
            dwDisplayHeight: f_dwDisplayHeight,
            lDisplayPitch: f_lDisplayPitch,
            ddpfDisplay: f_ddpfDisplay,
            dwOffscreenAlign: f_dwOffscreenAlign,
            dwOverlayAlign: f_dwOverlayAlign,
            dwTextureAlign: f_dwTextureAlign,
            dwZBufferAlign: f_dwZBufferAlign,
            dwAlphaAlign: f_dwAlphaAlign,
            pvPrimary: f_pvPrimary,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 76);
        FromIntoMemory::into_bytes(self.fpPrimary, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwDisplayWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwDisplayHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lDisplayPitch, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddpfDisplay, &mut into[20..20 + 32]);
        FromIntoMemory::into_bytes(self.dwOffscreenAlign, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayAlign, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwTextureAlign, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferAlign, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaAlign, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.pvPrimary, &mut into[72..72 + 4]);
    }
    fn size() -> usize {
        76
    }
}
pub struct VIDMEM {
    pub dwFlags: u32,
    pub fpStart: PtrRepr,
    pub Anonymous1: VIDMEM_0,
    pub ddsCaps: DDSCAPS,
    pub ddsCapsAlt: DDSCAPS,
    pub Anonymous2: VIDMEM_1,
}
impl ::core::marker::Copy for VIDMEM {}
impl ::core::clone::Clone for VIDMEM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDMEM {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.fpStart == other.fpStart
            && self.Anonymous1 == other.Anonymous1
            && self.ddsCaps == other.ddsCaps
            && self.ddsCapsAlt == other.ddsCapsAlt
            && self.Anonymous2 == other.Anonymous2
    }
}
impl ::core::cmp::Eq for VIDMEM {}
impl FromIntoMemory for VIDMEM {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fpStart = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_Anonymous1 = <VIDMEM_0 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ddsCaps = <DDSCAPS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ddsCapsAlt = <DDSCAPS as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_Anonymous2 = <VIDMEM_1 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwFlags: f_dwFlags,
            fpStart: f_fpStart,
            Anonymous1: f_Anonymous1,
            ddsCaps: f_ddsCaps,
            ddsCapsAlt: f_ddsCapsAlt,
            Anonymous2: f_Anonymous2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fpStart, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous1, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ddsCaps, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ddsCapsAlt, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous2, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct VIDMEM_0 {
    data: [u8; 4],
}
impl ::core::marker::Copy for VIDMEM_0 {}
impl ::core::clone::Clone for VIDMEM_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDMEM_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for VIDMEM_0 {}
impl FromIntoMemory for VIDMEM_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct VIDMEM_1 {
    data: [u8; 4],
}
impl ::core::marker::Copy for VIDMEM_1 {}
impl ::core::clone::Clone for VIDMEM_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDMEM_1 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for VIDMEM_1 {}
impl FromIntoMemory for VIDMEM_1 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        todo!()
    }
    fn size() -> usize {
        4
    }
}
pub struct VIDMEMINFO {
    pub fpPrimary: PtrRepr,
    pub dwFlags: u32,
    pub dwDisplayWidth: u32,
    pub dwDisplayHeight: u32,
    pub lDisplayPitch: i32,
    pub ddpfDisplay: DDPIXELFORMAT,
    pub dwOffscreenAlign: u32,
    pub dwOverlayAlign: u32,
    pub dwTextureAlign: u32,
    pub dwZBufferAlign: u32,
    pub dwAlphaAlign: u32,
    pub dwNumHeaps: u32,
    pub pvmList: MutPtr<VIDMEM>,
}
impl ::core::marker::Copy for VIDMEMINFO {}
impl ::core::clone::Clone for VIDMEMINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VIDMEMINFO {
    fn eq(&self, other: &Self) -> bool {
        self.fpPrimary == other.fpPrimary
            && self.dwFlags == other.dwFlags
            && self.dwDisplayWidth == other.dwDisplayWidth
            && self.dwDisplayHeight == other.dwDisplayHeight
            && self.lDisplayPitch == other.lDisplayPitch
            && self.ddpfDisplay == other.ddpfDisplay
            && self.dwOffscreenAlign == other.dwOffscreenAlign
            && self.dwOverlayAlign == other.dwOverlayAlign
            && self.dwTextureAlign == other.dwTextureAlign
            && self.dwZBufferAlign == other.dwZBufferAlign
            && self.dwAlphaAlign == other.dwAlphaAlign
            && self.dwNumHeaps == other.dwNumHeaps
            && self.pvmList == other.pvmList
    }
}
impl ::core::cmp::Eq for VIDMEMINFO {}
impl FromIntoMemory for VIDMEMINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 80);
        let f_fpPrimary = <PtrRepr as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwDisplayWidth = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwDisplayHeight = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lDisplayPitch = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_ddpfDisplay = <DDPIXELFORMAT as FromIntoMemory>::from_bytes(&from[20..20 + 32]);
        let f_dwOffscreenAlign = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_dwOverlayAlign = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_dwTextureAlign = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_dwZBufferAlign = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_dwAlphaAlign = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_dwNumHeaps = <u32 as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_pvmList = <MutPtr<VIDMEM> as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        Self {
            fpPrimary: f_fpPrimary,
            dwFlags: f_dwFlags,
            dwDisplayWidth: f_dwDisplayWidth,
            dwDisplayHeight: f_dwDisplayHeight,
            lDisplayPitch: f_lDisplayPitch,
            ddpfDisplay: f_ddpfDisplay,
            dwOffscreenAlign: f_dwOffscreenAlign,
            dwOverlayAlign: f_dwOverlayAlign,
            dwTextureAlign: f_dwTextureAlign,
            dwZBufferAlign: f_dwZBufferAlign,
            dwAlphaAlign: f_dwAlphaAlign,
            dwNumHeaps: f_dwNumHeaps,
            pvmList: f_pvmList,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 80);
        FromIntoMemory::into_bytes(self.fpPrimary, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwDisplayWidth, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwDisplayHeight, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lDisplayPitch, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.ddpfDisplay, &mut into[20..20 + 32]);
        FromIntoMemory::into_bytes(self.dwOffscreenAlign, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.dwOverlayAlign, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.dwTextureAlign, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.dwZBufferAlign, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.dwAlphaAlign, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.dwNumHeaps, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.pvmList, &mut into[76..76 + 4]);
    }
    fn size() -> usize {
        80
    }
}
pub const VIDMEM_HEAPDISABLED: i32 = 32i32;
pub const VIDMEM_ISHEAP: i32 = 4i32;
pub const VIDMEM_ISLINEAR: i32 = 1i32;
pub const VIDMEM_ISNONLOCAL: i32 = 8i32;
pub const VIDMEM_ISRECTANGULAR: i32 = 2i32;
pub const VIDMEM_ISWC: i32 = 16i32;
pub struct VMEMHEAP {
    pub dwFlags: u32,
    pub stride: u32,
    pub freeList: MutPtr<::core::ffi::c_void>,
    pub allocList: MutPtr<::core::ffi::c_void>,
    pub dwTotalSize: u32,
    pub fpGARTLin: PtrRepr,
    pub fpGARTDev: PtrRepr,
    pub dwCommitedSize: u32,
    pub dwCoalesceCount: u32,
    pub Alignment: HEAPALIGNMENT,
    pub ddsCapsEx: DDSCAPSEX,
    pub ddsCapsExAlt: DDSCAPSEX,
    pub liPhysAGPBase: i64,
    pub hdevAGP: super::super::Foundation::HANDLE,
    pub pvPhysRsrv: MutPtr<::core::ffi::c_void>,
    pub pAgpCommitMask: MutPtr<u8>,
    pub dwAgpCommitMaskSize: u32,
}
impl ::core::marker::Copy for VMEMHEAP {}
impl ::core::clone::Clone for VMEMHEAP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::cmp::PartialEq for VMEMHEAP {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.stride == other.stride
            && self.freeList == other.freeList
            && self.allocList == other.allocList
            && self.dwTotalSize == other.dwTotalSize
            && self.fpGARTLin == other.fpGARTLin
            && self.fpGARTDev == other.fpGARTDev
            && self.dwCommitedSize == other.dwCommitedSize
            && self.dwCoalesceCount == other.dwCoalesceCount
            && self.Alignment == other.Alignment
            && self.ddsCapsEx == other.ddsCapsEx
            && self.ddsCapsExAlt == other.ddsCapsExAlt
            && self.liPhysAGPBase == other.liPhysAGPBase
            && self.hdevAGP == other.hdevAGP
            && self.pvPhysRsrv == other.pvPhysRsrv
            && self.pAgpCommitMask == other.pAgpCommitMask
            && self.dwAgpCommitMaskSize == other.dwAgpCommitMaskSize
    }
}
impl ::core::cmp::Eq for VMEMHEAP {}
impl FromIntoMemory for VMEMHEAP {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 208);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_stride = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_freeList =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_allocList =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwTotalSize = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_fpGARTLin = <PtrRepr as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_fpGARTDev = <PtrRepr as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwCommitedSize = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwCoalesceCount = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_Alignment = <HEAPALIGNMENT as FromIntoMemory>::from_bytes(&from[36..36 + 124]);
        let f_ddsCapsEx = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[160..160 + 12]);
        let f_ddsCapsExAlt = <DDSCAPSEX as FromIntoMemory>::from_bytes(&from[172..172 + 12]);
        let f_liPhysAGPBase = <i64 as FromIntoMemory>::from_bytes(&from[184..184 + 8]);
        let f_hdevAGP =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[192..192 + 4]);
        let f_pvPhysRsrv =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[196..196 + 4]);
        let f_pAgpCommitMask = <MutPtr<u8> as FromIntoMemory>::from_bytes(&from[200..200 + 4]);
        let f_dwAgpCommitMaskSize = <u32 as FromIntoMemory>::from_bytes(&from[204..204 + 4]);
        Self {
            dwFlags: f_dwFlags,
            stride: f_stride,
            freeList: f_freeList,
            allocList: f_allocList,
            dwTotalSize: f_dwTotalSize,
            fpGARTLin: f_fpGARTLin,
            fpGARTDev: f_fpGARTDev,
            dwCommitedSize: f_dwCommitedSize,
            dwCoalesceCount: f_dwCoalesceCount,
            Alignment: f_Alignment,
            ddsCapsEx: f_ddsCapsEx,
            ddsCapsExAlt: f_ddsCapsExAlt,
            liPhysAGPBase: f_liPhysAGPBase,
            hdevAGP: f_hdevAGP,
            pvPhysRsrv: f_pvPhysRsrv,
            pAgpCommitMask: f_pAgpCommitMask,
            dwAgpCommitMaskSize: f_dwAgpCommitMaskSize,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 208);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.stride, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.freeList, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.allocList, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwTotalSize, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.fpGARTLin, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.fpGARTDev, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwCommitedSize, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwCoalesceCount, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.Alignment, &mut into[36..36 + 124]);
        FromIntoMemory::into_bytes(self.ddsCapsEx, &mut into[160..160 + 12]);
        FromIntoMemory::into_bytes(self.ddsCapsExAlt, &mut into[172..172 + 12]);
        FromIntoMemory::into_bytes(self.liPhysAGPBase, &mut into[184..184 + 8]);
        FromIntoMemory::into_bytes(self.hdevAGP, &mut into[192..192 + 4]);
        FromIntoMemory::into_bytes(self.pvPhysRsrv, &mut into[196..196 + 4]);
        FromIntoMemory::into_bytes(self.pAgpCommitMask, &mut into[200..200 + 4]);
        FromIntoMemory::into_bytes(self.dwAgpCommitMaskSize, &mut into[204..204 + 4]);
    }
    fn size() -> usize {
        208
    }
}
pub const VMEMHEAP_ALIGNMENT: i32 = 4i32;
pub const VMEMHEAP_LINEAR: i32 = 1i32;
pub const VMEMHEAP_RECTANGULAR: i32 = 2i32;
pub struct VMEML {
    pub next: MutPtr<VMEML>,
    pub ptr: PtrRepr,
    pub size: u32,
    pub bDiscardable: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for VMEML {}
impl ::core::clone::Clone for VMEML {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VMEML {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMEML")
            .field("next", &self.next)
            .field("ptr", &self.ptr)
            .field("size", &self.size)
            .field("bDiscardable", &self.bDiscardable)
            .finish()
    }
}
impl ::core::cmp::PartialEq for VMEML {
    fn eq(&self, other: &Self) -> bool {
        self.next == other.next
            && self.ptr == other.ptr
            && self.size == other.size
            && self.bDiscardable == other.bDiscardable
    }
}
impl ::core::cmp::Eq for VMEML {}
impl FromIntoMemory for VMEML {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_next = <MutPtr<VMEML> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ptr = <PtrRepr as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_size = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_bDiscardable =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            next: f_next,
            ptr: f_ptr,
            size: f_size,
            bDiscardable: f_bDiscardable,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.next, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ptr, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.size, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.bDiscardable, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct VMEMR {
    pub next: MutPtr<VMEMR>,
    pub prev: MutPtr<VMEMR>,
    pub pUp: MutPtr<VMEMR>,
    pub pDown: MutPtr<VMEMR>,
    pub pLeft: MutPtr<VMEMR>,
    pub pRight: MutPtr<VMEMR>,
    pub ptr: PtrRepr,
    pub size: u32,
    pub x: u32,
    pub y: u32,
    pub cx: u32,
    pub cy: u32,
    pub flags: u32,
    pub pBits: PtrRepr,
    pub bDiscardable: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for VMEMR {}
impl ::core::clone::Clone for VMEMR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VMEMR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VMEMR")
            .field("next", &self.next)
            .field("prev", &self.prev)
            .field("pUp", &self.pUp)
            .field("pDown", &self.pDown)
            .field("pLeft", &self.pLeft)
            .field("pRight", &self.pRight)
            .field("ptr", &self.ptr)
            .field("size", &self.size)
            .field("x", &self.x)
            .field("y", &self.y)
            .field("cx", &self.cx)
            .field("cy", &self.cy)
            .field("flags", &self.flags)
            .field("pBits", &self.pBits)
            .field("bDiscardable", &self.bDiscardable)
            .finish()
    }
}
impl ::core::cmp::PartialEq for VMEMR {
    fn eq(&self, other: &Self) -> bool {
        self.next == other.next
            && self.prev == other.prev
            && self.pUp == other.pUp
            && self.pDown == other.pDown
            && self.pLeft == other.pLeft
            && self.pRight == other.pRight
            && self.ptr == other.ptr
            && self.size == other.size
            && self.x == other.x
            && self.y == other.y
            && self.cx == other.cx
            && self.cy == other.cy
            && self.flags == other.flags
            && self.pBits == other.pBits
            && self.bDiscardable == other.bDiscardable
    }
}
impl ::core::cmp::Eq for VMEMR {}
impl FromIntoMemory for VMEMR {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_next = <MutPtr<VMEMR> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_prev = <MutPtr<VMEMR> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pUp = <MutPtr<VMEMR> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pDown = <MutPtr<VMEMR> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pLeft = <MutPtr<VMEMR> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pRight = <MutPtr<VMEMR> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_ptr = <PtrRepr as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_size = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_x = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_y = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_cx = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_cy = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_flags = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_pBits = <PtrRepr as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_bDiscardable =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            next: f_next,
            prev: f_prev,
            pUp: f_pUp,
            pDown: f_pDown,
            pLeft: f_pLeft,
            pRight: f_pRight,
            ptr: f_ptr,
            size: f_size,
            x: f_x,
            y: f_y,
            cx: f_cx,
            cy: f_cy,
            flags: f_flags,
            pBits: f_pBits,
            bDiscardable: f_bDiscardable,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.next, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.prev, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pUp, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pDown, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pLeft, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pRight, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.ptr, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.size, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.x, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.y, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.cx, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.cy, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.flags, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.pBits, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.bDiscardable, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
pub struct _DDFXROP(pub u8);
pub struct _DD_DESTROYDRIVERDATA(pub u8);
pub struct _DD_GETVPORTAUTOFLIPSURFACEDATA(pub u8);
pub struct _DD_SETMODEDATA(pub u8);
pub const _FACDD: u32 = 2166u32;
pub struct DirectDraw_Repr {
    pub vtable_IDirectDraw: PtrRepr,
    pub implementation: *const dyn IDirectDraw_Trait,
}
impl FromIntoMemory for DirectDraw_Repr {
    fn from_bytes(from: &[u8]) -> Self {
        const IMPL_SIZE: usize = std::mem::size_of::<*const dyn IDirectDraw_Trait>();
        assert_eq!(from.len(), Self::size());
        let vtable_IDirectDraw =
            <PtrRepr as FromIntoMemory>::from_bytes(&from[0usize..0usize + 4usize]);
        let implementation = <[u8; IMPL_SIZE]>::from_bytes(&from[(1usize * 4usize)..]);
        let implementation = unsafe { std::mem::transmute(implementation) };
        Self {
            vtable_IDirectDraw,
            implementation,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        const IMPL_SIZE: usize = std::mem::size_of::<*const dyn IDirectDraw_Trait>();
        assert_eq!(into.len(), Self::size());
        FromIntoMemory::into_bytes(self.vtable_IDirectDraw, &mut into[0usize..0usize + 4usize]);
        let implementation: [u8; IMPL_SIZE] = unsafe { std::mem::transmute(self.implementation) };
        into[(1usize * 4usize)..].copy_from_slice(&implementation);
    }
    fn size() -> usize {
        1usize * 4usize + std::mem::size_of::<*const dyn IDirectDraw_Trait>()
    }
}
pub struct DirectDrawSurface_Repr {
    pub vtable_IDirectDrawSurface: PtrRepr,
    pub implementation: *const dyn IDirectDrawSurface_Trait,
}
impl FromIntoMemory for DirectDrawSurface_Repr {
    fn from_bytes(from: &[u8]) -> Self {
        const IMPL_SIZE: usize = std::mem::size_of::<*const dyn IDirectDrawSurface_Trait>();
        assert_eq!(from.len(), Self::size());
        let vtable_IDirectDrawSurface =
            <PtrRepr as FromIntoMemory>::from_bytes(&from[0usize..0usize + 4usize]);
        let implementation = <[u8; IMPL_SIZE]>::from_bytes(&from[(1usize * 4usize)..]);
        let implementation = unsafe { std::mem::transmute(implementation) };
        Self {
            vtable_IDirectDrawSurface,
            implementation,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        const IMPL_SIZE: usize = std::mem::size_of::<*const dyn IDirectDrawSurface_Trait>();
        assert_eq!(into.len(), Self::size());
        FromIntoMemory::into_bytes(
            self.vtable_IDirectDrawSurface,
            &mut into[0usize..0usize + 4usize],
        );
        let implementation: [u8; IMPL_SIZE] = unsafe { std::mem::transmute(self.implementation) };
        into[(1usize * 4usize)..].copy_from_slice(&implementation);
    }
    fn size() -> usize {
        1usize * 4usize + std::mem::size_of::<*const dyn IDirectDrawSurface_Trait>()
    }
}
pub trait Api {
    fn DirectDrawCreate(
        &self,
        lp_guid: MutPtr<crate::core::GUID>,
        lplp_dd: MutPtr<IDirectDraw>,
        p_unk_outer: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("DirectDrawCreate")
    }
    fn DirectDrawCreateClipper(
        &self,
        dw_flags: u32,
        lplp_dd_clipper: MutPtr<IDirectDrawClipper>,
        p_unk_outer: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("DirectDrawCreateClipper")
    }
    fn DirectDrawCreateEx(
        &self,
        lp_guid: MutPtr<crate::core::GUID>,
        lplp_dd: MutPtr<ConstPtr<::core::ffi::c_void>>,
        iid: ConstPtr<crate::core::GUID>,
        p_unk_outer: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("DirectDrawCreateEx")
    }
    fn DirectDrawEnumerateA(
        &self,
        lp_callback: LPDDENUMCALLBACKA,
        lp_context: MutPtr<::core::ffi::c_void>,
    ) -> crate::core::HRESULT {
        todo!("DirectDrawEnumerateA")
    }
    fn DirectDrawEnumerateExA(
        &self,
        lp_callback: LPDDENUMCALLBACKEXA,
        lp_context: MutPtr<::core::ffi::c_void>,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("DirectDrawEnumerateExA")
    }
    fn DirectDrawEnumerateExW(
        &self,
        lp_callback: LPDDENUMCALLBACKEXW,
        lp_context: MutPtr<::core::ffi::c_void>,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("DirectDrawEnumerateExW")
    }
    fn DirectDrawEnumerateW(
        &self,
        lp_callback: LPDDENUMCALLBACKW,
        lp_context: MutPtr<::core::ffi::c_void>,
    ) -> crate::core::HRESULT {
        todo!("DirectDrawEnumerateW")
    }
}
pub fn get_api(ctx: &crate::core::Win32Context) -> std::sync::Arc<dyn Api> {
    ctx.get::<dyn Api>()
}
