#![doc = r" do not edit! File auto-generated with win32-bindgen"]
#![allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clashing_extern_declarations,
    unused_assignments,
    clippy::all
)]
#[allow(unused)]
use win32::core::prelude::*;
pub struct AASHELLMENUFILENAME {
    pub cbTotal: i16,
    pub rgbReserved: [u8; 12],
    pub szFileName: [u16; 1],
}
impl ::core::marker::Copy for AASHELLMENUFILENAME {}
impl ::core::clone::Clone for AASHELLMENUFILENAME {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for AASHELLMENUFILENAME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AASHELLMENUFILENAME")
            .field("cbTotal", &self.cbTotal)
            .field("rgbReserved", &self.rgbReserved)
            .field("szFileName", &self.szFileName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for AASHELLMENUFILENAME {
    fn eq(&self, other: &Self) -> bool {
        self.cbTotal == other.cbTotal
            && self.rgbReserved == other.rgbReserved
            && self.szFileName == other.szFileName
    }
}
impl ::core::cmp::Eq for AASHELLMENUFILENAME {}
impl FromIntoMemory for AASHELLMENUFILENAME {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_cbTotal = <i16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_rgbReserved = <[u8; 12] as FromIntoMemory>::from_bytes(&from[2..2 + 12]);
        let f_szFileName = <[u16; 1] as FromIntoMemory>::from_bytes(&from[14..14 + 1]);
        Self {
            cbTotal: f_cbTotal,
            rgbReserved: f_rgbReserved,
            szFileName: f_szFileName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.cbTotal, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.rgbReserved, &mut into[2..2 + 12]);
        FromIntoMemory::into_bytes(self.szFileName, &mut into[14..14 + 1]);
    }
    fn size() -> usize {
        16
    }
}
pub struct AASHELLMENUITEM {
    pub lpReserved1: MutPtr<::core::ffi::c_void>,
    pub iReserved: i32,
    pub uiReserved: u32,
    pub lpName: MutPtr<AASHELLMENUFILENAME>,
    pub psz: PWSTR,
}
impl ::core::marker::Copy for AASHELLMENUITEM {}
impl ::core::clone::Clone for AASHELLMENUITEM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for AASHELLMENUITEM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AASHELLMENUITEM")
            .field("lpReserved1", &self.lpReserved1)
            .field("iReserved", &self.iReserved)
            .field("uiReserved", &self.uiReserved)
            .field("lpName", &self.lpName)
            .field("psz", &self.psz)
            .finish()
    }
}
impl ::core::cmp::PartialEq for AASHELLMENUITEM {
    fn eq(&self, other: &Self) -> bool {
        self.lpReserved1 == other.lpReserved1
            && self.iReserved == other.iReserved
            && self.uiReserved == other.uiReserved
            && self.lpName == other.lpName
            && self.psz == other.psz
    }
}
impl ::core::cmp::Eq for AASHELLMENUITEM {}
impl FromIntoMemory for AASHELLMENUITEM {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_lpReserved1 =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iReserved = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uiReserved = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpName =
            <MutPtr<AASHELLMENUFILENAME> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_psz = <PWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            lpReserved1: f_lpReserved1,
            iReserved: f_iReserved,
            uiReserved: f_uiReserved,
            lpName: f_lpName,
            psz: f_psz,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.lpReserved1, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iReserved, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uiReserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpName, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.psz, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub const ABE_BOTTOM: u32 = 3u32;
pub const ABE_LEFT: u32 = 0u32;
pub const ABE_RIGHT: u32 = 2u32;
pub const ABE_TOP: u32 = 1u32;
pub const ABM_ACTIVATE: u32 = 6u32;
pub const ABM_GETAUTOHIDEBAR: u32 = 7u32;
pub const ABM_GETAUTOHIDEBAREX: u32 = 11u32;
pub const ABM_GETSTATE: u32 = 4u32;
pub const ABM_GETTASKBARPOS: u32 = 5u32;
pub const ABM_NEW: u32 = 0u32;
pub const ABM_QUERYPOS: u32 = 2u32;
pub const ABM_REMOVE: u32 = 1u32;
pub const ABM_SETAUTOHIDEBAR: u32 = 8u32;
pub const ABM_SETAUTOHIDEBAREX: u32 = 12u32;
pub const ABM_SETPOS: u32 = 3u32;
pub const ABM_SETSTATE: u32 = 10u32;
pub const ABM_WINDOWPOSCHANGED: u32 = 9u32;
pub const ABN_FULLSCREENAPP: u32 = 2u32;
pub const ABN_POSCHANGED: u32 = 1u32;
pub const ABN_STATECHANGE: u32 = 0u32;
pub const ABN_WINDOWARRANGE: u32 = 3u32;
pub const ABS_ALWAYSONTOP: u32 = 2u32;
pub const ABS_AUTOHIDE: u32 = 1u32;
pub const ACDD_VISIBLE: u32 = 1u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ACENUMOPTION(pub i32);
pub const ACEO_NONE: ACENUMOPTION = ACENUMOPTION(0i32);
pub const ACEO_MOSTRECENTFIRST: ACENUMOPTION = ACENUMOPTION(1i32);
pub const ACEO_FIRSTUNUSED: ACENUMOPTION = ACENUMOPTION(65536i32);
impl ::core::marker::Copy for ACENUMOPTION {}
impl ::core::clone::Clone for ACENUMOPTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ACENUMOPTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ACENUMOPTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ACENUMOPTION").field(&self.0).finish()
    }
}
impl FromIntoMemory for ACENUMOPTION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ACTIVATEOPTIONS(pub i32);
pub const AO_NONE: ACTIVATEOPTIONS = ACTIVATEOPTIONS(0i32);
pub const AO_DESIGNMODE: ACTIVATEOPTIONS = ACTIVATEOPTIONS(1i32);
pub const AO_NOERRORUI: ACTIVATEOPTIONS = ACTIVATEOPTIONS(2i32);
pub const AO_NOSPLASHSCREEN: ACTIVATEOPTIONS = ACTIVATEOPTIONS(4i32);
pub const AO_PRELAUNCH: ACTIVATEOPTIONS = ACTIVATEOPTIONS(33554432i32);
impl ::core::marker::Copy for ACTIVATEOPTIONS {}
impl ::core::clone::Clone for ACTIVATEOPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ACTIVATEOPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ACTIVATEOPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ACTIVATEOPTIONS").field(&self.0).finish()
    }
}
impl FromIntoMemory for ACTIVATEOPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const ADDURL_SILENT: u32 = 1u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ADJACENT_DISPLAY_EDGES(pub i32);
pub const ADE_NONE: ADJACENT_DISPLAY_EDGES = ADJACENT_DISPLAY_EDGES(0i32);
pub const ADE_LEFT: ADJACENT_DISPLAY_EDGES = ADJACENT_DISPLAY_EDGES(1i32);
pub const ADE_RIGHT: ADJACENT_DISPLAY_EDGES = ADJACENT_DISPLAY_EDGES(2i32);
impl ::core::marker::Copy for ADJACENT_DISPLAY_EDGES {}
impl ::core::clone::Clone for ADJACENT_DISPLAY_EDGES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ADJACENT_DISPLAY_EDGES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ADJACENT_DISPLAY_EDGES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ADJACENT_DISPLAY_EDGES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ADJACENT_DISPLAY_EDGES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const AD_APPLY_BUFFERED_REFRESH: u32 = 16u32;
pub const AD_APPLY_DYNAMICREFRESH: u32 = 32u32;
pub const AD_APPLY_FORCE: u32 = 8u32;
pub const AD_APPLY_HTMLGEN: u32 = 2u32;
pub const AD_APPLY_REFRESH: u32 = 4u32;
pub const AD_APPLY_SAVE: u32 = 1u32;
pub const AD_GETWP_BMP: u32 = 0u32;
pub const AD_GETWP_IMAGE: u32 = 1u32;
pub const AD_GETWP_LAST_APPLIED: u32 = 2u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct AHE_TYPE(pub i32);
pub const AHE_DESKTOP: AHE_TYPE = AHE_TYPE(0i32);
pub const AHE_IMMERSIVE: AHE_TYPE = AHE_TYPE(1i32);
impl ::core::marker::Copy for AHE_TYPE {}
impl ::core::clone::Clone for AHE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AHE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AHE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AHE_TYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for AHE_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct AHTYPE(pub i32);
pub const AHTYPE_UNDEFINED: AHTYPE = AHTYPE(0i32);
pub const AHTYPE_USER_APPLICATION: AHTYPE = AHTYPE(8i32);
pub const AHTYPE_ANY_APPLICATION: AHTYPE = AHTYPE(16i32);
pub const AHTYPE_MACHINEDEFAULT: AHTYPE = AHTYPE(32i32);
pub const AHTYPE_PROGID: AHTYPE = AHTYPE(64i32);
pub const AHTYPE_APPLICATION: AHTYPE = AHTYPE(128i32);
pub const AHTYPE_CLASS_APPLICATION: AHTYPE = AHTYPE(256i32);
pub const AHTYPE_ANY_PROGID: AHTYPE = AHTYPE(512i32);
impl ::core::marker::Copy for AHTYPE {}
impl ::core::clone::Clone for AHTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AHTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AHTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AHTYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for AHTYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct APPACTIONFLAGS(pub i32);
pub const APPACTION_INSTALL: APPACTIONFLAGS = APPACTIONFLAGS(1i32);
pub const APPACTION_UNINSTALL: APPACTIONFLAGS = APPACTIONFLAGS(2i32);
pub const APPACTION_MODIFY: APPACTIONFLAGS = APPACTIONFLAGS(4i32);
pub const APPACTION_REPAIR: APPACTIONFLAGS = APPACTIONFLAGS(8i32);
pub const APPACTION_UPGRADE: APPACTIONFLAGS = APPACTIONFLAGS(16i32);
pub const APPACTION_CANGETSIZE: APPACTIONFLAGS = APPACTIONFLAGS(32i32);
pub const APPACTION_MODIFYREMOVE: APPACTIONFLAGS = APPACTIONFLAGS(128i32);
pub const APPACTION_ADDLATER: APPACTIONFLAGS = APPACTIONFLAGS(256i32);
pub const APPACTION_UNSCHEDULE: APPACTIONFLAGS = APPACTIONFLAGS(512i32);
impl ::core::marker::Copy for APPACTIONFLAGS {}
impl ::core::clone::Clone for APPACTIONFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for APPACTIONFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for APPACTIONFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("APPACTIONFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for APPACTIONFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct APPBARDATA {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uCallbackMessage: u32,
    pub uEdge: u32,
    pub rc: super::super::Foundation::RECT,
    pub lParam: super::super::Foundation::LPARAM,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for APPBARDATA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for APPBARDATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for APPBARDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("APPBARDATA")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uCallbackMessage", &self.uCallbackMessage)
            .field("uEdge", &self.uEdge)
            .field("rc", &self.rc)
            .field("lParam", &self.lParam)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for APPBARDATA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uCallbackMessage == other.uCallbackMessage
            && self.uEdge == other.uEdge
            && self.rc == other.rc
            && self.lParam == other.lParam
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for APPBARDATA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for APPBARDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uCallbackMessage = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_uEdge = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_rc =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[16..16 + 16]);
        let f_lParam =
            <super::super::Foundation::LPARAM as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uCallbackMessage: f_uCallbackMessage,
            uEdge: f_uEdge,
            rc: f_rc,
            lParam: f_lParam,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uCallbackMessage, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.uEdge, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.rc, &mut into[16..16 + 16]);
        FromIntoMemory::into_bytes(self.lParam, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct APPBARDATA {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uCallbackMessage: u32,
    pub uEdge: u32,
    pub rc: super::super::Foundation::RECT,
    pub lParam: super::super::Foundation::LPARAM,
}
impl ::core::marker::Copy for APPBARDATA {}
impl ::core::clone::Clone for APPBARDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for APPBARDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("APPBARDATA")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uCallbackMessage", &self.uCallbackMessage)
            .field("uEdge", &self.uEdge)
            .field("rc", &self.rc)
            .field("lParam", &self.lParam)
            .finish()
    }
}
impl ::core::cmp::PartialEq for APPBARDATA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uCallbackMessage == other.uCallbackMessage
            && self.uEdge == other.uEdge
            && self.rc == other.rc
            && self.lParam == other.lParam
    }
}
impl ::core::cmp::Eq for APPBARDATA {}
impl FromIntoMemory for APPBARDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uCallbackMessage = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_uEdge = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_rc =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[16..16 + 16]);
        let f_lParam =
            <super::super::Foundation::LPARAM as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uCallbackMessage: f_uCallbackMessage,
            uEdge: f_uEdge,
            rc: f_rc,
            lParam: f_lParam,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uCallbackMessage, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.uEdge, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.rc, &mut into[16..16 + 16]);
        FromIntoMemory::into_bytes(self.lParam, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct APPCATEGORYINFO {
    pub Locale: u32,
    pub pszDescription: PWSTR,
    pub AppCategoryId: crate::core::GUID,
}
impl ::core::marker::Copy for APPCATEGORYINFO {}
impl ::core::clone::Clone for APPCATEGORYINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for APPCATEGORYINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("APPCATEGORYINFO")
            .field("Locale", &self.Locale)
            .field("pszDescription", &self.pszDescription)
            .field("AppCategoryId", &self.AppCategoryId)
            .finish()
    }
}
impl ::core::cmp::PartialEq for APPCATEGORYINFO {
    fn eq(&self, other: &Self) -> bool {
        self.Locale == other.Locale
            && self.pszDescription == other.pszDescription
            && self.AppCategoryId == other.AppCategoryId
    }
}
impl ::core::cmp::Eq for APPCATEGORYINFO {}
impl FromIntoMemory for APPCATEGORYINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_Locale = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszDescription = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_AppCategoryId = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        Self {
            Locale: f_Locale,
            pszDescription: f_pszDescription,
            AppCategoryId: f_AppCategoryId,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.Locale, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszDescription, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.AppCategoryId, &mut into[8..8 + 16]);
    }
    fn size() -> usize {
        24
    }
}
pub struct APPCATEGORYINFOLIST {
    pub cCategory: u32,
    pub pCategoryInfo: MutPtr<APPCATEGORYINFO>,
}
impl ::core::marker::Copy for APPCATEGORYINFOLIST {}
impl ::core::clone::Clone for APPCATEGORYINFOLIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for APPCATEGORYINFOLIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("APPCATEGORYINFOLIST")
            .field("cCategory", &self.cCategory)
            .field("pCategoryInfo", &self.pCategoryInfo)
            .finish()
    }
}
impl ::core::cmp::PartialEq for APPCATEGORYINFOLIST {
    fn eq(&self, other: &Self) -> bool {
        self.cCategory == other.cCategory && self.pCategoryInfo == other.pCategoryInfo
    }
}
impl ::core::cmp::Eq for APPCATEGORYINFOLIST {}
impl FromIntoMemory for APPCATEGORYINFOLIST {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_cCategory = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pCategoryInfo =
            <MutPtr<APPCATEGORYINFO> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            cCategory: f_cCategory,
            pCategoryInfo: f_pCategoryInfo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.cCategory, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pCategoryInfo, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct APPDOCLISTTYPE(pub i32);
pub const ADLT_RECENT: APPDOCLISTTYPE = APPDOCLISTTYPE(0i32);
pub const ADLT_FREQUENT: APPDOCLISTTYPE = APPDOCLISTTYPE(1i32);
impl ::core::marker::Copy for APPDOCLISTTYPE {}
impl ::core::clone::Clone for APPDOCLISTTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for APPDOCLISTTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for APPDOCLISTTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("APPDOCLISTTYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for APPDOCLISTTYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct APPINFODATA {
    pub cbSize: u32,
    pub dwMask: u32,
    pub pszDisplayName: PWSTR,
    pub pszVersion: PWSTR,
    pub pszPublisher: PWSTR,
    pub pszProductID: PWSTR,
    pub pszRegisteredOwner: PWSTR,
    pub pszRegisteredCompany: PWSTR,
    pub pszLanguage: PWSTR,
    pub pszSupportUrl: PWSTR,
    pub pszSupportTelephone: PWSTR,
    pub pszHelpLink: PWSTR,
    pub pszInstallLocation: PWSTR,
    pub pszInstallSource: PWSTR,
    pub pszInstallDate: PWSTR,
    pub pszContact: PWSTR,
    pub pszComments: PWSTR,
    pub pszImage: PWSTR,
    pub pszReadmeUrl: PWSTR,
    pub pszUpdateInfoUrl: PWSTR,
}
impl ::core::marker::Copy for APPINFODATA {}
impl ::core::clone::Clone for APPINFODATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for APPINFODATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("APPINFODATA")
            .field("cbSize", &self.cbSize)
            .field("dwMask", &self.dwMask)
            .field("pszDisplayName", &self.pszDisplayName)
            .field("pszVersion", &self.pszVersion)
            .field("pszPublisher", &self.pszPublisher)
            .field("pszProductID", &self.pszProductID)
            .field("pszRegisteredOwner", &self.pszRegisteredOwner)
            .field("pszRegisteredCompany", &self.pszRegisteredCompany)
            .field("pszLanguage", &self.pszLanguage)
            .field("pszSupportUrl", &self.pszSupportUrl)
            .field("pszSupportTelephone", &self.pszSupportTelephone)
            .field("pszHelpLink", &self.pszHelpLink)
            .field("pszInstallLocation", &self.pszInstallLocation)
            .field("pszInstallSource", &self.pszInstallSource)
            .field("pszInstallDate", &self.pszInstallDate)
            .field("pszContact", &self.pszContact)
            .field("pszComments", &self.pszComments)
            .field("pszImage", &self.pszImage)
            .field("pszReadmeUrl", &self.pszReadmeUrl)
            .field("pszUpdateInfoUrl", &self.pszUpdateInfoUrl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for APPINFODATA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwMask == other.dwMask
            && self.pszDisplayName == other.pszDisplayName
            && self.pszVersion == other.pszVersion
            && self.pszPublisher == other.pszPublisher
            && self.pszProductID == other.pszProductID
            && self.pszRegisteredOwner == other.pszRegisteredOwner
            && self.pszRegisteredCompany == other.pszRegisteredCompany
            && self.pszLanguage == other.pszLanguage
            && self.pszSupportUrl == other.pszSupportUrl
            && self.pszSupportTelephone == other.pszSupportTelephone
            && self.pszHelpLink == other.pszHelpLink
            && self.pszInstallLocation == other.pszInstallLocation
            && self.pszInstallSource == other.pszInstallSource
            && self.pszInstallDate == other.pszInstallDate
            && self.pszContact == other.pszContact
            && self.pszComments == other.pszComments
            && self.pszImage == other.pszImage
            && self.pszReadmeUrl == other.pszReadmeUrl
            && self.pszUpdateInfoUrl == other.pszUpdateInfoUrl
    }
}
impl ::core::cmp::Eq for APPINFODATA {}
impl FromIntoMemory for APPINFODATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 80);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszDisplayName = <PWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszVersion = <PWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pszPublisher = <PWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pszProductID = <PWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_pszRegisteredOwner = <PWSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_pszRegisteredCompany = <PWSTR as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_pszLanguage = <PWSTR as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_pszSupportUrl = <PWSTR as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_pszSupportTelephone = <PWSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_pszHelpLink = <PWSTR as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_pszInstallLocation = <PWSTR as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_pszInstallSource = <PWSTR as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_pszInstallDate = <PWSTR as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_pszContact = <PWSTR as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_pszComments = <PWSTR as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_pszImage = <PWSTR as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_pszReadmeUrl = <PWSTR as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f_pszUpdateInfoUrl = <PWSTR as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        Self {
            cbSize: f_cbSize,
            dwMask: f_dwMask,
            pszDisplayName: f_pszDisplayName,
            pszVersion: f_pszVersion,
            pszPublisher: f_pszPublisher,
            pszProductID: f_pszProductID,
            pszRegisteredOwner: f_pszRegisteredOwner,
            pszRegisteredCompany: f_pszRegisteredCompany,
            pszLanguage: f_pszLanguage,
            pszSupportUrl: f_pszSupportUrl,
            pszSupportTelephone: f_pszSupportTelephone,
            pszHelpLink: f_pszHelpLink,
            pszInstallLocation: f_pszInstallLocation,
            pszInstallSource: f_pszInstallSource,
            pszInstallDate: f_pszInstallDate,
            pszContact: f_pszContact,
            pszComments: f_pszComments,
            pszImage: f_pszImage,
            pszReadmeUrl: f_pszReadmeUrl,
            pszUpdateInfoUrl: f_pszUpdateInfoUrl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 80);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszDisplayName, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszVersion, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pszPublisher, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pszProductID, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.pszRegisteredOwner, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.pszRegisteredCompany, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.pszLanguage, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.pszSupportUrl, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.pszSupportTelephone, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.pszHelpLink, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.pszInstallLocation, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.pszInstallSource, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.pszInstallDate, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.pszContact, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.pszComments, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.pszImage, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.pszReadmeUrl, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self.pszUpdateInfoUrl, &mut into[76..76 + 4]);
    }
    fn size() -> usize {
        80
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct APPINFODATAFLAGS(pub i32);
pub const AIM_DISPLAYNAME: APPINFODATAFLAGS = APPINFODATAFLAGS(1i32);
pub const AIM_VERSION: APPINFODATAFLAGS = APPINFODATAFLAGS(2i32);
pub const AIM_PUBLISHER: APPINFODATAFLAGS = APPINFODATAFLAGS(4i32);
pub const AIM_PRODUCTID: APPINFODATAFLAGS = APPINFODATAFLAGS(8i32);
pub const AIM_REGISTEREDOWNER: APPINFODATAFLAGS = APPINFODATAFLAGS(16i32);
pub const AIM_REGISTEREDCOMPANY: APPINFODATAFLAGS = APPINFODATAFLAGS(32i32);
pub const AIM_LANGUAGE: APPINFODATAFLAGS = APPINFODATAFLAGS(64i32);
pub const AIM_SUPPORTURL: APPINFODATAFLAGS = APPINFODATAFLAGS(128i32);
pub const AIM_SUPPORTTELEPHONE: APPINFODATAFLAGS = APPINFODATAFLAGS(256i32);
pub const AIM_HELPLINK: APPINFODATAFLAGS = APPINFODATAFLAGS(512i32);
pub const AIM_INSTALLLOCATION: APPINFODATAFLAGS = APPINFODATAFLAGS(1024i32);
pub const AIM_INSTALLSOURCE: APPINFODATAFLAGS = APPINFODATAFLAGS(2048i32);
pub const AIM_INSTALLDATE: APPINFODATAFLAGS = APPINFODATAFLAGS(4096i32);
pub const AIM_CONTACT: APPINFODATAFLAGS = APPINFODATAFLAGS(16384i32);
pub const AIM_COMMENTS: APPINFODATAFLAGS = APPINFODATAFLAGS(32768i32);
pub const AIM_IMAGE: APPINFODATAFLAGS = APPINFODATAFLAGS(131072i32);
pub const AIM_READMEURL: APPINFODATAFLAGS = APPINFODATAFLAGS(262144i32);
pub const AIM_UPDATEINFOURL: APPINFODATAFLAGS = APPINFODATAFLAGS(524288i32);
impl ::core::marker::Copy for APPINFODATAFLAGS {}
impl ::core::clone::Clone for APPINFODATAFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for APPINFODATAFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for APPINFODATAFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("APPINFODATAFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for APPINFODATAFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub type APPLET_PROC = StdCallFnPtr<
    (
        super::super::Foundation::HWND,
        u32,
        super::super::Foundation::LPARAM,
        super::super::Foundation::LPARAM,
    ),
    i32,
>;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct APPLICATION_VIEW_MIN_WIDTH(pub i32);
pub const AVMW_DEFAULT: APPLICATION_VIEW_MIN_WIDTH = APPLICATION_VIEW_MIN_WIDTH(0i32);
pub const AVMW_320: APPLICATION_VIEW_MIN_WIDTH = APPLICATION_VIEW_MIN_WIDTH(1i32);
pub const AVMW_500: APPLICATION_VIEW_MIN_WIDTH = APPLICATION_VIEW_MIN_WIDTH(2i32);
impl ::core::marker::Copy for APPLICATION_VIEW_MIN_WIDTH {}
impl ::core::clone::Clone for APPLICATION_VIEW_MIN_WIDTH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for APPLICATION_VIEW_MIN_WIDTH {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for APPLICATION_VIEW_MIN_WIDTH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("APPLICATION_VIEW_MIN_WIDTH")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for APPLICATION_VIEW_MIN_WIDTH {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct APPLICATION_VIEW_ORIENTATION(pub i32);
pub const AVO_LANDSCAPE: APPLICATION_VIEW_ORIENTATION = APPLICATION_VIEW_ORIENTATION(0i32);
pub const AVO_PORTRAIT: APPLICATION_VIEW_ORIENTATION = APPLICATION_VIEW_ORIENTATION(1i32);
impl ::core::marker::Copy for APPLICATION_VIEW_ORIENTATION {}
impl ::core::clone::Clone for APPLICATION_VIEW_ORIENTATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for APPLICATION_VIEW_ORIENTATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for APPLICATION_VIEW_ORIENTATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("APPLICATION_VIEW_ORIENTATION")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for APPLICATION_VIEW_ORIENTATION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct APPLICATION_VIEW_SIZE_PREFERENCE(pub i32);
pub const AVSP_DEFAULT: APPLICATION_VIEW_SIZE_PREFERENCE = APPLICATION_VIEW_SIZE_PREFERENCE(0i32);
pub const AVSP_USE_LESS: APPLICATION_VIEW_SIZE_PREFERENCE = APPLICATION_VIEW_SIZE_PREFERENCE(1i32);
pub const AVSP_USE_HALF: APPLICATION_VIEW_SIZE_PREFERENCE = APPLICATION_VIEW_SIZE_PREFERENCE(2i32);
pub const AVSP_USE_MORE: APPLICATION_VIEW_SIZE_PREFERENCE = APPLICATION_VIEW_SIZE_PREFERENCE(3i32);
pub const AVSP_USE_MINIMUM: APPLICATION_VIEW_SIZE_PREFERENCE =
    APPLICATION_VIEW_SIZE_PREFERENCE(4i32);
pub const AVSP_USE_NONE: APPLICATION_VIEW_SIZE_PREFERENCE = APPLICATION_VIEW_SIZE_PREFERENCE(5i32);
pub const AVSP_CUSTOM: APPLICATION_VIEW_SIZE_PREFERENCE = APPLICATION_VIEW_SIZE_PREFERENCE(6i32);
impl ::core::marker::Copy for APPLICATION_VIEW_SIZE_PREFERENCE {}
impl ::core::clone::Clone for APPLICATION_VIEW_SIZE_PREFERENCE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for APPLICATION_VIEW_SIZE_PREFERENCE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for APPLICATION_VIEW_SIZE_PREFERENCE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("APPLICATION_VIEW_SIZE_PREFERENCE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for APPLICATION_VIEW_SIZE_PREFERENCE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct APPLICATION_VIEW_STATE(pub i32);
pub const AVS_FULLSCREEN_LANDSCAPE: APPLICATION_VIEW_STATE = APPLICATION_VIEW_STATE(0i32);
pub const AVS_FILLED: APPLICATION_VIEW_STATE = APPLICATION_VIEW_STATE(1i32);
pub const AVS_SNAPPED: APPLICATION_VIEW_STATE = APPLICATION_VIEW_STATE(2i32);
pub const AVS_FULLSCREEN_PORTRAIT: APPLICATION_VIEW_STATE = APPLICATION_VIEW_STATE(3i32);
impl ::core::marker::Copy for APPLICATION_VIEW_STATE {}
impl ::core::clone::Clone for APPLICATION_VIEW_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for APPLICATION_VIEW_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for APPLICATION_VIEW_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("APPLICATION_VIEW_STATE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for APPLICATION_VIEW_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const APPNAMEBUFFERLEN: u32 = 40u32;
pub const ARCONTENT_AUDIOCD: u32 = 4u32;
pub const ARCONTENT_AUTOPLAYMUSIC: u32 = 256u32;
pub const ARCONTENT_AUTOPLAYPIX: u32 = 128u32;
pub const ARCONTENT_AUTOPLAYVIDEO: u32 = 512u32;
pub const ARCONTENT_AUTORUNINF: u32 = 2u32;
pub const ARCONTENT_BLANKBD: u32 = 8192u32;
pub const ARCONTENT_BLANKCD: u32 = 16u32;
pub const ARCONTENT_BLANKDVD: u32 = 32u32;
pub const ARCONTENT_BLURAY: u32 = 16384u32;
pub const ARCONTENT_CAMERASTORAGE: u32 = 32768u32;
pub const ARCONTENT_CUSTOMEVENT: u32 = 65536u32;
pub const ARCONTENT_DVDAUDIO: u32 = 4096u32;
pub const ARCONTENT_DVDMOVIE: u32 = 8u32;
pub const ARCONTENT_MASK: u32 = 131070u32;
pub const ARCONTENT_NONE: u32 = 0u32;
pub const ARCONTENT_PHASE_FINAL: u32 = 1073741824u32;
pub const ARCONTENT_PHASE_MASK: u32 = 1879048192u32;
pub const ARCONTENT_PHASE_PRESNIFF: u32 = 268435456u32;
pub const ARCONTENT_PHASE_SNIFFING: u32 = 536870912u32;
pub const ARCONTENT_PHASE_UNKNOWN: u32 = 0u32;
pub const ARCONTENT_SVCD: u32 = 2048u32;
pub const ARCONTENT_UNKNOWNCONTENT: u32 = 64u32;
pub const ARCONTENT_VCD: u32 = 1024u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOCCLASS(pub i32);
pub const ASSOCCLASS_SHELL_KEY: ASSOCCLASS = ASSOCCLASS(0i32);
pub const ASSOCCLASS_PROGID_KEY: ASSOCCLASS = ASSOCCLASS(1i32);
pub const ASSOCCLASS_PROGID_STR: ASSOCCLASS = ASSOCCLASS(2i32);
pub const ASSOCCLASS_CLSID_KEY: ASSOCCLASS = ASSOCCLASS(3i32);
pub const ASSOCCLASS_CLSID_STR: ASSOCCLASS = ASSOCCLASS(4i32);
pub const ASSOCCLASS_APP_KEY: ASSOCCLASS = ASSOCCLASS(5i32);
pub const ASSOCCLASS_APP_STR: ASSOCCLASS = ASSOCCLASS(6i32);
pub const ASSOCCLASS_SYSTEM_STR: ASSOCCLASS = ASSOCCLASS(7i32);
pub const ASSOCCLASS_FOLDER: ASSOCCLASS = ASSOCCLASS(8i32);
pub const ASSOCCLASS_STAR: ASSOCCLASS = ASSOCCLASS(9i32);
pub const ASSOCCLASS_FIXED_PROGID_STR: ASSOCCLASS = ASSOCCLASS(10i32);
pub const ASSOCCLASS_PROTOCOL_STR: ASSOCCLASS = ASSOCCLASS(11i32);
impl ::core::marker::Copy for ASSOCCLASS {}
impl ::core::clone::Clone for ASSOCCLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOCCLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOCCLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOCCLASS").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOCCLASS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOCDATA(pub i32);
pub const ASSOCDATA_MSIDESCRIPTOR: ASSOCDATA = ASSOCDATA(1i32);
pub const ASSOCDATA_NOACTIVATEHANDLER: ASSOCDATA = ASSOCDATA(2i32);
pub const ASSOCDATA_UNUSED1: ASSOCDATA = ASSOCDATA(3i32);
pub const ASSOCDATA_HASPERUSERASSOC: ASSOCDATA = ASSOCDATA(4i32);
pub const ASSOCDATA_EDITFLAGS: ASSOCDATA = ASSOCDATA(5i32);
pub const ASSOCDATA_VALUE: ASSOCDATA = ASSOCDATA(6i32);
pub const ASSOCDATA_MAX: ASSOCDATA = ASSOCDATA(7i32);
impl ::core::marker::Copy for ASSOCDATA {}
impl ::core::clone::Clone for ASSOCDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOCDATA {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOCDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOCDATA").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOCDATA {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOCENUM(pub i32);
pub const ASSOCENUM_NONE: ASSOCENUM = ASSOCENUM(0i32);
impl ::core::marker::Copy for ASSOCENUM {}
impl ::core::clone::Clone for ASSOCENUM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOCENUM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOCENUM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOCENUM").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOCENUM {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const ASSOCF_APP_TO_APP: i32 = 65536i32;
pub const ASSOCF_IGNOREBASECLASS: i32 = 512i32;
pub const ASSOCF_INIT_BYEXENAME: i32 = 2i32;
pub const ASSOCF_INIT_DEFAULTTOFOLDER: i32 = 8i32;
pub const ASSOCF_INIT_DEFAULTTOSTAR: i32 = 4i32;
pub const ASSOCF_INIT_FIXED_PROGID: i32 = 2048i32;
pub const ASSOCF_INIT_FOR_FILE: i32 = 8192i32;
pub const ASSOCF_INIT_IGNOREUNKNOWN: i32 = 1024i32;
pub const ASSOCF_INIT_NOREMAPCLSID: i32 = 1i32;
pub const ASSOCF_IS_FULL_URI: i32 = 16384i32;
pub const ASSOCF_IS_PROTOCOL: i32 = 4096i32;
pub const ASSOCF_NOFIXUPS: i32 = 256i32;
pub const ASSOCF_NONE: i32 = 0i32;
pub const ASSOCF_NOTRUNCATE: i32 = 32i32;
pub const ASSOCF_NOUSERSETTINGS: i32 = 16i32;
pub const ASSOCF_OPEN_BYEXENAME: i32 = 2i32;
pub const ASSOCF_PER_MACHINE_ONLY: i32 = 32768i32;
pub const ASSOCF_REMAPRUNDLL: i32 = 128i32;
pub const ASSOCF_VERIFY: i32 = 64i32;
#[doc = "*Required namespaces: 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ASSOCIATIONELEMENT {
    pub ac: ASSOCCLASS,
    pub hkClass: super::super::System::Registry::HKEY,
    pub pszClass: PCWSTR,
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ASSOCIATIONELEMENT {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ASSOCIATIONELEMENT {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ASSOCIATIONELEMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ASSOCIATIONELEMENT")
            .field("ac", &self.ac)
            .field("hkClass", &self.hkClass)
            .field("pszClass", &self.pszClass)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ASSOCIATIONELEMENT {
    fn eq(&self, other: &Self) -> bool {
        self.ac == other.ac && self.hkClass == other.hkClass && self.pszClass == other.pszClass
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ASSOCIATIONELEMENT {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ASSOCIATIONELEMENT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_ac = <ASSOCCLASS as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hkClass =
            <super::super::System::Registry::HKEY as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszClass = <PCWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            ac: f_ac,
            hkClass: f_hkClass,
            pszClass: f_pszClass,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.ac, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hkClass, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszClass, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct ASSOCIATIONELEMENT {
    pub ac: ASSOCCLASS,
    pub hkClass: super::super::System::Registry::HKEY,
    pub pszClass: PCWSTR,
}
impl ::core::marker::Copy for ASSOCIATIONELEMENT {}
impl ::core::clone::Clone for ASSOCIATIONELEMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ASSOCIATIONELEMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ASSOCIATIONELEMENT")
            .field("ac", &self.ac)
            .field("hkClass", &self.hkClass)
            .field("pszClass", &self.pszClass)
            .finish()
    }
}
impl ::core::cmp::PartialEq for ASSOCIATIONELEMENT {
    fn eq(&self, other: &Self) -> bool {
        self.ac == other.ac && self.hkClass == other.hkClass && self.pszClass == other.pszClass
    }
}
impl ::core::cmp::Eq for ASSOCIATIONELEMENT {}
impl FromIntoMemory for ASSOCIATIONELEMENT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_ac = <ASSOCCLASS as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hkClass =
            <super::super::System::Registry::HKEY as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszClass = <PCWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            ac: f_ac,
            hkClass: f_hkClass,
            pszClass: f_pszClass,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.ac, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hkClass, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszClass, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOCIATIONLEVEL(pub i32);
pub const AL_MACHINE: ASSOCIATIONLEVEL = ASSOCIATIONLEVEL(0i32);
pub const AL_EFFECTIVE: ASSOCIATIONLEVEL = ASSOCIATIONLEVEL(1i32);
pub const AL_USER: ASSOCIATIONLEVEL = ASSOCIATIONLEVEL(2i32);
impl ::core::marker::Copy for ASSOCIATIONLEVEL {}
impl ::core::clone::Clone for ASSOCIATIONLEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOCIATIONLEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOCIATIONLEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOCIATIONLEVEL").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOCIATIONLEVEL {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOCIATIONTYPE(pub i32);
pub const AT_FILEEXTENSION: ASSOCIATIONTYPE = ASSOCIATIONTYPE(0i32);
pub const AT_URLPROTOCOL: ASSOCIATIONTYPE = ASSOCIATIONTYPE(1i32);
pub const AT_STARTMENUCLIENT: ASSOCIATIONTYPE = ASSOCIATIONTYPE(2i32);
pub const AT_MIMETYPE: ASSOCIATIONTYPE = ASSOCIATIONTYPE(3i32);
impl ::core::marker::Copy for ASSOCIATIONTYPE {}
impl ::core::clone::Clone for ASSOCIATIONTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOCIATIONTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOCIATIONTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOCIATIONTYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOCIATIONTYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOCKEY(pub i32);
pub const ASSOCKEY_SHELLEXECCLASS: ASSOCKEY = ASSOCKEY(1i32);
pub const ASSOCKEY_APP: ASSOCKEY = ASSOCKEY(2i32);
pub const ASSOCKEY_CLASS: ASSOCKEY = ASSOCKEY(3i32);
pub const ASSOCKEY_BASECLASS: ASSOCKEY = ASSOCKEY(4i32);
pub const ASSOCKEY_MAX: ASSOCKEY = ASSOCKEY(5i32);
impl ::core::marker::Copy for ASSOCKEY {}
impl ::core::clone::Clone for ASSOCKEY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOCKEY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOCKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOCKEY").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOCKEY {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOCSTR(pub i32);
pub const ASSOCSTR_COMMAND: ASSOCSTR = ASSOCSTR(1i32);
pub const ASSOCSTR_EXECUTABLE: ASSOCSTR = ASSOCSTR(2i32);
pub const ASSOCSTR_FRIENDLYDOCNAME: ASSOCSTR = ASSOCSTR(3i32);
pub const ASSOCSTR_FRIENDLYAPPNAME: ASSOCSTR = ASSOCSTR(4i32);
pub const ASSOCSTR_NOOPEN: ASSOCSTR = ASSOCSTR(5i32);
pub const ASSOCSTR_SHELLNEWVALUE: ASSOCSTR = ASSOCSTR(6i32);
pub const ASSOCSTR_DDECOMMAND: ASSOCSTR = ASSOCSTR(7i32);
pub const ASSOCSTR_DDEIFEXEC: ASSOCSTR = ASSOCSTR(8i32);
pub const ASSOCSTR_DDEAPPLICATION: ASSOCSTR = ASSOCSTR(9i32);
pub const ASSOCSTR_DDETOPIC: ASSOCSTR = ASSOCSTR(10i32);
pub const ASSOCSTR_INFOTIP: ASSOCSTR = ASSOCSTR(11i32);
pub const ASSOCSTR_QUICKTIP: ASSOCSTR = ASSOCSTR(12i32);
pub const ASSOCSTR_TILEINFO: ASSOCSTR = ASSOCSTR(13i32);
pub const ASSOCSTR_CONTENTTYPE: ASSOCSTR = ASSOCSTR(14i32);
pub const ASSOCSTR_DEFAULTICON: ASSOCSTR = ASSOCSTR(15i32);
pub const ASSOCSTR_SHELLEXTENSION: ASSOCSTR = ASSOCSTR(16i32);
pub const ASSOCSTR_DROPTARGET: ASSOCSTR = ASSOCSTR(17i32);
pub const ASSOCSTR_DELEGATEEXECUTE: ASSOCSTR = ASSOCSTR(18i32);
pub const ASSOCSTR_SUPPORTED_URI_PROTOCOLS: ASSOCSTR = ASSOCSTR(19i32);
pub const ASSOCSTR_PROGID: ASSOCSTR = ASSOCSTR(20i32);
pub const ASSOCSTR_APPID: ASSOCSTR = ASSOCSTR(21i32);
pub const ASSOCSTR_APPPUBLISHER: ASSOCSTR = ASSOCSTR(22i32);
pub const ASSOCSTR_APPICONREFERENCE: ASSOCSTR = ASSOCSTR(23i32);
pub const ASSOCSTR_MAX: ASSOCSTR = ASSOCSTR(24i32);
impl ::core::marker::Copy for ASSOCSTR {}
impl ::core::clone::Clone for ASSOCSTR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOCSTR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOCSTR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOCSTR").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOCSTR {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ASSOC_FILTER(pub i32);
pub const ASSOC_FILTER_NONE: ASSOC_FILTER = ASSOC_FILTER(0i32);
pub const ASSOC_FILTER_RECOMMENDED: ASSOC_FILTER = ASSOC_FILTER(1i32);
impl ::core::marker::Copy for ASSOC_FILTER {}
impl ::core::clone::Clone for ASSOC_FILTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASSOC_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ASSOC_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASSOC_FILTER").field(&self.0).finish()
    }
}
impl FromIntoMemory for ASSOC_FILTER {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ATTACHMENT_ACTION(pub i32);
pub const ATTACHMENT_ACTION_CANCEL: ATTACHMENT_ACTION = ATTACHMENT_ACTION(0i32);
pub const ATTACHMENT_ACTION_SAVE: ATTACHMENT_ACTION = ATTACHMENT_ACTION(1i32);
pub const ATTACHMENT_ACTION_EXEC: ATTACHMENT_ACTION = ATTACHMENT_ACTION(2i32);
impl ::core::marker::Copy for ATTACHMENT_ACTION {}
impl ::core::clone::Clone for ATTACHMENT_ACTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ATTACHMENT_ACTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ATTACHMENT_ACTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ATTACHMENT_ACTION").field(&self.0).finish()
    }
}
impl FromIntoMemory for ATTACHMENT_ACTION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ATTACHMENT_PROMPT(pub i32);
pub const ATTACHMENT_PROMPT_NONE: ATTACHMENT_PROMPT = ATTACHMENT_PROMPT(0i32);
pub const ATTACHMENT_PROMPT_SAVE: ATTACHMENT_PROMPT = ATTACHMENT_PROMPT(1i32);
pub const ATTACHMENT_PROMPT_EXEC: ATTACHMENT_PROMPT = ATTACHMENT_PROMPT(2i32);
pub const ATTACHMENT_PROMPT_EXEC_OR_SAVE: ATTACHMENT_PROMPT = ATTACHMENT_PROMPT(3i32);
impl ::core::marker::Copy for ATTACHMENT_PROMPT {}
impl ::core::clone::Clone for ATTACHMENT_PROMPT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ATTACHMENT_PROMPT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ATTACHMENT_PROMPT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ATTACHMENT_PROMPT").field(&self.0).finish()
    }
}
impl FromIntoMemory for ATTACHMENT_PROMPT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct AUTOCOMPLETELISTOPTIONS(pub i32);
pub const ACLO_NONE: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(0i32);
pub const ACLO_CURRENTDIR: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(1i32);
pub const ACLO_MYCOMPUTER: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(2i32);
pub const ACLO_DESKTOP: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(4i32);
pub const ACLO_FAVORITES: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(8i32);
pub const ACLO_FILESYSONLY: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(16i32);
pub const ACLO_FILESYSDIRS: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(32i32);
pub const ACLO_VIRTUALNAMESPACE: AUTOCOMPLETELISTOPTIONS = AUTOCOMPLETELISTOPTIONS(64i32);
impl ::core::marker::Copy for AUTOCOMPLETELISTOPTIONS {}
impl ::core::clone::Clone for AUTOCOMPLETELISTOPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AUTOCOMPLETELISTOPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AUTOCOMPLETELISTOPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AUTOCOMPLETELISTOPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for AUTOCOMPLETELISTOPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct AUTOCOMPLETEOPTIONS(pub i32);
pub const ACO_NONE: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(0i32);
pub const ACO_AUTOSUGGEST: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(1i32);
pub const ACO_AUTOAPPEND: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(2i32);
pub const ACO_SEARCH: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(4i32);
pub const ACO_FILTERPREFIXES: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(8i32);
pub const ACO_USETAB: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(16i32);
pub const ACO_UPDOWNKEYDROPSLIST: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(32i32);
pub const ACO_RTLREADING: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(64i32);
pub const ACO_WORD_FILTER: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(128i32);
pub const ACO_NOPREFIXFILTERING: AUTOCOMPLETEOPTIONS = AUTOCOMPLETEOPTIONS(256i32);
impl ::core::marker::Copy for AUTOCOMPLETEOPTIONS {}
impl ::core::clone::Clone for AUTOCOMPLETEOPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AUTOCOMPLETEOPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for AUTOCOMPLETEOPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AUTOCOMPLETEOPTIONS").field(&self.0).finish()
    }
}
impl FromIntoMemory for AUTOCOMPLETEOPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct AUTO_SCROLL_DATA {
    pub iNextSample: i32,
    pub dwLastScroll: u32,
    pub bFull: super::super::Foundation::BOOL,
    pub pts: [super::super::Foundation::POINT; 3],
    pub dwTimes: [u32; 3],
}
impl ::core::marker::Copy for AUTO_SCROLL_DATA {}
impl ::core::clone::Clone for AUTO_SCROLL_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for AUTO_SCROLL_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AUTO_SCROLL_DATA")
            .field("iNextSample", &self.iNextSample)
            .field("dwLastScroll", &self.dwLastScroll)
            .field("bFull", &self.bFull)
            .field("pts", &self.pts)
            .field("dwTimes", &self.dwTimes)
            .finish()
    }
}
impl ::core::cmp::PartialEq for AUTO_SCROLL_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.iNextSample == other.iNextSample
            && self.dwLastScroll == other.dwLastScroll
            && self.bFull == other.bFull
            && self.pts == other.pts
            && self.dwTimes == other.dwTimes
    }
}
impl ::core::cmp::Eq for AUTO_SCROLL_DATA {}
impl FromIntoMemory for AUTO_SCROLL_DATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 48);
        let f_iNextSample = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwLastScroll = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_bFull =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pts = <[super::super::Foundation::POINT; 3] as FromIntoMemory>::from_bytes(
            &from[12..12 + 24],
        );
        let f_dwTimes = <[u32; 3] as FromIntoMemory>::from_bytes(&from[36..36 + 12]);
        Self {
            iNextSample: f_iNextSample,
            dwLastScroll: f_dwLastScroll,
            bFull: f_bFull,
            pts: f_pts,
            dwTimes: f_dwTimes,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 48);
        FromIntoMemory::into_bytes(self.iNextSample, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwLastScroll, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.bFull, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pts, &mut into[12..12 + 24]);
        FromIntoMemory::into_bytes(self.dwTimes, &mut into[36..36 + 12]);
    }
    fn size() -> usize {
        48
    }
}
pub const AccessibilityDockingService: crate::core::GUID =
    crate::core::GUID::from_u128(0x29ce1d46_b481_4aa0_a08a_d3ebc8aca402);
pub const AlphabeticalCategorizer: crate::core::GUID =
    crate::core::GUID::from_u128(0x3c2654c6_7372_4f6b_b310_55d6128f49d2);
pub const AppShellVerbHandler: crate::core::GUID =
    crate::core::GUID::from_u128(0x4ed3a719_cea8_4bd9_910d_e252f997afc2);
pub const AppStartupLink: crate::core::GUID =
    crate::core::GUID::from_u128(0x273eb5e7_88b0_4843_bfef_e2c81d43aae5);
pub const AppVisibility: crate::core::GUID =
    crate::core::GUID::from_u128(0x7e5fe3d9_985f_4908_91f9_ee19f9fd1514);
pub const ApplicationActivationManager: crate::core::GUID =
    crate::core::GUID::from_u128(0x45ba127d_10a8_46ea_8ab7_56ea9078943c);
pub const ApplicationAssociationRegistration: crate::core::GUID =
    crate::core::GUID::from_u128(0x591209c7_767b_42b2_9fba_44ee4615f2c7);
pub const ApplicationAssociationRegistrationUI: crate::core::GUID =
    crate::core::GUID::from_u128(0x1968106d_f3b5_44cf_890e_116fcb9ecef1);
pub const ApplicationDesignModeSettings: crate::core::GUID =
    crate::core::GUID::from_u128(0x958a6fb5_dcb2_4faf_aafd_7fb054ad1a3b);
pub const ApplicationDestinations: crate::core::GUID =
    crate::core::GUID::from_u128(0x86c14003_4d6b_4ef3_a7b4_0506663b2e68);
pub const ApplicationDocumentLists: crate::core::GUID =
    crate::core::GUID::from_u128(0x86bec222_30f2_47e0_9f25_60d11cd75c28);
pub const AttachmentServices: crate::core::GUID =
    crate::core::GUID::from_u128(0x4125dd96_e03a_4103_8f70_e0597d803b9c);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct BANDINFOSFB {
    pub dwMask: u32,
    pub dwStateMask: u32,
    pub dwState: u32,
    pub crBkgnd: u32,
    pub crBtnLt: u32,
    pub crBtnDk: u32,
    pub wViewMode: u16,
    pub wAlign: u16,
    pub psf: IShellFolder,
    pub pidl: MutPtr<Common::ITEMIDLIST>,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for BANDINFOSFB {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for BANDINFOSFB {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for BANDINFOSFB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BANDINFOSFB")
            .field("dwMask", &self.dwMask)
            .field("dwStateMask", &self.dwStateMask)
            .field("dwState", &self.dwState)
            .field("crBkgnd", &self.crBkgnd)
            .field("crBtnLt", &self.crBtnLt)
            .field("crBtnDk", &self.crBtnDk)
            .field("wViewMode", &self.wViewMode)
            .field("wAlign", &self.wAlign)
            .field("psf", &self.psf)
            .field("pidl", &self.pidl)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for BANDINFOSFB {
    fn eq(&self, other: &Self) -> bool {
        self.dwMask == other.dwMask
            && self.dwStateMask == other.dwStateMask
            && self.dwState == other.dwState
            && self.crBkgnd == other.crBkgnd
            && self.crBtnLt == other.crBtnLt
            && self.crBtnDk == other.crBtnDk
            && self.wViewMode == other.wViewMode
            && self.wAlign == other.wAlign
            && self.psf == other.psf
            && self.pidl == other.pidl
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for BANDINFOSFB {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for BANDINFOSFB {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwStateMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwState = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_crBkgnd = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_crBtnLt = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_crBtnDk = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_wViewMode = <u16 as FromIntoMemory>::from_bytes(&from[24..24 + 2]);
        let f_wAlign = <u16 as FromIntoMemory>::from_bytes(&from[26..26 + 2]);
        let f_psf = <IShellFolder as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_pidl = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            dwMask: f_dwMask,
            dwStateMask: f_dwStateMask,
            dwState: f_dwState,
            crBkgnd: f_crBkgnd,
            crBtnLt: f_crBtnLt,
            crBtnDk: f_crBtnDk,
            wViewMode: f_wViewMode,
            wAlign: f_wAlign,
            psf: f_psf,
            pidl: f_pidl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwStateMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwState, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.crBkgnd, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.crBtnLt, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.crBtnDk, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.wViewMode, &mut into[24..24 + 2]);
        FromIntoMemory::into_bytes(self.wAlign, &mut into[26..26 + 2]);
        FromIntoMemory::into_bytes(self.psf, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.pidl, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct BANDSITECID(pub i32);
pub const BSID_BANDADDED: BANDSITECID = BANDSITECID(0i32);
pub const BSID_BANDREMOVED: BANDSITECID = BANDSITECID(1i32);
impl ::core::marker::Copy for BANDSITECID {}
impl ::core::clone::Clone for BANDSITECID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for BANDSITECID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BANDSITECID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BANDSITECID").field(&self.0).finish()
    }
}
impl FromIntoMemory for BANDSITECID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct BANDSITEINFO {
    pub dwMask: u32,
    pub dwState: u32,
    pub dwStyle: u32,
}
impl ::core::marker::Copy for BANDSITEINFO {}
impl ::core::clone::Clone for BANDSITEINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for BANDSITEINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BANDSITEINFO")
            .field("dwMask", &self.dwMask)
            .field("dwState", &self.dwState)
            .field("dwStyle", &self.dwStyle)
            .finish()
    }
}
impl ::core::cmp::PartialEq for BANDSITEINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwMask == other.dwMask
            && self.dwState == other.dwState
            && self.dwStyle == other.dwStyle
    }
}
impl ::core::cmp::Eq for BANDSITEINFO {}
impl FromIntoMemory for BANDSITEINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwState = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwStyle = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwMask: f_dwMask,
            dwState: f_dwState,
            dwStyle: f_dwStyle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwState, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwStyle, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub struct BANNER_NOTIFICATION {
    pub event: BANNER_NOTIFICATION_EVENT,
    pub providerIdentity: PCWSTR,
    pub contentId: PCWSTR,
}
impl ::core::marker::Copy for BANNER_NOTIFICATION {}
impl ::core::clone::Clone for BANNER_NOTIFICATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for BANNER_NOTIFICATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BANNER_NOTIFICATION")
            .field("event", &self.event)
            .field("providerIdentity", &self.providerIdentity)
            .field("contentId", &self.contentId)
            .finish()
    }
}
impl ::core::cmp::PartialEq for BANNER_NOTIFICATION {
    fn eq(&self, other: &Self) -> bool {
        self.event == other.event
            && self.providerIdentity == other.providerIdentity
            && self.contentId == other.contentId
    }
}
impl ::core::cmp::Eq for BANNER_NOTIFICATION {}
impl FromIntoMemory for BANNER_NOTIFICATION {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_event = <BANNER_NOTIFICATION_EVENT as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_providerIdentity = <PCWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_contentId = <PCWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            event: f_event,
            providerIdentity: f_providerIdentity,
            contentId: f_contentId,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.event, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.providerIdentity, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.contentId, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct BANNER_NOTIFICATION_EVENT(pub i32);
pub const BNE_Rendered: BANNER_NOTIFICATION_EVENT = BANNER_NOTIFICATION_EVENT(0i32);
pub const BNE_Hovered: BANNER_NOTIFICATION_EVENT = BANNER_NOTIFICATION_EVENT(1i32);
pub const BNE_Closed: BANNER_NOTIFICATION_EVENT = BANNER_NOTIFICATION_EVENT(2i32);
pub const BNE_Dismissed: BANNER_NOTIFICATION_EVENT = BANNER_NOTIFICATION_EVENT(3i32);
pub const BNE_Button1Clicked: BANNER_NOTIFICATION_EVENT = BANNER_NOTIFICATION_EVENT(4i32);
pub const BNE_Button2Clicked: BANNER_NOTIFICATION_EVENT = BANNER_NOTIFICATION_EVENT(5i32);
impl ::core::marker::Copy for BANNER_NOTIFICATION_EVENT {}
impl ::core::clone::Clone for BANNER_NOTIFICATION_EVENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for BANNER_NOTIFICATION_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BANNER_NOTIFICATION_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BANNER_NOTIFICATION_EVENT")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for BANNER_NOTIFICATION_EVENT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct BASEBROWSERDATALH {
    pub _hwnd: super::super::Foundation::HWND,
    pub _ptl: ITravelLog,
    pub _phlf: IHlinkFrame,
    pub _pautoWB2: IWebBrowser2,
    pub _pautoEDS: IExpDispSupport,
    pub _pautoSS: IShellService,
    pub _eSecureLockIcon: i32,
    pub _bitfield: u32,
    pub _uActivateState: u32,
    pub _pidlViewState: MutPtr<Common::ITEMIDLIST>,
    pub _pctView: super::super::System::Ole::IOleCommandTarget,
    pub _pidlCur: MutPtr<Common::ITEMIDLIST>,
    pub _psv: IShellView,
    pub _psf: IShellFolder,
    pub _hwndView: super::super::Foundation::HWND,
    pub _pszTitleCur: PWSTR,
    pub _pidlPending: MutPtr<Common::ITEMIDLIST>,
    pub _psvPending: IShellView,
    pub _psfPending: IShellFolder,
    pub _hwndViewPending: super::super::Foundation::HWND,
    pub _pszTitlePending: PWSTR,
    pub _fIsViewMSHTML: super::super::Foundation::BOOL,
    pub _fPrivacyImpacted: super::super::Foundation::BOOL,
    pub _clsidView: crate::core::GUID,
    pub _clsidViewPending: crate::core::GUID,
    pub _hwndFrame: super::super::Foundation::HWND,
    pub _lPhishingFilterStatus: i32,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for BASEBROWSERDATALH {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for BASEBROWSERDATALH {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for BASEBROWSERDATALH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BASEBROWSERDATALH")
            .field("_hwnd", &self._hwnd)
            .field("_ptl", &self._ptl)
            .field("_phlf", &self._phlf)
            .field("_pautoWB2", &self._pautoWB2)
            .field("_pautoEDS", &self._pautoEDS)
            .field("_pautoSS", &self._pautoSS)
            .field("_eSecureLockIcon", &self._eSecureLockIcon)
            .field("_bitfield", &self._bitfield)
            .field("_uActivateState", &self._uActivateState)
            .field("_pidlViewState", &self._pidlViewState)
            .field("_pctView", &self._pctView)
            .field("_pidlCur", &self._pidlCur)
            .field("_psv", &self._psv)
            .field("_psf", &self._psf)
            .field("_hwndView", &self._hwndView)
            .field("_pszTitleCur", &self._pszTitleCur)
            .field("_pidlPending", &self._pidlPending)
            .field("_psvPending", &self._psvPending)
            .field("_psfPending", &self._psfPending)
            .field("_hwndViewPending", &self._hwndViewPending)
            .field("_pszTitlePending", &self._pszTitlePending)
            .field("_fIsViewMSHTML", &self._fIsViewMSHTML)
            .field("_fPrivacyImpacted", &self._fPrivacyImpacted)
            .field("_clsidView", &self._clsidView)
            .field("_clsidViewPending", &self._clsidViewPending)
            .field("_hwndFrame", &self._hwndFrame)
            .field("_lPhishingFilterStatus", &self._lPhishingFilterStatus)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for BASEBROWSERDATALH {
    fn eq(&self, other: &Self) -> bool {
        self._hwnd == other._hwnd
            && self._ptl == other._ptl
            && self._phlf == other._phlf
            && self._pautoWB2 == other._pautoWB2
            && self._pautoEDS == other._pautoEDS
            && self._pautoSS == other._pautoSS
            && self._eSecureLockIcon == other._eSecureLockIcon
            && self._bitfield == other._bitfield
            && self._uActivateState == other._uActivateState
            && self._pidlViewState == other._pidlViewState
            && self._pctView == other._pctView
            && self._pidlCur == other._pidlCur
            && self._psv == other._psv
            && self._psf == other._psf
            && self._hwndView == other._hwndView
            && self._pszTitleCur == other._pszTitleCur
            && self._pidlPending == other._pidlPending
            && self._psvPending == other._psvPending
            && self._psfPending == other._psfPending
            && self._hwndViewPending == other._hwndViewPending
            && self._pszTitlePending == other._pszTitlePending
            && self._fIsViewMSHTML == other._fIsViewMSHTML
            && self._fPrivacyImpacted == other._fPrivacyImpacted
            && self._clsidView == other._clsidView
            && self._clsidViewPending == other._clsidViewPending
            && self._hwndFrame == other._hwndFrame
            && self._lPhishingFilterStatus == other._lPhishingFilterStatus
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for BASEBROWSERDATALH {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for BASEBROWSERDATALH {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 132);
        let f__hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f__ptl = <ITravelLog as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f__phlf = <IHlinkFrame as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f__pautoWB2 = <IWebBrowser2 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f__pautoEDS = <IExpDispSupport as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f__pautoSS = <IShellService as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f__eSecureLockIcon = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f__bitfield = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f__uActivateState = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f__pidlViewState =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f__pctView =
            <super::super::System::Ole::IOleCommandTarget as FromIntoMemory>::from_bytes(
                &from[40..40 + 4],
            );
        let f__pidlCur =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f__psv = <IShellView as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f__psf = <IShellFolder as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f__hwndView =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f__pszTitleCur = <PWSTR as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f__pidlPending =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f__psvPending = <IShellView as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f__psfPending = <IShellFolder as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f__hwndViewPending =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f__pszTitlePending = <PWSTR as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f__fIsViewMSHTML =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f__fPrivacyImpacted =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f__clsidView = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[92..92 + 16]);
        let f__clsidViewPending =
            <crate::core::GUID as FromIntoMemory>::from_bytes(&from[108..108 + 16]);
        let f__hwndFrame =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[124..124 + 4]);
        let f__lPhishingFilterStatus = <i32 as FromIntoMemory>::from_bytes(&from[128..128 + 4]);
        Self {
            _hwnd: f__hwnd,
            _ptl: f__ptl,
            _phlf: f__phlf,
            _pautoWB2: f__pautoWB2,
            _pautoEDS: f__pautoEDS,
            _pautoSS: f__pautoSS,
            _eSecureLockIcon: f__eSecureLockIcon,
            _bitfield: f__bitfield,
            _uActivateState: f__uActivateState,
            _pidlViewState: f__pidlViewState,
            _pctView: f__pctView,
            _pidlCur: f__pidlCur,
            _psv: f__psv,
            _psf: f__psf,
            _hwndView: f__hwndView,
            _pszTitleCur: f__pszTitleCur,
            _pidlPending: f__pidlPending,
            _psvPending: f__psvPending,
            _psfPending: f__psfPending,
            _hwndViewPending: f__hwndViewPending,
            _pszTitlePending: f__pszTitlePending,
            _fIsViewMSHTML: f__fIsViewMSHTML,
            _fPrivacyImpacted: f__fPrivacyImpacted,
            _clsidView: f__clsidView,
            _clsidViewPending: f__clsidViewPending,
            _hwndFrame: f__hwndFrame,
            _lPhishingFilterStatus: f__lPhishingFilterStatus,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 132);
        FromIntoMemory::into_bytes(self._hwnd, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self._ptl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self._phlf, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self._pautoWB2, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self._pautoEDS, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self._pautoSS, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self._eSecureLockIcon, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self._bitfield, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self._uActivateState, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self._pidlViewState, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self._pctView, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self._pidlCur, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self._psv, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self._psf, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self._hwndView, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self._pszTitleCur, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self._pidlPending, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self._psvPending, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self._psfPending, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self._hwndViewPending, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self._pszTitlePending, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self._fIsViewMSHTML, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self._fPrivacyImpacted, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self._clsidView, &mut into[92..92 + 16]);
        FromIntoMemory::into_bytes(self._clsidViewPending, &mut into[108..108 + 16]);
        FromIntoMemory::into_bytes(self._hwndFrame, &mut into[124..124 + 4]);
        FromIntoMemory::into_bytes(self._lPhishingFilterStatus, &mut into[128..128 + 4]);
    }
    fn size() -> usize {
        132
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct BASEBROWSERDATAXP {
    pub _hwnd: super::super::Foundation::HWND,
    pub _ptl: ITravelLog,
    pub _phlf: IHlinkFrame,
    pub _pautoWB2: IWebBrowser2,
    pub _pautoEDS: IExpDispSupportXP,
    pub _pautoSS: IShellService,
    pub _eSecureLockIcon: i32,
    pub _bitfield: u32,
    pub _uActivateState: u32,
    pub _pidlViewState: MutPtr<Common::ITEMIDLIST>,
    pub _pctView: super::super::System::Ole::IOleCommandTarget,
    pub _pidlCur: MutPtr<Common::ITEMIDLIST>,
    pub _psv: IShellView,
    pub _psf: IShellFolder,
    pub _hwndView: super::super::Foundation::HWND,
    pub _pszTitleCur: PWSTR,
    pub _pidlPending: MutPtr<Common::ITEMIDLIST>,
    pub _psvPending: IShellView,
    pub _psfPending: IShellFolder,
    pub _hwndViewPending: super::super::Foundation::HWND,
    pub _pszTitlePending: PWSTR,
    pub _fIsViewMSHTML: super::super::Foundation::BOOL,
    pub _fPrivacyImpacted: super::super::Foundation::BOOL,
    pub _clsidView: crate::core::GUID,
    pub _clsidViewPending: crate::core::GUID,
    pub _hwndFrame: super::super::Foundation::HWND,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for BASEBROWSERDATAXP {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for BASEBROWSERDATAXP {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for BASEBROWSERDATAXP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BASEBROWSERDATAXP")
            .field("_hwnd", &self._hwnd)
            .field("_ptl", &self._ptl)
            .field("_phlf", &self._phlf)
            .field("_pautoWB2", &self._pautoWB2)
            .field("_pautoEDS", &self._pautoEDS)
            .field("_pautoSS", &self._pautoSS)
            .field("_eSecureLockIcon", &self._eSecureLockIcon)
            .field("_bitfield", &self._bitfield)
            .field("_uActivateState", &self._uActivateState)
            .field("_pidlViewState", &self._pidlViewState)
            .field("_pctView", &self._pctView)
            .field("_pidlCur", &self._pidlCur)
            .field("_psv", &self._psv)
            .field("_psf", &self._psf)
            .field("_hwndView", &self._hwndView)
            .field("_pszTitleCur", &self._pszTitleCur)
            .field("_pidlPending", &self._pidlPending)
            .field("_psvPending", &self._psvPending)
            .field("_psfPending", &self._psfPending)
            .field("_hwndViewPending", &self._hwndViewPending)
            .field("_pszTitlePending", &self._pszTitlePending)
            .field("_fIsViewMSHTML", &self._fIsViewMSHTML)
            .field("_fPrivacyImpacted", &self._fPrivacyImpacted)
            .field("_clsidView", &self._clsidView)
            .field("_clsidViewPending", &self._clsidViewPending)
            .field("_hwndFrame", &self._hwndFrame)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for BASEBROWSERDATAXP {
    fn eq(&self, other: &Self) -> bool {
        self._hwnd == other._hwnd
            && self._ptl == other._ptl
            && self._phlf == other._phlf
            && self._pautoWB2 == other._pautoWB2
            && self._pautoEDS == other._pautoEDS
            && self._pautoSS == other._pautoSS
            && self._eSecureLockIcon == other._eSecureLockIcon
            && self._bitfield == other._bitfield
            && self._uActivateState == other._uActivateState
            && self._pidlViewState == other._pidlViewState
            && self._pctView == other._pctView
            && self._pidlCur == other._pidlCur
            && self._psv == other._psv
            && self._psf == other._psf
            && self._hwndView == other._hwndView
            && self._pszTitleCur == other._pszTitleCur
            && self._pidlPending == other._pidlPending
            && self._psvPending == other._psvPending
            && self._psfPending == other._psfPending
            && self._hwndViewPending == other._hwndViewPending
            && self._pszTitlePending == other._pszTitlePending
            && self._fIsViewMSHTML == other._fIsViewMSHTML
            && self._fPrivacyImpacted == other._fPrivacyImpacted
            && self._clsidView == other._clsidView
            && self._clsidViewPending == other._clsidViewPending
            && self._hwndFrame == other._hwndFrame
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for BASEBROWSERDATAXP {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for BASEBROWSERDATAXP {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 128);
        let f__hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f__ptl = <ITravelLog as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f__phlf = <IHlinkFrame as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f__pautoWB2 = <IWebBrowser2 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f__pautoEDS = <IExpDispSupportXP as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f__pautoSS = <IShellService as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f__eSecureLockIcon = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f__bitfield = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f__uActivateState = <u32 as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f__pidlViewState =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f__pctView =
            <super::super::System::Ole::IOleCommandTarget as FromIntoMemory>::from_bytes(
                &from[40..40 + 4],
            );
        let f__pidlCur =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f__psv = <IShellView as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f__psf = <IShellFolder as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f__hwndView =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f__pszTitleCur = <PWSTR as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f__pidlPending =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f__psvPending = <IShellView as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f__psfPending = <IShellFolder as FromIntoMemory>::from_bytes(&from[72..72 + 4]);
        let f__hwndViewPending =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f__pszTitlePending = <PWSTR as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f__fIsViewMSHTML =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f__fPrivacyImpacted =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f__clsidView = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[92..92 + 16]);
        let f__clsidViewPending =
            <crate::core::GUID as FromIntoMemory>::from_bytes(&from[108..108 + 16]);
        let f__hwndFrame =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[124..124 + 4]);
        Self {
            _hwnd: f__hwnd,
            _ptl: f__ptl,
            _phlf: f__phlf,
            _pautoWB2: f__pautoWB2,
            _pautoEDS: f__pautoEDS,
            _pautoSS: f__pautoSS,
            _eSecureLockIcon: f__eSecureLockIcon,
            _bitfield: f__bitfield,
            _uActivateState: f__uActivateState,
            _pidlViewState: f__pidlViewState,
            _pctView: f__pctView,
            _pidlCur: f__pidlCur,
            _psv: f__psv,
            _psf: f__psf,
            _hwndView: f__hwndView,
            _pszTitleCur: f__pszTitleCur,
            _pidlPending: f__pidlPending,
            _psvPending: f__psvPending,
            _psfPending: f__psfPending,
            _hwndViewPending: f__hwndViewPending,
            _pszTitlePending: f__pszTitlePending,
            _fIsViewMSHTML: f__fIsViewMSHTML,
            _fPrivacyImpacted: f__fPrivacyImpacted,
            _clsidView: f__clsidView,
            _clsidViewPending: f__clsidViewPending,
            _hwndFrame: f__hwndFrame,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 128);
        FromIntoMemory::into_bytes(self._hwnd, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self._ptl, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self._phlf, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self._pautoWB2, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self._pautoEDS, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self._pautoSS, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self._eSecureLockIcon, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self._bitfield, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self._uActivateState, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self._pidlViewState, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self._pctView, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self._pidlCur, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self._psv, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self._psf, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self._hwndView, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self._pszTitleCur, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self._pidlPending, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self._psvPending, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self._psfPending, &mut into[72..72 + 4]);
        FromIntoMemory::into_bytes(self._hwndViewPending, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self._pszTitlePending, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self._fIsViewMSHTML, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self._fPrivacyImpacted, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self._clsidView, &mut into[92..92 + 16]);
        FromIntoMemory::into_bytes(self._clsidViewPending, &mut into[108..108 + 16]);
        FromIntoMemory::into_bytes(self._hwndFrame, &mut into[124..124 + 4]);
    }
    fn size() -> usize {
        128
    }
}
pub type BFFCALLBACK = StdCallFnPtr<
    (
        super::super::Foundation::HWND,
        u32,
        super::super::Foundation::LPARAM,
        super::super::Foundation::LPARAM,
    ),
    i32,
>;
pub const BFFM_ENABLEOK: u32 = 1125u32;
pub const BFFM_INITIALIZED: u32 = 1u32;
pub const BFFM_IUNKNOWN: u32 = 5u32;
pub const BFFM_SELCHANGED: u32 = 2u32;
pub const BFFM_SETEXPANDED: u32 = 1130u32;
pub const BFFM_SETOKTEXT: u32 = 1129u32;
pub const BFFM_SETSELECTION: u32 = 1127u32;
pub const BFFM_SETSELECTIONA: u32 = 1126u32;
pub const BFFM_SETSELECTIONW: u32 = 1127u32;
pub const BFFM_SETSTATUSTEXT: u32 = 1128u32;
pub const BFFM_SETSTATUSTEXTA: u32 = 1124u32;
pub const BFFM_SETSTATUSTEXTW: u32 = 1128u32;
pub const BFFM_VALIDATEFAILED: u32 = 4u32;
pub const BFFM_VALIDATEFAILEDA: u32 = 3u32;
pub const BFFM_VALIDATEFAILEDW: u32 = 4u32;
pub const BHID_AssociationArray: crate::core::GUID =
    crate::core::GUID::from_u128(0xbea9ef17_82f1_4f60_9284_4f8db75c3be9);
pub const BHID_DataObject: crate::core::GUID =
    crate::core::GUID::from_u128(0xb8c0bd9f_ed24_455c_83e6_d5390c4fe8c4);
pub const BHID_EnumAssocHandlers: crate::core::GUID =
    crate::core::GUID::from_u128(0xb8ab0b9c_c2ec_4f7a_918d_314900e6280a);
pub const BHID_EnumItems: crate::core::GUID =
    crate::core::GUID::from_u128(0x94f60519_2850_4924_aa5a_d15e84868039);
pub const BHID_FilePlaceholder: crate::core::GUID =
    crate::core::GUID::from_u128(0x8677dceb_aae0_4005_8d3d_547fa852f825);
pub const BHID_Filter: crate::core::GUID =
    crate::core::GUID::from_u128(0x38d08778_f557_4690_9ebf_ba54706ad8f7);
pub const BHID_LinkTargetItem: crate::core::GUID =
    crate::core::GUID::from_u128(0x3981e228_f559_11d3_8e3a_00c04f6837d5);
pub const BHID_PropertyStore: crate::core::GUID =
    crate::core::GUID::from_u128(0x0384e1a4_1523_439c_a4c8_ab911052f586);
pub const BHID_RandomAccessStream: crate::core::GUID =
    crate::core::GUID::from_u128(0xf16fc93b_77ae_4cfe_bda7_a866eea6878d);
pub const BHID_SFObject: crate::core::GUID =
    crate::core::GUID::from_u128(0x3981e224_f559_11d3_8e3a_00c04f6837d5);
pub const BHID_SFUIObject: crate::core::GUID =
    crate::core::GUID::from_u128(0x3981e225_f559_11d3_8e3a_00c04f6837d5);
pub const BHID_SFViewObject: crate::core::GUID =
    crate::core::GUID::from_u128(0x3981e226_f559_11d3_8e3a_00c04f6837d5);
pub const BHID_Storage: crate::core::GUID =
    crate::core::GUID::from_u128(0x3981e227_f559_11d3_8e3a_00c04f6837d5);
pub const BHID_StorageEnum: crate::core::GUID =
    crate::core::GUID::from_u128(0x4621a4e3_f0d6_4773_8a9c_46e77b174840);
pub const BHID_StorageItem: crate::core::GUID =
    crate::core::GUID::from_u128(0x404e2109_77d2_4699_a5a0_4fdf10db9837);
pub const BHID_Stream: crate::core::GUID =
    crate::core::GUID::from_u128(0x1cebb3ab_7c10_499a_a417_92ca16c4cb83);
pub const BHID_ThumbnailHandler: crate::core::GUID =
    crate::core::GUID::from_u128(0x7b2e650a_8e20_4f4a_b09e_6597afc72fb0);
pub const BHID_Transfer: crate::core::GUID =
    crate::core::GUID::from_u128(0xd5e346a1_f753_4932_b403_4574800e2498);
pub const BIF_BROWSEFILEJUNCTIONS: u32 = 65536u32;
pub const BIF_BROWSEFORCOMPUTER: u32 = 4096u32;
pub const BIF_BROWSEFORPRINTER: u32 = 8192u32;
pub const BIF_BROWSEINCLUDEFILES: u32 = 16384u32;
pub const BIF_BROWSEINCLUDEURLS: u32 = 128u32;
pub const BIF_DONTGOBELOWDOMAIN: u32 = 2u32;
pub const BIF_EDITBOX: u32 = 16u32;
pub const BIF_NEWDIALOGSTYLE: u32 = 64u32;
pub const BIF_NONEWFOLDERBUTTON: u32 = 512u32;
pub const BIF_NOTRANSLATETARGETS: u32 = 1024u32;
pub const BIF_RETURNFSANCESTORS: u32 = 8u32;
pub const BIF_RETURNONLYFSDIRS: u32 = 1u32;
pub const BIF_SHAREABLE: u32 = 32768u32;
pub const BIF_STATUSTEXT: u32 = 4u32;
pub const BIF_UAHINT: u32 = 256u32;
pub const BIF_VALIDATE: u32 = 32u32;
pub const BIND_INTERRUPTABLE: u32 = 4294967295u32;
pub const BMICON_LARGE: i32 = 0i32;
pub const BMICON_SMALL: i32 = 1i32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct BNSTATE(pub i32);
pub const BNS_NORMAL: BNSTATE = BNSTATE(0i32);
pub const BNS_BEGIN_NAVIGATE: BNSTATE = BNSTATE(1i32);
pub const BNS_NAVIGATE: BNSTATE = BNSTATE(2i32);
impl ::core::marker::Copy for BNSTATE {}
impl ::core::clone::Clone for BNSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for BNSTATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BNSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BNSTATE").field(&self.0).finish()
    }
}
impl FromIntoMemory for BNSTATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct BROWSEINFOA {
    pub hwndOwner: super::super::Foundation::HWND,
    pub pidlRoot: MutPtr<Common::ITEMIDLIST>,
    pub pszDisplayName: PSTR,
    pub lpszTitle: PCSTR,
    pub ulFlags: u32,
    pub lpfn: BFFCALLBACK,
    pub lParam: super::super::Foundation::LPARAM,
    pub iImage: i32,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for BROWSEINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for BROWSEINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for BROWSEINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BROWSEINFOA")
            .field("hwndOwner", &self.hwndOwner)
            .field("pidlRoot", &self.pidlRoot)
            .field("pszDisplayName", &self.pszDisplayName)
            .field("lpszTitle", &self.lpszTitle)
            .field("ulFlags", &self.ulFlags)
            .field("lpfn", &self.lpfn)
            .field("lParam", &self.lParam)
            .field("iImage", &self.iImage)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for BROWSEINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.hwndOwner == other.hwndOwner
            && self.pidlRoot == other.pidlRoot
            && self.pszDisplayName == other.pszDisplayName
            && self.lpszTitle == other.lpszTitle
            && self.ulFlags == other.ulFlags
            && self.lpfn == other.lpfn
            && self.lParam == other.lParam
            && self.iImage == other.iImage
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for BROWSEINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for BROWSEINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_hwndOwner =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pidlRoot =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszDisplayName = <PSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpszTitle = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ulFlags = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpfn = <BFFCALLBACK as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lParam =
            <super::super::Foundation::LPARAM as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_iImage = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            hwndOwner: f_hwndOwner,
            pidlRoot: f_pidlRoot,
            pszDisplayName: f_pszDisplayName,
            lpszTitle: f_lpszTitle,
            ulFlags: f_ulFlags,
            lpfn: f_lpfn,
            lParam: f_lParam,
            iImage: f_iImage,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.hwndOwner, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pidlRoot, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszDisplayName, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpszTitle, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ulFlags, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpfn, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lParam, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.iImage, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct BROWSEINFOW {
    pub hwndOwner: super::super::Foundation::HWND,
    pub pidlRoot: MutPtr<Common::ITEMIDLIST>,
    pub pszDisplayName: PWSTR,
    pub lpszTitle: PCWSTR,
    pub ulFlags: u32,
    pub lpfn: BFFCALLBACK,
    pub lParam: super::super::Foundation::LPARAM,
    pub iImage: i32,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for BROWSEINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for BROWSEINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for BROWSEINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BROWSEINFOW")
            .field("hwndOwner", &self.hwndOwner)
            .field("pidlRoot", &self.pidlRoot)
            .field("pszDisplayName", &self.pszDisplayName)
            .field("lpszTitle", &self.lpszTitle)
            .field("ulFlags", &self.ulFlags)
            .field("lpfn", &self.lpfn)
            .field("lParam", &self.lParam)
            .field("iImage", &self.iImage)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for BROWSEINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.hwndOwner == other.hwndOwner
            && self.pidlRoot == other.pidlRoot
            && self.pszDisplayName == other.pszDisplayName
            && self.lpszTitle == other.lpszTitle
            && self.ulFlags == other.ulFlags
            && self.lpfn == other.lpfn
            && self.lParam == other.lParam
            && self.iImage == other.iImage
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for BROWSEINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for BROWSEINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_hwndOwner =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pidlRoot =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszDisplayName = <PWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpszTitle = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_ulFlags = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpfn = <BFFCALLBACK as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lParam =
            <super::super::Foundation::LPARAM as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_iImage = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            hwndOwner: f_hwndOwner,
            pidlRoot: f_pidlRoot,
            pszDisplayName: f_pszDisplayName,
            lpszTitle: f_lpszTitle,
            ulFlags: f_ulFlags,
            lpfn: f_lpfn,
            lParam: f_lParam,
            iImage: f_iImage,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.hwndOwner, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pidlRoot, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszDisplayName, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpszTitle, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.ulFlags, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpfn, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lParam, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.iImage, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub const BSF_CANMAXIMIZE: u32 = 1024u32;
pub const BSF_DELEGATEDNAVIGATION: u32 = 65536u32;
pub const BSF_DONTSHOWNAVCANCELPAGE: u32 = 16384u32;
pub const BSF_FEEDNAVIGATION: u32 = 524288u32;
pub const BSF_FEEDSUBSCRIBED: u32 = 1048576u32;
pub const BSF_HTMLNAVCANCELED: u32 = 8192u32;
pub const BSF_MERGEDMENUS: u32 = 262144u32;
pub const BSF_NAVNOHISTORY: u32 = 4096u32;
pub const BSF_NOLOCALFILEWARNING: u32 = 16u32;
pub const BSF_REGISTERASDROPTARGET: u32 = 1u32;
pub const BSF_RESIZABLE: u32 = 512u32;
pub const BSF_SETNAVIGATABLECODEPAGE: u32 = 32768u32;
pub const BSF_THEATERMODE: u32 = 2u32;
pub const BSF_TOPBROWSER: u32 = 2048u32;
pub const BSF_TRUSTEDFORACTIVEX: u32 = 131072u32;
pub const BSF_UISETBYAUTOMATION: u32 = 256u32;
pub const BSIM_STATE: u32 = 1u32;
pub const BSIM_STYLE: u32 = 2u32;
pub const BSIS_ALWAYSGRIPPER: u32 = 2u32;
pub const BSIS_AUTOGRIPPER: u32 = 0u32;
pub const BSIS_FIXEDORDER: u32 = 1024u32;
pub const BSIS_LEFTALIGN: u32 = 4u32;
pub const BSIS_LOCKED: u32 = 256u32;
pub const BSIS_NOCAPTION: u32 = 64u32;
pub const BSIS_NOCONTEXTMENU: u32 = 16u32;
pub const BSIS_NODROPTARGET: u32 = 32u32;
pub const BSIS_NOGRIPPER: u32 = 1u32;
pub const BSIS_PREFERNOLINEBREAK: u32 = 128u32;
pub const BSIS_PRESERVEORDERDURINGLAYOUT: u32 = 512u32;
pub const BSIS_SINGLECLICK: u32 = 8u32;
pub const BSSF_NOTITLE: u32 = 2u32;
pub const BSSF_UNDELETEABLE: u32 = 4096u32;
pub const BSSF_VISIBLE: u32 = 1u32;
pub const BUFFLEN: u32 = 255u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct BrowserNavConstants(pub i32);
pub const navOpenInNewWindow: BrowserNavConstants = BrowserNavConstants(1i32);
pub const navNoHistory: BrowserNavConstants = BrowserNavConstants(2i32);
pub const navNoReadFromCache: BrowserNavConstants = BrowserNavConstants(4i32);
pub const navNoWriteToCache: BrowserNavConstants = BrowserNavConstants(8i32);
pub const navAllowAutosearch: BrowserNavConstants = BrowserNavConstants(16i32);
pub const navBrowserBar: BrowserNavConstants = BrowserNavConstants(32i32);
pub const navHyperlink: BrowserNavConstants = BrowserNavConstants(64i32);
pub const navEnforceRestricted: BrowserNavConstants = BrowserNavConstants(128i32);
pub const navNewWindowsManaged: BrowserNavConstants = BrowserNavConstants(256i32);
pub const navUntrustedForDownload: BrowserNavConstants = BrowserNavConstants(512i32);
pub const navTrustedForActiveX: BrowserNavConstants = BrowserNavConstants(1024i32);
pub const navOpenInNewTab: BrowserNavConstants = BrowserNavConstants(2048i32);
pub const navOpenInBackgroundTab: BrowserNavConstants = BrowserNavConstants(4096i32);
pub const navKeepWordWheelText: BrowserNavConstants = BrowserNavConstants(8192i32);
pub const navVirtualTab: BrowserNavConstants = BrowserNavConstants(16384i32);
pub const navBlockRedirectsXDomain: BrowserNavConstants = BrowserNavConstants(32768i32);
pub const navOpenNewForegroundTab: BrowserNavConstants = BrowserNavConstants(65536i32);
pub const navTravelLogScreenshot: BrowserNavConstants = BrowserNavConstants(131072i32);
pub const navDeferUnload: BrowserNavConstants = BrowserNavConstants(262144i32);
pub const navSpeculative: BrowserNavConstants = BrowserNavConstants(524288i32);
pub const navSuggestNewWindow: BrowserNavConstants = BrowserNavConstants(1048576i32);
pub const navSuggestNewTab: BrowserNavConstants = BrowserNavConstants(2097152i32);
pub const navReserved1: BrowserNavConstants = BrowserNavConstants(4194304i32);
pub const navHomepageNavigate: BrowserNavConstants = BrowserNavConstants(8388608i32);
pub const navRefresh: BrowserNavConstants = BrowserNavConstants(16777216i32);
pub const navHostNavigation: BrowserNavConstants = BrowserNavConstants(33554432i32);
pub const navReserved2: BrowserNavConstants = BrowserNavConstants(67108864i32);
pub const navReserved3: BrowserNavConstants = BrowserNavConstants(134217728i32);
pub const navReserved4: BrowserNavConstants = BrowserNavConstants(268435456i32);
pub const navReserved5: BrowserNavConstants = BrowserNavConstants(536870912i32);
pub const navReserved6: BrowserNavConstants = BrowserNavConstants(1073741824i32);
pub const navReserved7: BrowserNavConstants = BrowserNavConstants(-2147483648i32);
impl ::core::marker::Copy for BrowserNavConstants {}
impl ::core::clone::Clone for BrowserNavConstants {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for BrowserNavConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for BrowserNavConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("BrowserNavConstants").field(&self.0).finish()
    }
}
impl FromIntoMemory for BrowserNavConstants {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct CABINETSTATE {
    pub cLength: u16,
    pub nVersion: u16,
    pub _bitfield: i32,
    pub fMenuEnumFilter: u32,
}
impl ::core::marker::Copy for CABINETSTATE {}
impl ::core::clone::Clone for CABINETSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CABINETSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CABINETSTATE")
            .field("cLength", &self.cLength)
            .field("nVersion", &self.nVersion)
            .field("_bitfield", &self._bitfield)
            .field("fMenuEnumFilter", &self.fMenuEnumFilter)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CABINETSTATE {
    fn eq(&self, other: &Self) -> bool {
        self.cLength == other.cLength
            && self.nVersion == other.nVersion
            && self._bitfield == other._bitfield
            && self.fMenuEnumFilter == other.fMenuEnumFilter
    }
}
impl ::core::cmp::Eq for CABINETSTATE {}
impl FromIntoMemory for CABINETSTATE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_cLength = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_nVersion = <u16 as FromIntoMemory>::from_bytes(&from[2..2 + 2]);
        let f__bitfield = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_fMenuEnumFilter = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            cLength: f_cLength,
            nVersion: f_nVersion,
            _bitfield: f__bitfield,
            fMenuEnumFilter: f_fMenuEnumFilter,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.cLength, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.nVersion, &mut into[2..2 + 2]);
        FromIntoMemory::into_bytes(self._bitfield, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.fMenuEnumFilter, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const CABINETSTATE_VERSION: u32 = 2u32;
pub const CAMERAROLL_E_NO_DOWNSAMPLING_REQUIRED: crate::core::HRESULT =
    crate::core::HRESULT(-2144927456i32);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CATEGORYINFO_FLAGS(pub i32);
pub const CATINFO_NORMAL: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(0i32);
pub const CATINFO_COLLAPSED: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(1i32);
pub const CATINFO_HIDDEN: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(2i32);
pub const CATINFO_EXPANDED: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(4i32);
pub const CATINFO_NOHEADER: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(8i32);
pub const CATINFO_NOTCOLLAPSIBLE: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(16i32);
pub const CATINFO_NOHEADERCOUNT: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(32i32);
pub const CATINFO_SUBSETTED: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(64i32);
pub const CATINFO_SEPARATE_IMAGES: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(128i32);
pub const CATINFO_SHOWEMPTY: CATEGORYINFO_FLAGS = CATEGORYINFO_FLAGS(256i32);
impl ::core::marker::Copy for CATEGORYINFO_FLAGS {}
impl ::core::clone::Clone for CATEGORYINFO_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CATEGORYINFO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CATEGORYINFO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CATEGORYINFO_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for CATEGORYINFO_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct CATEGORY_INFO {
    pub cif: CATEGORYINFO_FLAGS,
    pub wszName: [u16; 260],
}
impl ::core::marker::Copy for CATEGORY_INFO {}
impl ::core::clone::Clone for CATEGORY_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CATEGORY_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CATEGORY_INFO")
            .field("cif", &self.cif)
            .field("wszName", &self.wszName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CATEGORY_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.cif == other.cif && self.wszName == other.wszName
    }
}
impl ::core::cmp::Eq for CATEGORY_INFO {}
impl FromIntoMemory for CATEGORY_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 264);
        let f_cif = <CATEGORYINFO_FLAGS as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_wszName = <[u16; 260] as FromIntoMemory>::from_bytes(&from[4..4 + 260]);
        Self {
            cif: f_cif,
            wszName: f_wszName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 264);
        FromIntoMemory::into_bytes(self.cif, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.wszName, &mut into[4..4 + 260]);
    }
    fn size() -> usize {
        264
    }
}
pub const CATID_BrowsableShellExt: crate::core::GUID =
    crate::core::GUID::from_u128(0x00021490_0000_0000_c000_000000000046);
pub const CATID_BrowseInPlace: crate::core::GUID =
    crate::core::GUID::from_u128(0x00021491_0000_0000_c000_000000000046);
pub const CATID_CommBand: crate::core::GUID =
    crate::core::GUID::from_u128(0x00021494_0000_0000_c000_000000000046);
pub const CATID_DeskBand: crate::core::GUID =
    crate::core::GUID::from_u128(0x00021492_0000_0000_c000_000000000046);
pub const CATID_FilePlaceholderMergeHandler: crate::core::GUID =
    crate::core::GUID::from_u128(0x3e9c9a51_d4aa_4870_b47c_7424b491f1cc);
pub const CATID_InfoBand: crate::core::GUID =
    crate::core::GUID::from_u128(0x00021493_0000_0000_c000_000000000046);
pub const CATID_LocationFactory: crate::core::GUID =
    crate::core::GUID::from_u128(0x965c4d51_8b76_4e57_80b7_564d2ea4b55e);
pub const CATID_LocationProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x1b3ca474_2614_414b_b813_1aceca3e3dd8);
pub const CATID_SearchableApplication: crate::core::GUID =
    crate::core::GUID::from_u128(0x366c292a_d9b3_4dbf_bb70_e62ec3d0bbbf);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CATSORT_FLAGS(pub i32);
pub const CATSORT_DEFAULT: CATSORT_FLAGS = CATSORT_FLAGS(0i32);
pub const CATSORT_NAME: CATSORT_FLAGS = CATSORT_FLAGS(1i32);
impl ::core::marker::Copy for CATSORT_FLAGS {}
impl ::core::clone::Clone for CATSORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CATSORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CATSORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CATSORT_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for CATSORT_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const CDB2GVF_ADDSHIELD: u32 = 64u32;
pub const CDB2GVF_ALLOWPREVIEWPANE: u32 = 4u32;
pub const CDB2GVF_ISFILESAVE: u32 = 2u32;
pub const CDB2GVF_ISFOLDERPICKER: u32 = 32u32;
pub const CDB2GVF_NOINCLUDEITEM: u32 = 16u32;
pub const CDB2GVF_NOSELECTVERB: u32 = 8u32;
pub const CDB2GVF_SHOWALLFILES: u32 = 1u32;
pub const CDB2N_CONTEXTMENU_DONE: u32 = 1u32;
pub const CDB2N_CONTEXTMENU_START: u32 = 2u32;
pub const CDBOSC_KILLFOCUS: u32 = 1u32;
pub const CDBOSC_RENAME: u32 = 3u32;
pub const CDBOSC_SELCHANGE: u32 = 2u32;
pub const CDBOSC_SETFOCUS: u32 = 0u32;
pub const CDBOSC_STATECHANGE: u32 = 4u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CDBURNINGEXTENSIONRET(pub i32);
pub const CDBE_RET_DEFAULT: CDBURNINGEXTENSIONRET = CDBURNINGEXTENSIONRET(0i32);
pub const CDBE_RET_DONTRUNOTHEREXTS: CDBURNINGEXTENSIONRET = CDBURNINGEXTENSIONRET(1i32);
pub const CDBE_RET_STOPWIZARD: CDBURNINGEXTENSIONRET = CDBURNINGEXTENSIONRET(2i32);
impl ::core::marker::Copy for CDBURNINGEXTENSIONRET {}
impl ::core::clone::Clone for CDBURNINGEXTENSIONRET {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CDBURNINGEXTENSIONRET {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CDBURNINGEXTENSIONRET {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CDBURNINGEXTENSIONRET")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CDBURNINGEXTENSIONRET {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const CDBurn: crate::core::GUID =
    crate::core::GUID::from_u128(0xfbeb8a05_beee_4442_804e_409d6c4515e9);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CDCONTROLSTATEF(pub i32);
pub const CDCS_INACTIVE: CDCONTROLSTATEF = CDCONTROLSTATEF(0i32);
pub const CDCS_ENABLED: CDCONTROLSTATEF = CDCONTROLSTATEF(1i32);
pub const CDCS_VISIBLE: CDCONTROLSTATEF = CDCONTROLSTATEF(2i32);
pub const CDCS_ENABLEDVISIBLE: CDCONTROLSTATEF = CDCONTROLSTATEF(3i32);
impl ::core::marker::Copy for CDCONTROLSTATEF {}
impl ::core::clone::Clone for CDCONTROLSTATEF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CDCONTROLSTATEF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CDCONTROLSTATEF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CDCONTROLSTATEF").field(&self.0).finish()
    }
}
impl FromIntoMemory for CDCONTROLSTATEF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const CFSTR_AUTOPLAY_SHELLIDLISTS: &'static str = "Autoplay Enumerated IDList Array";
pub const CFSTR_DROPDESCRIPTION: &'static str = "DropDescription";
pub const CFSTR_FILECONTENTS: &'static str = "FileContents";
pub const CFSTR_FILEDESCRIPTOR: &'static str = "FileGroupDescriptorW";
pub const CFSTR_FILEDESCRIPTORA: &'static str = "FileGroupDescriptor";
pub const CFSTR_FILEDESCRIPTORW: &'static str = "FileGroupDescriptorW";
pub const CFSTR_FILENAME: &'static str = "FileNameW";
pub const CFSTR_FILENAMEA: &'static str = "FileName";
pub const CFSTR_FILENAMEMAP: &'static str = "FileNameMapW";
pub const CFSTR_FILENAMEMAPA: &'static str = "FileNameMap";
pub const CFSTR_FILENAMEMAPW: &'static str = "FileNameMapW";
pub const CFSTR_FILENAMEW: &'static str = "FileNameW";
pub const CFSTR_FILE_ATTRIBUTES_ARRAY: &'static str = "File Attributes Array";
pub const CFSTR_INDRAGLOOP: &'static str = "InShellDragLoop";
pub const CFSTR_INETURL: &'static str = "UniformResourceLocatorW";
pub const CFSTR_INETURLA: &'static str = "UniformResourceLocator";
pub const CFSTR_INETURLW: &'static str = "UniformResourceLocatorW";
pub const CFSTR_INVOKECOMMAND_DROPPARAM: &'static str = "InvokeCommand DropParam";
pub const CFSTR_LOGICALPERFORMEDDROPEFFECT: &'static str = "Logical Performed DropEffect";
pub const CFSTR_MOUNTEDVOLUME: &'static str = "MountedVolume";
pub const CFSTR_NETRESOURCES: &'static str = "Net Resource";
pub const CFSTR_PASTESUCCEEDED: &'static str = "Paste Succeeded";
pub const CFSTR_PERFORMEDDROPEFFECT: &'static str = "Performed DropEffect";
pub const CFSTR_PERSISTEDDATAOBJECT: &'static str = "PersistedDataObject";
pub const CFSTR_PREFERREDDROPEFFECT: &'static str = "Preferred DropEffect";
pub const CFSTR_PRINTERGROUP: &'static str = "PrinterFriendlyName";
pub const CFSTR_SHELLDROPHANDLER: &'static str = "DropHandlerCLSID";
pub const CFSTR_SHELLIDLIST: &'static str = "Shell IDList Array";
pub const CFSTR_SHELLIDLISTOFFSET: &'static str = "Shell Object Offsets";
pub const CFSTR_SHELLURL: &'static str = "UniformResourceLocator";
pub const CFSTR_TARGETCLSID: &'static str = "TargetCLSID";
pub const CFSTR_UNTRUSTEDDRAGDROP: &'static str = "UntrustedDragDrop";
pub const CFSTR_ZONEIDENTIFIER: &'static str = "ZoneIdentifier";
pub const CGID_DefView: crate::core::GUID =
    crate::core::GUID::from_u128(0x4af07f10_d231_11d0_b942_00a0c90312e1);
pub const CGID_Explorer: crate::core::GUID =
    crate::core::GUID::from_u128(0x000214d0_0000_0000_c000_000000000046);
pub const CGID_ExplorerBarDoc: crate::core::GUID =
    crate::core::GUID::from_u128(0x000214d3_0000_0000_c000_000000000046);
pub const CGID_MENUDESKBAR: crate::core::GUID =
    crate::core::GUID::from_u128(0x5c9f0a12_959e_11d0_a3a4_00a0c9082636);
pub const CGID_ShellDocView: crate::core::GUID =
    crate::core::GUID::from_u128(0x000214d1_0000_0000_c000_000000000046);
pub const CGID_ShellServiceObject: crate::core::GUID =
    crate::core::GUID::from_u128(0x000214d2_0000_0000_c000_000000000046);
pub const CGID_ShortCut: crate::core::GUID =
    crate::core::GUID::from_u128(0x93a68750_951a_11d1_946f_000000000000);
pub struct CIDA {
    pub cidl: u32,
    pub aoffset: [u32; 1],
}
impl ::core::marker::Copy for CIDA {}
impl ::core::clone::Clone for CIDA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CIDA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CIDA")
            .field("cidl", &self.cidl)
            .field("aoffset", &self.aoffset)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CIDA {
    fn eq(&self, other: &Self) -> bool {
        self.cidl == other.cidl && self.aoffset == other.aoffset
    }
}
impl ::core::cmp::Eq for CIDA {}
impl FromIntoMemory for CIDA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_cidl = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_aoffset = <[u32; 1] as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            cidl: f_cidl,
            aoffset: f_aoffset,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.cidl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.aoffset, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct CIE4ConnectionPoint(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait CIE4ConnectionPoint_Trait: super::super::System::Com::IConnectionPoint_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn DoInvokeIE4(
        &self,
        pf: MutPtr<super::super::Foundation::BOOL>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
        dispid: i32,
        pdispparams: MutPtr<super::super::System::Com::DISPPARAMS>,
    ) -> crate::core::HRESULT {
        todo!("DoInvokeIE4")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn DoInvokePIDLIE4(
        &self,
        dispid: i32,
        pidl: MutPtr<Common::ITEMIDLIST>,
        f_can_cancel: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("DoInvokePIDLIE4")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for CIE4ConnectionPoint {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for CIE4ConnectionPoint {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for CIE4ConnectionPoint {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for CIE4ConnectionPoint {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for CIE4ConnectionPoint {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CIE4ConnectionPoint").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for CIE4ConnectionPoint {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for CIE4ConnectionPoint {
    type Super = super::super::System::Com::IConnectionPoint;
    const IID: crate::core::GUID = crate::core::GUID::zeroed();
}
pub const CLOSEPROPS_DISCARD: u32 = 1u32;
pub const CLOSEPROPS_NONE: u32 = 0u32;
pub const CLSID_ACLCustomMRU: crate::core::GUID =
    crate::core::GUID::from_u128(0x6935db93_21e8_4ccc_beb9_9fe3c77a297a);
pub const CLSID_ACLHistory: crate::core::GUID =
    crate::core::GUID::from_u128(0x00bb2764_6a77_11d0_a535_00c04fd7d062);
pub const CLSID_ACLMRU: crate::core::GUID =
    crate::core::GUID::from_u128(0x6756a641_de71_11d0_831b_00aa005b4383);
pub const CLSID_ACLMulti: crate::core::GUID =
    crate::core::GUID::from_u128(0x00bb2765_6a77_11d0_a535_00c04fd7d062);
pub const CLSID_ACListISF: crate::core::GUID =
    crate::core::GUID::from_u128(0x03c036f1_a186_11d0_824a_00aa005b4383);
pub const CLSID_ActiveDesktop: crate::core::GUID =
    crate::core::GUID::from_u128(0x75048700_ef1f_11d0_9888_006097deacf9);
pub const CLSID_AutoComplete: crate::core::GUID =
    crate::core::GUID::from_u128(0x00bb2763_6a77_11d0_a535_00c04fd7d062);
pub const CLSID_CAnchorBrowsePropertyPage: crate::core::GUID =
    crate::core::GUID::from_u128(0x3050f3bb_98b5_11cf_bb82_00aa00bdce0b);
pub const CLSID_CDocBrowsePropertyPage: crate::core::GUID =
    crate::core::GUID::from_u128(0x3050f3b4_98b5_11cf_bb82_00aa00bdce0b);
pub const CLSID_CFSIconOverlayManager: crate::core::GUID =
    crate::core::GUID::from_u128(0x63b51f81_c868_11d0_999c_00c04fd655e1);
pub const CLSID_CImageBrowsePropertyPage: crate::core::GUID =
    crate::core::GUID::from_u128(0x3050f3b3_98b5_11cf_bb82_00aa00bdce0b);
pub const CLSID_CURLSearchHook: crate::core::GUID =
    crate::core::GUID::from_u128(0xcfbfae00_17a6_11d0_99cb_00c04fd64497);
pub const CLSID_CUrlHistory: crate::core::GUID =
    crate::core::GUID::from_u128(0x3c374a40_bae4_11cf_bf7d_00aa006946ee);
pub const CLSID_ControlPanel: crate::core::GUID =
    crate::core::GUID::from_u128(0x21ec2020_3aea_1069_a2dd_08002b30309d);
pub const CLSID_DarwinAppPublisher: crate::core::GUID =
    crate::core::GUID::from_u128(0xcfccc7a0_a282_11d1_9082_006008059382);
pub const CLSID_DocHostUIHandler: crate::core::GUID =
    crate::core::GUID::from_u128(0x7057e952_bd1b_11d1_8919_00c04fc2c836);
pub const CLSID_DragDropHelper: crate::core::GUID =
    crate::core::GUID::from_u128(0x4657278a_411b_11d2_839a_00c04fd918d0);
pub const CLSID_FileTypes: crate::core::GUID =
    crate::core::GUID::from_u128(0xb091e540_83e3_11cf_a713_0020afd79762);
pub const CLSID_FolderItemsMultiLevel: crate::core::GUID =
    crate::core::GUID::from_u128(0x53c74826_ab99_4d33_aca4_3117f51d3788);
pub const CLSID_FolderShortcut: crate::core::GUID =
    crate::core::GUID::from_u128(0x0afaced1_e828_11d1_9187_b532f1e9575d);
pub const CLSID_HWShellExecute: crate::core::GUID =
    crate::core::GUID::from_u128(0xffb8655f_81b9_4fce_b89c_9a6ba76d13e7);
pub const CLSID_ISFBand: crate::core::GUID =
    crate::core::GUID::from_u128(0xd82be2b0_5764_11d0_a96e_00c04fd705a2);
pub const CLSID_Internet: crate::core::GUID =
    crate::core::GUID::from_u128(0x871c5380_42a0_1069_a2ea_08002b30309d);
pub const CLSID_InternetButtons: crate::core::GUID =
    crate::core::GUID::from_u128(0x1e796980_9cc5_11d1_a83f_00c04fc99d61);
pub const CLSID_InternetShortcut: crate::core::GUID =
    crate::core::GUID::from_u128(0xfbf23b40_e3f0_101b_8488_00aa003e56f8);
pub const CLSID_LinkColumnProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x24f14f02_7b1c_11d1_838f_0000f80461cf);
pub const CLSID_MSOButtons: crate::core::GUID =
    crate::core::GUID::from_u128(0x178f34b8_a282_11d2_86c5_00c04f8eea99);
pub const CLSID_MenuBand: crate::core::GUID =
    crate::core::GUID::from_u128(0x5b4dae26_b807_11d0_9815_00c04fd91972);
pub const CLSID_MenuBandSite: crate::core::GUID =
    crate::core::GUID::from_u128(0xe13ef4e4_d2f2_11d0_9816_00c04fd91972);
pub const CLSID_MenuToolbarBase: crate::core::GUID =
    crate::core::GUID::from_u128(0x40b96610_b522_11d1_b3b4_00aa006efde7);
pub const CLSID_MyComputer: crate::core::GUID =
    crate::core::GUID::from_u128(0x20d04fe0_3aea_1069_a2d8_08002b30309d);
pub const CLSID_MyDocuments: crate::core::GUID =
    crate::core::GUID::from_u128(0x450d8fba_ad25_11d0_98a8_0800361b1103);
pub const CLSID_NetworkDomain: crate::core::GUID =
    crate::core::GUID::from_u128(0x46e06680_4bf0_11d1_83ee_00a0c90dc849);
pub const CLSID_NetworkServer: crate::core::GUID =
    crate::core::GUID::from_u128(0xc0542a90_4bf0_11d1_83ee_00a0c90dc849);
pub const CLSID_NetworkShare: crate::core::GUID =
    crate::core::GUID::from_u128(0x54a754c0_4bf0_11d1_83ee_00a0c90dc849);
pub const CLSID_NewMenu: crate::core::GUID =
    crate::core::GUID::from_u128(0xd969a300_e7ff_11d0_a93b_00a0c90f2719);
pub const CLSID_Printers: crate::core::GUID =
    crate::core::GUID::from_u128(0x2227a280_3aea_1069_a2de_08002b30309d);
pub const CLSID_ProgressDialog: crate::core::GUID =
    crate::core::GUID::from_u128(0xf8383852_fcd3_11d1_a6b9_006097df5bd4);
pub const CLSID_QueryAssociations: crate::core::GUID =
    crate::core::GUID::from_u128(0xa07034fd_6caa_4954_ac3f_97a27216f98a);
pub const CLSID_QuickLinks: crate::core::GUID =
    crate::core::GUID::from_u128(0x0e5cbf21_d15f_11d0_8301_00aa005b4383);
pub const CLSID_RecycleBin: crate::core::GUID =
    crate::core::GUID::from_u128(0x645ff040_5081_101b_9f08_00aa002f954e);
pub const CLSID_ShellFldSetExt: crate::core::GUID =
    crate::core::GUID::from_u128(0x6d5313c0_8c62_11d1_b2cd_006097df8c11);
pub const CLSID_ShellThumbnailDiskCache: crate::core::GUID =
    crate::core::GUID::from_u128(0x1ebdcf80_a200_11d0_a3a4_00c04fd706ec);
pub const CLSID_ToolbarExtButtons: crate::core::GUID =
    crate::core::GUID::from_u128(0x2ce4b5d8_a28f_11d2_86c5_00c04f8eea99);
pub const CMDID_INTSHORTCUTCREATE: i32 = 1i32;
pub const CMDSTR_NEWFOLDER: &'static str = "NewFolder";
pub const CMDSTR_NEWFOLDERA: &'static str = "NewFolder";
pub const CMDSTR_NEWFOLDERW: &'static str = "NewFolder";
pub const CMDSTR_VIEWDETAILS: &'static str = "ViewDetails";
pub const CMDSTR_VIEWDETAILSA: &'static str = "ViewDetails";
pub const CMDSTR_VIEWDETAILSW: &'static str = "ViewDetails";
pub const CMDSTR_VIEWLIST: &'static str = "ViewList";
pub const CMDSTR_VIEWLISTA: &'static str = "ViewList";
pub const CMDSTR_VIEWLISTW: &'static str = "ViewList";
pub const CMF_ASYNCVERBSTATE: u32 = 1024u32;
pub const CMF_CANRENAME: u32 = 16u32;
pub const CMF_DEFAULTONLY: u32 = 1u32;
pub const CMF_DISABLEDVERBS: u32 = 512u32;
pub const CMF_DONOTPICKDEFAULT: u32 = 8192u32;
pub const CMF_EXPLORE: u32 = 4u32;
pub const CMF_EXTENDEDVERBS: u32 = 256u32;
pub const CMF_INCLUDESTATIC: u32 = 64u32;
pub const CMF_ITEMMENU: u32 = 128u32;
pub const CMF_NODEFAULT: u32 = 32u32;
pub const CMF_NORMAL: u32 = 0u32;
pub const CMF_NOVERBS: u32 = 8u32;
pub const CMF_OPTIMIZEFORINVOKE: u32 = 2048u32;
pub const CMF_RESERVED: u32 = 4294901760u32;
pub const CMF_SYNCCASCADEMENU: u32 = 4096u32;
pub const CMF_VERBSONLY: u32 = 2u32;
pub const CMIC_MASK_CONTROL_DOWN: u32 = 1073741824u32;
pub const CMIC_MASK_PTINVOKE: u32 = 536870912u32;
pub const CMIC_MASK_SHIFT_DOWN: u32 = 268435456u32;
pub struct CMINVOKECOMMANDINFO {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub lpVerb: PCSTR,
    pub lpParameters: PCSTR,
    pub lpDirectory: PCSTR,
    pub nShow: i32,
    pub dwHotKey: u32,
    pub hIcon: super::super::Foundation::HANDLE,
}
impl ::core::marker::Copy for CMINVOKECOMMANDINFO {}
impl ::core::clone::Clone for CMINVOKECOMMANDINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CMINVOKECOMMANDINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CMINVOKECOMMANDINFO")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("lpVerb", &self.lpVerb)
            .field("lpParameters", &self.lpParameters)
            .field("lpDirectory", &self.lpDirectory)
            .field("nShow", &self.nShow)
            .field("dwHotKey", &self.dwHotKey)
            .field("hIcon", &self.hIcon)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CMINVOKECOMMANDINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.lpVerb == other.lpVerb
            && self.lpParameters == other.lpParameters
            && self.lpDirectory == other.lpDirectory
            && self.nShow == other.nShow
            && self.dwHotKey == other.dwHotKey
            && self.hIcon == other.hIcon
    }
}
impl ::core::cmp::Eq for CMINVOKECOMMANDINFO {}
impl FromIntoMemory for CMINVOKECOMMANDINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVerb = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpParameters = <PCSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpDirectory = <PCSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_nShow = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwHotKey = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_hIcon =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            lpVerb: f_lpVerb,
            lpParameters: f_lpParameters,
            lpDirectory: f_lpDirectory,
            nShow: f_nShow,
            dwHotKey: f_dwHotKey,
            hIcon: f_hIcon,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVerb, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpParameters, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectory, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.nShow, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwHotKey, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
pub struct CMINVOKECOMMANDINFOEX {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub lpVerb: PCSTR,
    pub lpParameters: PCSTR,
    pub lpDirectory: PCSTR,
    pub nShow: i32,
    pub dwHotKey: u32,
    pub hIcon: super::super::Foundation::HANDLE,
    pub lpTitle: PCSTR,
    pub lpVerbW: PCWSTR,
    pub lpParametersW: PCWSTR,
    pub lpDirectoryW: PCWSTR,
    pub lpTitleW: PCWSTR,
    pub ptInvoke: super::super::Foundation::POINT,
}
impl ::core::marker::Copy for CMINVOKECOMMANDINFOEX {}
impl ::core::clone::Clone for CMINVOKECOMMANDINFOEX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CMINVOKECOMMANDINFOEX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CMINVOKECOMMANDINFOEX")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("lpVerb", &self.lpVerb)
            .field("lpParameters", &self.lpParameters)
            .field("lpDirectory", &self.lpDirectory)
            .field("nShow", &self.nShow)
            .field("dwHotKey", &self.dwHotKey)
            .field("hIcon", &self.hIcon)
            .field("lpTitle", &self.lpTitle)
            .field("lpVerbW", &self.lpVerbW)
            .field("lpParametersW", &self.lpParametersW)
            .field("lpDirectoryW", &self.lpDirectoryW)
            .field("lpTitleW", &self.lpTitleW)
            .field("ptInvoke", &self.ptInvoke)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CMINVOKECOMMANDINFOEX {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.lpVerb == other.lpVerb
            && self.lpParameters == other.lpParameters
            && self.lpDirectory == other.lpDirectory
            && self.nShow == other.nShow
            && self.dwHotKey == other.dwHotKey
            && self.hIcon == other.hIcon
            && self.lpTitle == other.lpTitle
            && self.lpVerbW == other.lpVerbW
            && self.lpParametersW == other.lpParametersW
            && self.lpDirectoryW == other.lpDirectoryW
            && self.lpTitleW == other.lpTitleW
            && self.ptInvoke == other.ptInvoke
    }
}
impl ::core::cmp::Eq for CMINVOKECOMMANDINFOEX {}
impl FromIntoMemory for CMINVOKECOMMANDINFOEX {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 64);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVerb = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpParameters = <PCSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpDirectory = <PCSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_nShow = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwHotKey = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_hIcon =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpTitle = <PCSTR as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpVerbW = <PCWSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpParametersW = <PCWSTR as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_lpDirectoryW = <PCWSTR as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_lpTitleW = <PCWSTR as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_ptInvoke =
            <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[56..56 + 8]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            lpVerb: f_lpVerb,
            lpParameters: f_lpParameters,
            lpDirectory: f_lpDirectory,
            nShow: f_nShow,
            dwHotKey: f_dwHotKey,
            hIcon: f_hIcon,
            lpTitle: f_lpTitle,
            lpVerbW: f_lpVerbW,
            lpParametersW: f_lpParametersW,
            lpDirectoryW: f_lpDirectoryW,
            lpTitleW: f_lpTitleW,
            ptInvoke: f_ptInvoke,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 64);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVerb, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpParameters, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectory, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.nShow, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwHotKey, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpTitle, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpVerbW, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpParametersW, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectoryW, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.lpTitleW, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.ptInvoke, &mut into[56..56 + 8]);
    }
    fn size() -> usize {
        64
    }
}
pub struct CMINVOKECOMMANDINFOEX_REMOTE {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub lpVerbString: PCSTR,
    pub lpParameters: PCSTR,
    pub lpDirectory: PCSTR,
    pub nShow: i32,
    pub dwHotKey: u32,
    pub lpTitle: PCSTR,
    pub lpVerbWString: PCWSTR,
    pub lpParametersW: PCWSTR,
    pub lpDirectoryW: PCWSTR,
    pub lpTitleW: PCWSTR,
    pub ptInvoke: super::super::Foundation::POINT,
    pub lpVerbInt: u32,
    pub lpVerbWInt: u32,
}
impl ::core::marker::Copy for CMINVOKECOMMANDINFOEX_REMOTE {}
impl ::core::clone::Clone for CMINVOKECOMMANDINFOEX_REMOTE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CMINVOKECOMMANDINFOEX_REMOTE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CMINVOKECOMMANDINFOEX_REMOTE")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("lpVerbString", &self.lpVerbString)
            .field("lpParameters", &self.lpParameters)
            .field("lpDirectory", &self.lpDirectory)
            .field("nShow", &self.nShow)
            .field("dwHotKey", &self.dwHotKey)
            .field("lpTitle", &self.lpTitle)
            .field("lpVerbWString", &self.lpVerbWString)
            .field("lpParametersW", &self.lpParametersW)
            .field("lpDirectoryW", &self.lpDirectoryW)
            .field("lpTitleW", &self.lpTitleW)
            .field("ptInvoke", &self.ptInvoke)
            .field("lpVerbInt", &self.lpVerbInt)
            .field("lpVerbWInt", &self.lpVerbWInt)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CMINVOKECOMMANDINFOEX_REMOTE {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.lpVerbString == other.lpVerbString
            && self.lpParameters == other.lpParameters
            && self.lpDirectory == other.lpDirectory
            && self.nShow == other.nShow
            && self.dwHotKey == other.dwHotKey
            && self.lpTitle == other.lpTitle
            && self.lpVerbWString == other.lpVerbWString
            && self.lpParametersW == other.lpParametersW
            && self.lpDirectoryW == other.lpDirectoryW
            && self.lpTitleW == other.lpTitleW
            && self.ptInvoke == other.ptInvoke
            && self.lpVerbInt == other.lpVerbInt
            && self.lpVerbWInt == other.lpVerbWInt
    }
}
impl ::core::cmp::Eq for CMINVOKECOMMANDINFOEX_REMOTE {}
impl FromIntoMemory for CMINVOKECOMMANDINFOEX_REMOTE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 68);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVerbString = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpParameters = <PCSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpDirectory = <PCSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_nShow = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_dwHotKey = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_lpTitle = <PCSTR as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpVerbWString = <PCWSTR as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpParametersW = <PCWSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpDirectoryW = <PCWSTR as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_lpTitleW = <PCWSTR as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_ptInvoke =
            <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[52..52 + 8]);
        let f_lpVerbInt = <u32 as FromIntoMemory>::from_bytes(&from[60..60 + 4]);
        let f_lpVerbWInt = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            lpVerbString: f_lpVerbString,
            lpParameters: f_lpParameters,
            lpDirectory: f_lpDirectory,
            nShow: f_nShow,
            dwHotKey: f_dwHotKey,
            lpTitle: f_lpTitle,
            lpVerbWString: f_lpVerbWString,
            lpParametersW: f_lpParametersW,
            lpDirectoryW: f_lpDirectoryW,
            lpTitleW: f_lpTitleW,
            ptInvoke: f_ptInvoke,
            lpVerbInt: f_lpVerbInt,
            lpVerbWInt: f_lpVerbWInt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 68);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVerbString, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpParameters, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectory, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.nShow, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.dwHotKey, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpTitle, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpVerbWString, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpParametersW, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectoryW, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.lpTitleW, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.ptInvoke, &mut into[52..52 + 8]);
        FromIntoMemory::into_bytes(self.lpVerbInt, &mut into[60..60 + 4]);
        FromIntoMemory::into_bytes(self.lpVerbWInt, &mut into[64..64 + 4]);
    }
    fn size() -> usize {
        68
    }
}
pub struct CM_COLUMNINFO {
    pub cbSize: u32,
    pub dwMask: u32,
    pub dwState: u32,
    pub uWidth: u32,
    pub uDefaultWidth: u32,
    pub uIdealWidth: u32,
    pub wszName: [u16; 80],
}
impl ::core::marker::Copy for CM_COLUMNINFO {}
impl ::core::clone::Clone for CM_COLUMNINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CM_COLUMNINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CM_COLUMNINFO")
            .field("cbSize", &self.cbSize)
            .field("dwMask", &self.dwMask)
            .field("dwState", &self.dwState)
            .field("uWidth", &self.uWidth)
            .field("uDefaultWidth", &self.uDefaultWidth)
            .field("uIdealWidth", &self.uIdealWidth)
            .field("wszName", &self.wszName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CM_COLUMNINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwMask == other.dwMask
            && self.dwState == other.dwState
            && self.uWidth == other.uWidth
            && self.uDefaultWidth == other.uDefaultWidth
            && self.uIdealWidth == other.uIdealWidth
            && self.wszName == other.wszName
    }
}
impl ::core::cmp::Eq for CM_COLUMNINFO {}
impl FromIntoMemory for CM_COLUMNINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 104);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwState = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_uWidth = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_uDefaultWidth = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_uIdealWidth = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_wszName = <[u16; 80] as FromIntoMemory>::from_bytes(&from[24..24 + 80]);
        Self {
            cbSize: f_cbSize,
            dwMask: f_dwMask,
            dwState: f_dwState,
            uWidth: f_uWidth,
            uDefaultWidth: f_uDefaultWidth,
            uIdealWidth: f_uIdealWidth,
            wszName: f_wszName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 104);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwState, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.uWidth, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.uDefaultWidth, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.uIdealWidth, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.wszName, &mut into[24..24 + 80]);
    }
    fn size() -> usize {
        104
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CM_ENUM_FLAGS(pub i32);
pub const CM_ENUM_ALL: CM_ENUM_FLAGS = CM_ENUM_FLAGS(1i32);
pub const CM_ENUM_VISIBLE: CM_ENUM_FLAGS = CM_ENUM_FLAGS(2i32);
impl ::core::marker::Copy for CM_ENUM_FLAGS {}
impl ::core::clone::Clone for CM_ENUM_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CM_ENUM_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CM_ENUM_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CM_ENUM_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for CM_ENUM_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CM_MASK(pub i32);
pub const CM_MASK_WIDTH: CM_MASK = CM_MASK(1i32);
pub const CM_MASK_DEFAULTWIDTH: CM_MASK = CM_MASK(2i32);
pub const CM_MASK_IDEALWIDTH: CM_MASK = CM_MASK(4i32);
pub const CM_MASK_NAME: CM_MASK = CM_MASK(8i32);
pub const CM_MASK_STATE: CM_MASK = CM_MASK(16i32);
impl ::core::marker::Copy for CM_MASK {}
impl ::core::clone::Clone for CM_MASK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CM_MASK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CM_MASK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CM_MASK").field(&self.0).finish()
    }
}
impl FromIntoMemory for CM_MASK {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CM_SET_WIDTH_VALUE(pub i32);
pub const CM_WIDTH_USEDEFAULT: CM_SET_WIDTH_VALUE = CM_SET_WIDTH_VALUE(-1i32);
pub const CM_WIDTH_AUTOSIZE: CM_SET_WIDTH_VALUE = CM_SET_WIDTH_VALUE(-2i32);
impl ::core::marker::Copy for CM_SET_WIDTH_VALUE {}
impl ::core::clone::Clone for CM_SET_WIDTH_VALUE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CM_SET_WIDTH_VALUE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CM_SET_WIDTH_VALUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CM_SET_WIDTH_VALUE").field(&self.0).finish()
    }
}
impl FromIntoMemory for CM_SET_WIDTH_VALUE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CM_STATE(pub i32);
pub const CM_STATE_NONE: CM_STATE = CM_STATE(0i32);
pub const CM_STATE_VISIBLE: CM_STATE = CM_STATE(1i32);
pub const CM_STATE_FIXEDWIDTH: CM_STATE = CM_STATE(2i32);
pub const CM_STATE_NOSORTBYFOLDERNESS: CM_STATE = CM_STATE(4i32);
pub const CM_STATE_ALWAYSVISIBLE: CM_STATE = CM_STATE(8i32);
impl ::core::marker::Copy for CM_STATE {}
impl ::core::clone::Clone for CM_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CM_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CM_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CM_STATE").field(&self.0).finish()
    }
}
impl FromIntoMemory for CM_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const COMPONENT_DEFAULT_LEFT: u32 = 65535u32;
pub const COMPONENT_DEFAULT_TOP: u32 = 65535u32;
pub const COMPONENT_TOP: u32 = 1073741823u32;
pub const COMP_ELEM_CHECKED: u32 = 2u32;
pub const COMP_ELEM_CURITEMSTATE: u32 = 16384u32;
pub const COMP_ELEM_DIRTY: u32 = 4u32;
pub const COMP_ELEM_FRIENDLYNAME: u32 = 1024u32;
pub const COMP_ELEM_NOSCROLL: u32 = 8u32;
pub const COMP_ELEM_ORIGINAL_CSI: u32 = 4096u32;
pub const COMP_ELEM_POS_LEFT: u32 = 16u32;
pub const COMP_ELEM_POS_TOP: u32 = 32u32;
pub const COMP_ELEM_POS_ZINDEX: u32 = 256u32;
pub const COMP_ELEM_RESTORED_CSI: u32 = 8192u32;
pub const COMP_ELEM_SIZE_HEIGHT: u32 = 128u32;
pub const COMP_ELEM_SIZE_WIDTH: u32 = 64u32;
pub const COMP_ELEM_SOURCE: u32 = 512u32;
pub const COMP_ELEM_SUBSCRIBEDURL: u32 = 2048u32;
pub const COMP_ELEM_TYPE: u32 = 1u32;
pub const COMP_TYPE_CFHTML: u32 = 4u32;
pub const COMP_TYPE_CONTROL: u32 = 3u32;
pub const COMP_TYPE_HTMLDOC: u32 = 0u32;
pub const COMP_TYPE_MAX: u32 = 4u32;
pub const COMP_TYPE_PICTURE: u32 = 1u32;
pub const COMP_TYPE_WEBSITE: u32 = 2u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct CONFIRM_CONFLICT_ITEM {
    pub pShellItem: IShellItem2,
    pub pszOriginalName: PWSTR,
    pub pszAlternateName: PWSTR,
    pub pszLocationShort: PWSTR,
    pub pszLocationFull: PWSTR,
    pub nType: SYNCMGR_CONFLICT_ITEM_TYPE,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for CONFIRM_CONFLICT_ITEM {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for CONFIRM_CONFLICT_ITEM {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for CONFIRM_CONFLICT_ITEM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CONFIRM_CONFLICT_ITEM")
            .field("pShellItem", &self.pShellItem)
            .field("pszOriginalName", &self.pszOriginalName)
            .field("pszAlternateName", &self.pszAlternateName)
            .field("pszLocationShort", &self.pszLocationShort)
            .field("pszLocationFull", &self.pszLocationFull)
            .field("nType", &self.nType)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for CONFIRM_CONFLICT_ITEM {
    fn eq(&self, other: &Self) -> bool {
        self.pShellItem == other.pShellItem
            && self.pszOriginalName == other.pszOriginalName
            && self.pszAlternateName == other.pszAlternateName
            && self.pszLocationShort == other.pszLocationShort
            && self.pszLocationFull == other.pszLocationFull
            && self.nType == other.nType
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for CONFIRM_CONFLICT_ITEM {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for CONFIRM_CONFLICT_ITEM {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_pShellItem = <IShellItem2 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszOriginalName = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszAlternateName = <PWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszLocationShort = <PWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pszLocationFull = <PWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_nType = <SYNCMGR_CONFLICT_ITEM_TYPE as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            pShellItem: f_pShellItem,
            pszOriginalName: f_pszOriginalName,
            pszAlternateName: f_pszAlternateName,
            pszLocationShort: f_pszLocationShort,
            pszLocationFull: f_pszLocationFull,
            nType: f_nType,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.pShellItem, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszOriginalName, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszAlternateName, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszLocationShort, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pszLocationFull, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.nType, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct CONFIRM_CONFLICT_RESULT_INFO {
    pub pszNewName: PWSTR,
    pub iItemIndex: u32,
}
impl ::core::marker::Copy for CONFIRM_CONFLICT_RESULT_INFO {}
impl ::core::clone::Clone for CONFIRM_CONFLICT_RESULT_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CONFIRM_CONFLICT_RESULT_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CONFIRM_CONFLICT_RESULT_INFO")
            .field("pszNewName", &self.pszNewName)
            .field("iItemIndex", &self.iItemIndex)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CONFIRM_CONFLICT_RESULT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.pszNewName == other.pszNewName && self.iItemIndex == other.iItemIndex
    }
}
impl ::core::cmp::Eq for CONFIRM_CONFLICT_RESULT_INFO {}
impl FromIntoMemory for CONFIRM_CONFLICT_RESULT_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_pszNewName = <PWSTR as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iItemIndex = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            pszNewName: f_pszNewName,
            iItemIndex: f_iItemIndex,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.pszNewName, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iItemIndex, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub const CONFLICT_RESOLUTION_CLSID_KEY: &'static str = "ConflictResolutionCLSID";
pub const COPYENGINE_E_ACCESSDENIED_READONLY: crate::core::HRESULT =
    crate::core::HRESULT(-2144927681i32);
pub const COPYENGINE_E_ACCESS_DENIED_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927710i32);
pub const COPYENGINE_E_ACCESS_DENIED_SRC: crate::core::HRESULT =
    crate::core::HRESULT(-2144927711i32);
pub const COPYENGINE_E_ALREADY_EXISTS_FOLDER: crate::core::HRESULT =
    crate::core::HRESULT(-2144927700i32);
pub const COPYENGINE_E_ALREADY_EXISTS_NORMAL: crate::core::HRESULT =
    crate::core::HRESULT(-2144927703i32);
pub const COPYENGINE_E_ALREADY_EXISTS_READONLY: crate::core::HRESULT =
    crate::core::HRESULT(-2144927702i32);
pub const COPYENGINE_E_ALREADY_EXISTS_SYSTEM: crate::core::HRESULT =
    crate::core::HRESULT(-2144927701i32);
pub const COPYENGINE_E_BLOCKED_BY_DLP_POLICY: crate::core::HRESULT =
    crate::core::HRESULT(-2144927666i32);
pub const COPYENGINE_E_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927670i32);
pub const COPYENGINE_E_BLOCKED_BY_EDP_POLICY: crate::core::HRESULT =
    crate::core::HRESULT(-2144927672i32);
pub const COPYENGINE_E_CANCELLED: crate::core::HRESULT = crate::core::HRESULT(-2144927743i32);
pub const COPYENGINE_E_CANNOT_MOVE_FROM_RECYCLE_BIN: crate::core::HRESULT =
    crate::core::HRESULT(-2144927677i32);
pub const COPYENGINE_E_CANNOT_MOVE_SHARED_FOLDER: crate::core::HRESULT =
    crate::core::HRESULT(-2144927676i32);
pub const COPYENGINE_E_CANT_REACH_SOURCE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927691i32);
pub const COPYENGINE_E_DEST_IS_RO_CD: crate::core::HRESULT = crate::core::HRESULT(-2144927729i32);
pub const COPYENGINE_E_DEST_IS_RO_DVD: crate::core::HRESULT = crate::core::HRESULT(-2144927726i32);
pub const COPYENGINE_E_DEST_IS_RW_CD: crate::core::HRESULT = crate::core::HRESULT(-2144927728i32);
pub const COPYENGINE_E_DEST_IS_RW_DVD: crate::core::HRESULT = crate::core::HRESULT(-2144927725i32);
pub const COPYENGINE_E_DEST_IS_R_CD: crate::core::HRESULT = crate::core::HRESULT(-2144927727i32);
pub const COPYENGINE_E_DEST_IS_R_DVD: crate::core::HRESULT = crate::core::HRESULT(-2144927724i32);
pub const COPYENGINE_E_DEST_SAME_TREE: crate::core::HRESULT = crate::core::HRESULT(-2144927734i32);
pub const COPYENGINE_E_DEST_SUBTREE: crate::core::HRESULT = crate::core::HRESULT(-2144927735i32);
pub const COPYENGINE_E_DIFF_DIR: crate::core::HRESULT = crate::core::HRESULT(-2144927740i32);
pub const COPYENGINE_E_DIR_NOT_EMPTY: crate::core::HRESULT = crate::core::HRESULT(-2144927683i32);
pub const COPYENGINE_E_DISK_FULL: crate::core::HRESULT = crate::core::HRESULT(-2144927694i32);
pub const COPYENGINE_E_DISK_FULL_CLEAN: crate::core::HRESULT = crate::core::HRESULT(-2144927693i32);
pub const COPYENGINE_E_EA_LOSS: crate::core::HRESULT = crate::core::HRESULT(-2144927698i32);
pub const COPYENGINE_E_EA_NOT_SUPPORTED: crate::core::HRESULT =
    crate::core::HRESULT(-2144927692i32);
pub const COPYENGINE_E_ENCRYPTION_LOSS: crate::core::HRESULT = crate::core::HRESULT(-2144927695i32);
pub const COPYENGINE_E_FAT_MAX_IN_ROOT: crate::core::HRESULT = crate::core::HRESULT(-2144927682i32);
pub const COPYENGINE_E_FILE_IS_FLD_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927732i32);
pub const COPYENGINE_E_FILE_TOO_LARGE: crate::core::HRESULT = crate::core::HRESULT(-2144927731i32);
pub const COPYENGINE_E_FLD_IS_FILE_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927733i32);
pub const COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_ERROR: crate::core::HRESULT =
    crate::core::HRESULT(-2144927675i32);
pub const COPYENGINE_E_INTERNET_ITEM_STORAGE_PROVIDER_PAUSED: crate::core::HRESULT =
    crate::core::HRESULT(-2144927674i32);
pub const COPYENGINE_E_INTERNET_ITEM_UNAVAILABLE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927678i32);
pub const COPYENGINE_E_INVALID_FILES_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927716i32);
pub const COPYENGINE_E_INVALID_FILES_SRC: crate::core::HRESULT =
    crate::core::HRESULT(-2144927717i32);
pub const COPYENGINE_E_MANY_SRC_1_DEST: crate::core::HRESULT = crate::core::HRESULT(-2144927739i32);
pub const COPYENGINE_E_NET_DISCONNECT_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927706i32);
pub const COPYENGINE_E_NET_DISCONNECT_SRC: crate::core::HRESULT =
    crate::core::HRESULT(-2144927707i32);
pub const COPYENGINE_E_NEWFILE_NAME_TOO_LONG: crate::core::HRESULT =
    crate::core::HRESULT(-2144927685i32);
pub const COPYENGINE_E_NEWFOLDER_NAME_TOO_LONG: crate::core::HRESULT =
    crate::core::HRESULT(-2144927684i32);
pub const COPYENGINE_E_PATH_NOT_FOUND_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927708i32);
pub const COPYENGINE_E_PATH_NOT_FOUND_SRC: crate::core::HRESULT =
    crate::core::HRESULT(-2144927709i32);
pub const COPYENGINE_E_PATH_TOO_DEEP_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927714i32);
pub const COPYENGINE_E_PATH_TOO_DEEP_SRC: crate::core::HRESULT =
    crate::core::HRESULT(-2144927715i32);
pub const COPYENGINE_E_PROPERTIES_LOSS: crate::core::HRESULT = crate::core::HRESULT(-2144927696i32);
pub const COPYENGINE_E_PROPERTY_LOSS: crate::core::HRESULT = crate::core::HRESULT(-2144927697i32);
pub const COPYENGINE_E_RECYCLE_BIN_NOT_FOUND: crate::core::HRESULT =
    crate::core::HRESULT(-2144927686i32);
pub const COPYENGINE_E_RECYCLE_FORCE_NUKE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927690i32);
pub const COPYENGINE_E_RECYCLE_PATH_TOO_LONG: crate::core::HRESULT =
    crate::core::HRESULT(-2144927688i32);
pub const COPYENGINE_E_RECYCLE_SIZE_TOO_BIG: crate::core::HRESULT =
    crate::core::HRESULT(-2144927689i32);
pub const COPYENGINE_E_RECYCLE_UNKNOWN_ERROR: crate::core::HRESULT =
    crate::core::HRESULT(-2144927691i32);
pub const COPYENGINE_E_REDIRECTED_TO_WEBPAGE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927680i32);
pub const COPYENGINE_E_REMOVABLE_FULL: crate::core::HRESULT = crate::core::HRESULT(-2144927730i32);
pub const COPYENGINE_E_REQUIRES_EDP_CONSENT: crate::core::HRESULT =
    crate::core::HRESULT(-2144927673i32);
pub const COPYENGINE_E_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927671i32);
pub const COPYENGINE_E_REQUIRES_ELEVATION: crate::core::HRESULT =
    crate::core::HRESULT(-2144927742i32);
pub const COPYENGINE_E_RMS_BLOCKED_BY_EDP_FOR_REMOVABLE_DRIVE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927668i32);
pub const COPYENGINE_E_RMS_REQUIRES_EDP_CONSENT_FOR_REMOVABLE_DRIVE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927669i32);
pub const COPYENGINE_E_ROOT_DIR_DEST: crate::core::HRESULT = crate::core::HRESULT(-2144927712i32);
pub const COPYENGINE_E_ROOT_DIR_SRC: crate::core::HRESULT = crate::core::HRESULT(-2144927713i32);
pub const COPYENGINE_E_SAME_FILE: crate::core::HRESULT = crate::core::HRESULT(-2144927741i32);
pub const COPYENGINE_E_SERVER_BAD_FILE_TYPE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927679i32);
pub const COPYENGINE_E_SHARING_VIOLATION_DEST: crate::core::HRESULT =
    crate::core::HRESULT(-2144927704i32);
pub const COPYENGINE_E_SHARING_VIOLATION_SRC: crate::core::HRESULT =
    crate::core::HRESULT(-2144927705i32);
pub const COPYENGINE_E_SILENT_FAIL_BY_DLP_POLICY: crate::core::HRESULT =
    crate::core::HRESULT(-2144927665i32);
pub const COPYENGINE_E_SRC_IS_RO_CD: crate::core::HRESULT = crate::core::HRESULT(-2144927723i32);
pub const COPYENGINE_E_SRC_IS_RO_DVD: crate::core::HRESULT = crate::core::HRESULT(-2144927720i32);
pub const COPYENGINE_E_SRC_IS_RW_CD: crate::core::HRESULT = crate::core::HRESULT(-2144927722i32);
pub const COPYENGINE_E_SRC_IS_RW_DVD: crate::core::HRESULT = crate::core::HRESULT(-2144927719i32);
pub const COPYENGINE_E_SRC_IS_R_CD: crate::core::HRESULT = crate::core::HRESULT(-2144927721i32);
pub const COPYENGINE_E_SRC_IS_R_DVD: crate::core::HRESULT = crate::core::HRESULT(-2144927718i32);
pub const COPYENGINE_E_STREAM_LOSS: crate::core::HRESULT = crate::core::HRESULT(-2144927699i32);
pub const COPYENGINE_E_USER_CANCELLED: crate::core::HRESULT = crate::core::HRESULT(-2144927744i32);
pub const COPYENGINE_E_WARNED_BY_DLP_POLICY: crate::core::HRESULT =
    crate::core::HRESULT(-2144927667i32);
pub const COPYENGINE_S_ALREADY_DONE: crate::core::HRESULT = crate::core::HRESULT(2555914i32);
pub const COPYENGINE_S_CLOSE_PROGRAM: crate::core::HRESULT = crate::core::HRESULT(2555917i32);
pub const COPYENGINE_S_COLLISIONRESOLVED: crate::core::HRESULT = crate::core::HRESULT(2555918i32);
pub const COPYENGINE_S_DONT_PROCESS_CHILDREN: crate::core::HRESULT =
    crate::core::HRESULT(2555912i32);
pub const COPYENGINE_S_KEEP_BOTH: crate::core::HRESULT = crate::core::HRESULT(2555916i32);
pub const COPYENGINE_S_MERGE: crate::core::HRESULT = crate::core::HRESULT(2555910i32);
pub const COPYENGINE_S_NOT_HANDLED: crate::core::HRESULT = crate::core::HRESULT(2555907i32);
pub const COPYENGINE_S_PENDING: crate::core::HRESULT = crate::core::HRESULT(2555915i32);
pub const COPYENGINE_S_PROGRESS_PAUSE: crate::core::HRESULT = crate::core::HRESULT(2555919i32);
pub const COPYENGINE_S_USER_IGNORED: crate::core::HRESULT = crate::core::HRESULT(2555909i32);
pub const COPYENGINE_S_USER_RETRY: crate::core::HRESULT = crate::core::HRESULT(2555908i32);
pub const COPYENGINE_S_YES: crate::core::HRESULT = crate::core::HRESULT(2555905i32);
pub const CPFG_CREDENTIAL_PROVIDER_LABEL: crate::core::GUID =
    crate::core::GUID::from_u128(0x286bbff3_bad4_438f_b007_79b7267c3d48);
pub const CPFG_CREDENTIAL_PROVIDER_LOGO: crate::core::GUID =
    crate::core::GUID::from_u128(0x2d837775_f6cd_464e_a745_482fd0b47493);
pub const CPFG_LOGON_PASSWORD: crate::core::GUID =
    crate::core::GUID::from_u128(0x60624cfa_a477_47b1_8a8e_3a4a19981827);
pub const CPFG_LOGON_USERNAME: crate::core::GUID =
    crate::core::GUID::from_u128(0xda15bbe8_954d_4fd3_b0f4_1fb5b90b174b);
pub const CPFG_SMARTCARD_PIN: crate::core::GUID =
    crate::core::GUID::from_u128(0x4fe5263b_9181_46c1_b0a4_9dedd4db7dea);
pub const CPFG_SMARTCARD_USERNAME: crate::core::GUID =
    crate::core::GUID::from_u128(0x3e1ecf69_568c_4d96_9d59_46444174e2d6);
pub const CPFG_STANDALONE_SUBMIT_BUTTON: crate::core::GUID =
    crate::core::GUID::from_u128(0x0b7b0ad8_cc36_4d59_802b_82f714fa7022);
pub const CPFG_STYLE_LINK_AS_BUTTON: crate::core::GUID =
    crate::core::GUID::from_u128(0x088fa508_94a6_4430_a4cb_6fc6e3c0b9e2);
pub struct CPLINFO {
    pub idIcon: i32,
    pub idName: i32,
    pub idInfo: i32,
    pub lData: PtrDiffRepr,
}
impl ::core::marker::Copy for CPLINFO {}
impl ::core::clone::Clone for CPLINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CPLINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CPLINFO")
            .field("idIcon", &self.idIcon)
            .field("idName", &self.idName)
            .field("idInfo", &self.idInfo)
            .field("lData", &self.lData)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CPLINFO {
    fn eq(&self, other: &Self) -> bool {
        self.idIcon == other.idIcon
            && self.idName == other.idName
            && self.idInfo == other.idInfo
            && self.lData == other.lData
    }
}
impl ::core::cmp::Eq for CPLINFO {}
impl FromIntoMemory for CPLINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_idIcon = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_idName = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_idInfo = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lData = <PtrDiffRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            idIcon: f_idIcon,
            idName: f_idName,
            idInfo: f_idInfo,
            lData: f_lData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.idIcon, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.idName, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.idInfo, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lData, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const CPLPAGE_DISPLAY_BACKGROUND: u32 = 1u32;
pub const CPLPAGE_KEYBOARD_SPEED: u32 = 1u32;
pub const CPLPAGE_MOUSE_BUTTONS: u32 = 1u32;
pub const CPLPAGE_MOUSE_PTRMOTION: u32 = 2u32;
pub const CPLPAGE_MOUSE_WHEEL: u32 = 3u32;
pub const CPL_DBLCLK: u32 = 5u32;
pub const CPL_DYNAMIC_RES: u32 = 0u32;
pub const CPL_EXIT: u32 = 7u32;
pub const CPL_GETCOUNT: u32 = 2u32;
pub const CPL_INIT: u32 = 1u32;
pub const CPL_INQUIRE: u32 = 3u32;
pub const CPL_NEWINQUIRE: u32 = 8u32;
pub const CPL_SELECT: u32 = 4u32;
pub const CPL_SETUP: u32 = 200u32;
pub const CPL_STARTWPARMS: u32 = 10u32;
pub const CPL_STARTWPARMSA: u32 = 9u32;
pub const CPL_STARTWPARMSW: u32 = 10u32;
pub const CPL_STOP: u32 = 6u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CPVIEW(pub i32);
pub const CPVIEW_CLASSIC: CPVIEW = CPVIEW(0i32);
pub const CPVIEW_ALLITEMS: CPVIEW = CPVIEW(0i32);
pub const CPVIEW_CATEGORY: CPVIEW = CPVIEW(1i32);
pub const CPVIEW_HOME: CPVIEW = CPVIEW(1i32);
impl ::core::marker::Copy for CPVIEW {}
impl ::core::clone::Clone for CPVIEW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CPVIEW {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CPVIEW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CPVIEW").field(&self.0).finish()
    }
}
impl FromIntoMemory for CPVIEW {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS(pub i32);
pub const CPAO_NONE: CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS =
    CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS(0i32);
pub const CPAO_EMPTY_LOCAL: CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS =
    CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS(1i32);
pub const CPAO_EMPTY_CONNECTED: CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS =
    CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS(2i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS(pub i32);
pub const CPCFO_NONE: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS =
    CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS(0i32);
pub const CPCFO_ENABLE_PASSWORD_REVEAL: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS =
    CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS(1i32);
pub const CPCFO_IS_EMAIL_ADDRESS: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS =
    CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS(2i32);
pub const CPCFO_ENABLE_TOUCH_KEYBOARD_AUTO_INVOKE: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS =
    CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS(4i32);
pub const CPCFO_NUMBERS_ONLY: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS =
    CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS(8i32);
pub const CPCFO_SHOW_ENGLISH_KEYBOARD: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS =
    CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS(16i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {
    pub ulAuthenticationPackage: u32,
    pub clsidCredentialProvider: crate::core::GUID,
    pub cbSerialization: u32,
    pub rgbSerialization: MutPtr<u8>,
}
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION")
            .field("ulAuthenticationPackage", &self.ulAuthenticationPackage)
            .field("clsidCredentialProvider", &self.clsidCredentialProvider)
            .field("cbSerialization", &self.cbSerialization)
            .field("rgbSerialization", &self.rgbSerialization)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {
    fn eq(&self, other: &Self) -> bool {
        self.ulAuthenticationPackage == other.ulAuthenticationPackage
            && self.clsidCredentialProvider == other.clsidCredentialProvider
            && self.cbSerialization == other.cbSerialization
            && self.rgbSerialization == other.rgbSerialization
    }
}
impl ::core::cmp::Eq for CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {}
impl FromIntoMemory for CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_ulAuthenticationPackage = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_clsidCredentialProvider =
            <crate::core::GUID as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        let f_cbSerialization = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_rgbSerialization = <MutPtr<u8> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            ulAuthenticationPackage: f_ulAuthenticationPackage,
            clsidCredentialProvider: f_clsidCredentialProvider,
            cbSerialization: f_cbSerialization,
            rgbSerialization: f_rgbSerialization,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.ulAuthenticationPackage, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.clsidCredentialProvider, &mut into[4..4 + 16]);
        FromIntoMemory::into_bytes(self.cbSerialization, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.rgbSerialization, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {
    pub dwFieldID: u32,
    pub cpft: CREDENTIAL_PROVIDER_FIELD_TYPE,
    pub pszLabel: PWSTR,
    pub guidFieldType: crate::core::GUID,
}
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR")
            .field("dwFieldID", &self.dwFieldID)
            .field("cpft", &self.cpft)
            .field("pszLabel", &self.pszLabel)
            .field("guidFieldType", &self.guidFieldType)
            .finish()
    }
}
impl ::core::cmp::PartialEq for CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.dwFieldID == other.dwFieldID
            && self.cpft == other.cpft
            && self.pszLabel == other.pszLabel
            && self.guidFieldType == other.guidFieldType
    }
}
impl ::core::cmp::Eq for CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {}
impl FromIntoMemory for CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_dwFieldID = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_cpft =
            <CREDENTIAL_PROVIDER_FIELD_TYPE as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszLabel = <PWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_guidFieldType = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        Self {
            dwFieldID: f_dwFieldID,
            cpft: f_cpft,
            pszLabel: f_pszLabel,
            guidFieldType: f_guidFieldType,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.dwFieldID, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.cpft, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszLabel, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.guidFieldType, &mut into[12..12 + 16]);
    }
    fn size() -> usize {
        28
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE(pub i32);
pub const CPFIS_NONE: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE =
    CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE(0i32);
pub const CPFIS_READONLY: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE =
    CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE(1i32);
pub const CPFIS_DISABLED: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE =
    CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE(2i32);
pub const CPFIS_FOCUSED: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE =
    CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE(3i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_FIELD_STATE(pub i32);
pub const CPFS_HIDDEN: CREDENTIAL_PROVIDER_FIELD_STATE = CREDENTIAL_PROVIDER_FIELD_STATE(0i32);
pub const CPFS_DISPLAY_IN_SELECTED_TILE: CREDENTIAL_PROVIDER_FIELD_STATE =
    CREDENTIAL_PROVIDER_FIELD_STATE(1i32);
pub const CPFS_DISPLAY_IN_DESELECTED_TILE: CREDENTIAL_PROVIDER_FIELD_STATE =
    CREDENTIAL_PROVIDER_FIELD_STATE(2i32);
pub const CPFS_DISPLAY_IN_BOTH: CREDENTIAL_PROVIDER_FIELD_STATE =
    CREDENTIAL_PROVIDER_FIELD_STATE(3i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_FIELD_STATE {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_FIELD_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_FIELD_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_FIELD_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_FIELD_STATE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_FIELD_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_FIELD_TYPE(pub i32);
pub const CPFT_INVALID: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(0i32);
pub const CPFT_LARGE_TEXT: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(1i32);
pub const CPFT_SMALL_TEXT: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(2i32);
pub const CPFT_COMMAND_LINK: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(3i32);
pub const CPFT_EDIT_TEXT: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(4i32);
pub const CPFT_PASSWORD_TEXT: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(5i32);
pub const CPFT_TILE_IMAGE: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(6i32);
pub const CPFT_CHECKBOX: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(7i32);
pub const CPFT_COMBOBOX: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(8i32);
pub const CPFT_SUBMIT_BUTTON: CREDENTIAL_PROVIDER_FIELD_TYPE = CREDENTIAL_PROVIDER_FIELD_TYPE(9i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_FIELD_TYPE {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_FIELD_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_FIELD_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_FIELD_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_FIELD_TYPE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_FIELD_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE(pub i32);
pub const CPGSR_NO_CREDENTIAL_NOT_FINISHED: CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE =
    CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE(0i32);
pub const CPGSR_NO_CREDENTIAL_FINISHED: CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE =
    CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE(1i32);
pub const CPGSR_RETURN_CREDENTIAL_FINISHED: CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE =
    CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE(2i32);
pub const CPGSR_RETURN_NO_CREDENTIAL_FINISHED: CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE =
    CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE(3i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const CREDENTIAL_PROVIDER_NO_DEFAULT: u32 = 4294967295u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_STATUS_ICON(pub i32);
pub const CPSI_NONE: CREDENTIAL_PROVIDER_STATUS_ICON = CREDENTIAL_PROVIDER_STATUS_ICON(0i32);
pub const CPSI_ERROR: CREDENTIAL_PROVIDER_STATUS_ICON = CREDENTIAL_PROVIDER_STATUS_ICON(1i32);
pub const CPSI_WARNING: CREDENTIAL_PROVIDER_STATUS_ICON = CREDENTIAL_PROVIDER_STATUS_ICON(2i32);
pub const CPSI_SUCCESS: CREDENTIAL_PROVIDER_STATUS_ICON = CREDENTIAL_PROVIDER_STATUS_ICON(3i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_STATUS_ICON {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_STATUS_ICON {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_STATUS_ICON {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_STATUS_ICON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_STATUS_ICON")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_STATUS_ICON {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CREDENTIAL_PROVIDER_USAGE_SCENARIO(pub i32);
pub const CPUS_INVALID: CREDENTIAL_PROVIDER_USAGE_SCENARIO =
    CREDENTIAL_PROVIDER_USAGE_SCENARIO(0i32);
pub const CPUS_LOGON: CREDENTIAL_PROVIDER_USAGE_SCENARIO = CREDENTIAL_PROVIDER_USAGE_SCENARIO(1i32);
pub const CPUS_UNLOCK_WORKSTATION: CREDENTIAL_PROVIDER_USAGE_SCENARIO =
    CREDENTIAL_PROVIDER_USAGE_SCENARIO(2i32);
pub const CPUS_CHANGE_PASSWORD: CREDENTIAL_PROVIDER_USAGE_SCENARIO =
    CREDENTIAL_PROVIDER_USAGE_SCENARIO(3i32);
pub const CPUS_CREDUI: CREDENTIAL_PROVIDER_USAGE_SCENARIO =
    CREDENTIAL_PROVIDER_USAGE_SCENARIO(4i32);
pub const CPUS_PLAP: CREDENTIAL_PROVIDER_USAGE_SCENARIO = CREDENTIAL_PROVIDER_USAGE_SCENARIO(5i32);
impl ::core::marker::Copy for CREDENTIAL_PROVIDER_USAGE_SCENARIO {}
impl ::core::clone::Clone for CREDENTIAL_PROVIDER_USAGE_SCENARIO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CREDENTIAL_PROVIDER_USAGE_SCENARIO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CREDENTIAL_PROVIDER_USAGE_SCENARIO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CREDENTIAL_PROVIDER_USAGE_SCENARIO")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CREDENTIAL_PROVIDER_USAGE_SCENARIO {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct CSFV {
    pub cbSize: u32,
    pub pshf: IShellFolder,
    pub psvOuter: IShellView,
    pub pidl: MutPtr<Common::ITEMIDLIST>,
    pub lEvents: i32,
    pub pfnCallback: LPFNVIEWCALLBACK,
    pub fvm: FOLDERVIEWMODE,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for CSFV {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for CSFV {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for CSFV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSFV")
            .field("cbSize", &self.cbSize)
            .field("pshf", &self.pshf)
            .field("psvOuter", &self.psvOuter)
            .field("pidl", &self.pidl)
            .field("lEvents", &self.lEvents)
            .field("pfnCallback", &self.pfnCallback)
            .field("fvm", &self.fvm)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for CSFV {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.pshf == other.pshf
            && self.psvOuter == other.psvOuter
            && self.pidl == other.pidl
            && self.lEvents == other.lEvents
            && self.pfnCallback == other.pfnCallback
            && self.fvm == other.fvm
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for CSFV {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for CSFV {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pshf = <IShellFolder as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_psvOuter = <IShellView as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pidl = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lEvents = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pfnCallback = <LPFNVIEWCALLBACK as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_fvm = <FOLDERVIEWMODE as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            cbSize: f_cbSize,
            pshf: f_pshf,
            psvOuter: f_psvOuter,
            pidl: f_pidl,
            lEvents: f_lEvents,
            pfnCallback: f_pfnCallback,
            fvm: f_fvm,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pshf, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.psvOuter, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pidl, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lEvents, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pfnCallback, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.fvm, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub const CSIDL_ADMINTOOLS: u32 = 48u32;
pub const CSIDL_ALTSTARTUP: u32 = 29u32;
pub const CSIDL_APPDATA: u32 = 26u32;
pub const CSIDL_BITBUCKET: u32 = 10u32;
pub const CSIDL_CDBURN_AREA: u32 = 59u32;
pub const CSIDL_COMMON_ADMINTOOLS: u32 = 47u32;
pub const CSIDL_COMMON_ALTSTARTUP: u32 = 30u32;
pub const CSIDL_COMMON_APPDATA: u32 = 35u32;
pub const CSIDL_COMMON_DESKTOPDIRECTORY: u32 = 25u32;
pub const CSIDL_COMMON_DOCUMENTS: u32 = 46u32;
pub const CSIDL_COMMON_FAVORITES: u32 = 31u32;
pub const CSIDL_COMMON_MUSIC: u32 = 53u32;
pub const CSIDL_COMMON_OEM_LINKS: u32 = 58u32;
pub const CSIDL_COMMON_PICTURES: u32 = 54u32;
pub const CSIDL_COMMON_PROGRAMS: u32 = 23u32;
pub const CSIDL_COMMON_STARTMENU: u32 = 22u32;
pub const CSIDL_COMMON_STARTUP: u32 = 24u32;
pub const CSIDL_COMMON_TEMPLATES: u32 = 45u32;
pub const CSIDL_COMMON_VIDEO: u32 = 55u32;
pub const CSIDL_COMPUTERSNEARME: u32 = 61u32;
pub const CSIDL_CONNECTIONS: u32 = 49u32;
pub const CSIDL_CONTROLS: u32 = 3u32;
pub const CSIDL_COOKIES: u32 = 33u32;
pub const CSIDL_DESKTOP: u32 = 0u32;
pub const CSIDL_DESKTOPDIRECTORY: u32 = 16u32;
pub const CSIDL_DRIVES: u32 = 17u32;
pub const CSIDL_FAVORITES: u32 = 6u32;
pub const CSIDL_FLAG_CREATE: u32 = 32768u32;
pub const CSIDL_FLAG_DONT_UNEXPAND: u32 = 8192u32;
pub const CSIDL_FLAG_DONT_VERIFY: u32 = 16384u32;
pub const CSIDL_FLAG_MASK: u32 = 65280u32;
pub const CSIDL_FLAG_NO_ALIAS: u32 = 4096u32;
pub const CSIDL_FLAG_PER_USER_INIT: u32 = 2048u32;
pub const CSIDL_FLAG_PFTI_TRACKTARGET: u32 = 16384u32;
pub const CSIDL_FONTS: u32 = 20u32;
pub const CSIDL_HISTORY: u32 = 34u32;
pub const CSIDL_INTERNET: u32 = 1u32;
pub const CSIDL_INTERNET_CACHE: u32 = 32u32;
pub const CSIDL_LOCAL_APPDATA: u32 = 28u32;
pub const CSIDL_MYDOCUMENTS: u32 = 5u32;
pub const CSIDL_MYMUSIC: u32 = 13u32;
pub const CSIDL_MYPICTURES: u32 = 39u32;
pub const CSIDL_MYVIDEO: u32 = 14u32;
pub const CSIDL_NETHOOD: u32 = 19u32;
pub const CSIDL_NETWORK: u32 = 18u32;
pub const CSIDL_PERSONAL: u32 = 5u32;
pub const CSIDL_PRINTERS: u32 = 4u32;
pub const CSIDL_PRINTHOOD: u32 = 27u32;
pub const CSIDL_PROFILE: u32 = 40u32;
pub const CSIDL_PROGRAMS: u32 = 2u32;
pub const CSIDL_PROGRAM_FILES: u32 = 38u32;
pub const CSIDL_PROGRAM_FILESX86: u32 = 42u32;
pub const CSIDL_PROGRAM_FILES_COMMON: u32 = 43u32;
pub const CSIDL_PROGRAM_FILES_COMMONX86: u32 = 44u32;
pub const CSIDL_RECENT: u32 = 8u32;
pub const CSIDL_RESOURCES: u32 = 56u32;
pub const CSIDL_RESOURCES_LOCALIZED: u32 = 57u32;
pub const CSIDL_SENDTO: u32 = 9u32;
pub const CSIDL_STARTMENU: u32 = 11u32;
pub const CSIDL_STARTUP: u32 = 7u32;
pub const CSIDL_SYSTEM: u32 = 37u32;
pub const CSIDL_SYSTEMX86: u32 = 41u32;
pub const CSIDL_TEMPLATES: u32 = 21u32;
pub const CSIDL_WINDOWS: u32 = 36u32;
pub const CScriptErrorList: crate::core::GUID =
    crate::core::GUID::from_u128(0xefd01300_160f_11d2_bb2e_00805ff7efca);
pub const CTF_COINIT: i32 = 8i32;
pub const CTF_COINIT_MTA: i32 = 4096i32;
pub const CTF_COINIT_STA: i32 = 8i32;
pub const CTF_FREELIBANDEXIT: i32 = 16i32;
pub const CTF_INHERITWOW64: i32 = 256i32;
pub const CTF_INSIST: i32 = 1i32;
pub const CTF_KEYBOARD_LOCALE: i32 = 1024i32;
pub const CTF_NOADDREFLIB: i32 = 8192i32;
pub const CTF_OLEINITIALIZE: i32 = 2048i32;
pub const CTF_PROCESS_REF: i32 = 4i32;
pub const CTF_REF_COUNTED: i32 = 32i32;
pub const CTF_THREAD_REF: i32 = 2i32;
pub const CTF_UNUSED: i32 = 128i32;
pub const CTF_WAIT_ALLOWCOM: i32 = 64i32;
pub const CTF_WAIT_NO_REENTRANCY: i32 = 512i32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct CommandStateChangeConstants(pub i32);
pub const CSC_UPDATECOMMANDS: CommandStateChangeConstants = CommandStateChangeConstants(-1i32);
pub const CSC_NAVIGATEFORWARD: CommandStateChangeConstants = CommandStateChangeConstants(1i32);
pub const CSC_NAVIGATEBACK: CommandStateChangeConstants = CommandStateChangeConstants(2i32);
impl ::core::marker::Copy for CommandStateChangeConstants {}
impl ::core::clone::Clone for CommandStateChangeConstants {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CommandStateChangeConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for CommandStateChangeConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CommandStateChangeConstants")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for CommandStateChangeConstants {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const ConflictFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x289978ac_a101_4341_a817_21eba7fd046d);
pub struct DATABLOCK_HEADER {
    pub cbSize: u32,
    pub dwSignature: u32,
}
impl ::core::marker::Copy for DATABLOCK_HEADER {}
impl ::core::clone::Clone for DATABLOCK_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DATABLOCK_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DATABLOCK_HEADER")
            .field("cbSize", &self.cbSize)
            .field("dwSignature", &self.dwSignature)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DATABLOCK_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize && self.dwSignature == other.dwSignature
    }
}
impl ::core::cmp::Eq for DATABLOCK_HEADER {}
impl FromIntoMemory for DATABLOCK_HEADER {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSignature = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            cbSize: f_cbSize,
            dwSignature: f_dwSignature,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSignature, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DATAOBJ_GET_ITEM_FLAGS(pub i32);
pub const DOGIF_DEFAULT: DATAOBJ_GET_ITEM_FLAGS = DATAOBJ_GET_ITEM_FLAGS(0i32);
pub const DOGIF_TRAVERSE_LINK: DATAOBJ_GET_ITEM_FLAGS = DATAOBJ_GET_ITEM_FLAGS(1i32);
pub const DOGIF_NO_HDROP: DATAOBJ_GET_ITEM_FLAGS = DATAOBJ_GET_ITEM_FLAGS(2i32);
pub const DOGIF_NO_URL: DATAOBJ_GET_ITEM_FLAGS = DATAOBJ_GET_ITEM_FLAGS(4i32);
pub const DOGIF_ONLY_IF_ONE: DATAOBJ_GET_ITEM_FLAGS = DATAOBJ_GET_ITEM_FLAGS(8i32);
impl ::core::marker::Copy for DATAOBJ_GET_ITEM_FLAGS {}
impl ::core::clone::Clone for DATAOBJ_GET_ITEM_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DATAOBJ_GET_ITEM_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DATAOBJ_GET_ITEM_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DATAOBJ_GET_ITEM_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for DATAOBJ_GET_ITEM_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const DBCID_CLSIDOFBAR: i32 = 2i32;
pub const DBCID_EMPTY: i32 = 0i32;
pub const DBCID_GETBAR: i32 = 4i32;
pub const DBCID_ONDRAG: i32 = 1i32;
pub const DBCID_RESIZE: i32 = 3i32;
pub const DBCID_UPDATESIZE: i32 = 5i32;
pub const DBC_GS_IDEAL: u32 = 0u32;
pub const DBC_GS_SIZEDOWN: u32 = 1u32;
pub const DBC_HIDE: u32 = 0u32;
pub const DBC_SHOW: u32 = 1u32;
pub const DBC_SHOWOBSCURE: u32 = 2u32;
pub const DBIF_VIEWMODE_FLOATING: u32 = 2u32;
pub const DBIF_VIEWMODE_NORMAL: u32 = 0u32;
pub const DBIF_VIEWMODE_TRANSPARENT: u32 = 4u32;
pub const DBIF_VIEWMODE_VERTICAL: u32 = 1u32;
pub const DBIMF_ADDTOFRONT: u32 = 512u32;
pub const DBIMF_ALWAYSGRIPPER: u32 = 4096u32;
pub const DBIMF_BKCOLOR: u32 = 64u32;
pub const DBIMF_BREAK: u32 = 256u32;
pub const DBIMF_DEBOSSED: u32 = 32u32;
pub const DBIMF_FIXED: u32 = 1u32;
pub const DBIMF_FIXEDBMP: u32 = 4u32;
pub const DBIMF_NOGRIPPER: u32 = 2048u32;
pub const DBIMF_NOMARGINS: u32 = 8192u32;
pub const DBIMF_NORMAL: u32 = 0u32;
pub const DBIMF_TOPALIGN: u32 = 1024u32;
pub const DBIMF_UNDELETEABLE: u32 = 16u32;
pub const DBIMF_USECHEVRON: u32 = 128u32;
pub const DBIMF_VARIABLEHEIGHT: u32 = 8u32;
pub const DBIM_ACTUAL: u32 = 8u32;
pub const DBIM_BKCOLOR: u32 = 64u32;
pub const DBIM_INTEGRAL: u32 = 4u32;
pub const DBIM_MAXSIZE: u32 = 2u32;
pub const DBIM_MINSIZE: u32 = 1u32;
pub const DBIM_MODEFLAGS: u32 = 32u32;
pub const DBIM_TITLE: u32 = 16u32;
pub const DBPC_SELECTFIRST: u32 = 4294967295u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DEFAULTSAVEFOLDERTYPE(pub i32);
pub const DSFT_DETECT: DEFAULTSAVEFOLDERTYPE = DEFAULTSAVEFOLDERTYPE(1i32);
pub const DSFT_PRIVATE: DEFAULTSAVEFOLDERTYPE = DEFAULTSAVEFOLDERTYPE(2i32);
pub const DSFT_PUBLIC: DEFAULTSAVEFOLDERTYPE = DEFAULTSAVEFOLDERTYPE(3i32);
impl ::core::marker::Copy for DEFAULTSAVEFOLDERTYPE {}
impl ::core::clone::Clone for DEFAULTSAVEFOLDERTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DEFAULTSAVEFOLDERTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DEFAULTSAVEFOLDERTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DEFAULTSAVEFOLDERTYPE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for DEFAULTSAVEFOLDERTYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DEFAULT_FOLDER_MENU_RESTRICTIONS(pub i32);
pub const DFMR_DEFAULT: DEFAULT_FOLDER_MENU_RESTRICTIONS = DEFAULT_FOLDER_MENU_RESTRICTIONS(0i32);
pub const DFMR_NO_STATIC_VERBS: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(8i32);
pub const DFMR_STATIC_VERBS_ONLY: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(16i32);
pub const DFMR_NO_RESOURCE_VERBS: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(32i32);
pub const DFMR_OPTIN_HANDLERS_ONLY: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(64i32);
pub const DFMR_RESOURCE_AND_FOLDER_VERBS_ONLY: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(128i32);
pub const DFMR_USE_SPECIFIED_HANDLERS: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(256i32);
pub const DFMR_USE_SPECIFIED_VERBS: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(512i32);
pub const DFMR_NO_ASYNC_VERBS: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(1024i32);
pub const DFMR_NO_NATIVECPU_VERBS: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(2048i32);
pub const DFMR_NO_NONWOW_VERBS: DEFAULT_FOLDER_MENU_RESTRICTIONS =
    DEFAULT_FOLDER_MENU_RESTRICTIONS(4096i32);
impl ::core::marker::Copy for DEFAULT_FOLDER_MENU_RESTRICTIONS {}
impl ::core::clone::Clone for DEFAULT_FOLDER_MENU_RESTRICTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DEFAULT_FOLDER_MENU_RESTRICTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DEFAULT_FOLDER_MENU_RESTRICTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DEFAULT_FOLDER_MENU_RESTRICTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for DEFAULT_FOLDER_MENU_RESTRICTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DEFCONTEXTMENU {
    pub hwnd: super::super::Foundation::HWND,
    pub pcmcb: IContextMenuCB,
    pub pidlFolder: MutPtr<Common::ITEMIDLIST>,
    pub psf: IShellFolder,
    pub cidl: u32,
    pub apidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    pub punkAssociationInfo: crate::core::IUnknown,
    pub cKeys: u32,
    pub aKeys: ConstPtr<super::super::System::Registry::HKEY>,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DEFCONTEXTMENU {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DEFCONTEXTMENU {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DEFCONTEXTMENU {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DEFCONTEXTMENU")
            .field("hwnd", &self.hwnd)
            .field("pcmcb", &self.pcmcb)
            .field("pidlFolder", &self.pidlFolder)
            .field("psf", &self.psf)
            .field("cidl", &self.cidl)
            .field("apidl", &self.apidl)
            .field("punkAssociationInfo", &self.punkAssociationInfo)
            .field("cKeys", &self.cKeys)
            .field("aKeys", &self.aKeys)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DEFCONTEXTMENU {
    fn eq(&self, other: &Self) -> bool {
        self.hwnd == other.hwnd
            && self.pcmcb == other.pcmcb
            && self.pidlFolder == other.pidlFolder
            && self.psf == other.psf
            && self.cidl == other.cidl
            && self.apidl == other.apidl
            && self.punkAssociationInfo == other.punkAssociationInfo
            && self.cKeys == other.cKeys
            && self.aKeys == other.aKeys
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DEFCONTEXTMENU {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DEFCONTEXTMENU {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pcmcb = <IContextMenuCB as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pidlFolder =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_psf = <IShellFolder as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_cidl = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_apidl =
            <MutPtr<ConstPtr<Common::ITEMIDLIST>> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_punkAssociationInfo =
            <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_cKeys = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_aKeys =
            <ConstPtr<super::super::System::Registry::HKEY> as FromIntoMemory>::from_bytes(
                &from[32..32 + 4],
            );
        Self {
            hwnd: f_hwnd,
            pcmcb: f_pcmcb,
            pidlFolder: f_pidlFolder,
            psf: f_psf,
            cidl: f_cidl,
            apidl: f_apidl,
            punkAssociationInfo: f_punkAssociationInfo,
            cKeys: f_cKeys,
            aKeys: f_aKeys,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pcmcb, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pidlFolder, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.psf, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.cidl, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.apidl, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.punkAssociationInfo, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.cKeys, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.aKeys, &mut into[32..32 + 4]);
    }
    fn size() -> usize {
        36
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DEF_SHARE_ID(pub i32);
pub const DEFSHAREID_USERS: DEF_SHARE_ID = DEF_SHARE_ID(1i32);
pub const DEFSHAREID_PUBLIC: DEF_SHARE_ID = DEF_SHARE_ID(2i32);
impl ::core::marker::Copy for DEF_SHARE_ID {}
impl ::core::clone::Clone for DEF_SHARE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DEF_SHARE_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DEF_SHARE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DEF_SHARE_ID").field(&self.0).finish()
    }
}
impl FromIntoMemory for DEF_SHARE_ID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct DELEGATEITEMID {
    pub cbSize: u16,
    pub wOuter: u16,
    pub cbInner: u16,
    pub rgb: [u8; 1],
}
impl ::core::marker::Copy for DELEGATEITEMID {}
impl ::core::clone::Clone for DELEGATEITEMID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DELEGATEITEMID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DELEGATEITEMID")
            .field("cbSize", &self.cbSize)
            .field("wOuter", &self.wOuter)
            .field("cbInner", &self.cbInner)
            .field("rgb", &self.rgb)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DELEGATEITEMID {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.wOuter == other.wOuter
            && self.cbInner == other.cbInner
            && self.rgb == other.rgb
    }
}
impl ::core::cmp::Eq for DELEGATEITEMID {}
impl FromIntoMemory for DELEGATEITEMID {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 7);
        let f_cbSize = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_wOuter = <u16 as FromIntoMemory>::from_bytes(&from[2..2 + 2]);
        let f_cbInner = <u16 as FromIntoMemory>::from_bytes(&from[4..4 + 2]);
        let f_rgb = <[u8; 1] as FromIntoMemory>::from_bytes(&from[6..6 + 1]);
        Self {
            cbSize: f_cbSize,
            wOuter: f_wOuter,
            cbInner: f_cbInner,
            rgb: f_rgb,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 7);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.wOuter, &mut into[2..2 + 2]);
        FromIntoMemory::into_bytes(self.cbInner, &mut into[4..4 + 2]);
        FromIntoMemory::into_bytes(self.rgb, &mut into[6..6 + 1]);
    }
    fn size() -> usize {
        7
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DESKBANDCID(pub i32);
pub const DBID_BANDINFOCHANGED: DESKBANDCID = DESKBANDCID(0i32);
pub const DBID_SHOWONLY: DESKBANDCID = DESKBANDCID(1i32);
pub const DBID_MAXIMIZEBAND: DESKBANDCID = DESKBANDCID(2i32);
pub const DBID_PUSHCHEVRON: DESKBANDCID = DESKBANDCID(3i32);
pub const DBID_DELAYINIT: DESKBANDCID = DESKBANDCID(4i32);
pub const DBID_FINISHINIT: DESKBANDCID = DESKBANDCID(5i32);
pub const DBID_SETWINDOWTHEME: DESKBANDCID = DESKBANDCID(6i32);
pub const DBID_PERMITAUTOHIDE: DESKBANDCID = DESKBANDCID(7i32);
impl ::core::marker::Copy for DESKBANDCID {}
impl ::core::clone::Clone for DESKBANDCID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DESKBANDCID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DESKBANDCID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DESKBANDCID").field(&self.0).finish()
    }
}
impl FromIntoMemory for DESKBANDCID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct DESKBANDINFO {
    pub dwMask: u32,
    pub ptMinSize: super::super::Foundation::POINTL,
    pub ptMaxSize: super::super::Foundation::POINTL,
    pub ptIntegral: super::super::Foundation::POINTL,
    pub ptActual: super::super::Foundation::POINTL,
    pub wszTitle: [u16; 256],
    pub dwModeFlags: u32,
    pub crBkgnd: u32,
}
impl ::core::marker::Copy for DESKBANDINFO {}
impl ::core::clone::Clone for DESKBANDINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DESKBANDINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DESKBANDINFO")
            .field("dwMask", &self.dwMask)
            .field("ptMinSize", &self.ptMinSize)
            .field("ptMaxSize", &self.ptMaxSize)
            .field("ptIntegral", &self.ptIntegral)
            .field("ptActual", &self.ptActual)
            .field("wszTitle", &self.wszTitle)
            .field("dwModeFlags", &self.dwModeFlags)
            .field("crBkgnd", &self.crBkgnd)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DESKBANDINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwMask == other.dwMask
            && self.ptMinSize == other.ptMinSize
            && self.ptMaxSize == other.ptMaxSize
            && self.ptIntegral == other.ptIntegral
            && self.ptActual == other.ptActual
            && self.wszTitle == other.wszTitle
            && self.dwModeFlags == other.dwModeFlags
            && self.crBkgnd == other.crBkgnd
    }
}
impl ::core::cmp::Eq for DESKBANDINFO {}
impl FromIntoMemory for DESKBANDINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 300);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_ptMinSize =
            <super::super::Foundation::POINTL as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        let f_ptMaxSize =
            <super::super::Foundation::POINTL as FromIntoMemory>::from_bytes(&from[12..12 + 8]);
        let f_ptIntegral =
            <super::super::Foundation::POINTL as FromIntoMemory>::from_bytes(&from[20..20 + 8]);
        let f_ptActual =
            <super::super::Foundation::POINTL as FromIntoMemory>::from_bytes(&from[28..28 + 8]);
        let f_wszTitle = <[u16; 256] as FromIntoMemory>::from_bytes(&from[36..36 + 256]);
        let f_dwModeFlags = <u32 as FromIntoMemory>::from_bytes(&from[292..292 + 4]);
        let f_crBkgnd = <u32 as FromIntoMemory>::from_bytes(&from[296..296 + 4]);
        Self {
            dwMask: f_dwMask,
            ptMinSize: f_ptMinSize,
            ptMaxSize: f_ptMaxSize,
            ptIntegral: f_ptIntegral,
            ptActual: f_ptActual,
            wszTitle: f_wszTitle,
            dwModeFlags: f_dwModeFlags,
            crBkgnd: f_crBkgnd,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 300);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.ptMinSize, &mut into[4..4 + 8]);
        FromIntoMemory::into_bytes(self.ptMaxSize, &mut into[12..12 + 8]);
        FromIntoMemory::into_bytes(self.ptIntegral, &mut into[20..20 + 8]);
        FromIntoMemory::into_bytes(self.ptActual, &mut into[28..28 + 8]);
        FromIntoMemory::into_bytes(self.wszTitle, &mut into[36..36 + 256]);
        FromIntoMemory::into_bytes(self.dwModeFlags, &mut into[292..292 + 4]);
        FromIntoMemory::into_bytes(self.crBkgnd, &mut into[296..296 + 4]);
    }
    fn size() -> usize {
        300
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DESKTOP_SLIDESHOW_DIRECTION(pub i32);
pub const DSD_FORWARD: DESKTOP_SLIDESHOW_DIRECTION = DESKTOP_SLIDESHOW_DIRECTION(0i32);
pub const DSD_BACKWARD: DESKTOP_SLIDESHOW_DIRECTION = DESKTOP_SLIDESHOW_DIRECTION(1i32);
impl ::core::marker::Copy for DESKTOP_SLIDESHOW_DIRECTION {}
impl ::core::clone::Clone for DESKTOP_SLIDESHOW_DIRECTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DESKTOP_SLIDESHOW_DIRECTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DESKTOP_SLIDESHOW_DIRECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DESKTOP_SLIDESHOW_DIRECTION")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for DESKTOP_SLIDESHOW_DIRECTION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DESKTOP_SLIDESHOW_OPTIONS(pub i32);
pub const DSO_SHUFFLEIMAGES: DESKTOP_SLIDESHOW_OPTIONS = DESKTOP_SLIDESHOW_OPTIONS(1i32);
impl ::core::marker::Copy for DESKTOP_SLIDESHOW_OPTIONS {}
impl ::core::clone::Clone for DESKTOP_SLIDESHOW_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DESKTOP_SLIDESHOW_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DESKTOP_SLIDESHOW_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DESKTOP_SLIDESHOW_OPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for DESKTOP_SLIDESHOW_OPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DESKTOP_SLIDESHOW_STATE(pub i32);
pub const DSS_ENABLED: DESKTOP_SLIDESHOW_STATE = DESKTOP_SLIDESHOW_STATE(1i32);
pub const DSS_SLIDESHOW: DESKTOP_SLIDESHOW_STATE = DESKTOP_SLIDESHOW_STATE(2i32);
pub const DSS_DISABLED_BY_REMOTE_SESSION: DESKTOP_SLIDESHOW_STATE = DESKTOP_SLIDESHOW_STATE(4i32);
impl ::core::marker::Copy for DESKTOP_SLIDESHOW_STATE {}
impl ::core::clone::Clone for DESKTOP_SLIDESHOW_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DESKTOP_SLIDESHOW_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DESKTOP_SLIDESHOW_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DESKTOP_SLIDESHOW_STATE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for DESKTOP_SLIDESHOW_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DESKTOP_WALLPAPER_POSITION(pub i32);
pub const DWPOS_CENTER: DESKTOP_WALLPAPER_POSITION = DESKTOP_WALLPAPER_POSITION(0i32);
pub const DWPOS_TILE: DESKTOP_WALLPAPER_POSITION = DESKTOP_WALLPAPER_POSITION(1i32);
pub const DWPOS_STRETCH: DESKTOP_WALLPAPER_POSITION = DESKTOP_WALLPAPER_POSITION(2i32);
pub const DWPOS_FIT: DESKTOP_WALLPAPER_POSITION = DESKTOP_WALLPAPER_POSITION(3i32);
pub const DWPOS_FILL: DESKTOP_WALLPAPER_POSITION = DESKTOP_WALLPAPER_POSITION(4i32);
pub const DWPOS_SPAN: DESKTOP_WALLPAPER_POSITION = DESKTOP_WALLPAPER_POSITION(5i32);
impl ::core::marker::Copy for DESKTOP_WALLPAPER_POSITION {}
impl ::core::clone::Clone for DESKTOP_WALLPAPER_POSITION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DESKTOP_WALLPAPER_POSITION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DESKTOP_WALLPAPER_POSITION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DESKTOP_WALLPAPER_POSITION")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for DESKTOP_WALLPAPER_POSITION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DETAILSINFO {
    pub pidl: MutPtr<Common::ITEMIDLIST>,
    pub fmt: i32,
    pub cxChar: i32,
    pub str: Common::STRRET,
    pub iImage: i32,
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DETAILSINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DETAILSINFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DETAILSINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DETAILSINFO")
            .field("pidl", &self.pidl)
            .field("fmt", &self.fmt)
            .field("cxChar", &self.cxChar)
            .field("str", &self.str)
            .field("iImage", &self.iImage)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DETAILSINFO {
    fn eq(&self, other: &Self) -> bool {
        self.pidl == other.pidl
            && self.fmt == other.fmt
            && self.cxChar == other.cxChar
            && self.str == other.str
            && self.iImage == other.iImage
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DETAILSINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DETAILSINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 280);
        let f_pidl = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fmt = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cxChar = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_str = <Common::STRRET as FromIntoMemory>::from_bytes(&from[12..12 + 264]);
        let f_iImage = <i32 as FromIntoMemory>::from_bytes(&from[276..276 + 4]);
        Self {
            pidl: f_pidl,
            fmt: f_fmt,
            cxChar: f_cxChar,
            str: f_str,
            iImage: f_iImage,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 280);
        FromIntoMemory::into_bytes(self.pidl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fmt, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cxChar, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.str, &mut into[12..12 + 264]);
        FromIntoMemory::into_bytes(self.iImage, &mut into[276..276 + 4]);
    }
    fn size() -> usize {
        280
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DFConstraint(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait DFConstraint_Trait: super::super::System::Com::IDispatch_Trait {
    fn get_Name(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Name")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Value(&self, pv: MutPtr<super::super::System::Com::VARIANT>) -> crate::core::HRESULT {
        todo!("get_Value")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DFConstraint {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DFConstraint {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DFConstraint {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DFConstraint {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DFConstraint {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DFConstraint").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DFConstraint {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for DFConstraint {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4a3df050_23bd_11d2_939f_00a0c91eedba);
}
pub struct DFMICS {
    pub cbSize: u32,
    pub fMask: u32,
    pub lParam: super::super::Foundation::LPARAM,
    pub idCmdFirst: u32,
    pub idDefMax: u32,
    pub pici: MutPtr<CMINVOKECOMMANDINFO>,
    pub punkSite: crate::core::IUnknown,
}
impl ::core::marker::Copy for DFMICS {}
impl ::core::clone::Clone for DFMICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DFMICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DFMICS")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("lParam", &self.lParam)
            .field("idCmdFirst", &self.idCmdFirst)
            .field("idDefMax", &self.idDefMax)
            .field("pici", &self.pici)
            .field("punkSite", &self.punkSite)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DFMICS {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.lParam == other.lParam
            && self.idCmdFirst == other.idCmdFirst
            && self.idDefMax == other.idDefMax
            && self.pici == other.pici
            && self.punkSite == other.punkSite
    }
}
impl ::core::cmp::Eq for DFMICS {}
impl FromIntoMemory for DFMICS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lParam =
            <super::super::Foundation::LPARAM as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_idCmdFirst = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_idDefMax = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pici = <MutPtr<CMINVOKECOMMANDINFO> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_punkSite = <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            lParam: f_lParam,
            idCmdFirst: f_idCmdFirst,
            idDefMax: f_idDefMax,
            pici: f_pici,
            punkSite: f_punkSite,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lParam, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.idCmdFirst, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.idDefMax, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pici, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.punkSite, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DFM_CMD(pub i32);
pub const DFM_CMD_DELETE: DFM_CMD = DFM_CMD(-1i32);
pub const DFM_CMD_MOVE: DFM_CMD = DFM_CMD(-2i32);
pub const DFM_CMD_COPY: DFM_CMD = DFM_CMD(-3i32);
pub const DFM_CMD_LINK: DFM_CMD = DFM_CMD(-4i32);
pub const DFM_CMD_PROPERTIES: DFM_CMD = DFM_CMD(-5i32);
pub const DFM_CMD_NEWFOLDER: DFM_CMD = DFM_CMD(-6i32);
pub const DFM_CMD_PASTE: DFM_CMD = DFM_CMD(-7i32);
pub const DFM_CMD_VIEWLIST: DFM_CMD = DFM_CMD(-8i32);
pub const DFM_CMD_VIEWDETAILS: DFM_CMD = DFM_CMD(-9i32);
pub const DFM_CMD_PASTELINK: DFM_CMD = DFM_CMD(-10i32);
pub const DFM_CMD_PASTESPECIAL: DFM_CMD = DFM_CMD(-11i32);
pub const DFM_CMD_MODALPROP: DFM_CMD = DFM_CMD(-12i32);
pub const DFM_CMD_RENAME: DFM_CMD = DFM_CMD(-13i32);
impl ::core::marker::Copy for DFM_CMD {}
impl ::core::clone::Clone for DFM_CMD {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DFM_CMD {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DFM_CMD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DFM_CMD").field(&self.0).finish()
    }
}
impl FromIntoMemory for DFM_CMD {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DFM_MESSAGE_ID(pub i32);
pub const DFM_MERGECONTEXTMENU: DFM_MESSAGE_ID = DFM_MESSAGE_ID(1i32);
pub const DFM_INVOKECOMMAND: DFM_MESSAGE_ID = DFM_MESSAGE_ID(2i32);
pub const DFM_GETHELPTEXT: DFM_MESSAGE_ID = DFM_MESSAGE_ID(5i32);
pub const DFM_WM_MEASUREITEM: DFM_MESSAGE_ID = DFM_MESSAGE_ID(6i32);
pub const DFM_WM_DRAWITEM: DFM_MESSAGE_ID = DFM_MESSAGE_ID(7i32);
pub const DFM_WM_INITMENUPOPUP: DFM_MESSAGE_ID = DFM_MESSAGE_ID(8i32);
pub const DFM_VALIDATECMD: DFM_MESSAGE_ID = DFM_MESSAGE_ID(9i32);
pub const DFM_MERGECONTEXTMENU_TOP: DFM_MESSAGE_ID = DFM_MESSAGE_ID(10i32);
pub const DFM_GETHELPTEXTW: DFM_MESSAGE_ID = DFM_MESSAGE_ID(11i32);
pub const DFM_INVOKECOMMANDEX: DFM_MESSAGE_ID = DFM_MESSAGE_ID(12i32);
pub const DFM_MAPCOMMANDNAME: DFM_MESSAGE_ID = DFM_MESSAGE_ID(13i32);
pub const DFM_GETDEFSTATICID: DFM_MESSAGE_ID = DFM_MESSAGE_ID(14i32);
pub const DFM_GETVERBW: DFM_MESSAGE_ID = DFM_MESSAGE_ID(15i32);
pub const DFM_GETVERBA: DFM_MESSAGE_ID = DFM_MESSAGE_ID(16i32);
pub const DFM_MERGECONTEXTMENU_BOTTOM: DFM_MESSAGE_ID = DFM_MESSAGE_ID(17i32);
pub const DFM_MODIFYQCMFLAGS: DFM_MESSAGE_ID = DFM_MESSAGE_ID(18i32);
impl ::core::marker::Copy for DFM_MESSAGE_ID {}
impl ::core::clone::Clone for DFM_MESSAGE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DFM_MESSAGE_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DFM_MESSAGE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DFM_MESSAGE_ID").field(&self.0).finish()
    }
}
impl FromIntoMemory for DFM_MESSAGE_ID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const DISPID_BEGINDRAG: u32 = 204u32;
pub const DISPID_CHECKSTATECHANGED: u32 = 209u32;
pub const DISPID_COLUMNSCHANGED: u32 = 212u32;
pub const DISPID_CONTENTSCHANGED: u32 = 207u32;
pub const DISPID_CTRLMOUSEWHEEL: u32 = 213u32;
pub const DISPID_DEFAULTVERBINVOKED: u32 = 203u32;
pub const DISPID_ENTERPRESSED: u32 = 200u32;
pub const DISPID_ENTERPRISEIDCHANGED: u32 = 224u32;
pub const DISPID_EXPLORERWINDOWREADY: u32 = 221u32;
pub const DISPID_FILELISTENUMDONE: u32 = 201u32;
pub const DISPID_FILTERINVOKED: u32 = 218u32;
pub const DISPID_FOCUSCHANGED: u32 = 208u32;
pub const DISPID_FOLDERCHANGED: u32 = 217u32;
pub const DISPID_IADCCTL_DEFAULTCAT: u32 = 262u32;
pub const DISPID_IADCCTL_DIRTY: u32 = 256u32;
pub const DISPID_IADCCTL_FORCEX86: u32 = 259u32;
pub const DISPID_IADCCTL_ONDOMAIN: u32 = 261u32;
pub const DISPID_IADCCTL_PUBCAT: u32 = 257u32;
pub const DISPID_IADCCTL_SHOWPOSTSETUP: u32 = 260u32;
pub const DISPID_IADCCTL_SORT: u32 = 258u32;
pub const DISPID_ICONSIZECHANGED: u32 = 215u32;
pub const DISPID_INITIALENUMERATIONDONE: u32 = 223u32;
pub const DISPID_NOITEMSTATE_CHANGED: u32 = 206u32;
pub const DISPID_ORDERCHANGED: u32 = 210u32;
pub const DISPID_SEARCHCOMMAND_ABORT: u32 = 3u32;
pub const DISPID_SEARCHCOMMAND_COMPLETE: u32 = 2u32;
pub const DISPID_SEARCHCOMMAND_ERROR: u32 = 6u32;
pub const DISPID_SEARCHCOMMAND_PROGRESSTEXT: u32 = 5u32;
pub const DISPID_SEARCHCOMMAND_RESTORE: u32 = 7u32;
pub const DISPID_SEARCHCOMMAND_START: u32 = 1u32;
pub const DISPID_SEARCHCOMMAND_UPDATE: u32 = 4u32;
pub const DISPID_SELECTEDITEMCHANGED: u32 = 220u32;
pub const DISPID_SELECTIONCHANGED: u32 = 200u32;
pub const DISPID_SORTDONE: u32 = 214u32;
pub const DISPID_UPDATEIMAGE: u32 = 222u32;
pub const DISPID_VERBINVOKED: u32 = 202u32;
pub const DISPID_VIEWMODECHANGED: u32 = 205u32;
pub const DISPID_VIEWPAINTDONE: u32 = 211u32;
pub const DISPID_WORDWHEELEDITED: u32 = 219u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DISPLAY_DEVICE_TYPE(pub i32);
pub const DEVICE_PRIMARY: DISPLAY_DEVICE_TYPE = DISPLAY_DEVICE_TYPE(0i32);
pub const DEVICE_IMMERSIVE: DISPLAY_DEVICE_TYPE = DISPLAY_DEVICE_TYPE(1i32);
impl ::core::marker::Copy for DISPLAY_DEVICE_TYPE {}
impl ::core::clone::Clone for DISPLAY_DEVICE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DISPLAY_DEVICE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DISPLAY_DEVICE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DISPLAY_DEVICE_TYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for DISPLAY_DEVICE_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const DI_GETDRAGIMAGE: &'static str = "ShellGetDragImage";
pub const DLG_SCRNSAVECONFIGURE: u32 = 2003u32;
pub type DLLGETVERSIONPROC = StdCallFnPtr<(MutPtr<DLLVERSIONINFO>,), crate::core::HRESULT>;
pub struct DLLVERSIONINFO {
    pub cbSize: u32,
    pub dwMajorVersion: u32,
    pub dwMinorVersion: u32,
    pub dwBuildNumber: u32,
    pub dwPlatformID: u32,
}
impl ::core::marker::Copy for DLLVERSIONINFO {}
impl ::core::clone::Clone for DLLVERSIONINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DLLVERSIONINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DLLVERSIONINFO")
            .field("cbSize", &self.cbSize)
            .field("dwMajorVersion", &self.dwMajorVersion)
            .field("dwMinorVersion", &self.dwMinorVersion)
            .field("dwBuildNumber", &self.dwBuildNumber)
            .field("dwPlatformID", &self.dwPlatformID)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DLLVERSIONINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwMajorVersion == other.dwMajorVersion
            && self.dwMinorVersion == other.dwMinorVersion
            && self.dwBuildNumber == other.dwBuildNumber
            && self.dwPlatformID == other.dwPlatformID
    }
}
impl ::core::cmp::Eq for DLLVERSIONINFO {}
impl FromIntoMemory for DLLVERSIONINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwMajorVersion = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwMinorVersion = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwBuildNumber = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwPlatformID = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            cbSize: f_cbSize,
            dwMajorVersion: f_dwMajorVersion,
            dwMinorVersion: f_dwMinorVersion,
            dwBuildNumber: f_dwBuildNumber,
            dwPlatformID: f_dwPlatformID,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwMajorVersion, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwMinorVersion, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwBuildNumber, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwPlatformID, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct DLLVERSIONINFO2 {
    pub info1: DLLVERSIONINFO,
    pub dwFlags: u32,
    pub ullVersion: u64,
}
impl ::core::marker::Copy for DLLVERSIONINFO2 {}
impl ::core::clone::Clone for DLLVERSIONINFO2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DLLVERSIONINFO2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DLLVERSIONINFO2")
            .field("info1", &self.info1)
            .field("dwFlags", &self.dwFlags)
            .field("ullVersion", &self.ullVersion)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DLLVERSIONINFO2 {
    fn eq(&self, other: &Self) -> bool {
        self.info1 == other.info1
            && self.dwFlags == other.dwFlags
            && self.ullVersion == other.ullVersion
    }
}
impl ::core::cmp::Eq for DLLVERSIONINFO2 {}
impl FromIntoMemory for DLLVERSIONINFO2 {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_info1 = <DLLVERSIONINFO as FromIntoMemory>::from_bytes(&from[0..0 + 20]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_ullVersion = <u64 as FromIntoMemory>::from_bytes(&from[24..24 + 8]);
        Self {
            info1: f_info1,
            dwFlags: f_dwFlags,
            ullVersion: f_ullVersion,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.info1, &mut into[0..0 + 20]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.ullVersion, &mut into[24..24 + 8]);
    }
    fn size() -> usize {
        32
    }
}
pub const DLLVER_BUILD_MASK: u64 = 4294901760u64;
pub const DLLVER_MAJOR_MASK: u64 = 18446462598732840960u64;
pub const DLLVER_MINOR_MASK: u64 = 281470681743360u64;
pub const DLLVER_PLATFORM_NT: u32 = 2u32;
pub const DLLVER_PLATFORM_WINDOWS: u32 = 1u32;
pub const DLLVER_QFE_MASK: u64 = 65535u64;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DRAGINFOA {
    pub uSize: u32,
    pub pt: super::super::Foundation::POINT,
    pub fNC: super::super::Foundation::BOOL,
    pub lpFileList: PSTR,
    pub grfKeyState: u32,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DRAGINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DRAGINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DRAGINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DRAGINFOA")
            .field("uSize", &self.uSize)
            .field("pt", &self.pt)
            .field("fNC", &self.fNC)
            .field("lpFileList", &self.lpFileList)
            .field("grfKeyState", &self.grfKeyState)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DRAGINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.uSize == other.uSize
            && self.pt == other.pt
            && self.fNC == other.fNC
            && self.lpFileList == other.lpFileList
            && self.grfKeyState == other.grfKeyState
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DRAGINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DRAGINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_uSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pt = <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        let f_fNC =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFileList = <PSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_grfKeyState = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            uSize: f_uSize,
            pt: f_pt,
            fNC: f_fNC,
            lpFileList: f_lpFileList,
            grfKeyState: f_grfKeyState,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.uSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pt, &mut into[4..4 + 8]);
        FromIntoMemory::into_bytes(self.fNC, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFileList, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.grfKeyState, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DRAGINFOA {
    pub uSize: u32,
    pub pt: super::super::Foundation::POINT,
    pub fNC: super::super::Foundation::BOOL,
    pub lpFileList: PSTR,
    pub grfKeyState: u32,
}
impl ::core::marker::Copy for DRAGINFOA {}
impl ::core::clone::Clone for DRAGINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DRAGINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DRAGINFOA")
            .field("uSize", &self.uSize)
            .field("pt", &self.pt)
            .field("fNC", &self.fNC)
            .field("lpFileList", &self.lpFileList)
            .field("grfKeyState", &self.grfKeyState)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DRAGINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.uSize == other.uSize
            && self.pt == other.pt
            && self.fNC == other.fNC
            && self.lpFileList == other.lpFileList
            && self.grfKeyState == other.grfKeyState
    }
}
impl ::core::cmp::Eq for DRAGINFOA {}
impl FromIntoMemory for DRAGINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_uSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pt = <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        let f_fNC =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFileList = <PSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_grfKeyState = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            uSize: f_uSize,
            pt: f_pt,
            fNC: f_fNC,
            lpFileList: f_lpFileList,
            grfKeyState: f_grfKeyState,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.uSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pt, &mut into[4..4 + 8]);
        FromIntoMemory::into_bytes(self.fNC, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFileList, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.grfKeyState, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DRAGINFOW {
    pub uSize: u32,
    pub pt: super::super::Foundation::POINT,
    pub fNC: super::super::Foundation::BOOL,
    pub lpFileList: PWSTR,
    pub grfKeyState: u32,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DRAGINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DRAGINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DRAGINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DRAGINFOW")
            .field("uSize", &self.uSize)
            .field("pt", &self.pt)
            .field("fNC", &self.fNC)
            .field("lpFileList", &self.lpFileList)
            .field("grfKeyState", &self.grfKeyState)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DRAGINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.uSize == other.uSize
            && self.pt == other.pt
            && self.fNC == other.fNC
            && self.lpFileList == other.lpFileList
            && self.grfKeyState == other.grfKeyState
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DRAGINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DRAGINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_uSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pt = <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        let f_fNC =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFileList = <PWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_grfKeyState = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            uSize: f_uSize,
            pt: f_pt,
            fNC: f_fNC,
            lpFileList: f_lpFileList,
            grfKeyState: f_grfKeyState,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.uSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pt, &mut into[4..4 + 8]);
        FromIntoMemory::into_bytes(self.fNC, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFileList, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.grfKeyState, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DRAGINFOW {
    pub uSize: u32,
    pub pt: super::super::Foundation::POINT,
    pub fNC: super::super::Foundation::BOOL,
    pub lpFileList: PWSTR,
    pub grfKeyState: u32,
}
impl ::core::marker::Copy for DRAGINFOW {}
impl ::core::clone::Clone for DRAGINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DRAGINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DRAGINFOW")
            .field("uSize", &self.uSize)
            .field("pt", &self.pt)
            .field("fNC", &self.fNC)
            .field("lpFileList", &self.lpFileList)
            .field("grfKeyState", &self.grfKeyState)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DRAGINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.uSize == other.uSize
            && self.pt == other.pt
            && self.fNC == other.fNC
            && self.lpFileList == other.lpFileList
            && self.grfKeyState == other.grfKeyState
    }
}
impl ::core::cmp::Eq for DRAGINFOW {}
impl FromIntoMemory for DRAGINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_uSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pt = <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        let f_fNC =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFileList = <PWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_grfKeyState = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            uSize: f_uSize,
            pt: f_pt,
            fNC: f_fNC,
            lpFileList: f_lpFileList,
            grfKeyState: f_grfKeyState,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.uSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pt, &mut into[4..4 + 8]);
        FromIntoMemory::into_bytes(self.fNC, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFileList, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.grfKeyState, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct DROPDESCRIPTION {
    pub r#type: DROPIMAGETYPE,
    pub szMessage: [u16; 260],
    pub szInsert: [u16; 260],
}
impl ::core::marker::Copy for DROPDESCRIPTION {}
impl ::core::clone::Clone for DROPDESCRIPTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DROPDESCRIPTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DROPDESCRIPTION")
            .field("type", &self.r#type)
            .field("szMessage", &self.szMessage)
            .field("szInsert", &self.szInsert)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DROPDESCRIPTION {
    fn eq(&self, other: &Self) -> bool {
        self.r#type == other.r#type
            && self.szMessage == other.szMessage
            && self.szInsert == other.szInsert
    }
}
impl ::core::cmp::Eq for DROPDESCRIPTION {}
impl FromIntoMemory for DROPDESCRIPTION {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 524);
        let f_type = <DROPIMAGETYPE as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_szMessage = <[u16; 260] as FromIntoMemory>::from_bytes(&from[4..4 + 260]);
        let f_szInsert = <[u16; 260] as FromIntoMemory>::from_bytes(&from[264..264 + 260]);
        Self {
            r#type: f_type,
            szMessage: f_szMessage,
            szInsert: f_szInsert,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 524);
        FromIntoMemory::into_bytes(self.r#type, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.szMessage, &mut into[4..4 + 260]);
        FromIntoMemory::into_bytes(self.szInsert, &mut into[264..264 + 260]);
    }
    fn size() -> usize {
        524
    }
}
pub struct DROPFILES {
    pub pFiles: u32,
    pub pt: super::super::Foundation::POINT,
    pub fNC: super::super::Foundation::BOOL,
    pub fWide: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for DROPFILES {}
impl ::core::clone::Clone for DROPFILES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DROPFILES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DROPFILES")
            .field("pFiles", &self.pFiles)
            .field("pt", &self.pt)
            .field("fNC", &self.fNC)
            .field("fWide", &self.fWide)
            .finish()
    }
}
impl ::core::cmp::PartialEq for DROPFILES {
    fn eq(&self, other: &Self) -> bool {
        self.pFiles == other.pFiles
            && self.pt == other.pt
            && self.fNC == other.fNC
            && self.fWide == other.fWide
    }
}
impl ::core::cmp::Eq for DROPFILES {}
impl FromIntoMemory for DROPFILES {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_pFiles = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pt = <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        let f_fNC =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_fWide =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            pFiles: f_pFiles,
            pt: f_pt,
            fNC: f_fNC,
            fWide: f_fWide,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.pFiles, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pt, &mut into[4..4 + 8]);
        FromIntoMemory::into_bytes(self.fNC, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.fWide, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DROPIMAGETYPE(pub i32);
pub const DROPIMAGE_INVALID: DROPIMAGETYPE = DROPIMAGETYPE(-1i32);
pub const DROPIMAGE_NONE: DROPIMAGETYPE = DROPIMAGETYPE(0i32);
pub const DROPIMAGE_COPY: DROPIMAGETYPE = DROPIMAGETYPE(1i32);
pub const DROPIMAGE_MOVE: DROPIMAGETYPE = DROPIMAGETYPE(2i32);
pub const DROPIMAGE_LINK: DROPIMAGETYPE = DROPIMAGETYPE(4i32);
pub const DROPIMAGE_LABEL: DROPIMAGETYPE = DROPIMAGETYPE(6i32);
pub const DROPIMAGE_WARNING: DROPIMAGETYPE = DROPIMAGETYPE(7i32);
pub const DROPIMAGE_NOIMAGE: DROPIMAGETYPE = DROPIMAGETYPE(8i32);
impl ::core::marker::Copy for DROPIMAGETYPE {}
impl ::core::clone::Clone for DROPIMAGETYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DROPIMAGETYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DROPIMAGETYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DROPIMAGETYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for DROPIMAGETYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct DSH_FLAGS(pub i32);
pub const DSH_ALLOWDROPDESCRIPTIONTEXT: DSH_FLAGS = DSH_FLAGS(1i32);
impl ::core::marker::Copy for DSH_FLAGS {}
impl ::core::clone::Clone for DSH_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DSH_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for DSH_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DSH_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for DSH_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DShellFolderViewEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait DShellFolderViewEvents_Trait: super::super::System::Com::IDispatch_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DShellFolderViewEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DShellFolderViewEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DShellFolderViewEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DShellFolderViewEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DShellFolderViewEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DShellFolderViewEvents")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DShellFolderViewEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for DShellFolderViewEvents {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x62112aa2_ebe4_11cf_a5fb_0020afe7292d);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DShellNameSpaceEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait DShellNameSpaceEvents_Trait: super::super::System::Com::IDispatch_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DShellNameSpaceEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DShellNameSpaceEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DShellNameSpaceEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DShellNameSpaceEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DShellNameSpaceEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DShellNameSpaceEvents")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DShellNameSpaceEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for DShellNameSpaceEvents {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x55136806_b2de_11d1_b9f2_00a0c98bc547);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DShellWindowsEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait DShellWindowsEvents_Trait: super::super::System::Com::IDispatch_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DShellWindowsEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DShellWindowsEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DShellWindowsEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DShellWindowsEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DShellWindowsEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DShellWindowsEvents").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DShellWindowsEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for DShellWindowsEvents {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfe4106e0_399a_11d0_a48c_00a0c90a8f39);
}
pub const DVASPECT_COPY: u32 = 3u32;
pub const DVASPECT_LINK: u32 = 4u32;
pub const DVASPECT_SHORTNAME: u32 = 2u32;
pub const DWFAF_AUTOHIDE: u32 = 16u32;
pub const DWFAF_GROUP1: u32 = 2u32;
pub const DWFAF_GROUP2: u32 = 4u32;
pub const DWFAF_HIDDEN: u32 = 1u32;
pub const DWFRF_DELETECONFIGDATA: u32 = 1u32;
pub const DWFRF_NORMAL: u32 = 0u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DWebBrowserEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait DWebBrowserEvents_Trait: super::super::System::Com::IDispatch_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DWebBrowserEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DWebBrowserEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DWebBrowserEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DWebBrowserEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DWebBrowserEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DWebBrowserEvents").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DWebBrowserEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for DWebBrowserEvents {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xeab22ac2_30c1_11cf_a7eb_0000c05bae0b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct DWebBrowserEvents2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait DWebBrowserEvents2_Trait: super::super::System::Com::IDispatch_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for DWebBrowserEvents2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for DWebBrowserEvents2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for DWebBrowserEvents2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for DWebBrowserEvents2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for DWebBrowserEvents2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DWebBrowserEvents2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for DWebBrowserEvents2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for DWebBrowserEvents2 {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x34a715a0_6587_11d0_924a_0020afc7ac4d);
}
pub const DefFolderMenu: crate::core::GUID =
    crate::core::GUID::from_u128(0xc63382be_7933_48d0_9ac8_85fb46be2fdd);
pub const DesktopGadget: crate::core::GUID =
    crate::core::GUID::from_u128(0x924ccc1b_6562_4c85_8657_d177925222b6);
pub const DesktopWallpaper: crate::core::GUID =
    crate::core::GUID::from_u128(0xc2cf3110_460e_4fc1_b9d0_8a1c0c9cc4bd);
pub const DestinationList: crate::core::GUID =
    crate::core::GUID::from_u128(0x77f10cf0_3db5_4966_b520_b7c54fd35ed6);
pub const DocPropShellExtension: crate::core::GUID =
    crate::core::GUID::from_u128(0x883373c3_bf89_11d1_be35_080036b11a03);
pub const DriveSizeCategorizer: crate::core::GUID =
    crate::core::GUID::from_u128(0x94357b53_ca29_4b78_83ae_e8fe7409134f);
pub const DriveTypeCategorizer: crate::core::GUID =
    crate::core::GUID::from_u128(0xb0a8f3cf_4333_4bab_8873_1ccb1cada48b);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct EC_HOST_UI_MODE(pub i32);
pub const ECHUIM_DESKTOP: EC_HOST_UI_MODE = EC_HOST_UI_MODE(0i32);
pub const ECHUIM_IMMERSIVE: EC_HOST_UI_MODE = EC_HOST_UI_MODE(1i32);
pub const ECHUIM_SYSTEM_LAUNCHER: EC_HOST_UI_MODE = EC_HOST_UI_MODE(2i32);
impl ::core::marker::Copy for EC_HOST_UI_MODE {}
impl ::core::clone::Clone for EC_HOST_UI_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for EC_HOST_UI_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EC_HOST_UI_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EC_HOST_UI_MODE").field(&self.0).finish()
    }
}
impl FromIntoMemory for EC_HOST_UI_MODE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct EDGE_GESTURE_KIND(pub i32);
pub const EGK_TOUCH: EDGE_GESTURE_KIND = EDGE_GESTURE_KIND(0i32);
pub const EGK_KEYBOARD: EDGE_GESTURE_KIND = EDGE_GESTURE_KIND(1i32);
pub const EGK_MOUSE: EDGE_GESTURE_KIND = EDGE_GESTURE_KIND(2i32);
impl ::core::marker::Copy for EDGE_GESTURE_KIND {}
impl ::core::clone::Clone for EDGE_GESTURE_KIND {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for EDGE_GESTURE_KIND {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EDGE_GESTURE_KIND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EDGE_GESTURE_KIND").field(&self.0).finish()
    }
}
impl FromIntoMemory for EDGE_GESTURE_KIND {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const EP_AdvQueryPane: crate::core::GUID =
    crate::core::GUID::from_u128(0xb4e9db8b_34ba_4c39_b5cc_16a1bd2c411c);
pub const EP_Commands: crate::core::GUID =
    crate::core::GUID::from_u128(0xd9745868_ca5f_4a76_91cd_f5a129fbb076);
pub const EP_Commands_Organize: crate::core::GUID =
    crate::core::GUID::from_u128(0x72e81700_e3ec_4660_bf24_3c3b7b648806);
pub const EP_Commands_View: crate::core::GUID =
    crate::core::GUID::from_u128(0x21f7c32d_eeaa_439b_bb51_37b96fd6a943);
pub const EP_DetailsPane: crate::core::GUID =
    crate::core::GUID::from_u128(0x43abf98b_89b8_472d_b9ce_e69b8229f019);
pub const EP_NavPane: crate::core::GUID =
    crate::core::GUID::from_u128(0xcb316b22_25f7_42b8_8a09_540d23a43c2f);
pub const EP_PreviewPane: crate::core::GUID =
    crate::core::GUID::from_u128(0x893c63d1_45c8_4d17_be19_223be71be365);
pub const EP_QueryPane: crate::core::GUID =
    crate::core::GUID::from_u128(0x65bcde4f_4f07_4f27_83a7_1afca4df7ddd);
pub const EP_Ribbon: crate::core::GUID =
    crate::core::GUID::from_u128(0xd27524a8_c9f2_4834_a106_df8889fd4f37);
pub const EP_StatusBar: crate::core::GUID =
    crate::core::GUID::from_u128(0x65fe56ce_5cfe_4bc4_ad8a_7ae3fe7e8f7c);
pub const EXECUTE_E_LAUNCH_APPLICATION: crate::core::HRESULT = crate::core::HRESULT(-2144927487i32);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct EXPLORER_BROWSER_FILL_FLAGS(pub i32);
pub const EBF_NONE: EXPLORER_BROWSER_FILL_FLAGS = EXPLORER_BROWSER_FILL_FLAGS(0i32);
pub const EBF_SELECTFROMDATAOBJECT: EXPLORER_BROWSER_FILL_FLAGS =
    EXPLORER_BROWSER_FILL_FLAGS(256i32);
pub const EBF_NODROPTARGET: EXPLORER_BROWSER_FILL_FLAGS = EXPLORER_BROWSER_FILL_FLAGS(512i32);
impl ::core::marker::Copy for EXPLORER_BROWSER_FILL_FLAGS {}
impl ::core::clone::Clone for EXPLORER_BROWSER_FILL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for EXPLORER_BROWSER_FILL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EXPLORER_BROWSER_FILL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EXPLORER_BROWSER_FILL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for EXPLORER_BROWSER_FILL_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct EXPLORER_BROWSER_OPTIONS(pub i32);
pub const EBO_NONE: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(0i32);
pub const EBO_NAVIGATEONCE: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(1i32);
pub const EBO_SHOWFRAMES: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(2i32);
pub const EBO_ALWAYSNAVIGATE: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(4i32);
pub const EBO_NOTRAVELLOG: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(8i32);
pub const EBO_NOWRAPPERWINDOW: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(16i32);
pub const EBO_HTMLSHAREPOINTVIEW: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(32i32);
pub const EBO_NOBORDER: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(64i32);
pub const EBO_NOPERSISTVIEWSTATE: EXPLORER_BROWSER_OPTIONS = EXPLORER_BROWSER_OPTIONS(128i32);
impl ::core::marker::Copy for EXPLORER_BROWSER_OPTIONS {}
impl ::core::clone::Clone for EXPLORER_BROWSER_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for EXPLORER_BROWSER_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for EXPLORER_BROWSER_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EXPLORER_BROWSER_OPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for EXPLORER_BROWSER_OPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const EXP_DARWIN_ID_SIG: u32 = 2684354566u32;
pub struct EXP_DARWIN_LINK {
    pub dbh: DATABLOCK_HEADER,
    pub szDarwinID: [super::super::Foundation::CHAR; 260],
    pub szwDarwinID: [u16; 260],
}
impl ::core::marker::Copy for EXP_DARWIN_LINK {}
impl ::core::clone::Clone for EXP_DARWIN_LINK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXP_DARWIN_LINK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXP_DARWIN_LINK")
            .field("dbh", &self.dbh)
            .field("szDarwinID", &self.szDarwinID)
            .field("szwDarwinID", &self.szwDarwinID)
            .finish()
    }
}
impl ::core::cmp::PartialEq for EXP_DARWIN_LINK {
    fn eq(&self, other: &Self) -> bool {
        self.dbh == other.dbh
            && self.szDarwinID == other.szDarwinID
            && self.szwDarwinID == other.szwDarwinID
    }
}
impl ::core::cmp::Eq for EXP_DARWIN_LINK {}
impl FromIntoMemory for EXP_DARWIN_LINK {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 528);
        let f_dbh = <DATABLOCK_HEADER as FromIntoMemory>::from_bytes(&from[0..0 + 8]);
        let f_szDarwinID = <[super::super::Foundation::CHAR; 260] as FromIntoMemory>::from_bytes(
            &from[8..8 + 260],
        );
        let f_szwDarwinID = <[u16; 260] as FromIntoMemory>::from_bytes(&from[268..268 + 260]);
        Self {
            dbh: f_dbh,
            szDarwinID: f_szDarwinID,
            szwDarwinID: f_szwDarwinID,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 528);
        FromIntoMemory::into_bytes(self.dbh, &mut into[0..0 + 8]);
        FromIntoMemory::into_bytes(self.szDarwinID, &mut into[8..8 + 260]);
        FromIntoMemory::into_bytes(self.szwDarwinID, &mut into[268..268 + 260]);
    }
    fn size() -> usize {
        528
    }
}
pub struct EXP_PROPERTYSTORAGE {
    pub cbSize: u32,
    pub dwSignature: u32,
    pub abPropertyStorage: [u8; 1],
}
impl ::core::marker::Copy for EXP_PROPERTYSTORAGE {}
impl ::core::clone::Clone for EXP_PROPERTYSTORAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXP_PROPERTYSTORAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXP_PROPERTYSTORAGE")
            .field("cbSize", &self.cbSize)
            .field("dwSignature", &self.dwSignature)
            .field("abPropertyStorage", &self.abPropertyStorage)
            .finish()
    }
}
impl ::core::cmp::PartialEq for EXP_PROPERTYSTORAGE {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwSignature == other.dwSignature
            && self.abPropertyStorage == other.abPropertyStorage
    }
}
impl ::core::cmp::Eq for EXP_PROPERTYSTORAGE {}
impl FromIntoMemory for EXP_PROPERTYSTORAGE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 9);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSignature = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_abPropertyStorage = <[u8; 1] as FromIntoMemory>::from_bytes(&from[8..8 + 1]);
        Self {
            cbSize: f_cbSize,
            dwSignature: f_dwSignature,
            abPropertyStorage: f_abPropertyStorage,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 9);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSignature, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.abPropertyStorage, &mut into[8..8 + 1]);
    }
    fn size() -> usize {
        9
    }
}
pub const EXP_PROPERTYSTORAGE_SIG: u32 = 2684354569u32;
pub struct EXP_SPECIAL_FOLDER {
    pub cbSize: u32,
    pub dwSignature: u32,
    pub idSpecialFolder: u32,
    pub cbOffset: u32,
}
impl ::core::marker::Copy for EXP_SPECIAL_FOLDER {}
impl ::core::clone::Clone for EXP_SPECIAL_FOLDER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXP_SPECIAL_FOLDER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXP_SPECIAL_FOLDER")
            .field("cbSize", &self.cbSize)
            .field("dwSignature", &self.dwSignature)
            .field("idSpecialFolder", &self.idSpecialFolder)
            .field("cbOffset", &self.cbOffset)
            .finish()
    }
}
impl ::core::cmp::PartialEq for EXP_SPECIAL_FOLDER {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwSignature == other.dwSignature
            && self.idSpecialFolder == other.idSpecialFolder
            && self.cbOffset == other.cbOffset
    }
}
impl ::core::cmp::Eq for EXP_SPECIAL_FOLDER {}
impl FromIntoMemory for EXP_SPECIAL_FOLDER {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSignature = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_idSpecialFolder = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_cbOffset = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            cbSize: f_cbSize,
            dwSignature: f_dwSignature,
            idSpecialFolder: f_idSpecialFolder,
            cbOffset: f_cbOffset,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSignature, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.idSpecialFolder, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.cbOffset, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const EXP_SPECIAL_FOLDER_SIG: u32 = 2684354565u32;
pub const EXP_SZ_ICON_SIG: u32 = 2684354567u32;
pub struct EXP_SZ_LINK {
    pub cbSize: u32,
    pub dwSignature: u32,
    pub szTarget: [super::super::Foundation::CHAR; 260],
    pub swzTarget: [u16; 260],
}
impl ::core::marker::Copy for EXP_SZ_LINK {}
impl ::core::clone::Clone for EXP_SZ_LINK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXP_SZ_LINK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXP_SZ_LINK")
            .field("cbSize", &self.cbSize)
            .field("dwSignature", &self.dwSignature)
            .field("szTarget", &self.szTarget)
            .field("swzTarget", &self.swzTarget)
            .finish()
    }
}
impl ::core::cmp::PartialEq for EXP_SZ_LINK {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwSignature == other.dwSignature
            && self.szTarget == other.szTarget
            && self.swzTarget == other.swzTarget
    }
}
impl ::core::cmp::Eq for EXP_SZ_LINK {}
impl FromIntoMemory for EXP_SZ_LINK {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 528);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSignature = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_szTarget = <[super::super::Foundation::CHAR; 260] as FromIntoMemory>::from_bytes(
            &from[8..8 + 260],
        );
        let f_swzTarget = <[u16; 260] as FromIntoMemory>::from_bytes(&from[268..268 + 260]);
        Self {
            cbSize: f_cbSize,
            dwSignature: f_dwSignature,
            szTarget: f_szTarget,
            swzTarget: f_swzTarget,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 528);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSignature, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.szTarget, &mut into[8..8 + 260]);
        FromIntoMemory::into_bytes(self.swzTarget, &mut into[268..268 + 260]);
    }
    fn size() -> usize {
        528
    }
}
pub const EXP_SZ_LINK_SIG: u32 = 2684354561u32;
pub struct EXTRASEARCH {
    pub guidSearch: crate::core::GUID,
    pub wszFriendlyName: [u16; 80],
    pub wszUrl: [u16; 2084],
}
impl ::core::marker::Copy for EXTRASEARCH {}
impl ::core::clone::Clone for EXTRASEARCH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXTRASEARCH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXTRASEARCH")
            .field("guidSearch", &self.guidSearch)
            .field("wszFriendlyName", &self.wszFriendlyName)
            .field("wszUrl", &self.wszUrl)
            .finish()
    }
}
impl ::core::cmp::PartialEq for EXTRASEARCH {
    fn eq(&self, other: &Self) -> bool {
        self.guidSearch == other.guidSearch
            && self.wszFriendlyName == other.wszFriendlyName
            && self.wszUrl == other.wszUrl
    }
}
impl ::core::cmp::Eq for EXTRASEARCH {}
impl FromIntoMemory for EXTRASEARCH {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 2180);
        let f_guidSearch = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[0..0 + 16]);
        let f_wszFriendlyName = <[u16; 80] as FromIntoMemory>::from_bytes(&from[16..16 + 80]);
        let f_wszUrl = <[u16; 2084] as FromIntoMemory>::from_bytes(&from[96..96 + 2084]);
        Self {
            guidSearch: f_guidSearch,
            wszFriendlyName: f_wszFriendlyName,
            wszUrl: f_wszUrl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 2180);
        FromIntoMemory::into_bytes(self.guidSearch, &mut into[0..0 + 16]);
        FromIntoMemory::into_bytes(self.wszFriendlyName, &mut into[16..16 + 80]);
        FromIntoMemory::into_bytes(self.wszUrl, &mut into[96..96 + 2084]);
    }
    fn size() -> usize {
        2180
    }
}
pub const E_ACTIVATIONDENIED_SHELLERROR: crate::core::HRESULT =
    crate::core::HRESULT(-2144927439i32);
pub const E_ACTIVATIONDENIED_SHELLNOTREADY: crate::core::HRESULT =
    crate::core::HRESULT(-2144927436i32);
pub const E_ACTIVATIONDENIED_SHELLRESTART: crate::core::HRESULT =
    crate::core::HRESULT(-2144927438i32);
pub const E_ACTIVATIONDENIED_UNEXPECTED: crate::core::HRESULT =
    crate::core::HRESULT(-2144927437i32);
pub const E_ACTIVATIONDENIED_USERCLOSE: crate::core::HRESULT = crate::core::HRESULT(-2144927440i32);
pub const E_FILE_PLACEHOLDER_NOT_INITIALIZED: crate::core::HRESULT =
    crate::core::HRESULT(-2144927472i32);
pub const E_FILE_PLACEHOLDER_SERVER_TIMED_OUT: crate::core::HRESULT =
    crate::core::HRESULT(-2144927470i32);
pub const E_FILE_PLACEHOLDER_STORAGEPROVIDER_NOT_FOUND: crate::core::HRESULT =
    crate::core::HRESULT(-2144927469i32);
pub const E_FILE_PLACEHOLDER_VERSION_MISMATCH: crate::core::HRESULT =
    crate::core::HRESULT(-2144927471i32);
pub const E_FLAGS: crate::core::HRESULT = crate::core::HRESULT(-2147217408i32);
pub const E_IMAGEFEED_CHANGEDISABLED: crate::core::HRESULT = crate::core::HRESULT(-2144926960i32);
pub const E_NOTVALIDFORANIMATEDIMAGE: crate::core::HRESULT = crate::core::HRESULT(-2147221503i32);
pub const E_PREVIEWHANDLER_CORRUPT: crate::core::HRESULT = crate::core::HRESULT(-2042494972i32);
pub const E_PREVIEWHANDLER_DRM_FAIL: crate::core::HRESULT = crate::core::HRESULT(-2042494975i32);
pub const E_PREVIEWHANDLER_NOAUTH: crate::core::HRESULT = crate::core::HRESULT(-2042494974i32);
pub const E_PREVIEWHANDLER_NOTFOUND: crate::core::HRESULT = crate::core::HRESULT(-2042494973i32);
pub const E_SHELL_EXTENSION_BLOCKED: crate::core::HRESULT = crate::core::HRESULT(-2144926975i32);
pub const E_TILE_NOTIFICATIONS_PLATFORM_FAILURE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927159i32);
pub const E_USERTILE_CHANGEDISABLED: crate::core::HRESULT = crate::core::HRESULT(-2144927215i32);
pub const E_USERTILE_FILESIZE: crate::core::HRESULT = crate::core::HRESULT(-2144927212i32);
pub const E_USERTILE_LARGEORDYNAMIC: crate::core::HRESULT = crate::core::HRESULT(-2144927214i32);
pub const E_USERTILE_UNSUPPORTEDFILETYPE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927216i32);
pub const E_USERTILE_VIDEOFRAMESIZE: crate::core::HRESULT = crate::core::HRESULT(-2144927213i32);
pub const EnumerableObjectCollection: crate::core::GUID =
    crate::core::GUID::from_u128(0x2d3468c1_36a7_43b6_ac24_d3f02fd9607a);
pub const ExecuteFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x11dbb47c_a525_400b_9e80_a54615a090c0);
pub const ExecuteUnknown: crate::core::GUID =
    crate::core::GUID::from_u128(0xe44e9428_bdbc_4987_a099_40dc8fd255e7);
pub const ExplorerBrowser: crate::core::GUID =
    crate::core::GUID::from_u128(0x71f96385_ddd6_48d3_a0c1_ae06e8b055fb);
pub const FCIDM_BROWSERFIRST: u32 = 40960u32;
pub const FCIDM_BROWSERLAST: u32 = 48896u32;
pub const FCIDM_GLOBALFIRST: u32 = 32768u32;
pub const FCIDM_GLOBALLAST: u32 = 40959u32;
pub const FCIDM_MENU_EDIT: u32 = 32832u32;
pub const FCIDM_MENU_EXPLORE: u32 = 33104u32;
pub const FCIDM_MENU_FAVORITES: u32 = 33136u32;
pub const FCIDM_MENU_FILE: u32 = 32768u32;
pub const FCIDM_MENU_FIND: u32 = 33088u32;
pub const FCIDM_MENU_HELP: u32 = 33024u32;
pub const FCIDM_MENU_TOOLS: u32 = 32960u32;
pub const FCIDM_MENU_TOOLS_SEP_GOTO: u32 = 32961u32;
pub const FCIDM_MENU_VIEW: u32 = 32896u32;
pub const FCIDM_MENU_VIEW_SEP_OPTIONS: u32 = 32897u32;
pub const FCIDM_SHVIEWFIRST: u32 = 0u32;
pub const FCIDM_SHVIEWLAST: u32 = 32767u32;
pub const FCIDM_STATUS: u32 = 40961u32;
pub const FCIDM_TOOLBAR: u32 = 40960u32;
pub const FCSM_CLSID: u32 = 8u32;
pub const FCSM_FLAGS: u32 = 64u32;
pub const FCSM_ICONFILE: u32 = 16u32;
pub const FCSM_INFOTIP: u32 = 4u32;
pub const FCSM_LOGO: u32 = 32u32;
pub const FCSM_VIEWID: u32 = 1u32;
pub const FCSM_WEBVIEWTEMPLATE: u32 = 2u32;
pub const FCS_FLAG_DRAGDROP: u32 = 2u32;
pub const FCS_FORCEWRITE: u32 = 2u32;
pub const FCS_READ: u32 = 1u32;
pub const FCT_ADDTOEND: u32 = 4u32;
pub const FCT_CONFIGABLE: u32 = 2u32;
pub const FCT_MERGE: u32 = 1u32;
pub const FCW_INTERNETBAR: u32 = 6u32;
pub const FCW_PROGRESS: u32 = 8u32;
pub const FCW_STATUS: u32 = 1u32;
pub const FCW_TOOLBAR: u32 = 2u32;
pub const FCW_TREE: u32 = 3u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FDAP(pub i32);
pub const FDAP_BOTTOM: FDAP = FDAP(0i32);
pub const FDAP_TOP: FDAP = FDAP(1i32);
impl ::core::marker::Copy for FDAP {}
impl ::core::clone::Clone for FDAP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FDAP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FDAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FDAP").field(&self.0).finish()
    }
}
impl FromIntoMemory for FDAP {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FDE_OVERWRITE_RESPONSE(pub i32);
pub const FDEOR_DEFAULT: FDE_OVERWRITE_RESPONSE = FDE_OVERWRITE_RESPONSE(0i32);
pub const FDEOR_ACCEPT: FDE_OVERWRITE_RESPONSE = FDE_OVERWRITE_RESPONSE(1i32);
pub const FDEOR_REFUSE: FDE_OVERWRITE_RESPONSE = FDE_OVERWRITE_RESPONSE(2i32);
impl ::core::marker::Copy for FDE_OVERWRITE_RESPONSE {}
impl ::core::clone::Clone for FDE_OVERWRITE_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FDE_OVERWRITE_RESPONSE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FDE_OVERWRITE_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FDE_OVERWRITE_RESPONSE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for FDE_OVERWRITE_RESPONSE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FDE_SHAREVIOLATION_RESPONSE(pub i32);
pub const FDESVR_DEFAULT: FDE_SHAREVIOLATION_RESPONSE = FDE_SHAREVIOLATION_RESPONSE(0i32);
pub const FDESVR_ACCEPT: FDE_SHAREVIOLATION_RESPONSE = FDE_SHAREVIOLATION_RESPONSE(1i32);
pub const FDESVR_REFUSE: FDE_SHAREVIOLATION_RESPONSE = FDE_SHAREVIOLATION_RESPONSE(2i32);
impl ::core::marker::Copy for FDE_SHAREVIOLATION_RESPONSE {}
impl ::core::clone::Clone for FDE_SHAREVIOLATION_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FDE_SHAREVIOLATION_RESPONSE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FDE_SHAREVIOLATION_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FDE_SHAREVIOLATION_RESPONSE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for FDE_SHAREVIOLATION_RESPONSE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const FDTF_LONGDATE: u32 = 4u32;
pub const FDTF_LONGTIME: u32 = 8u32;
pub const FDTF_LTRDATE: u32 = 256u32;
pub const FDTF_NOAUTOREADINGORDER: u32 = 1024u32;
pub const FDTF_RELATIVE: u32 = 16u32;
pub const FDTF_RTLDATE: u32 = 512u32;
pub const FDTF_SHORTDATE: u32 = 2u32;
pub const FDTF_SHORTTIME: u32 = 1u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FD_FLAGS(pub i32);
pub const FD_CLSID: FD_FLAGS = FD_FLAGS(1i32);
pub const FD_SIZEPOINT: FD_FLAGS = FD_FLAGS(2i32);
pub const FD_ATTRIBUTES: FD_FLAGS = FD_FLAGS(4i32);
pub const FD_CREATETIME: FD_FLAGS = FD_FLAGS(8i32);
pub const FD_ACCESSTIME: FD_FLAGS = FD_FLAGS(16i32);
pub const FD_WRITESTIME: FD_FLAGS = FD_FLAGS(32i32);
pub const FD_FILESIZE: FD_FLAGS = FD_FLAGS(64i32);
pub const FD_PROGRESSUI: FD_FLAGS = FD_FLAGS(16384i32);
pub const FD_LINKUI: FD_FLAGS = FD_FLAGS(32768i32);
pub const FD_UNICODE: FD_FLAGS = FD_FLAGS(-2147483648i32);
impl ::core::marker::Copy for FD_FLAGS {}
impl ::core::clone::Clone for FD_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FD_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FD_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FD_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for FD_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FFFP_MODE(pub i32);
pub const FFFP_EXACTMATCH: FFFP_MODE = FFFP_MODE(0i32);
pub const FFFP_NEARESTPARENTMATCH: FFFP_MODE = FFFP_MODE(1i32);
impl ::core::marker::Copy for FFFP_MODE {}
impl ::core::clone::Clone for FFFP_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FFFP_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FFFP_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FFFP_MODE").field(&self.0).finish()
    }
}
impl FromIntoMemory for FFFP_MODE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct FILEDESCRIPTORA {
    pub dwFlags: u32,
    pub clsid: crate::core::GUID,
    pub sizel: super::super::Foundation::SIZE,
    pub pointl: super::super::Foundation::POINTL,
    pub dwFileAttributes: u32,
    pub ftCreationTime: super::super::Foundation::FILETIME,
    pub ftLastAccessTime: super::super::Foundation::FILETIME,
    pub ftLastWriteTime: super::super::Foundation::FILETIME,
    pub nFileSizeHigh: u32,
    pub nFileSizeLow: u32,
    pub cFileName: [super::super::Foundation::CHAR; 260],
}
impl ::core::marker::Copy for FILEDESCRIPTORA {}
impl ::core::clone::Clone for FILEDESCRIPTORA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILEDESCRIPTORA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILEDESCRIPTORA")
            .field("dwFlags", &self.dwFlags)
            .field("clsid", &self.clsid)
            .field("sizel", &self.sizel)
            .field("pointl", &self.pointl)
            .field("dwFileAttributes", &self.dwFileAttributes)
            .field("ftCreationTime", &self.ftCreationTime)
            .field("ftLastAccessTime", &self.ftLastAccessTime)
            .field("ftLastWriteTime", &self.ftLastWriteTime)
            .field("nFileSizeHigh", &self.nFileSizeHigh)
            .field("nFileSizeLow", &self.nFileSizeLow)
            .field("cFileName", &self.cFileName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for FILEDESCRIPTORA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.clsid == other.clsid
            && self.sizel == other.sizel
            && self.pointl == other.pointl
            && self.dwFileAttributes == other.dwFileAttributes
            && self.ftCreationTime == other.ftCreationTime
            && self.ftLastAccessTime == other.ftLastAccessTime
            && self.ftLastWriteTime == other.ftLastWriteTime
            && self.nFileSizeHigh == other.nFileSizeHigh
            && self.nFileSizeLow == other.nFileSizeLow
            && self.cFileName == other.cFileName
    }
}
impl ::core::cmp::Eq for FILEDESCRIPTORA {}
impl FromIntoMemory for FILEDESCRIPTORA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 332);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_clsid = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        let f_sizel =
            <super::super::Foundation::SIZE as FromIntoMemory>::from_bytes(&from[20..20 + 8]);
        let f_pointl =
            <super::super::Foundation::POINTL as FromIntoMemory>::from_bytes(&from[28..28 + 8]);
        let f_dwFileAttributes = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_ftCreationTime =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[40..40 + 8]);
        let f_ftLastAccessTime =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[48..48 + 8]);
        let f_ftLastWriteTime =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[56..56 + 8]);
        let f_nFileSizeHigh = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_nFileSizeLow = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_cFileName = <[super::super::Foundation::CHAR; 260] as FromIntoMemory>::from_bytes(
            &from[72..72 + 260],
        );
        Self {
            dwFlags: f_dwFlags,
            clsid: f_clsid,
            sizel: f_sizel,
            pointl: f_pointl,
            dwFileAttributes: f_dwFileAttributes,
            ftCreationTime: f_ftCreationTime,
            ftLastAccessTime: f_ftLastAccessTime,
            ftLastWriteTime: f_ftLastWriteTime,
            nFileSizeHigh: f_nFileSizeHigh,
            nFileSizeLow: f_nFileSizeLow,
            cFileName: f_cFileName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 332);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.clsid, &mut into[4..4 + 16]);
        FromIntoMemory::into_bytes(self.sizel, &mut into[20..20 + 8]);
        FromIntoMemory::into_bytes(self.pointl, &mut into[28..28 + 8]);
        FromIntoMemory::into_bytes(self.dwFileAttributes, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.ftCreationTime, &mut into[40..40 + 8]);
        FromIntoMemory::into_bytes(self.ftLastAccessTime, &mut into[48..48 + 8]);
        FromIntoMemory::into_bytes(self.ftLastWriteTime, &mut into[56..56 + 8]);
        FromIntoMemory::into_bytes(self.nFileSizeHigh, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.nFileSizeLow, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.cFileName, &mut into[72..72 + 260]);
    }
    fn size() -> usize {
        332
    }
}
pub struct FILEDESCRIPTORW {
    pub dwFlags: u32,
    pub clsid: crate::core::GUID,
    pub sizel: super::super::Foundation::SIZE,
    pub pointl: super::super::Foundation::POINTL,
    pub dwFileAttributes: u32,
    pub ftCreationTime: super::super::Foundation::FILETIME,
    pub ftLastAccessTime: super::super::Foundation::FILETIME,
    pub ftLastWriteTime: super::super::Foundation::FILETIME,
    pub nFileSizeHigh: u32,
    pub nFileSizeLow: u32,
    pub cFileName: [u16; 260],
}
impl ::core::marker::Copy for FILEDESCRIPTORW {}
impl ::core::clone::Clone for FILEDESCRIPTORW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILEDESCRIPTORW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILEDESCRIPTORW")
            .field("dwFlags", &self.dwFlags)
            .field("clsid", &self.clsid)
            .field("sizel", &self.sizel)
            .field("pointl", &self.pointl)
            .field("dwFileAttributes", &self.dwFileAttributes)
            .field("ftCreationTime", &self.ftCreationTime)
            .field("ftLastAccessTime", &self.ftLastAccessTime)
            .field("ftLastWriteTime", &self.ftLastWriteTime)
            .field("nFileSizeHigh", &self.nFileSizeHigh)
            .field("nFileSizeLow", &self.nFileSizeLow)
            .field("cFileName", &self.cFileName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for FILEDESCRIPTORW {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.clsid == other.clsid
            && self.sizel == other.sizel
            && self.pointl == other.pointl
            && self.dwFileAttributes == other.dwFileAttributes
            && self.ftCreationTime == other.ftCreationTime
            && self.ftLastAccessTime == other.ftLastAccessTime
            && self.ftLastWriteTime == other.ftLastWriteTime
            && self.nFileSizeHigh == other.nFileSizeHigh
            && self.nFileSizeLow == other.nFileSizeLow
            && self.cFileName == other.cFileName
    }
}
impl ::core::cmp::Eq for FILEDESCRIPTORW {}
impl FromIntoMemory for FILEDESCRIPTORW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 332);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_clsid = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        let f_sizel =
            <super::super::Foundation::SIZE as FromIntoMemory>::from_bytes(&from[20..20 + 8]);
        let f_pointl =
            <super::super::Foundation::POINTL as FromIntoMemory>::from_bytes(&from[28..28 + 8]);
        let f_dwFileAttributes = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_ftCreationTime =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[40..40 + 8]);
        let f_ftLastAccessTime =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[48..48 + 8]);
        let f_ftLastWriteTime =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[56..56 + 8]);
        let f_nFileSizeHigh = <u32 as FromIntoMemory>::from_bytes(&from[64..64 + 4]);
        let f_nFileSizeLow = <u32 as FromIntoMemory>::from_bytes(&from[68..68 + 4]);
        let f_cFileName = <[u16; 260] as FromIntoMemory>::from_bytes(&from[72..72 + 260]);
        Self {
            dwFlags: f_dwFlags,
            clsid: f_clsid,
            sizel: f_sizel,
            pointl: f_pointl,
            dwFileAttributes: f_dwFileAttributes,
            ftCreationTime: f_ftCreationTime,
            ftLastAccessTime: f_ftLastAccessTime,
            ftLastWriteTime: f_ftLastWriteTime,
            nFileSizeHigh: f_nFileSizeHigh,
            nFileSizeLow: f_nFileSizeLow,
            cFileName: f_cFileName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 332);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.clsid, &mut into[4..4 + 16]);
        FromIntoMemory::into_bytes(self.sizel, &mut into[20..20 + 8]);
        FromIntoMemory::into_bytes(self.pointl, &mut into[28..28 + 8]);
        FromIntoMemory::into_bytes(self.dwFileAttributes, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.ftCreationTime, &mut into[40..40 + 8]);
        FromIntoMemory::into_bytes(self.ftLastAccessTime, &mut into[48..48 + 8]);
        FromIntoMemory::into_bytes(self.ftLastWriteTime, &mut into[56..56 + 8]);
        FromIntoMemory::into_bytes(self.nFileSizeHigh, &mut into[64..64 + 4]);
        FromIntoMemory::into_bytes(self.nFileSizeLow, &mut into[68..68 + 4]);
        FromIntoMemory::into_bytes(self.cFileName, &mut into[72..72 + 260]);
    }
    fn size() -> usize {
        332
    }
}
pub struct FILEGROUPDESCRIPTORA {
    pub cItems: u32,
    pub fgd: [FILEDESCRIPTORA; 1],
}
impl ::core::marker::Copy for FILEGROUPDESCRIPTORA {}
impl ::core::clone::Clone for FILEGROUPDESCRIPTORA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILEGROUPDESCRIPTORA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILEGROUPDESCRIPTORA")
            .field("cItems", &self.cItems)
            .field("fgd", &self.fgd)
            .finish()
    }
}
impl ::core::cmp::PartialEq for FILEGROUPDESCRIPTORA {
    fn eq(&self, other: &Self) -> bool {
        self.cItems == other.cItems && self.fgd == other.fgd
    }
}
impl ::core::cmp::Eq for FILEGROUPDESCRIPTORA {}
impl FromIntoMemory for FILEGROUPDESCRIPTORA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 336);
        let f_cItems = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fgd = <[FILEDESCRIPTORA; 1] as FromIntoMemory>::from_bytes(&from[4..4 + 332]);
        Self {
            cItems: f_cItems,
            fgd: f_fgd,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 336);
        FromIntoMemory::into_bytes(self.cItems, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fgd, &mut into[4..4 + 332]);
    }
    fn size() -> usize {
        336
    }
}
pub struct FILEGROUPDESCRIPTORW {
    pub cItems: u32,
    pub fgd: [FILEDESCRIPTORW; 1],
}
impl ::core::marker::Copy for FILEGROUPDESCRIPTORW {}
impl ::core::clone::Clone for FILEGROUPDESCRIPTORW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILEGROUPDESCRIPTORW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILEGROUPDESCRIPTORW")
            .field("cItems", &self.cItems)
            .field("fgd", &self.fgd)
            .finish()
    }
}
impl ::core::cmp::PartialEq for FILEGROUPDESCRIPTORW {
    fn eq(&self, other: &Self) -> bool {
        self.cItems == other.cItems && self.fgd == other.fgd
    }
}
impl ::core::cmp::Eq for FILEGROUPDESCRIPTORW {}
impl FromIntoMemory for FILEGROUPDESCRIPTORW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 336);
        let f_cItems = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fgd = <[FILEDESCRIPTORW; 1] as FromIntoMemory>::from_bytes(&from[4..4 + 332]);
        Self {
            cItems: f_cItems,
            fgd: f_fgd,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 336);
        FromIntoMemory::into_bytes(self.cItems, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fgd, &mut into[4..4 + 332]);
    }
    fn size() -> usize {
        336
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FILEOPENDIALOGOPTIONS(pub u32);
pub const FOS_OVERWRITEPROMPT: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(2u32);
pub const FOS_STRICTFILETYPES: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(4u32);
pub const FOS_NOCHANGEDIR: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(8u32);
pub const FOS_PICKFOLDERS: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(32u32);
pub const FOS_FORCEFILESYSTEM: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(64u32);
pub const FOS_ALLNONSTORAGEITEMS: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(128u32);
pub const FOS_NOVALIDATE: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(256u32);
pub const FOS_ALLOWMULTISELECT: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(512u32);
pub const FOS_PATHMUSTEXIST: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(2048u32);
pub const FOS_FILEMUSTEXIST: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(4096u32);
pub const FOS_CREATEPROMPT: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(8192u32);
pub const FOS_SHAREAWARE: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(16384u32);
pub const FOS_NOREADONLYRETURN: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(32768u32);
pub const FOS_NOTESTFILECREATE: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(65536u32);
pub const FOS_HIDEMRUPLACES: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(131072u32);
pub const FOS_HIDEPINNEDPLACES: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(262144u32);
pub const FOS_NODEREFERENCELINKS: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(1048576u32);
pub const FOS_OKBUTTONNEEDSINTERACTION: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(2097152u32);
pub const FOS_DONTADDTORECENT: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(33554432u32);
pub const FOS_FORCESHOWHIDDEN: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(268435456u32);
pub const FOS_DEFAULTNOMINIMODE: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(536870912u32);
pub const FOS_FORCEPREVIEWPANEON: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(1073741824u32);
pub const FOS_SUPPORTSTREAMABLEITEMS: FILEOPENDIALOGOPTIONS = FILEOPENDIALOGOPTIONS(2147483648u32);
impl ::core::marker::Copy for FILEOPENDIALOGOPTIONS {}
impl ::core::clone::Clone for FILEOPENDIALOGOPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILEOPENDIALOGOPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FILEOPENDIALOGOPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILEOPENDIALOGOPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for FILEOPENDIALOGOPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FILETYPEATTRIBUTEFLAGS(pub i32);
pub const FTA_None: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(0i32);
pub const FTA_Exclude: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(1i32);
pub const FTA_Show: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(2i32);
pub const FTA_HasExtension: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(4i32);
pub const FTA_NoEdit: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(8i32);
pub const FTA_NoRemove: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(16i32);
pub const FTA_NoNewVerb: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(32i32);
pub const FTA_NoEditVerb: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(64i32);
pub const FTA_NoRemoveVerb: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(128i32);
pub const FTA_NoEditDesc: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(256i32);
pub const FTA_NoEditIcon: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(512i32);
pub const FTA_NoEditDflt: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(1024i32);
pub const FTA_NoEditVerbCmd: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(2048i32);
pub const FTA_NoEditVerbExe: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(4096i32);
pub const FTA_NoDDE: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(8192i32);
pub const FTA_NoEditMIME: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(32768i32);
pub const FTA_OpenIsSafe: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(65536i32);
pub const FTA_AlwaysUnsafe: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(131072i32);
pub const FTA_NoRecentDocs: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(1048576i32);
pub const FTA_SafeForElevation: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(2097152i32);
pub const FTA_AlwaysUseDirectInvoke: FILETYPEATTRIBUTEFLAGS = FILETYPEATTRIBUTEFLAGS(4194304i32);
impl ::core::marker::Copy for FILETYPEATTRIBUTEFLAGS {}
impl ::core::clone::Clone for FILETYPEATTRIBUTEFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILETYPEATTRIBUTEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FILETYPEATTRIBUTEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILETYPEATTRIBUTEFLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for FILETYPEATTRIBUTEFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct FILE_ATTRIBUTES_ARRAY {
    pub cItems: u32,
    pub dwSumFileAttributes: u32,
    pub dwProductFileAttributes: u32,
    pub rgdwFileAttributes: [u32; 1],
}
impl ::core::marker::Copy for FILE_ATTRIBUTES_ARRAY {}
impl ::core::clone::Clone for FILE_ATTRIBUTES_ARRAY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ATTRIBUTES_ARRAY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ATTRIBUTES_ARRAY")
            .field("cItems", &self.cItems)
            .field("dwSumFileAttributes", &self.dwSumFileAttributes)
            .field("dwProductFileAttributes", &self.dwProductFileAttributes)
            .field("rgdwFileAttributes", &self.rgdwFileAttributes)
            .finish()
    }
}
impl ::core::cmp::PartialEq for FILE_ATTRIBUTES_ARRAY {
    fn eq(&self, other: &Self) -> bool {
        self.cItems == other.cItems
            && self.dwSumFileAttributes == other.dwSumFileAttributes
            && self.dwProductFileAttributes == other.dwProductFileAttributes
            && self.rgdwFileAttributes == other.rgdwFileAttributes
    }
}
impl ::core::cmp::Eq for FILE_ATTRIBUTES_ARRAY {}
impl FromIntoMemory for FILE_ATTRIBUTES_ARRAY {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_cItems = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwSumFileAttributes = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwProductFileAttributes = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_rgdwFileAttributes = <[u32; 1] as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            cItems: f_cItems,
            dwSumFileAttributes: f_dwSumFileAttributes,
            dwProductFileAttributes: f_dwProductFileAttributes,
            rgdwFileAttributes: f_rgdwFileAttributes,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.cItems, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwSumFileAttributes, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwProductFileAttributes, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.rgdwFileAttributes, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FILE_OPERATION_FLAGS2(pub i32);
pub const FOF2_NONE: FILE_OPERATION_FLAGS2 = FILE_OPERATION_FLAGS2(0i32);
pub const FOF2_MERGEFOLDERSONCOLLISION: FILE_OPERATION_FLAGS2 = FILE_OPERATION_FLAGS2(1i32);
impl ::core::marker::Copy for FILE_OPERATION_FLAGS2 {}
impl ::core::clone::Clone for FILE_OPERATION_FLAGS2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_OPERATION_FLAGS2 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FILE_OPERATION_FLAGS2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_OPERATION_FLAGS2")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for FILE_OPERATION_FLAGS2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FILE_USAGE_TYPE(pub i32);
pub const FUT_PLAYING: FILE_USAGE_TYPE = FILE_USAGE_TYPE(0i32);
pub const FUT_EDITING: FILE_USAGE_TYPE = FILE_USAGE_TYPE(1i32);
pub const FUT_GENERIC: FILE_USAGE_TYPE = FILE_USAGE_TYPE(2i32);
impl ::core::marker::Copy for FILE_USAGE_TYPE {}
impl ::core::clone::Clone for FILE_USAGE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_USAGE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FILE_USAGE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_USAGE_TYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for FILE_USAGE_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FLYOUT_PLACEMENT(pub i32);
pub const FP_DEFAULT: FLYOUT_PLACEMENT = FLYOUT_PLACEMENT(0i32);
pub const FP_ABOVE: FLYOUT_PLACEMENT = FLYOUT_PLACEMENT(1i32);
pub const FP_BELOW: FLYOUT_PLACEMENT = FLYOUT_PLACEMENT(2i32);
pub const FP_LEFT: FLYOUT_PLACEMENT = FLYOUT_PLACEMENT(3i32);
pub const FP_RIGHT: FLYOUT_PLACEMENT = FLYOUT_PLACEMENT(4i32);
impl ::core::marker::Copy for FLYOUT_PLACEMENT {}
impl ::core::clone::Clone for FLYOUT_PLACEMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FLYOUT_PLACEMENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FLYOUT_PLACEMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FLYOUT_PLACEMENT").field(&self.0).finish()
    }
}
impl FromIntoMemory for FLYOUT_PLACEMENT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const FMTID_Briefcase: crate::core::GUID =
    crate::core::GUID::from_u128(0x328d8b21_7729_4bfc_954c_902b329d56b0);
pub const FMTID_CustomImageProperties: crate::core::GUID =
    crate::core::GUID::from_u128(0x7ecd8b0e_c136_4a9b_9411_4ebd6673ccc3);
pub const FMTID_DRM: crate::core::GUID =
    crate::core::GUID::from_u128(0xaeac19e4_89ae_4508_b9b7_bb867abee2ed);
pub const FMTID_Displaced: crate::core::GUID =
    crate::core::GUID::from_u128(0x9b174b33_40ff_11d2_a27e_00c04fc30871);
pub const FMTID_ImageProperties: crate::core::GUID =
    crate::core::GUID::from_u128(0x14b81da1_0135_4d31_96d9_6cbfc9671a99);
pub const FMTID_InternetSite: crate::core::GUID =
    crate::core::GUID::from_u128(0x000214a1_0000_0000_c000_000000000046);
pub const FMTID_Intshcut: crate::core::GUID =
    crate::core::GUID::from_u128(0x000214a0_0000_0000_c000_000000000046);
pub const FMTID_LibraryProperties: crate::core::GUID =
    crate::core::GUID::from_u128(0x5d76b67f_9b3d_44bb_b6ae_25da4f638a67);
pub const FMTID_MUSIC: crate::core::GUID =
    crate::core::GUID::from_u128(0x56a3372e_ce9c_11d2_9f0e_006097c686f6);
pub const FMTID_Misc: crate::core::GUID =
    crate::core::GUID::from_u128(0x9b174b34_40ff_11d2_a27e_00c04fc30871);
pub const FMTID_Query: crate::core::GUID =
    crate::core::GUID::from_u128(0x49691c90_7e17_101a_a91c_08002b2ecda9);
pub const FMTID_ShellDetails: crate::core::GUID =
    crate::core::GUID::from_u128(0x28636aa6_953d_11d2_b5d6_00c04fd918d0);
pub const FMTID_Storage: crate::core::GUID =
    crate::core::GUID::from_u128(0xb725f130_47ef_101a_a5f1_02608c9eebac);
pub const FMTID_Volume: crate::core::GUID =
    crate::core::GUID::from_u128(0x9b174b35_40ff_11d2_a27e_00c04fc30871);
pub const FMTID_WebView: crate::core::GUID =
    crate::core::GUID::from_u128(0xf2275480_f782_4291_bd94_f13693513aec);
pub const FOFX_ADDUNDORECORD: u32 = 536870912u32;
pub const FOFX_COPYASDOWNLOAD: u32 = 1073741824u32;
pub const FOFX_DONTDISPLAYDESTPATH: u32 = 134217728u32;
pub const FOFX_DONTDISPLAYLOCATIONS: u32 = 2147483648u32;
pub const FOFX_DONTDISPLAYSOURCEPATH: u32 = 67108864u32;
pub const FOFX_EARLYFAILURE: u32 = 1048576u32;
pub const FOFX_KEEPNEWERFILE: u32 = 4194304u32;
pub const FOFX_MOVEACLSACROSSVOLUMES: u32 = 33554432u32;
pub const FOFX_NOCOPYHOOKS: u32 = 8388608u32;
pub const FOFX_NOMINIMIZEBOX: u32 = 16777216u32;
pub const FOFX_NOSKIPJUNCTIONS: u32 = 65536u32;
pub const FOFX_PREFERHARDLINK: u32 = 131072u32;
pub const FOFX_PRESERVEFILEEXTENSIONS: u32 = 2097152u32;
pub const FOFX_RECYCLEONDELETE: u32 = 524288u32;
pub const FOFX_REQUIREELEVATION: u32 = 268435456u32;
pub const FOFX_SHOWELEVATIONPROMPT: u32 = 262144u32;
pub const FOF_ALLOWUNDO: u32 = 64u32;
pub const FOF_CONFIRMMOUSE: u32 = 2u32;
pub const FOF_FILESONLY: u32 = 128u32;
pub const FOF_MULTIDESTFILES: u32 = 1u32;
pub const FOF_NOCONFIRMATION: u32 = 16u32;
pub const FOF_NOCONFIRMMKDIR: u32 = 512u32;
pub const FOF_NOCOPYSECURITYATTRIBS: u32 = 2048u32;
pub const FOF_NOERRORUI: u32 = 1024u32;
pub const FOF_NORECURSEREPARSE: u32 = 32768u32;
pub const FOF_NORECURSION: u32 = 4096u32;
pub const FOF_NO_CONNECTED_ELEMENTS: u32 = 8192u32;
pub const FOF_RENAMEONCOLLISION: u32 = 8u32;
pub const FOF_SILENT: u32 = 4u32;
pub const FOF_SIMPLEPROGRESS: u32 = 256u32;
pub const FOF_WANTMAPPINGHANDLE: u32 = 32u32;
pub const FOF_WANTNUKEWARNING: u32 = 16384u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FOLDERFLAGS(pub i32);
pub const FWF_NONE: FOLDERFLAGS = FOLDERFLAGS(0i32);
pub const FWF_AUTOARRANGE: FOLDERFLAGS = FOLDERFLAGS(1i32);
pub const FWF_ABBREVIATEDNAMES: FOLDERFLAGS = FOLDERFLAGS(2i32);
pub const FWF_SNAPTOGRID: FOLDERFLAGS = FOLDERFLAGS(4i32);
pub const FWF_OWNERDATA: FOLDERFLAGS = FOLDERFLAGS(8i32);
pub const FWF_BESTFITWINDOW: FOLDERFLAGS = FOLDERFLAGS(16i32);
pub const FWF_DESKTOP: FOLDERFLAGS = FOLDERFLAGS(32i32);
pub const FWF_SINGLESEL: FOLDERFLAGS = FOLDERFLAGS(64i32);
pub const FWF_NOSUBFOLDERS: FOLDERFLAGS = FOLDERFLAGS(128i32);
pub const FWF_TRANSPARENT: FOLDERFLAGS = FOLDERFLAGS(256i32);
pub const FWF_NOCLIENTEDGE: FOLDERFLAGS = FOLDERFLAGS(512i32);
pub const FWF_NOSCROLL: FOLDERFLAGS = FOLDERFLAGS(1024i32);
pub const FWF_ALIGNLEFT: FOLDERFLAGS = FOLDERFLAGS(2048i32);
pub const FWF_NOICONS: FOLDERFLAGS = FOLDERFLAGS(4096i32);
pub const FWF_SHOWSELALWAYS: FOLDERFLAGS = FOLDERFLAGS(8192i32);
pub const FWF_NOVISIBLE: FOLDERFLAGS = FOLDERFLAGS(16384i32);
pub const FWF_SINGLECLICKACTIVATE: FOLDERFLAGS = FOLDERFLAGS(32768i32);
pub const FWF_NOWEBVIEW: FOLDERFLAGS = FOLDERFLAGS(65536i32);
pub const FWF_HIDEFILENAMES: FOLDERFLAGS = FOLDERFLAGS(131072i32);
pub const FWF_CHECKSELECT: FOLDERFLAGS = FOLDERFLAGS(262144i32);
pub const FWF_NOENUMREFRESH: FOLDERFLAGS = FOLDERFLAGS(524288i32);
pub const FWF_NOGROUPING: FOLDERFLAGS = FOLDERFLAGS(1048576i32);
pub const FWF_FULLROWSELECT: FOLDERFLAGS = FOLDERFLAGS(2097152i32);
pub const FWF_NOFILTERS: FOLDERFLAGS = FOLDERFLAGS(4194304i32);
pub const FWF_NOCOLUMNHEADER: FOLDERFLAGS = FOLDERFLAGS(8388608i32);
pub const FWF_NOHEADERINALLVIEWS: FOLDERFLAGS = FOLDERFLAGS(16777216i32);
pub const FWF_EXTENDEDTILES: FOLDERFLAGS = FOLDERFLAGS(33554432i32);
pub const FWF_TRICHECKSELECT: FOLDERFLAGS = FOLDERFLAGS(67108864i32);
pub const FWF_AUTOCHECKSELECT: FOLDERFLAGS = FOLDERFLAGS(134217728i32);
pub const FWF_NOBROWSERVIEWSTATE: FOLDERFLAGS = FOLDERFLAGS(268435456i32);
pub const FWF_SUBSETGROUPS: FOLDERFLAGS = FOLDERFLAGS(536870912i32);
pub const FWF_USESEARCHFOLDER: FOLDERFLAGS = FOLDERFLAGS(1073741824i32);
pub const FWF_ALLOWRTLREADING: FOLDERFLAGS = FOLDERFLAGS(-2147483648i32);
impl ::core::marker::Copy for FOLDERFLAGS {}
impl ::core::clone::Clone for FOLDERFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FOLDERFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FOLDERFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FOLDERFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for FOLDERFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const FOLDERID_AccountPictures: crate::core::GUID =
    crate::core::GUID::from_u128(0x008ca0b1_55b4_4c56_b8a8_4de4b299d3be);
pub const FOLDERID_AddNewPrograms: crate::core::GUID =
    crate::core::GUID::from_u128(0xde61d971_5ebc_4f02_a3a9_6c82895e5c04);
pub const FOLDERID_AdminTools: crate::core::GUID =
    crate::core::GUID::from_u128(0x724ef170_a42d_4fef_9f26_b60e846fba4f);
pub const FOLDERID_AllAppMods: crate::core::GUID =
    crate::core::GUID::from_u128(0x7ad67899_66af_43ba_9156_6aad42e6c596);
pub const FOLDERID_AppCaptures: crate::core::GUID =
    crate::core::GUID::from_u128(0xedc0fe71_98d8_4f4a_b920_c8dc133cb165);
pub const FOLDERID_AppDataDesktop: crate::core::GUID =
    crate::core::GUID::from_u128(0xb2c5e279_7add_439f_b28c_c41fe1bbf672);
pub const FOLDERID_AppDataDocuments: crate::core::GUID =
    crate::core::GUID::from_u128(0x7be16610_1f7f_44ac_bff0_83e15f2ffca1);
pub const FOLDERID_AppDataFavorites: crate::core::GUID =
    crate::core::GUID::from_u128(0x7cfbefbc_de1f_45aa_b843_a542ac536cc9);
pub const FOLDERID_AppDataProgramData: crate::core::GUID =
    crate::core::GUID::from_u128(0x559d40a3_a036_40fa_af61_84cb430a4d34);
pub const FOLDERID_AppUpdates: crate::core::GUID =
    crate::core::GUID::from_u128(0xa305ce99_f527_492b_8b1a_7e76fa98d6e4);
pub const FOLDERID_ApplicationShortcuts: crate::core::GUID =
    crate::core::GUID::from_u128(0xa3918781_e5f2_4890_b3d9_a7e54332328c);
pub const FOLDERID_AppsFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x1e87508d_89c2_42f0_8a7e_645a0f50ca58);
pub const FOLDERID_CDBurning: crate::core::GUID =
    crate::core::GUID::from_u128(0x9e52ab10_f80d_49df_acb8_4330f5687855);
pub const FOLDERID_CameraRoll: crate::core::GUID =
    crate::core::GUID::from_u128(0xab5fb87b_7ce2_4f83_915d_550846c9537b);
pub const FOLDERID_CameraRollLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0x2b20df75_1eda_4039_8097_38798227d5b7);
pub const FOLDERID_ChangeRemovePrograms: crate::core::GUID =
    crate::core::GUID::from_u128(0xdf7266ac_9274_4867_8d55_3bd661de872d);
pub const FOLDERID_CommonAdminTools: crate::core::GUID =
    crate::core::GUID::from_u128(0xd0384e7d_bac3_4797_8f14_cba229b392b5);
pub const FOLDERID_CommonOEMLinks: crate::core::GUID =
    crate::core::GUID::from_u128(0xc1bae2d0_10df_4334_bedd_7aa20b227a9d);
pub const FOLDERID_CommonPrograms: crate::core::GUID =
    crate::core::GUID::from_u128(0x0139d44e_6afe_49f2_8690_3dafcae6ffb8);
pub const FOLDERID_CommonStartMenu: crate::core::GUID =
    crate::core::GUID::from_u128(0xa4115719_d62e_491d_aa7c_e74b8be3b067);
pub const FOLDERID_CommonStartMenuPlaces: crate::core::GUID =
    crate::core::GUID::from_u128(0xa440879f_87a0_4f7d_b700_0207b966194a);
pub const FOLDERID_CommonStartup: crate::core::GUID =
    crate::core::GUID::from_u128(0x82a5ea35_d9cd_47c5_9629_e15d2f714e6e);
pub const FOLDERID_CommonTemplates: crate::core::GUID =
    crate::core::GUID::from_u128(0xb94237e7_57ac_4347_9151_b08c6c32d1f7);
pub const FOLDERID_ComputerFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x0ac0837c_bbf8_452a_850d_79d08e667ca7);
pub const FOLDERID_ConflictFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x4bfefb45_347d_4006_a5be_ac0cb0567192);
pub const FOLDERID_ConnectionsFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x6f0cd92b_2e97_45d1_88ff_b0d186b8dedd);
pub const FOLDERID_Contacts: crate::core::GUID =
    crate::core::GUID::from_u128(0x56784854_c6cb_462b_8169_88e350acb882);
pub const FOLDERID_ControlPanelFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x82a74aeb_aeb4_465c_a014_d097ee346d63);
pub const FOLDERID_Cookies: crate::core::GUID =
    crate::core::GUID::from_u128(0x2b0f765d_c0e9_4171_908e_08a611b84ff6);
pub const FOLDERID_CurrentAppMods: crate::core::GUID =
    crate::core::GUID::from_u128(0x3db40b20_2a30_4dbe_917e_771dd21dd099);
pub const FOLDERID_Desktop: crate::core::GUID =
    crate::core::GUID::from_u128(0xb4bfcc3a_db2c_424c_b029_7fe99a87c641);
pub const FOLDERID_DevelopmentFiles: crate::core::GUID =
    crate::core::GUID::from_u128(0xdbe8e08e_3053_4bbc_b183_2a7b2b191e59);
pub const FOLDERID_Device: crate::core::GUID =
    crate::core::GUID::from_u128(0x1c2ac1dc_4358_4b6c_9733_af21156576f0);
pub const FOLDERID_DeviceMetadataStore: crate::core::GUID =
    crate::core::GUID::from_u128(0x5ce4a5e9_e4eb_479d_b89f_130c02886155);
pub const FOLDERID_Documents: crate::core::GUID =
    crate::core::GUID::from_u128(0xfdd39ad0_238f_46af_adb4_6c85480369c7);
pub const FOLDERID_DocumentsLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0x7b0db17d_9cd2_4a93_9733_46cc89022e7c);
pub const FOLDERID_Downloads: crate::core::GUID =
    crate::core::GUID::from_u128(0x374de290_123f_4565_9164_39c4925e467b);
pub const FOLDERID_Favorites: crate::core::GUID =
    crate::core::GUID::from_u128(0x1777f761_68ad_4d8a_87bd_30b759fa33dd);
pub const FOLDERID_Fonts: crate::core::GUID =
    crate::core::GUID::from_u128(0xfd228cb7_ae11_4ae3_864c_16f3910ab8fe);
pub const FOLDERID_GameTasks: crate::core::GUID =
    crate::core::GUID::from_u128(0x054fae61_4dd8_4787_80b6_090220c4b700);
pub const FOLDERID_Games: crate::core::GUID =
    crate::core::GUID::from_u128(0xcac52c1a_b53d_4edc_92d7_6b2e8ac19434);
pub const FOLDERID_History: crate::core::GUID =
    crate::core::GUID::from_u128(0xd9dc8a3b_b784_432e_a781_5a1130a75963);
pub const FOLDERID_HomeGroup: crate::core::GUID =
    crate::core::GUID::from_u128(0x52528a6b_b9e3_4add_b60d_588c2dba842d);
pub const FOLDERID_HomeGroupCurrentUser: crate::core::GUID =
    crate::core::GUID::from_u128(0x9b74b6a3_0dfd_4f11_9e78_5f7800f2e772);
pub const FOLDERID_ImplicitAppShortcuts: crate::core::GUID =
    crate::core::GUID::from_u128(0xbcb5256f_79f6_4cee_b725_dc34e402fd46);
pub const FOLDERID_InternetCache: crate::core::GUID =
    crate::core::GUID::from_u128(0x352481e8_33be_4251_ba85_6007caedcf9d);
pub const FOLDERID_InternetFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x4d9f7874_4e0c_4904_967b_40b0d20c3e4b);
pub const FOLDERID_Libraries: crate::core::GUID =
    crate::core::GUID::from_u128(0x1b3ea5dc_b587_4786_b4ef_bd1dc332aeae);
pub const FOLDERID_Links: crate::core::GUID =
    crate::core::GUID::from_u128(0xbfb9d5e0_c6a9_404c_b2b2_ae6db6af4968);
pub const FOLDERID_LocalAppData: crate::core::GUID =
    crate::core::GUID::from_u128(0xf1b32785_6fba_4fcf_9d55_7b8e7f157091);
pub const FOLDERID_LocalAppDataLow: crate::core::GUID =
    crate::core::GUID::from_u128(0xa520a1a4_1780_4ff6_bd18_167343c5af16);
pub const FOLDERID_LocalDocuments: crate::core::GUID =
    crate::core::GUID::from_u128(0xf42ee2d3_909f_4907_8871_4c22fc0bf756);
pub const FOLDERID_LocalDownloads: crate::core::GUID =
    crate::core::GUID::from_u128(0x7d83ee9b_2244_4e70_b1f5_5393042af1e4);
pub const FOLDERID_LocalMusic: crate::core::GUID =
    crate::core::GUID::from_u128(0xa0c69a99_21c8_4671_8703_7934162fcf1d);
pub const FOLDERID_LocalPictures: crate::core::GUID =
    crate::core::GUID::from_u128(0x0ddd015d_b06c_45d5_8c4c_f59713854639);
pub const FOLDERID_LocalStorage: crate::core::GUID =
    crate::core::GUID::from_u128(0xb3eb08d3_a1f3_496b_865a_42b536cda0ec);
pub const FOLDERID_LocalVideos: crate::core::GUID =
    crate::core::GUID::from_u128(0x35286a68_3c57_41a1_bbb1_0eae73d76c95);
pub const FOLDERID_LocalizedResourcesDir: crate::core::GUID =
    crate::core::GUID::from_u128(0x2a00375e_224c_49de_b8d1_440df7ef3ddc);
pub const FOLDERID_Music: crate::core::GUID =
    crate::core::GUID::from_u128(0x4bd8d571_6d19_48d3_be97_422220080e43);
pub const FOLDERID_MusicLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0x2112ab0a_c86a_4ffe_a368_0de96e47012e);
pub const FOLDERID_NetHood: crate::core::GUID =
    crate::core::GUID::from_u128(0xc5abbf53_e17f_4121_8900_86626fc2c973);
pub const FOLDERID_NetworkFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0xd20beec4_5ca8_4905_ae3b_bf251ea09b53);
pub const FOLDERID_Objects3D: crate::core::GUID =
    crate::core::GUID::from_u128(0x31c0dd25_9439_4f12_bf41_7ff4eda38722);
pub const FOLDERID_OneDrive: crate::core::GUID =
    crate::core::GUID::from_u128(0xa52bba46_e9e1_435f_b3d9_28daa648c0f6);
pub const FOLDERID_OriginalImages: crate::core::GUID =
    crate::core::GUID::from_u128(0x2c36c0aa_5812_4b87_bfd0_4cd0dfb19b39);
pub const FOLDERID_PhotoAlbums: crate::core::GUID =
    crate::core::GUID::from_u128(0x69d2cf90_fc33_4fb7_9a0c_ebb0f0fcb43c);
pub const FOLDERID_Pictures: crate::core::GUID =
    crate::core::GUID::from_u128(0x33e28130_4e1e_4676_835a_98395c3bc3bb);
pub const FOLDERID_PicturesLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0xa990ae9f_a03b_4e80_94bc_9912d7504104);
pub const FOLDERID_Playlists: crate::core::GUID =
    crate::core::GUID::from_u128(0xde92c1c7_837f_4f69_a3bb_86e631204a23);
pub const FOLDERID_PrintHood: crate::core::GUID =
    crate::core::GUID::from_u128(0x9274bd8d_cfd1_41c3_b35e_b13f55a758f4);
pub const FOLDERID_PrintersFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x76fc4e2d_d6ad_4519_a663_37bd56068185);
pub const FOLDERID_Profile: crate::core::GUID =
    crate::core::GUID::from_u128(0x5e6c858f_0e22_4760_9afe_ea3317b67173);
pub const FOLDERID_ProgramData: crate::core::GUID =
    crate::core::GUID::from_u128(0x62ab5d82_fdc1_4dc3_a9dd_070d1d495d97);
pub const FOLDERID_ProgramFiles: crate::core::GUID =
    crate::core::GUID::from_u128(0x905e63b6_c1bf_494e_b29c_65b732d3d21a);
pub const FOLDERID_ProgramFilesCommon: crate::core::GUID =
    crate::core::GUID::from_u128(0xf7f1ed05_9f6d_47a2_aaae_29d317c6f066);
pub const FOLDERID_ProgramFilesCommonX64: crate::core::GUID =
    crate::core::GUID::from_u128(0x6365d5a7_0f0d_45e5_87f6_0da56b6a4f7d);
pub const FOLDERID_ProgramFilesCommonX86: crate::core::GUID =
    crate::core::GUID::from_u128(0xde974d24_d9c6_4d3e_bf91_f4455120b917);
pub const FOLDERID_ProgramFilesX64: crate::core::GUID =
    crate::core::GUID::from_u128(0x6d809377_6af0_444b_8957_a3773f02200e);
pub const FOLDERID_ProgramFilesX86: crate::core::GUID =
    crate::core::GUID::from_u128(0x7c5a40ef_a0fb_4bfc_874a_c0f2e0b9fa8e);
pub const FOLDERID_Programs: crate::core::GUID =
    crate::core::GUID::from_u128(0xa77f5d77_2e2b_44c3_a6a2_aba601054a51);
pub const FOLDERID_Public: crate::core::GUID =
    crate::core::GUID::from_u128(0xdfdf76a2_c82a_4d63_906a_5644ac457385);
pub const FOLDERID_PublicDesktop: crate::core::GUID =
    crate::core::GUID::from_u128(0xc4aa340d_f20f_4863_afef_f87ef2e6ba25);
pub const FOLDERID_PublicDocuments: crate::core::GUID =
    crate::core::GUID::from_u128(0xed4824af_dce4_45a8_81e2_fc7965083634);
pub const FOLDERID_PublicDownloads: crate::core::GUID =
    crate::core::GUID::from_u128(0x3d644c9b_1fb8_4f30_9b45_f670235f79c0);
pub const FOLDERID_PublicGameTasks: crate::core::GUID =
    crate::core::GUID::from_u128(0xdebf2536_e1a8_4c59_b6a2_414586476aea);
pub const FOLDERID_PublicLibraries: crate::core::GUID =
    crate::core::GUID::from_u128(0x48daf80b_e6cf_4f4e_b800_0e69d84ee384);
pub const FOLDERID_PublicMusic: crate::core::GUID =
    crate::core::GUID::from_u128(0x3214fab5_9757_4298_bb61_92a9deaa44ff);
pub const FOLDERID_PublicPictures: crate::core::GUID =
    crate::core::GUID::from_u128(0xb6ebfb86_6907_413c_9af7_4fc2abf07cc5);
pub const FOLDERID_PublicRingtones: crate::core::GUID =
    crate::core::GUID::from_u128(0xe555ab60_153b_4d17_9f04_a5fe99fc15ec);
pub const FOLDERID_PublicUserTiles: crate::core::GUID =
    crate::core::GUID::from_u128(0x0482af6c_08f1_4c34_8c90_e17ec98b1e17);
pub const FOLDERID_PublicVideos: crate::core::GUID =
    crate::core::GUID::from_u128(0x2400183a_6185_49fb_a2d8_4a392a602ba3);
pub const FOLDERID_QuickLaunch: crate::core::GUID =
    crate::core::GUID::from_u128(0x52a4f021_7b75_48a9_9f6b_4b87a210bc8f);
pub const FOLDERID_Recent: crate::core::GUID =
    crate::core::GUID::from_u128(0xae50c081_ebd2_438a_8655_8a092e34987a);
pub const FOLDERID_RecordedCalls: crate::core::GUID =
    crate::core::GUID::from_u128(0x2f8b40c2_83ed_48ee_b383_a1f157ec6f9a);
pub const FOLDERID_RecordedTVLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0x1a6fdba2_f42d_4358_a798_b74d745926c5);
pub const FOLDERID_RecycleBinFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0xb7534046_3ecb_4c18_be4e_64cd4cb7d6ac);
pub const FOLDERID_ResourceDir: crate::core::GUID =
    crate::core::GUID::from_u128(0x8ad10c31_2adb_4296_a8f7_e4701232c972);
pub const FOLDERID_RetailDemo: crate::core::GUID =
    crate::core::GUID::from_u128(0x12d4c69e_24ad_4923_be19_31321c43a767);
pub const FOLDERID_Ringtones: crate::core::GUID =
    crate::core::GUID::from_u128(0xc870044b_f49e_4126_a9c3_b52a1ff411e8);
pub const FOLDERID_RoamedTileImages: crate::core::GUID =
    crate::core::GUID::from_u128(0xaaa8d5a5_f1d6_4259_baa8_78e7ef60835e);
pub const FOLDERID_RoamingAppData: crate::core::GUID =
    crate::core::GUID::from_u128(0x3eb685db_65f9_4cf6_a03a_e3ef65729f3d);
pub const FOLDERID_RoamingTiles: crate::core::GUID =
    crate::core::GUID::from_u128(0x00bcfc5a_ed94_4e48_96a1_3f6217f21990);
pub const FOLDERID_SEARCH_CSC: crate::core::GUID =
    crate::core::GUID::from_u128(0xee32e446_31ca_4aba_814f_a5ebd2fd6d5e);
pub const FOLDERID_SEARCH_MAPI: crate::core::GUID =
    crate::core::GUID::from_u128(0x98ec0e18_2098_4d44_8644_66979315a281);
pub const FOLDERID_SampleMusic: crate::core::GUID =
    crate::core::GUID::from_u128(0xb250c668_f57d_4ee1_a63c_290ee7d1aa1f);
pub const FOLDERID_SamplePictures: crate::core::GUID =
    crate::core::GUID::from_u128(0xc4900540_2379_4c75_844b_64e6faf8716b);
pub const FOLDERID_SamplePlaylists: crate::core::GUID =
    crate::core::GUID::from_u128(0x15ca69b3_30ee_49c1_ace1_6b5ec372afb5);
pub const FOLDERID_SampleVideos: crate::core::GUID =
    crate::core::GUID::from_u128(0x859ead94_2e85_48ad_a71a_0969cb56a6cd);
pub const FOLDERID_SavedGames: crate::core::GUID =
    crate::core::GUID::from_u128(0x4c5c32ff_bb9d_43b0_b5b4_2d72e54eaaa4);
pub const FOLDERID_SavedPictures: crate::core::GUID =
    crate::core::GUID::from_u128(0x3b193882_d3ad_4eab_965a_69829d1fb59f);
pub const FOLDERID_SavedPicturesLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0xe25b5812_be88_4bd9_94b0_29233477b6c3);
pub const FOLDERID_SavedSearches: crate::core::GUID =
    crate::core::GUID::from_u128(0x7d1d3a04_debb_4115_95cf_2f29da2920da);
pub const FOLDERID_Screenshots: crate::core::GUID =
    crate::core::GUID::from_u128(0xb7bede81_df94_4682_a7d8_57a52620b86f);
pub const FOLDERID_SearchHistory: crate::core::GUID =
    crate::core::GUID::from_u128(0x0d4c3db6_03a3_462f_a0e6_08924c41b5d4);
pub const FOLDERID_SearchHome: crate::core::GUID =
    crate::core::GUID::from_u128(0x190337d1_b8ca_4121_a639_6d472d16972a);
pub const FOLDERID_SearchTemplates: crate::core::GUID =
    crate::core::GUID::from_u128(0x7e636bfe_dfa9_4d5e_b456_d7b39851d8a9);
pub const FOLDERID_SendTo: crate::core::GUID =
    crate::core::GUID::from_u128(0x8983036c_27c0_404b_8f08_102d10dcfd74);
pub const FOLDERID_SidebarDefaultParts: crate::core::GUID =
    crate::core::GUID::from_u128(0x7b396e54_9ec5_4300_be0a_2482ebae1a26);
pub const FOLDERID_SidebarParts: crate::core::GUID =
    crate::core::GUID::from_u128(0xa75d362e_50fc_4fb7_ac2c_a8beaa314493);
pub const FOLDERID_SkyDrive: crate::core::GUID =
    crate::core::GUID::from_u128(0xa52bba46_e9e1_435f_b3d9_28daa648c0f6);
pub const FOLDERID_SkyDriveCameraRoll: crate::core::GUID =
    crate::core::GUID::from_u128(0x767e6811_49cb_4273_87c2_20f355e1085b);
pub const FOLDERID_SkyDriveDocuments: crate::core::GUID =
    crate::core::GUID::from_u128(0x24d89e24_2f19_4534_9dde_6a6671fbb8fe);
pub const FOLDERID_SkyDriveMusic: crate::core::GUID =
    crate::core::GUID::from_u128(0xc3f2459e_80d6_45dc_bfef_1f769f2be730);
pub const FOLDERID_SkyDrivePictures: crate::core::GUID =
    crate::core::GUID::from_u128(0x339719b5_8c47_4894_94c2_d8f77add44a6);
pub const FOLDERID_StartMenu: crate::core::GUID =
    crate::core::GUID::from_u128(0x625b53c3_ab48_4ec1_ba1f_a1ef4146fc19);
pub const FOLDERID_StartMenuAllPrograms: crate::core::GUID =
    crate::core::GUID::from_u128(0xf26305ef_6948_40b9_b255_81453d09c785);
pub const FOLDERID_Startup: crate::core::GUID =
    crate::core::GUID::from_u128(0xb97d20bb_f46a_4c97_ba10_5e3608430854);
pub const FOLDERID_SyncManagerFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x43668bf8_c14e_49b2_97c9_747784d784b7);
pub const FOLDERID_SyncResultsFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x289a9a43_be44_4057_a41b_587a76d7e7f9);
pub const FOLDERID_SyncSetupFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x0f214138_b1d3_4a90_bba9_27cbc0c5389a);
pub const FOLDERID_System: crate::core::GUID =
    crate::core::GUID::from_u128(0x1ac14e77_02e7_4e5d_b744_2eb1ae5198b7);
pub const FOLDERID_SystemX86: crate::core::GUID =
    crate::core::GUID::from_u128(0xd65231b0_b2f1_4857_a4ce_a8e7c6ea7d27);
pub const FOLDERID_Templates: crate::core::GUID =
    crate::core::GUID::from_u128(0xa63293e8_664e_48db_a079_df759e0509f7);
pub const FOLDERID_UserPinned: crate::core::GUID =
    crate::core::GUID::from_u128(0x9e3995ab_1f9c_4f13_b827_48b24b6c7174);
pub const FOLDERID_UserProfiles: crate::core::GUID =
    crate::core::GUID::from_u128(0x0762d272_c50a_4bb0_a382_697dcd729b80);
pub const FOLDERID_UserProgramFiles: crate::core::GUID =
    crate::core::GUID::from_u128(0x5cd7aee2_2219_4a67_b85d_6c9ce15660cb);
pub const FOLDERID_UserProgramFilesCommon: crate::core::GUID =
    crate::core::GUID::from_u128(0xbcbd3057_ca5c_4622_b42d_bc56db0ae516);
pub const FOLDERID_UsersFiles: crate::core::GUID =
    crate::core::GUID::from_u128(0xf3ce0f7c_4901_4acc_8648_d5d44b04ef8f);
pub const FOLDERID_UsersLibraries: crate::core::GUID =
    crate::core::GUID::from_u128(0xa302545d_deff_464b_abe8_61c8648d939b);
pub const FOLDERID_Videos: crate::core::GUID =
    crate::core::GUID::from_u128(0x18989b1d_99b5_455b_841c_ab7c74e4ddfc);
pub const FOLDERID_VideosLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0x491e922f_5643_4af4_a7eb_4e7a138d8174);
pub const FOLDERID_Windows: crate::core::GUID =
    crate::core::GUID::from_u128(0xf38bf404_1d43_42f2_9305_67de0b28fc23);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FOLDERLOGICALVIEWMODE(pub i32);
pub const FLVM_UNSPECIFIED: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(-1i32);
pub const FLVM_FIRST: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(1i32);
pub const FLVM_DETAILS: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(1i32);
pub const FLVM_TILES: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(2i32);
pub const FLVM_ICONS: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(3i32);
pub const FLVM_LIST: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(4i32);
pub const FLVM_CONTENT: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(5i32);
pub const FLVM_LAST: FOLDERLOGICALVIEWMODE = FOLDERLOGICALVIEWMODE(5i32);
impl ::core::marker::Copy for FOLDERLOGICALVIEWMODE {}
impl ::core::clone::Clone for FOLDERLOGICALVIEWMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FOLDERLOGICALVIEWMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FOLDERLOGICALVIEWMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FOLDERLOGICALVIEWMODE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for FOLDERLOGICALVIEWMODE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct FOLDERSETDATA {
    pub _fs: FOLDERSETTINGS,
    pub _vidRestore: crate::core::GUID,
    pub _dwViewPriority: u32,
}
impl ::core::marker::Copy for FOLDERSETDATA {}
impl ::core::clone::Clone for FOLDERSETDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FOLDERSETDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FOLDERSETDATA")
            .field("_fs", &self._fs)
            .field("_vidRestore", &self._vidRestore)
            .field("_dwViewPriority", &self._dwViewPriority)
            .finish()
    }
}
impl ::core::cmp::PartialEq for FOLDERSETDATA {
    fn eq(&self, other: &Self) -> bool {
        self._fs == other._fs
            && self._vidRestore == other._vidRestore
            && self._dwViewPriority == other._dwViewPriority
    }
}
impl ::core::cmp::Eq for FOLDERSETDATA {}
impl FromIntoMemory for FOLDERSETDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f__fs = <FOLDERSETTINGS as FromIntoMemory>::from_bytes(&from[0..0 + 8]);
        let f__vidRestore = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f__dwViewPriority = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            _fs: f__fs,
            _vidRestore: f__vidRestore,
            _dwViewPriority: f__dwViewPriority,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self._fs, &mut into[0..0 + 8]);
        FromIntoMemory::into_bytes(self._vidRestore, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self._dwViewPriority, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
pub struct FOLDERSETTINGS {
    pub ViewMode: u32,
    pub fFlags: u32,
}
impl ::core::marker::Copy for FOLDERSETTINGS {}
impl ::core::clone::Clone for FOLDERSETTINGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FOLDERSETTINGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FOLDERSETTINGS")
            .field("ViewMode", &self.ViewMode)
            .field("fFlags", &self.fFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for FOLDERSETTINGS {
    fn eq(&self, other: &Self) -> bool {
        self.ViewMode == other.ViewMode && self.fFlags == other.fFlags
    }
}
impl ::core::cmp::Eq for FOLDERSETTINGS {}
impl FromIntoMemory for FOLDERSETTINGS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_ViewMode = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            ViewMode: f_ViewMode,
            fFlags: f_fFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.ViewMode, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fFlags, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub const FOLDERTYPEID_AccountPictures: crate::core::GUID =
    crate::core::GUID::from_u128(0xdb2a5d8f_06e6_4007_aba6_af877d526ea6);
pub const FOLDERTYPEID_Communications: crate::core::GUID =
    crate::core::GUID::from_u128(0x91475fe5_586b_4eba_8d75_d17434b8cdf6);
pub const FOLDERTYPEID_CompressedFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x80213e82_bcfd_4c4f_8817_bb27601267a9);
pub const FOLDERTYPEID_Contacts: crate::core::GUID =
    crate::core::GUID::from_u128(0xde2b70ec_9bf7_4a93_bd3d_243f7881d492);
pub const FOLDERTYPEID_ControlPanelCategory: crate::core::GUID =
    crate::core::GUID::from_u128(0xde4f0660_fa10_4b8f_a494_068b20b22307);
pub const FOLDERTYPEID_ControlPanelClassic: crate::core::GUID =
    crate::core::GUID::from_u128(0x0c3794f3_b545_43aa_a329_c37430c58d2a);
pub const FOLDERTYPEID_Documents: crate::core::GUID =
    crate::core::GUID::from_u128(0x7d49d726_3c21_4f05_99aa_fdc2c9474656);
pub const FOLDERTYPEID_Downloads: crate::core::GUID =
    crate::core::GUID::from_u128(0x885a186e_a440_4ada_812b_db871b942259);
pub const FOLDERTYPEID_Games: crate::core::GUID =
    crate::core::GUID::from_u128(0xb689b0d0_76d3_4cbb_87f7_585d0e0ce070);
pub const FOLDERTYPEID_Generic: crate::core::GUID =
    crate::core::GUID::from_u128(0x5c4f28b5_f869_4e84_8e60_f11db97c5cc7);
pub const FOLDERTYPEID_GenericLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0x5f4eab9a_6833_4f61_899d_31cf46979d49);
pub const FOLDERTYPEID_GenericSearchResults: crate::core::GUID =
    crate::core::GUID::from_u128(0x7fde1a1e_8b31_49a5_93b8_6be14cfa4943);
pub const FOLDERTYPEID_Invalid: crate::core::GUID =
    crate::core::GUID::from_u128(0x57807898_8c4f_4462_bb63_71042380b109);
pub const FOLDERTYPEID_Music: crate::core::GUID =
    crate::core::GUID::from_u128(0x94d6ddcc_4a68_4175_a374_bd584a510b78);
pub const FOLDERTYPEID_NetworkExplorer: crate::core::GUID =
    crate::core::GUID::from_u128(0x25cc242b_9a7c_4f51_80e0_7a2928febe42);
pub const FOLDERTYPEID_OpenSearch: crate::core::GUID =
    crate::core::GUID::from_u128(0x8faf9629_1980_46ff_8023_9dceab9c3ee3);
pub const FOLDERTYPEID_OtherUsers: crate::core::GUID =
    crate::core::GUID::from_u128(0xb337fd00_9dd5_4635_a6d4_da33fd102b7a);
pub const FOLDERTYPEID_Pictures: crate::core::GUID =
    crate::core::GUID::from_u128(0xb3690e58_e961_423b_b687_386ebfd83239);
pub const FOLDERTYPEID_Printers: crate::core::GUID =
    crate::core::GUID::from_u128(0x2c7bbec6_c844_4a0a_91fa_cef6f59cfda1);
pub const FOLDERTYPEID_PublishedItems: crate::core::GUID =
    crate::core::GUID::from_u128(0x7f2f5b96_ff74_41da_afd8_1c78a5f3aea2);
pub const FOLDERTYPEID_RecordedTV: crate::core::GUID =
    crate::core::GUID::from_u128(0x5557a28f_5da6_4f83_8809_c2c98a11a6fa);
pub const FOLDERTYPEID_RecycleBin: crate::core::GUID =
    crate::core::GUID::from_u128(0xd6d9e004_cd87_442b_9d57_5e0aeb4f6f72);
pub const FOLDERTYPEID_SavedGames: crate::core::GUID =
    crate::core::GUID::from_u128(0xd0363307_28cb_4106_9f23_2956e3e5e0e7);
pub const FOLDERTYPEID_SearchConnector: crate::core::GUID =
    crate::core::GUID::from_u128(0x982725ee_6f47_479e_b447_812bfa7d2e8f);
pub const FOLDERTYPEID_SearchHome: crate::core::GUID =
    crate::core::GUID::from_u128(0x834d8a44_0974_4ed6_866e_f203d80b3810);
pub const FOLDERTYPEID_Searches: crate::core::GUID =
    crate::core::GUID::from_u128(0x0b0ba2e3_405f_415e_a6ee_cad625207853);
pub const FOLDERTYPEID_SoftwareExplorer: crate::core::GUID =
    crate::core::GUID::from_u128(0xd674391b_52d9_4e07_834e_67c98610f39d);
pub const FOLDERTYPEID_StartMenu: crate::core::GUID =
    crate::core::GUID::from_u128(0xef87b4cb_f2ce_4785_8658_4ca6c63e38c6);
pub const FOLDERTYPEID_StorageProviderDocuments: crate::core::GUID =
    crate::core::GUID::from_u128(0xdd61bd66_70e8_48dd_9655_65c5e1aac2d1);
pub const FOLDERTYPEID_StorageProviderGeneric: crate::core::GUID =
    crate::core::GUID::from_u128(0x4f01ebc5_2385_41f2_a28e_2c5c91fb56e0);
pub const FOLDERTYPEID_StorageProviderMusic: crate::core::GUID =
    crate::core::GUID::from_u128(0x672ecd7e_af04_4399_875c_0290845b6247);
pub const FOLDERTYPEID_StorageProviderPictures: crate::core::GUID =
    crate::core::GUID::from_u128(0x71d642a9_f2b1_42cd_ad92_eb9300c7cc0a);
pub const FOLDERTYPEID_StorageProviderVideos: crate::core::GUID =
    crate::core::GUID::from_u128(0x51294da1_d7b1_485b_9e9a_17cffe33e187);
pub const FOLDERTYPEID_UserFiles: crate::core::GUID =
    crate::core::GUID::from_u128(0xcd0fc69b_71e2_46e5_9690_5bcd9f57aab3);
pub const FOLDERTYPEID_UsersLibraries: crate::core::GUID =
    crate::core::GUID::from_u128(0xc4d98f09_6124_4fe0_9942_826416082da9);
pub const FOLDERTYPEID_Videos: crate::core::GUID =
    crate::core::GUID::from_u128(0x5fa96407_7e77_483c_ac93_691d05850de8);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FOLDERVIEWMODE(pub i32);
pub const FVM_AUTO: FOLDERVIEWMODE = FOLDERVIEWMODE(-1i32);
pub const FVM_FIRST: FOLDERVIEWMODE = FOLDERVIEWMODE(1i32);
pub const FVM_ICON: FOLDERVIEWMODE = FOLDERVIEWMODE(1i32);
pub const FVM_SMALLICON: FOLDERVIEWMODE = FOLDERVIEWMODE(2i32);
pub const FVM_LIST: FOLDERVIEWMODE = FOLDERVIEWMODE(3i32);
pub const FVM_DETAILS: FOLDERVIEWMODE = FOLDERVIEWMODE(4i32);
pub const FVM_THUMBNAIL: FOLDERVIEWMODE = FOLDERVIEWMODE(5i32);
pub const FVM_TILE: FOLDERVIEWMODE = FOLDERVIEWMODE(6i32);
pub const FVM_THUMBSTRIP: FOLDERVIEWMODE = FOLDERVIEWMODE(7i32);
pub const FVM_CONTENT: FOLDERVIEWMODE = FOLDERVIEWMODE(8i32);
pub const FVM_LAST: FOLDERVIEWMODE = FOLDERVIEWMODE(8i32);
impl ::core::marker::Copy for FOLDERVIEWMODE {}
impl ::core::clone::Clone for FOLDERVIEWMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FOLDERVIEWMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FOLDERVIEWMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FOLDERVIEWMODE").field(&self.0).finish()
    }
}
impl FromIntoMemory for FOLDERVIEWMODE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FOLDERVIEWOPTIONS(pub i32);
pub const FVO_DEFAULT: FOLDERVIEWOPTIONS = FOLDERVIEWOPTIONS(0i32);
pub const FVO_VISTALAYOUT: FOLDERVIEWOPTIONS = FOLDERVIEWOPTIONS(1i32);
pub const FVO_CUSTOMPOSITION: FOLDERVIEWOPTIONS = FOLDERVIEWOPTIONS(2i32);
pub const FVO_CUSTOMORDERING: FOLDERVIEWOPTIONS = FOLDERVIEWOPTIONS(4i32);
pub const FVO_SUPPORTHYPERLINKS: FOLDERVIEWOPTIONS = FOLDERVIEWOPTIONS(8i32);
pub const FVO_NOANIMATIONS: FOLDERVIEWOPTIONS = FOLDERVIEWOPTIONS(16i32);
pub const FVO_NOSCROLLTIPS: FOLDERVIEWOPTIONS = FOLDERVIEWOPTIONS(32i32);
impl ::core::marker::Copy for FOLDERVIEWOPTIONS {}
impl ::core::clone::Clone for FOLDERVIEWOPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FOLDERVIEWOPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FOLDERVIEWOPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FOLDERVIEWOPTIONS").field(&self.0).finish()
    }
}
impl FromIntoMemory for FOLDERVIEWOPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FOLDER_ENUM_MODE(pub i32);
pub const FEM_VIEWRESULT: FOLDER_ENUM_MODE = FOLDER_ENUM_MODE(0i32);
pub const FEM_NAVIGATION: FOLDER_ENUM_MODE = FOLDER_ENUM_MODE(1i32);
impl ::core::marker::Copy for FOLDER_ENUM_MODE {}
impl ::core::clone::Clone for FOLDER_ENUM_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FOLDER_ENUM_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FOLDER_ENUM_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FOLDER_ENUM_MODE").field(&self.0).finish()
    }
}
impl FromIntoMemory for FOLDER_ENUM_MODE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const FO_COPY: u32 = 2u32;
pub const FO_DELETE: u32 = 3u32;
pub const FO_MOVE: u32 = 1u32;
pub const FO_RENAME: u32 = 4u32;
pub const FSCopyHandler: crate::core::GUID =
    crate::core::GUID::from_u128(0xd197380a_0a79_4dc8_a033_ed882c2fa14b);
pub const FVSIF_CANVIEWIT: u32 = 1073741824u32;
pub const FVSIF_NEWFAILED: u32 = 134217728u32;
pub const FVSIF_NEWFILE: u32 = 2147483648u32;
pub const FVSIF_PINNED: u32 = 2u32;
pub const FVSIF_RECT: u32 = 1u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct FVTEXTTYPE(pub i32);
pub const FVST_EMPTYTEXT: FVTEXTTYPE = FVTEXTTYPE(0i32);
impl ::core::marker::Copy for FVTEXTTYPE {}
impl ::core::clone::Clone for FVTEXTTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FVTEXTTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for FVTEXTTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FVTEXTTYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for FVTEXTTYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const FileOpenDialog: crate::core::GUID =
    crate::core::GUID::from_u128(0xdc1c5a9c_e88a_4dde_a5a1_60f82a20aef7);
pub const FileOperation: crate::core::GUID =
    crate::core::GUID::from_u128(0x3ad05575_8857_4850_9277_11b85bdb8e09);
pub const FileSaveDialog: crate::core::GUID =
    crate::core::GUID::from_u128(0xc0b4e2f3_ba21_4773_8dba_335ec946eb8b);
pub const FileSearchBand: crate::core::GUID =
    crate::core::GUID::from_u128(0xc4ee31f3_4768_11d2_be5c_00a0c9a83da1);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct Folder(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait Folder_Trait: super::super::System::Com::IDispatch_Trait {
    fn get_Title(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Title")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_ParentFolder(&self, ppsf: MutPtr<Folder>) -> crate::core::HRESULT {
        todo!("get_ParentFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Items(&self, ppid: MutPtr<FolderItems>) -> crate::core::HRESULT {
        todo!("Items")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ParseName(
        &self,
        b_name: super::super::Foundation::BSTR,
        ppid: MutPtr<FolderItem>,
    ) -> crate::core::HRESULT {
        todo!("ParseName")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn NewFolder(
        &self,
        b_name: super::super::Foundation::BSTR,
        v_options: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("NewFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn MoveHere(
        &self,
        v_item: super::super::System::Com::VARIANT,
        v_options: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("MoveHere")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CopyHere(
        &self,
        v_item: super::super::System::Com::VARIANT,
        v_options: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("CopyHere")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDetailsOf(
        &self,
        v_item: super::super::System::Com::VARIANT,
        i_column: i32,
        pbs: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetDetailsOf")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for Folder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for Folder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for Folder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for Folder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for Folder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("Folder").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for Folder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for Folder {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xbbcbde60_c3ff_11ce_8350_444553540000);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct Folder2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait Folder2_Trait: Folder_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Self(&self, ppfi: MutPtr<FolderItem>) -> crate::core::HRESULT {
        todo!("get_Self")
    }
    fn get_OfflineStatus(&self, pul: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_OfflineStatus")
    }
    fn Synchronize(&self) -> crate::core::HRESULT {
        todo!("Synchronize")
    }
    fn get_HaveToShowWebViewBarricade(
        &self,
        pb_have_to_show_web_view_barricade: MutPtr<i16>,
    ) -> crate::core::HRESULT {
        todo!("get_HaveToShowWebViewBarricade")
    }
    fn DismissedWebViewBarricade(&self) -> crate::core::HRESULT {
        todo!("DismissedWebViewBarricade")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for Folder2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for Folder2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for Folder2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for Folder2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for Folder2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("Folder2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for Folder2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for Folder2 {
    type Super = Folder;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf0d2d8ef_3890_11d2_bf8b_00c04fb93661);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct Folder3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait Folder3_Trait: Folder2_Trait {
    fn get_ShowWebViewBarricade(
        &self,
        pb_show_web_view_barricade: MutPtr<i16>,
    ) -> crate::core::HRESULT {
        todo!("get_ShowWebViewBarricade")
    }
    fn put_ShowWebViewBarricade(&self, b_show_web_view_barricade: i16) -> crate::core::HRESULT {
        todo!("put_ShowWebViewBarricade")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for Folder3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for Folder3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for Folder3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for Folder3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for Folder3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("Folder3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for Folder3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for Folder3 {
    type Super = Folder2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa7ae5f64_c4d7_4d7f_9307_4d24ee54b841);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct FolderItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait FolderItem_Trait: super::super::System::Com::IDispatch_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    fn get_Name(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Name")
    }
    fn put_Name(&self, bs: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_Name")
    }
    fn get_Path(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Path")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_GetLink(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_GetLink")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_GetFolder(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_GetFolder")
    }
    fn get_IsLink(&self, pb: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_IsLink")
    }
    fn get_IsFolder(&self, pb: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_IsFolder")
    }
    fn get_IsFileSystem(&self, pb: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_IsFileSystem")
    }
    fn get_IsBrowsable(&self, pb: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_IsBrowsable")
    }
    fn get_ModifyDate(&self, pdt: MutPtr<f64>) -> crate::core::HRESULT {
        todo!("get_ModifyDate")
    }
    fn put_ModifyDate(&self, dt: f64) -> crate::core::HRESULT {
        todo!("put_ModifyDate")
    }
    fn get_Size(&self, pul: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Size")
    }
    fn get_Type(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Type")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Verbs(&self, ppfic: MutPtr<FolderItemVerbs>) -> crate::core::HRESULT {
        todo!("Verbs")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InvokeVerb(&self, v_verb: super::super::System::Com::VARIANT) -> crate::core::HRESULT {
        todo!("InvokeVerb")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for FolderItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for FolderItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for FolderItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for FolderItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for FolderItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FolderItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for FolderItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for FolderItem {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfac32c80_cbe4_11ce_8350_444553540000);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct FolderItem2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait FolderItem2_Trait: FolderItem_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InvokeVerbEx(
        &self,
        v_verb: super::super::System::Com::VARIANT,
        v_args: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("InvokeVerbEx")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ExtendedProperty(
        &self,
        bstr_prop_name: super::super::Foundation::BSTR,
        pv_ret: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ExtendedProperty")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for FolderItem2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for FolderItem2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for FolderItem2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for FolderItem2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for FolderItem2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FolderItem2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for FolderItem2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for FolderItem2 {
    type Super = FolderItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xedc817aa_92b8_11d1_b075_00c04fc33aa5);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct FolderItemVerb(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait FolderItemVerb_Trait: super::super::System::Com::IDispatch_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    fn get_Name(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Name")
    }
    fn DoIt(&self) -> crate::core::HRESULT {
        todo!("DoIt")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for FolderItemVerb {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for FolderItemVerb {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for FolderItemVerb {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for FolderItemVerb {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for FolderItemVerb {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FolderItemVerb").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for FolderItemVerb {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for FolderItemVerb {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x08ec3e00_50b0_11cf_960c_0080c7f4ee85);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct FolderItemVerbs(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait FolderItemVerbs_Trait: super::super::System::Com::IDispatch_Trait {
    fn get_Count(&self, pl_count: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Count")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Item(
        &self,
        index: super::super::System::Com::VARIANT,
        ppid: MutPtr<FolderItemVerb>,
    ) -> crate::core::HRESULT {
        todo!("Item")
    }
    fn _NewEnum(&self, ppunk: MutPtr<crate::core::IUnknown>) -> crate::core::HRESULT {
        todo!("_NewEnum")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for FolderItemVerbs {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for FolderItemVerbs {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for FolderItemVerbs {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for FolderItemVerbs {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for FolderItemVerbs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FolderItemVerbs").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for FolderItemVerbs {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for FolderItemVerbs {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1f8352c0_50b0_11cf_960c_0080c7f4ee85);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct FolderItems(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait FolderItems_Trait: super::super::System::Com::IDispatch_Trait {
    fn get_Count(&self, pl_count: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Count")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Item(
        &self,
        index: super::super::System::Com::VARIANT,
        ppid: MutPtr<FolderItem>,
    ) -> crate::core::HRESULT {
        todo!("Item")
    }
    fn _NewEnum(&self, ppunk: MutPtr<crate::core::IUnknown>) -> crate::core::HRESULT {
        todo!("_NewEnum")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for FolderItems {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for FolderItems {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for FolderItems {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for FolderItems {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for FolderItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FolderItems").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for FolderItems {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for FolderItems {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x744129e0_cbe5_11ce_8350_444553540000);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct FolderItems2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait FolderItems2_Trait: FolderItems_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InvokeVerbEx(
        &self,
        v_verb: super::super::System::Com::VARIANT,
        v_args: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("InvokeVerbEx")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for FolderItems2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for FolderItems2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for FolderItems2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for FolderItems2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for FolderItems2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FolderItems2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for FolderItems2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for FolderItems2 {
    type Super = FolderItems;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc94f0ad0_f363_11d2_a327_00c04f8eec7f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct FolderItems3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait FolderItems3_Trait: FolderItems2_Trait {
    fn Filter(
        &self,
        grf_flags: i32,
        bstr_file_spec: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("Filter")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Verbs(&self, ppfic: MutPtr<FolderItemVerbs>) -> crate::core::HRESULT {
        todo!("get_Verbs")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for FolderItems3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for FolderItems3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for FolderItems3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for FolderItems3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for FolderItems3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FolderItems3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for FolderItems3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for FolderItems3 {
    type Super = FolderItems2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xeaa7c309_bbec_49d5_821d_64d966cb667f);
}
pub const FolderViewHost: crate::core::GUID =
    crate::core::GUID::from_u128(0x20b1cb23_6968_4eb9_b7d4_a66d00d07cee);
pub const FrameworkInputPane: crate::core::GUID =
    crate::core::GUID::from_u128(0xd5120aa3_46ba_44c5_822d_ca8092c1fc72);
pub const FreeSpaceCategorizer: crate::core::GUID =
    crate::core::GUID::from_u128(0xb5607793_24ac_44c7_82e2_831726aa6cb7);
pub const GADOF_DIRTY: u32 = 1u32;
pub const GCS_HELPTEXT: u32 = 5u32;
pub const GCS_HELPTEXTA: u32 = 1u32;
pub const GCS_HELPTEXTW: u32 = 5u32;
pub const GCS_UNICODE: u32 = 4u32;
pub const GCS_VALIDATE: u32 = 6u32;
pub const GCS_VALIDATEA: u32 = 2u32;
pub const GCS_VALIDATEW: u32 = 6u32;
pub const GCS_VERB: u32 = 4u32;
pub const GCS_VERBA: u32 = 0u32;
pub const GCS_VERBICONW: u32 = 20u32;
pub const GCS_VERBW: u32 = 4u32;
pub const GCT_INVALID: u32 = 0u32;
pub const GCT_LFNCHAR: u32 = 1u32;
pub const GCT_SEPARATOR: u32 = 8u32;
pub const GCT_SHORTCHAR: u32 = 2u32;
pub const GCT_WILD: u32 = 4u32;
pub const GETPROPS_NONE: u32 = 0u32;
pub const GIL_ASYNC: u32 = 32u32;
pub const GIL_CHECKSHIELD: u32 = 512u32;
pub const GIL_DEFAULTICON: u32 = 64u32;
pub const GIL_DONTCACHE: u32 = 16u32;
pub const GIL_FORCENOSHIELD: u32 = 1024u32;
pub const GIL_FORSHELL: u32 = 2u32;
pub const GIL_FORSHORTCUT: u32 = 128u32;
pub const GIL_NOTFILENAME: u32 = 8u32;
pub const GIL_OPENICON: u32 = 1u32;
pub const GIL_PERCLASS: u32 = 4u32;
pub const GIL_PERINSTANCE: u32 = 2u32;
pub const GIL_SHIELD: u32 = 512u32;
pub const GIL_SIMULATEDOC: u32 = 1u32;
pub const GPFIDL_ALTNAME: i32 = 1i32;
pub const GPFIDL_DEFAULT: i32 = 0i32;
pub const GPFIDL_UNCPRINTER: i32 = 2i32;
pub const GenericCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x25cbb996_92ed_457e_b28c_4774084bd562);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HDROP(pub PtrDiffRepr);
impl HDROP {
    pub fn is_invalid(&self) -> bool {
        *self == unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for HDROP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::clone::Clone for HDROP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::marker::Copy for HDROP {}
impl ::core::hash::Hash for HDROP {
    fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}
impl ::core::fmt::Debug for HDROP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HDROP").field(&self.0).finish()
    }
}
impl FromIntoMemory for HDROP {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<PtrDiffRepr as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        std::mem::size_of::<PtrDiffRepr>()
    }
}
pub struct HELPINFO {
    pub cbSize: u32,
    pub iContextType: i32,
    pub iCtrlId: i32,
    pub hItemHandle: super::super::Foundation::HANDLE,
    pub dwContextId: PtrRepr,
    pub MousePos: super::super::Foundation::POINT,
}
impl ::core::marker::Copy for HELPINFO {}
impl ::core::clone::Clone for HELPINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HELPINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HELPINFO")
            .field("cbSize", &self.cbSize)
            .field("iContextType", &self.iContextType)
            .field("iCtrlId", &self.iCtrlId)
            .field("hItemHandle", &self.hItemHandle)
            .field("dwContextId", &self.dwContextId)
            .field("MousePos", &self.MousePos)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HELPINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.iContextType == other.iContextType
            && self.iCtrlId == other.iCtrlId
            && self.hItemHandle == other.hItemHandle
            && self.dwContextId == other.dwContextId
            && self.MousePos == other.MousePos
    }
}
impl ::core::cmp::Eq for HELPINFO {}
impl FromIntoMemory for HELPINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iContextType = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_iCtrlId = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_hItemHandle =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwContextId = <PtrRepr as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_MousePos =
            <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[20..20 + 8]);
        Self {
            cbSize: f_cbSize,
            iContextType: f_iContextType,
            iCtrlId: f_iCtrlId,
            hItemHandle: f_hItemHandle,
            dwContextId: f_dwContextId,
            MousePos: f_MousePos,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iContextType, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.iCtrlId, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.hItemHandle, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwContextId, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.MousePos, &mut into[20..20 + 8]);
    }
    fn size() -> usize {
        28
    }
}
pub struct HELPWININFOA {
    pub wStructSize: i32,
    pub x: i32,
    pub y: i32,
    pub dx: i32,
    pub dy: i32,
    pub wMax: i32,
    pub rgchMember: [super::super::Foundation::CHAR; 2],
}
impl ::core::marker::Copy for HELPWININFOA {}
impl ::core::clone::Clone for HELPWININFOA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HELPWININFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HELPWININFOA")
            .field("wStructSize", &self.wStructSize)
            .field("x", &self.x)
            .field("y", &self.y)
            .field("dx", &self.dx)
            .field("dy", &self.dy)
            .field("wMax", &self.wMax)
            .field("rgchMember", &self.rgchMember)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HELPWININFOA {
    fn eq(&self, other: &Self) -> bool {
        self.wStructSize == other.wStructSize
            && self.x == other.x
            && self.y == other.y
            && self.dx == other.dx
            && self.dy == other.dy
            && self.wMax == other.wMax
            && self.rgchMember == other.rgchMember
    }
}
impl ::core::cmp::Eq for HELPWININFOA {}
impl FromIntoMemory for HELPWININFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_wStructSize = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_x = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_y = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dx = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dy = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_wMax = <i32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_rgchMember =
            <[super::super::Foundation::CHAR; 2] as FromIntoMemory>::from_bytes(&from[24..24 + 2]);
        Self {
            wStructSize: f_wStructSize,
            x: f_x,
            y: f_y,
            dx: f_dx,
            dy: f_dy,
            wMax: f_wMax,
            rgchMember: f_rgchMember,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.wStructSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.x, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.y, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dx, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dy, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.wMax, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.rgchMember, &mut into[24..24 + 2]);
    }
    fn size() -> usize {
        28
    }
}
pub struct HELPWININFOW {
    pub wStructSize: i32,
    pub x: i32,
    pub y: i32,
    pub dx: i32,
    pub dy: i32,
    pub wMax: i32,
    pub rgchMember: [u16; 2],
}
impl ::core::marker::Copy for HELPWININFOW {}
impl ::core::clone::Clone for HELPWININFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HELPWININFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HELPWININFOW")
            .field("wStructSize", &self.wStructSize)
            .field("x", &self.x)
            .field("y", &self.y)
            .field("dx", &self.dx)
            .field("dy", &self.dy)
            .field("wMax", &self.wMax)
            .field("rgchMember", &self.rgchMember)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HELPWININFOW {
    fn eq(&self, other: &Self) -> bool {
        self.wStructSize == other.wStructSize
            && self.x == other.x
            && self.y == other.y
            && self.dx == other.dx
            && self.dy == other.dy
            && self.wMax == other.wMax
            && self.rgchMember == other.rgchMember
    }
}
impl ::core::cmp::Eq for HELPWININFOW {}
impl FromIntoMemory for HELPWININFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_wStructSize = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_x = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_y = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dx = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dy = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_wMax = <i32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_rgchMember = <[u16; 2] as FromIntoMemory>::from_bytes(&from[24..24 + 2]);
        Self {
            wStructSize: f_wStructSize,
            x: f_x,
            y: f_y,
            dx: f_dx,
            dy: f_dy,
            wMax: f_wMax,
            rgchMember: f_rgchMember,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.wStructSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.x, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.y, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dx, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dy, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.wMax, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.rgchMember, &mut into[24..24 + 2]);
    }
    fn size() -> usize {
        28
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLBWIF_FLAGS(pub u32);
pub const HLBWIF_HASFRAMEWNDINFO: HLBWIF_FLAGS = HLBWIF_FLAGS(1u32);
pub const HLBWIF_HASDOCWNDINFO: HLBWIF_FLAGS = HLBWIF_FLAGS(2u32);
pub const HLBWIF_FRAMEWNDMAXIMIZED: HLBWIF_FLAGS = HLBWIF_FLAGS(4u32);
pub const HLBWIF_DOCWNDMAXIMIZED: HLBWIF_FLAGS = HLBWIF_FLAGS(8u32);
pub const HLBWIF_HASWEBTOOLBARINFO: HLBWIF_FLAGS = HLBWIF_FLAGS(16u32);
pub const HLBWIF_WEBTOOLBARHIDDEN: HLBWIF_FLAGS = HLBWIF_FLAGS(32u32);
impl ::core::marker::Copy for HLBWIF_FLAGS {}
impl ::core::clone::Clone for HLBWIF_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLBWIF_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLBWIF_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLBWIF_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for HLBWIF_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for HLBWIF_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for HLBWIF_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for HLBWIF_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for HLBWIF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for HLBWIF_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct HLBWINFO {
    pub cbSize: u32,
    pub grfHLBWIF: u32,
    pub rcFramePos: super::super::Foundation::RECT,
    pub rcDocPos: super::super::Foundation::RECT,
    pub hltbinfo: HLTBINFO,
}
impl ::core::marker::Copy for HLBWINFO {}
impl ::core::clone::Clone for HLBWINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HLBWINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HLBWINFO")
            .field("cbSize", &self.cbSize)
            .field("grfHLBWIF", &self.grfHLBWIF)
            .field("rcFramePos", &self.rcFramePos)
            .field("rcDocPos", &self.rcDocPos)
            .field("hltbinfo", &self.hltbinfo)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HLBWINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.grfHLBWIF == other.grfHLBWIF
            && self.rcFramePos == other.rcFramePos
            && self.rcDocPos == other.rcDocPos
            && self.hltbinfo == other.hltbinfo
    }
}
impl ::core::cmp::Eq for HLBWINFO {}
impl FromIntoMemory for HLBWINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_grfHLBWIF = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_rcFramePos =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_rcDocPos =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[24..24 + 16]);
        let f_hltbinfo = <HLTBINFO as FromIntoMemory>::from_bytes(&from[40..40 + 20]);
        Self {
            cbSize: f_cbSize,
            grfHLBWIF: f_grfHLBWIF,
            rcFramePos: f_rcFramePos,
            rcDocPos: f_rcDocPos,
            hltbinfo: f_hltbinfo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.grfHLBWIF, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.rcFramePos, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.rcDocPos, &mut into[24..24 + 16]);
        FromIntoMemory::into_bytes(self.hltbinfo, &mut into[40..40 + 20]);
    }
    fn size() -> usize {
        60
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLFNAMEF(pub u32);
pub const HLFNAMEF_DEFAULT: HLFNAMEF = HLFNAMEF(0u32);
pub const HLFNAMEF_TRYCACHE: HLFNAMEF = HLFNAMEF(1u32);
pub const HLFNAMEF_TRYPRETTYTARGET: HLFNAMEF = HLFNAMEF(2u32);
pub const HLFNAMEF_TRYFULLTARGET: HLFNAMEF = HLFNAMEF(4u32);
pub const HLFNAMEF_TRYWIN95SHORTCUT: HLFNAMEF = HLFNAMEF(8u32);
impl ::core::marker::Copy for HLFNAMEF {}
impl ::core::clone::Clone for HLFNAMEF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLFNAMEF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLFNAMEF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLFNAMEF").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for HLFNAMEF {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for HLFNAMEF {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for HLFNAMEF {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for HLFNAMEF {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for HLFNAMEF {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for HLFNAMEF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLID_INFO(pub u32);
pub const HLID_INVALID: HLID_INFO = HLID_INFO(0u32);
pub const HLID_PREVIOUS: HLID_INFO = HLID_INFO(4294967295u32);
pub const HLID_NEXT: HLID_INFO = HLID_INFO(4294967294u32);
pub const HLID_CURRENT: HLID_INFO = HLID_INFO(4294967293u32);
pub const HLID_STACKBOTTOM: HLID_INFO = HLID_INFO(4294967292u32);
pub const HLID_STACKTOP: HLID_INFO = HLID_INFO(4294967291u32);
impl ::core::marker::Copy for HLID_INFO {}
impl ::core::clone::Clone for HLID_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLID_INFO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLID_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLID_INFO").field(&self.0).finish()
    }
}
impl FromIntoMemory for HLID_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLINKGETREF(pub i32);
pub const HLINKGETREF_DEFAULT: HLINKGETREF = HLINKGETREF(0i32);
pub const HLINKGETREF_ABSOLUTE: HLINKGETREF = HLINKGETREF(1i32);
pub const HLINKGETREF_RELATIVE: HLINKGETREF = HLINKGETREF(2i32);
impl ::core::marker::Copy for HLINKGETREF {}
impl ::core::clone::Clone for HLINKGETREF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLINKGETREF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLINKGETREF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLINKGETREF").field(&self.0).finish()
    }
}
impl FromIntoMemory for HLINKGETREF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLINKMISC(pub i32);
pub const HLINKMISC_RELATIVE: HLINKMISC = HLINKMISC(1i32);
impl ::core::marker::Copy for HLINKMISC {}
impl ::core::clone::Clone for HLINKMISC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLINKMISC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLINKMISC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLINKMISC").field(&self.0).finish()
    }
}
impl FromIntoMemory for HLINKMISC {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLINKSETF(pub i32);
pub const HLINKSETF_TARGET: HLINKSETF = HLINKSETF(1i32);
pub const HLINKSETF_LOCATION: HLINKSETF = HLINKSETF(2i32);
impl ::core::marker::Copy for HLINKSETF {}
impl ::core::clone::Clone for HLINKSETF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLINKSETF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLINKSETF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLINKSETF").field(&self.0).finish()
    }
}
impl FromIntoMemory for HLINKSETF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLINKWHICHMK(pub i32);
pub const HLINKWHICHMK_CONTAINER: HLINKWHICHMK = HLINKWHICHMK(1i32);
pub const HLINKWHICHMK_BASE: HLINKWHICHMK = HLINKWHICHMK(2i32);
impl ::core::marker::Copy for HLINKWHICHMK {}
impl ::core::clone::Clone for HLINKWHICHMK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLINKWHICHMK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLINKWHICHMK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLINKWHICHMK").field(&self.0).finish()
    }
}
impl FromIntoMemory for HLINKWHICHMK {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const HLINK_E_FIRST: crate::core::HRESULT = crate::core::HRESULT(-2147221248i32);
pub const HLINK_S_DONTHIDE: i32 = 262400i32;
pub const HLINK_S_FIRST: crate::core::HRESULT = crate::core::HRESULT(262400i32);
pub struct HLITEM {
    pub uHLID: u32,
    pub pwzFriendlyName: PWSTR,
}
impl ::core::marker::Copy for HLITEM {}
impl ::core::clone::Clone for HLITEM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HLITEM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HLITEM")
            .field("uHLID", &self.uHLID)
            .field("pwzFriendlyName", &self.pwzFriendlyName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HLITEM {
    fn eq(&self, other: &Self) -> bool {
        self.uHLID == other.uHLID && self.pwzFriendlyName == other.pwzFriendlyName
    }
}
impl ::core::cmp::Eq for HLITEM {}
impl FromIntoMemory for HLITEM {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_uHLID = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pwzFriendlyName = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            uHLID: f_uHLID,
            pwzFriendlyName: f_pwzFriendlyName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.uHLID, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pwzFriendlyName, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLNF(pub u32);
pub const HLNF_INTERNALJUMP: HLNF = HLNF(1u32);
pub const HLNF_OPENINNEWWINDOW: HLNF = HLNF(2u32);
pub const HLNF_NAVIGATINGBACK: HLNF = HLNF(4u32);
pub const HLNF_NAVIGATINGFORWARD: HLNF = HLNF(8u32);
pub const HLNF_NAVIGATINGTOSTACKITEM: HLNF = HLNF(16u32);
pub const HLNF_CREATENOHISTORY: HLNF = HLNF(32u32);
impl ::core::marker::Copy for HLNF {}
impl ::core::clone::Clone for HLNF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLNF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLNF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLNF").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for HLNF {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for HLNF {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for HLNF {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for HLNF {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for HLNF {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for HLNF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const HLNF_ALLOW_AUTONAVIGATE: u32 = 536870912u32;
pub const HLNF_CALLERUNTRUSTED: u32 = 2097152u32;
pub const HLNF_DISABLEWINDOWRESTRICTIONS: u32 = 8388608u32;
pub const HLNF_EXTERNALNAVIGATE: u32 = 268435456u32;
pub const HLNF_NEWWINDOWSMANAGED: u32 = 2147483648u32;
pub const HLNF_TRUSTEDFORACTIVEX: u32 = 4194304u32;
pub const HLNF_TRUSTFIRSTDOWNLOAD: u32 = 16777216u32;
pub const HLNF_UNTRUSTEDFORDOWNLOAD: u32 = 33554432u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLQF_INFO(pub i32);
pub const HLQF_ISVALID: HLQF_INFO = HLQF_INFO(1i32);
pub const HLQF_ISCURRENT: HLQF_INFO = HLQF_INFO(2i32);
impl ::core::marker::Copy for HLQF_INFO {}
impl ::core::clone::Clone for HLQF_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLQF_INFO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLQF_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLQF_INFO").field(&self.0).finish()
    }
}
impl FromIntoMemory for HLQF_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct HLTBINFO {
    pub uDockType: u32,
    pub rcTbPos: super::super::Foundation::RECT,
}
impl ::core::marker::Copy for HLTBINFO {}
impl ::core::clone::Clone for HLTBINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for HLTBINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HLTBINFO")
            .field("uDockType", &self.uDockType)
            .field("rcTbPos", &self.rcTbPos)
            .finish()
    }
}
impl ::core::cmp::PartialEq for HLTBINFO {
    fn eq(&self, other: &Self) -> bool {
        self.uDockType == other.uDockType && self.rcTbPos == other.rcTbPos
    }
}
impl ::core::cmp::Eq for HLTBINFO {}
impl FromIntoMemory for HLTBINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_uDockType = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_rcTbPos =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        Self {
            uDockType: f_uDockType,
            rcTbPos: f_rcTbPos,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.uDockType, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.rcTbPos, &mut into[4..4 + 16]);
    }
    fn size() -> usize {
        20
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HLTB_INFO(pub i32);
pub const HLTB_DOCKEDLEFT: HLTB_INFO = HLTB_INFO(0i32);
pub const HLTB_DOCKEDTOP: HLTB_INFO = HLTB_INFO(1i32);
pub const HLTB_DOCKEDRIGHT: HLTB_INFO = HLTB_INFO(2i32);
pub const HLTB_DOCKEDBOTTOM: HLTB_INFO = HLTB_INFO(3i32);
pub const HLTB_FLOATING: HLTB_INFO = HLTB_INFO(4i32);
impl ::core::marker::Copy for HLTB_INFO {}
impl ::core::clone::Clone for HLTB_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HLTB_INFO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HLTB_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HLTB_INFO").field(&self.0).finish()
    }
}
impl FromIntoMemory for HLTB_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HOMEGROUPSHARINGCHOICES(pub i32);
pub const HGSC_NONE: HOMEGROUPSHARINGCHOICES = HOMEGROUPSHARINGCHOICES(0i32);
pub const HGSC_MUSICLIBRARY: HOMEGROUPSHARINGCHOICES = HOMEGROUPSHARINGCHOICES(1i32);
pub const HGSC_PICTURESLIBRARY: HOMEGROUPSHARINGCHOICES = HOMEGROUPSHARINGCHOICES(2i32);
pub const HGSC_VIDEOSLIBRARY: HOMEGROUPSHARINGCHOICES = HOMEGROUPSHARINGCHOICES(4i32);
pub const HGSC_DOCUMENTSLIBRARY: HOMEGROUPSHARINGCHOICES = HOMEGROUPSHARINGCHOICES(8i32);
pub const HGSC_PRINTERS: HOMEGROUPSHARINGCHOICES = HOMEGROUPSHARINGCHOICES(16i32);
impl ::core::marker::Copy for HOMEGROUPSHARINGCHOICES {}
impl ::core::clone::Clone for HOMEGROUPSHARINGCHOICES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HOMEGROUPSHARINGCHOICES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for HOMEGROUPSHARINGCHOICES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HOMEGROUPSHARINGCHOICES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for HOMEGROUPSHARINGCHOICES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const HOMEGROUP_SECURITY_GROUP: &'static str = "HomeUsers";
pub const HOMEGROUP_SECURITY_GROUP_MULTI: &'static str = "HUG";
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct HPSXA(pub PtrDiffRepr);
impl HPSXA {
    pub fn is_invalid(&self) -> bool {
        *self == unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for HPSXA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::clone::Clone for HPSXA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::marker::Copy for HPSXA {}
impl ::core::hash::Hash for HPSXA {
    fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}
impl ::core::fmt::Debug for HPSXA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HPSXA").field(&self.0).finish()
    }
}
impl FromIntoMemory for HPSXA {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<PtrDiffRepr as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        std::mem::size_of::<PtrDiffRepr>()
    }
}
pub const HideInputPaneAnimationCoordinator: crate::core::GUID =
    crate::core::GUID::from_u128(0x384742b1_2a77_4cb3_8cf8_1136f5e17e59);
pub const HomeGroup: crate::core::GUID =
    crate::core::GUID::from_u128(0xde77ba04_3c92_4d11_a1a5_42352a53e0e3);
pub struct IACList(pub crate::core::IUnknown);
pub trait IACList_Trait: crate::core::IUnknown_Trait {
    fn Expand(&self, psz_expand: PCWSTR) -> crate::core::HRESULT {
        todo!("Expand")
    }
}
impl ::core::clone::Clone for IACList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IACList {}
impl ::core::cmp::PartialEq for IACList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IACList {}
impl ::core::fmt::Debug for IACList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IACList").field(&self.0).finish()
    }
}
impl FromIntoMemory for IACList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IACList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x77a130b0_94fd_11d0_a544_00c04fd7d062);
}
pub struct IACList2(pub crate::core::IUnknown);
pub trait IACList2_Trait: IACList_Trait {
    fn SetOptions(&self, dw_flag: u32) -> crate::core::HRESULT {
        todo!("SetOptions")
    }
    fn GetOptions(&self, pdw_flag: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetOptions")
    }
}
impl ::core::clone::Clone for IACList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IACList2 {}
impl ::core::cmp::PartialEq for IACList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IACList2 {}
impl ::core::fmt::Debug for IACList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IACList2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IACList2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IACList2 {
    type Super = IACList;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x470141a0_5186_11d2_bbb6_0060977b464c);
}
pub struct IAccessibilityDockingService(pub crate::core::IUnknown);
pub trait IAccessibilityDockingService_Trait: crate::core::IUnknown_Trait {
    fn GetAvailableSize(
        &self,
        h_monitor: super::super::Graphics::Gdi::HMONITOR,
        pcx_fixed: MutPtr<u32>,
        pcy_max: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetAvailableSize")
    }
    fn DockWindow(
        &self,
        hwnd: super::super::Foundation::HWND,
        h_monitor: super::super::Graphics::Gdi::HMONITOR,
        cy_requested: u32,
        p_callback: IAccessibilityDockingServiceCallback,
    ) -> crate::core::HRESULT {
        todo!("DockWindow")
    }
    fn UndockWindow(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("UndockWindow")
    }
}
impl ::core::clone::Clone for IAccessibilityDockingService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAccessibilityDockingService {}
impl ::core::cmp::PartialEq for IAccessibilityDockingService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAccessibilityDockingService {}
impl ::core::fmt::Debug for IAccessibilityDockingService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAccessibilityDockingService")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IAccessibilityDockingService {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAccessibilityDockingService {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8849dc22_cedf_4c95_998d_051419dd3f76);
}
pub struct IAccessibilityDockingServiceCallback(pub crate::core::IUnknown);
pub trait IAccessibilityDockingServiceCallback_Trait: crate::core::IUnknown_Trait {
    fn Undocked(&self, undock_reason: UNDOCK_REASON) -> crate::core::HRESULT {
        todo!("Undocked")
    }
}
impl ::core::clone::Clone for IAccessibilityDockingServiceCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAccessibilityDockingServiceCallback {}
impl ::core::cmp::PartialEq for IAccessibilityDockingServiceCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAccessibilityDockingServiceCallback {}
impl ::core::fmt::Debug for IAccessibilityDockingServiceCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAccessibilityDockingServiceCallback")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IAccessibilityDockingServiceCallback {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAccessibilityDockingServiceCallback {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x157733fd_a592_42e5_b594_248468c5a81b);
}
pub struct IAccessibleObject(pub crate::core::IUnknown);
pub trait IAccessibleObject_Trait: crate::core::IUnknown_Trait {
    fn SetAccessibleName(&self, psz_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAccessibleName")
    }
}
impl ::core::clone::Clone for IAccessibleObject {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAccessibleObject {}
impl ::core::cmp::PartialEq for IAccessibleObject {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAccessibleObject {}
impl ::core::fmt::Debug for IAccessibleObject {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAccessibleObject").field(&self.0).finish()
    }
}
impl FromIntoMemory for IAccessibleObject {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAccessibleObject {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x95a391c5_9ed4_4c28_8401_ab9e06719e11);
}
pub struct IActionProgress(pub crate::core::IUnknown);
pub trait IActionProgress_Trait: crate::core::IUnknown_Trait {
    fn Begin(&self, action: SPACTION, flags: u32) -> crate::core::HRESULT {
        todo!("Begin")
    }
    fn UpdateProgress(&self, ul_completed: u64, ul_total: u64) -> crate::core::HRESULT {
        todo!("UpdateProgress")
    }
    fn UpdateText(
        &self,
        sptext: SPTEXT,
        psz_text: PCWSTR,
        f_may_compact: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("UpdateText")
    }
    fn QueryCancel(
        &self,
        pf_cancelled: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("QueryCancel")
    }
    fn ResetCancel(&self) -> crate::core::HRESULT {
        todo!("ResetCancel")
    }
    fn End(&self) -> crate::core::HRESULT {
        todo!("End")
    }
}
impl ::core::clone::Clone for IActionProgress {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IActionProgress {}
impl ::core::cmp::PartialEq for IActionProgress {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IActionProgress {}
impl ::core::fmt::Debug for IActionProgress {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IActionProgress").field(&self.0).finish()
    }
}
impl FromIntoMemory for IActionProgress {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IActionProgress {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x49ff1173_eadc_446d_9285_156453a6431c);
}
pub struct IActionProgressDialog(pub crate::core::IUnknown);
pub trait IActionProgressDialog_Trait: crate::core::IUnknown_Trait {
    fn Initialize(
        &self,
        flags: u32,
        psz_title: PCWSTR,
        psz_cancel: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn Stop(&self) -> crate::core::HRESULT {
        todo!("Stop")
    }
}
impl ::core::clone::Clone for IActionProgressDialog {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IActionProgressDialog {}
impl ::core::cmp::PartialEq for IActionProgressDialog {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IActionProgressDialog {}
impl ::core::fmt::Debug for IActionProgressDialog {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IActionProgressDialog")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IActionProgressDialog {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IActionProgressDialog {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x49ff1172_eadc_446d_9285_156453a6431c);
}
pub struct IAppActivationUIInfo(pub crate::core::IUnknown);
pub trait IAppActivationUIInfo_Trait: crate::core::IUnknown_Trait {
    fn GetMonitor(
        &self,
        value: MutPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> crate::core::HRESULT {
        todo!("GetMonitor")
    }
    fn GetInvokePoint(
        &self,
        value: MutPtr<super::super::Foundation::POINT>,
    ) -> crate::core::HRESULT {
        todo!("GetInvokePoint")
    }
    fn GetShowCommand(&self, value: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetShowCommand")
    }
    fn GetShowUI(&self, value: MutPtr<super::super::Foundation::BOOL>) -> crate::core::HRESULT {
        todo!("GetShowUI")
    }
    fn GetKeyState(&self, value: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetKeyState")
    }
}
impl ::core::clone::Clone for IAppActivationUIInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAppActivationUIInfo {}
impl ::core::cmp::PartialEq for IAppActivationUIInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAppActivationUIInfo {}
impl ::core::fmt::Debug for IAppActivationUIInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAppActivationUIInfo")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IAppActivationUIInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAppActivationUIInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xabad189d_9fa3_4278_b3ca_8ca448a88dcb);
}
pub struct IAppPublisher(pub crate::core::IUnknown);
pub trait IAppPublisher_Trait: crate::core::IUnknown_Trait {
    fn GetNumberOfCategories(&self, pdw_cat: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetNumberOfCategories")
    }
    fn GetCategories(
        &self,
        p_app_category_list: MutPtr<APPCATEGORYINFOLIST>,
    ) -> crate::core::HRESULT {
        todo!("GetCategories")
    }
    fn GetNumberOfApps(&self, pdw_apps: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetNumberOfApps")
    }
    fn EnumApps(
        &self,
        p_app_category_id: ConstPtr<crate::core::GUID>,
        ppepa: MutPtr<IEnumPublishedApps>,
    ) -> crate::core::HRESULT {
        todo!("EnumApps")
    }
}
impl ::core::clone::Clone for IAppPublisher {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAppPublisher {}
impl ::core::cmp::PartialEq for IAppPublisher {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAppPublisher {}
impl ::core::fmt::Debug for IAppPublisher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAppPublisher").field(&self.0).finish()
    }
}
impl FromIntoMemory for IAppPublisher {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAppPublisher {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x07250a10_9cf9_11d1_9076_006008059382);
}
pub struct IAppVisibility(pub crate::core::IUnknown);
pub trait IAppVisibility_Trait: crate::core::IUnknown_Trait {
    fn GetAppVisibilityOnMonitor(
        &self,
        h_monitor: super::super::Graphics::Gdi::HMONITOR,
        p_mode: MutPtr<MONITOR_APP_VISIBILITY>,
    ) -> crate::core::HRESULT {
        todo!("GetAppVisibilityOnMonitor")
    }
    fn IsLauncherVisible(
        &self,
        pf_visible: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("IsLauncherVisible")
    }
    fn Advise(
        &self,
        p_callback: IAppVisibilityEvents,
        pdw_cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn Unadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("Unadvise")
    }
}
impl ::core::clone::Clone for IAppVisibility {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAppVisibility {}
impl ::core::cmp::PartialEq for IAppVisibility {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAppVisibility {}
impl ::core::fmt::Debug for IAppVisibility {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAppVisibility").field(&self.0).finish()
    }
}
impl FromIntoMemory for IAppVisibility {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAppVisibility {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2246ea2d_caea_4444_a3c4_6de827e44313);
}
pub struct IAppVisibilityEvents(pub crate::core::IUnknown);
pub trait IAppVisibilityEvents_Trait: crate::core::IUnknown_Trait {
    fn AppVisibilityOnMonitorChanged(
        &self,
        h_monitor: super::super::Graphics::Gdi::HMONITOR,
        previous_mode: MONITOR_APP_VISIBILITY,
        current_mode: MONITOR_APP_VISIBILITY,
    ) -> crate::core::HRESULT {
        todo!("AppVisibilityOnMonitorChanged")
    }
    fn LauncherVisibilityChange(
        &self,
        current_visible_state: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("LauncherVisibilityChange")
    }
}
impl ::core::clone::Clone for IAppVisibilityEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAppVisibilityEvents {}
impl ::core::cmp::PartialEq for IAppVisibilityEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAppVisibilityEvents {}
impl ::core::fmt::Debug for IAppVisibilityEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAppVisibilityEvents")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IAppVisibilityEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAppVisibilityEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6584ce6b_7d82_49c2_89c9_c6bc02ba8c38);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IApplicationActivationManager(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IApplicationActivationManager_Trait: crate::core::IUnknown_Trait {
    fn ActivateApplication(
        &self,
        app_user_model_id: PCWSTR,
        arguments: PCWSTR,
        options: ACTIVATEOPTIONS,
        process_id: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("ActivateApplication")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ActivateForFile(
        &self,
        app_user_model_id: PCWSTR,
        item_array: IShellItemArray,
        verb: PCWSTR,
        process_id: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("ActivateForFile")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ActivateForProtocol(
        &self,
        app_user_model_id: PCWSTR,
        item_array: IShellItemArray,
        process_id: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("ActivateForProtocol")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IApplicationActivationManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IApplicationActivationManager {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IApplicationActivationManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IApplicationActivationManager {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IApplicationActivationManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IApplicationActivationManager")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IApplicationActivationManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IApplicationActivationManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2e941141_7f97_4756_ba1d_9decde894a3d);
}
pub struct IApplicationAssociationRegistration(pub crate::core::IUnknown);
pub trait IApplicationAssociationRegistration_Trait: crate::core::IUnknown_Trait {
    fn QueryCurrentDefault(
        &self,
        psz_query: PCWSTR,
        at_query_type: ASSOCIATIONTYPE,
        al_query_level: ASSOCIATIONLEVEL,
        ppsz_association: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("QueryCurrentDefault")
    }
    fn QueryAppIsDefault(
        &self,
        psz_query: PCWSTR,
        at_query_type: ASSOCIATIONTYPE,
        al_query_level: ASSOCIATIONLEVEL,
        psz_app_registry_name: PCWSTR,
        pf_default: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("QueryAppIsDefault")
    }
    fn QueryAppIsDefaultAll(
        &self,
        al_query_level: ASSOCIATIONLEVEL,
        psz_app_registry_name: PCWSTR,
        pf_default: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("QueryAppIsDefaultAll")
    }
    fn SetAppAsDefault(
        &self,
        psz_app_registry_name: PCWSTR,
        psz_set: PCWSTR,
        at_set_type: ASSOCIATIONTYPE,
    ) -> crate::core::HRESULT {
        todo!("SetAppAsDefault")
    }
    fn SetAppAsDefaultAll(&self, psz_app_registry_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAppAsDefaultAll")
    }
    fn ClearUserAssociations(&self) -> crate::core::HRESULT {
        todo!("ClearUserAssociations")
    }
}
impl ::core::clone::Clone for IApplicationAssociationRegistration {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IApplicationAssociationRegistration {}
impl ::core::cmp::PartialEq for IApplicationAssociationRegistration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IApplicationAssociationRegistration {}
impl ::core::fmt::Debug for IApplicationAssociationRegistration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IApplicationAssociationRegistration")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IApplicationAssociationRegistration {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IApplicationAssociationRegistration {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4e530b0a_e611_4c77_a3ac_9031d022281b);
}
pub struct IApplicationAssociationRegistrationUI(pub crate::core::IUnknown);
pub trait IApplicationAssociationRegistrationUI_Trait: crate::core::IUnknown_Trait {
    fn LaunchAdvancedAssociationUI(&self, psz_app_registry_name: PCWSTR) -> crate::core::HRESULT {
        todo!("LaunchAdvancedAssociationUI")
    }
}
impl ::core::clone::Clone for IApplicationAssociationRegistrationUI {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IApplicationAssociationRegistrationUI {}
impl ::core::cmp::PartialEq for IApplicationAssociationRegistrationUI {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IApplicationAssociationRegistrationUI {}
impl ::core::fmt::Debug for IApplicationAssociationRegistrationUI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IApplicationAssociationRegistrationUI")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IApplicationAssociationRegistrationUI {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IApplicationAssociationRegistrationUI {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1f76a169_f994_40ac_8fc8_0959e8874710);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IApplicationDesignModeSettings(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IApplicationDesignModeSettings_Trait: crate::core::IUnknown_Trait {
    fn SetNativeDisplaySize(
        &self,
        native_display_size_pixels: super::super::Foundation::SIZE,
    ) -> crate::core::HRESULT {
        todo!("SetNativeDisplaySize")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetScaleFactor(&self, scale_factor: Common::DEVICE_SCALE_FACTOR) -> crate::core::HRESULT {
        todo!("SetScaleFactor")
    }
    fn SetApplicationViewState(&self, view_state: APPLICATION_VIEW_STATE) -> crate::core::HRESULT {
        todo!("SetApplicationViewState")
    }
    fn ComputeApplicationSize(
        &self,
        application_size_pixels: MutPtr<super::super::Foundation::SIZE>,
    ) -> crate::core::HRESULT {
        todo!("ComputeApplicationSize")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IsApplicationViewStateSupported(
        &self,
        view_state: APPLICATION_VIEW_STATE,
        native_display_size_pixels: super::super::Foundation::SIZE,
        scale_factor: Common::DEVICE_SCALE_FACTOR,
        supported: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("IsApplicationViewStateSupported")
    }
    fn TriggerEdgeGesture(&self, edge_gesture_kind: EDGE_GESTURE_KIND) -> crate::core::HRESULT {
        todo!("TriggerEdgeGesture")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IApplicationDesignModeSettings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IApplicationDesignModeSettings {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IApplicationDesignModeSettings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IApplicationDesignModeSettings {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IApplicationDesignModeSettings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IApplicationDesignModeSettings")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IApplicationDesignModeSettings {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IApplicationDesignModeSettings {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2a3dee9a_e31d_46d6_8508_bcc597db3557);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IApplicationDesignModeSettings2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IApplicationDesignModeSettings2_Trait: IApplicationDesignModeSettings_Trait {
    fn SetNativeDisplayOrientation(
        &self,
        native_display_orientation: NATIVE_DISPLAY_ORIENTATION,
    ) -> crate::core::HRESULT {
        todo!("SetNativeDisplayOrientation")
    }
    fn SetApplicationViewOrientation(
        &self,
        view_orientation: APPLICATION_VIEW_ORIENTATION,
    ) -> crate::core::HRESULT {
        todo!("SetApplicationViewOrientation")
    }
    fn SetAdjacentDisplayEdges(
        &self,
        adjacent_display_edges: ADJACENT_DISPLAY_EDGES,
    ) -> crate::core::HRESULT {
        todo!("SetAdjacentDisplayEdges")
    }
    fn SetIsOnLockScreen(
        &self,
        is_on_lock_screen: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetIsOnLockScreen")
    }
    fn SetApplicationViewMinWidth(
        &self,
        view_min_width: APPLICATION_VIEW_MIN_WIDTH,
    ) -> crate::core::HRESULT {
        todo!("SetApplicationViewMinWidth")
    }
    fn GetApplicationSizeBounds(
        &self,
        min_application_size_pixels: MutPtr<super::super::Foundation::SIZE>,
        max_application_size_pixels: MutPtr<super::super::Foundation::SIZE>,
    ) -> crate::core::HRESULT {
        todo!("GetApplicationSizeBounds")
    }
    fn GetApplicationViewOrientation(
        &self,
        application_size_pixels: super::super::Foundation::SIZE,
        view_orientation: MutPtr<APPLICATION_VIEW_ORIENTATION>,
    ) -> crate::core::HRESULT {
        todo!("GetApplicationViewOrientation")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IApplicationDesignModeSettings2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IApplicationDesignModeSettings2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IApplicationDesignModeSettings2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IApplicationDesignModeSettings2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IApplicationDesignModeSettings2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IApplicationDesignModeSettings2")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IApplicationDesignModeSettings2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IApplicationDesignModeSettings2 {
    type Super = IApplicationDesignModeSettings;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x490514e1_675a_4d6e_a58d_e54901b4ca2f);
}
pub struct IApplicationDestinations(pub crate::core::IUnknown);
pub trait IApplicationDestinations_Trait: crate::core::IUnknown_Trait {
    fn SetAppID(&self, psz_app_id: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAppID")
    }
    fn RemoveDestination(&self, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("RemoveDestination")
    }
    fn RemoveAllDestinations(&self) -> crate::core::HRESULT {
        todo!("RemoveAllDestinations")
    }
}
impl ::core::clone::Clone for IApplicationDestinations {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IApplicationDestinations {}
impl ::core::cmp::PartialEq for IApplicationDestinations {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IApplicationDestinations {}
impl ::core::fmt::Debug for IApplicationDestinations {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IApplicationDestinations")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IApplicationDestinations {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IApplicationDestinations {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x12337d35_94c6_48a0_bce7_6a9c69d4d600);
}
pub struct IApplicationDocumentLists(pub crate::core::IUnknown);
pub trait IApplicationDocumentLists_Trait: crate::core::IUnknown_Trait {
    fn SetAppID(&self, psz_app_id: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAppID")
    }
    fn GetList(
        &self,
        listtype: APPDOCLISTTYPE,
        c_items_desired: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetList")
    }
}
impl ::core::clone::Clone for IApplicationDocumentLists {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IApplicationDocumentLists {}
impl ::core::cmp::PartialEq for IApplicationDocumentLists {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IApplicationDocumentLists {}
impl ::core::fmt::Debug for IApplicationDocumentLists {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IApplicationDocumentLists")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IApplicationDocumentLists {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IApplicationDocumentLists {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3c594f9f_9f30_47a1_979a_c9e83d3d0a06);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IAssocHandler(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IAssocHandler_Trait: crate::core::IUnknown_Trait {
    fn GetName(&self, ppsz: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetName")
    }
    fn GetUIName(&self, ppsz: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetUIName")
    }
    fn GetIconLocation(
        &self,
        ppsz_path: MutPtr<PWSTR>,
        p_index: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetIconLocation")
    }
    fn IsRecommended(&self) -> crate::core::HRESULT {
        todo!("IsRecommended")
    }
    fn MakeDefault(&self, psz_description: PCWSTR) -> crate::core::HRESULT {
        todo!("MakeDefault")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Invoke(&self, pdo: super::super::System::Com::IDataObject) -> crate::core::HRESULT {
        todo!("Invoke")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateInvoker(
        &self,
        pdo: super::super::System::Com::IDataObject,
        pp_invoker: MutPtr<IAssocHandlerInvoker>,
    ) -> crate::core::HRESULT {
        todo!("CreateInvoker")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IAssocHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IAssocHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IAssocHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IAssocHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IAssocHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAssocHandler").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IAssocHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IAssocHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf04061ac_1659_4a3f_a954_775aa57fc083);
}
pub struct IAssocHandlerInvoker(pub crate::core::IUnknown);
pub trait IAssocHandlerInvoker_Trait: crate::core::IUnknown_Trait {
    fn SupportsSelection(&self) -> crate::core::HRESULT {
        todo!("SupportsSelection")
    }
    fn Invoke(&self) -> crate::core::HRESULT {
        todo!("Invoke")
    }
}
impl ::core::clone::Clone for IAssocHandlerInvoker {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAssocHandlerInvoker {}
impl ::core::cmp::PartialEq for IAssocHandlerInvoker {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAssocHandlerInvoker {}
impl ::core::fmt::Debug for IAssocHandlerInvoker {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAssocHandlerInvoker")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IAssocHandlerInvoker {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAssocHandlerInvoker {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x92218cab_ecaa_4335_8133_807fd234c2ee);
}
pub struct IAttachmentExecute(pub crate::core::IUnknown);
pub trait IAttachmentExecute_Trait: crate::core::IUnknown_Trait {
    fn SetClientTitle(&self, psz_title: PCWSTR) -> crate::core::HRESULT {
        todo!("SetClientTitle")
    }
    fn SetClientGuid(&self, guid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("SetClientGuid")
    }
    fn SetLocalPath(&self, psz_local_path: PCWSTR) -> crate::core::HRESULT {
        todo!("SetLocalPath")
    }
    fn SetFileName(&self, psz_file_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetFileName")
    }
    fn SetSource(&self, psz_source: PCWSTR) -> crate::core::HRESULT {
        todo!("SetSource")
    }
    fn SetReferrer(&self, psz_referrer: PCWSTR) -> crate::core::HRESULT {
        todo!("SetReferrer")
    }
    fn CheckPolicy(&self) -> crate::core::HRESULT {
        todo!("CheckPolicy")
    }
    fn Prompt(
        &self,
        hwnd: super::super::Foundation::HWND,
        prompt: ATTACHMENT_PROMPT,
        paction: MutPtr<ATTACHMENT_ACTION>,
    ) -> crate::core::HRESULT {
        todo!("Prompt")
    }
    fn Save(&self) -> crate::core::HRESULT {
        todo!("Save")
    }
    fn Execute(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_verb: PCWSTR,
        ph_process: MutPtr<super::super::Foundation::HANDLE>,
    ) -> crate::core::HRESULT {
        todo!("Execute")
    }
    fn SaveWithUI(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("SaveWithUI")
    }
    fn ClearClientState(&self) -> crate::core::HRESULT {
        todo!("ClearClientState")
    }
}
impl ::core::clone::Clone for IAttachmentExecute {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAttachmentExecute {}
impl ::core::cmp::PartialEq for IAttachmentExecute {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAttachmentExecute {}
impl ::core::fmt::Debug for IAttachmentExecute {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAttachmentExecute").field(&self.0).finish()
    }
}
impl FromIntoMemory for IAttachmentExecute {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAttachmentExecute {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x73db1241_1e85_4581_8e4f_a81e1d0f8c57);
}
pub struct IAutoComplete(pub crate::core::IUnknown);
pub trait IAutoComplete_Trait: crate::core::IUnknown_Trait {
    fn Init(
        &self,
        hwnd_edit: super::super::Foundation::HWND,
        punk_acl: crate::core::IUnknown,
        pwsz_reg_key_path: PCWSTR,
        pwsz_quick_complete: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("Init")
    }
    fn Enable(&self, f_enable: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("Enable")
    }
}
impl ::core::clone::Clone for IAutoComplete {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAutoComplete {}
impl ::core::cmp::PartialEq for IAutoComplete {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAutoComplete {}
impl ::core::fmt::Debug for IAutoComplete {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAutoComplete").field(&self.0).finish()
    }
}
impl FromIntoMemory for IAutoComplete {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAutoComplete {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x00bb2762_6a77_11d0_a535_00c04fd7d062);
}
pub struct IAutoComplete2(pub crate::core::IUnknown);
pub trait IAutoComplete2_Trait: IAutoComplete_Trait {
    fn SetOptions(&self, dw_flag: u32) -> crate::core::HRESULT {
        todo!("SetOptions")
    }
    fn GetOptions(&self, pdw_flag: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetOptions")
    }
}
impl ::core::clone::Clone for IAutoComplete2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAutoComplete2 {}
impl ::core::cmp::PartialEq for IAutoComplete2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAutoComplete2 {}
impl ::core::fmt::Debug for IAutoComplete2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAutoComplete2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IAutoComplete2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAutoComplete2 {
    type Super = IAutoComplete;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xeac04bc0_3791_11d2_bb95_0060977b464c);
}
pub struct IAutoCompleteDropDown(pub crate::core::IUnknown);
pub trait IAutoCompleteDropDown_Trait: crate::core::IUnknown_Trait {
    fn GetDropDownStatus(
        &self,
        pdw_flags: MutPtr<u32>,
        ppwsz_string: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetDropDownStatus")
    }
    fn ResetEnumerator(&self) -> crate::core::HRESULT {
        todo!("ResetEnumerator")
    }
}
impl ::core::clone::Clone for IAutoCompleteDropDown {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IAutoCompleteDropDown {}
impl ::core::cmp::PartialEq for IAutoCompleteDropDown {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAutoCompleteDropDown {}
impl ::core::fmt::Debug for IAutoCompleteDropDown {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAutoCompleteDropDown")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IAutoCompleteDropDown {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IAutoCompleteDropDown {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3cd141f4_3c6a_11d2_bcaa_00c04fd929db);
}
pub struct IBandHost(pub crate::core::IUnknown);
pub trait IBandHost_Trait: crate::core::IUnknown_Trait {
    fn CreateBand(
        &self,
        rclsid_band: ConstPtr<crate::core::GUID>,
        f_available: super::super::Foundation::BOOL,
        f_visible: super::super::Foundation::BOOL,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("CreateBand")
    }
    fn SetBandAvailability(
        &self,
        rclsid_band: ConstPtr<crate::core::GUID>,
        f_available: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetBandAvailability")
    }
    fn DestroyBand(&self, rclsid_band: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("DestroyBand")
    }
}
impl ::core::clone::Clone for IBandHost {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IBandHost {}
impl ::core::cmp::PartialEq for IBandHost {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBandHost {}
impl ::core::fmt::Debug for IBandHost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBandHost").field(&self.0).finish()
    }
}
impl FromIntoMemory for IBandHost {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IBandHost {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb9075c7c_d48e_403f_ab99_d6c77a1084ac);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IBandSite(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IBandSite_Trait: crate::core::IUnknown_Trait {
    fn AddBand(&self, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("AddBand")
    }
    fn EnumBands(&self, u_band: u32, pdw_band_id: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("EnumBands")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn QueryBand(
        &self,
        dw_band_id: u32,
        ppstb: MutPtr<IDeskBand>,
        pdw_state: MutPtr<u32>,
        psz_name: PWSTR,
        cch_name: i32,
    ) -> crate::core::HRESULT {
        todo!("QueryBand")
    }
    fn SetBandState(&self, dw_band_id: u32, dw_mask: u32, dw_state: u32) -> crate::core::HRESULT {
        todo!("SetBandState")
    }
    fn RemoveBand(&self, dw_band_id: u32) -> crate::core::HRESULT {
        todo!("RemoveBand")
    }
    fn GetBandObject(
        &self,
        dw_band_id: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetBandObject")
    }
    fn SetBandSiteInfo(&self, pbsinfo: ConstPtr<BANDSITEINFO>) -> crate::core::HRESULT {
        todo!("SetBandSiteInfo")
    }
    fn GetBandSiteInfo(&self, pbsinfo: MutPtr<BANDSITEINFO>) -> crate::core::HRESULT {
        todo!("GetBandSiteInfo")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IBandSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IBandSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IBandSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IBandSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IBandSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBandSite").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IBandSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IBandSite {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4cf504b0_de96_11d0_8b3f_00a0c911e8e5);
}
pub struct IBannerNotificationHandler(pub crate::core::IUnknown);
pub trait IBannerNotificationHandler_Trait: crate::core::IUnknown_Trait {
    fn OnBannerEvent(&self, notification: ConstPtr<BANNER_NOTIFICATION>) -> crate::core::HRESULT {
        todo!("OnBannerEvent")
    }
}
impl ::core::clone::Clone for IBannerNotificationHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IBannerNotificationHandler {}
impl ::core::cmp::PartialEq for IBannerNotificationHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBannerNotificationHandler {}
impl ::core::fmt::Debug for IBannerNotificationHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBannerNotificationHandler")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IBannerNotificationHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IBannerNotificationHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8d7b2ba7_db05_46a8_823c_d2b6de08ee91);
}
pub struct IBanneredBar(pub crate::core::IUnknown);
pub trait IBanneredBar_Trait: crate::core::IUnknown_Trait {
    fn SetIconSize(&self, i_icon: u32) -> crate::core::HRESULT {
        todo!("SetIconSize")
    }
    fn GetIconSize(&self, pi_icon: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetIconSize")
    }
    fn SetBitmap(&self, h_bitmap: super::super::Graphics::Gdi::HBITMAP) -> crate::core::HRESULT {
        todo!("SetBitmap")
    }
    fn GetBitmap(
        &self,
        ph_bitmap: MutPtr<super::super::Graphics::Gdi::HBITMAP>,
    ) -> crate::core::HRESULT {
        todo!("GetBitmap")
    }
}
impl ::core::clone::Clone for IBanneredBar {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IBanneredBar {}
impl ::core::cmp::PartialEq for IBanneredBar {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBanneredBar {}
impl ::core::fmt::Debug for IBanneredBar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBanneredBar").field(&self.0).finish()
    }
}
impl FromIntoMemory for IBanneredBar {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IBanneredBar {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x596a9a94_013e_11d1_8d34_00a0c90f2719);
}
pub struct IBrowserFrameOptions(pub crate::core::IUnknown);
pub trait IBrowserFrameOptions_Trait: crate::core::IUnknown_Trait {
    fn GetFrameOptions(&self, dw_mask: u32, pdw_options: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFrameOptions")
    }
}
impl ::core::clone::Clone for IBrowserFrameOptions {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IBrowserFrameOptions {}
impl ::core::cmp::PartialEq for IBrowserFrameOptions {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IBrowserFrameOptions {}
impl ::core::fmt::Debug for IBrowserFrameOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBrowserFrameOptions")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IBrowserFrameOptions {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IBrowserFrameOptions {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x10df43c8_1dbe_11d3_8b34_006097df5bd4);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IBrowserService(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IBrowserService_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetParentSite(
        &self,
        ppipsite: MutPtr<super::super::System::Ole::IOleInPlaceSite>,
    ) -> crate::core::HRESULT {
        todo!("GetParentSite")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetTitle(&self, psv: IShellView, psz_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetTitle")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetTitle(&self, psv: IShellView, psz_name: PWSTR, cch_name: u32) -> crate::core::HRESULT {
        todo!("GetTitle")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetOleObject(
        &self,
        ppobjv: MutPtr<super::super::System::Ole::IOleObject>,
    ) -> crate::core::HRESULT {
        todo!("GetOleObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetTravelLog(&self, pptl: MutPtr<ITravelLog>) -> crate::core::HRESULT {
        todo!("GetTravelLog")
    }
    fn ShowControlWindow(
        &self,
        id: u32,
        f_show: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("ShowControlWindow")
    }
    fn IsControlWindowShown(
        &self,
        id: u32,
        pf_shown: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("IsControlWindowShown")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IEGetDisplayName(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pwsz_name: PWSTR,
        u_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("IEGetDisplayName")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IEParseDisplayName(
        &self,
        ui_cp: u32,
        pwsz_path: PCWSTR,
        ppidl_out: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("IEParseDisplayName")
    }
    fn DisplayParseError(
        &self,
        hres: crate::core::HRESULT,
        pwsz_path: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("DisplayParseError")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn NavigateToPidl(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        grf_hlnf: u32,
    ) -> crate::core::HRESULT {
        todo!("NavigateToPidl")
    }
    fn SetNavigateState(&self, bnstate: BNSTATE) -> crate::core::HRESULT {
        todo!("SetNavigateState")
    }
    fn GetNavigateState(&self, pbnstate: MutPtr<BNSTATE>) -> crate::core::HRESULT {
        todo!("GetNavigateState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn NotifyRedirect(
        &self,
        psv: IShellView,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pf_did_browse: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("NotifyRedirect")
    }
    fn UpdateWindowList(&self) -> crate::core::HRESULT {
        todo!("UpdateWindowList")
    }
    fn UpdateBackForwardState(&self) -> crate::core::HRESULT {
        todo!("UpdateBackForwardState")
    }
    fn SetFlags(&self, dw_flags: u32, dw_flag_mask: u32) -> crate::core::HRESULT {
        todo!("SetFlags")
    }
    fn GetFlags(&self, pdw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFlags")
    }
    fn CanNavigateNow(&self) -> crate::core::HRESULT {
        todo!("CanNavigateNow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPidl(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetPidl")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetReferrer(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("SetReferrer")
    }
    fn GetBrowserIndex(&self) -> u32 {
        todo!("GetBrowserIndex")
    }
    fn GetBrowserByIndex(
        &self,
        dw_id: u32,
        ppunk: MutPtr<crate::core::IUnknown>,
    ) -> crate::core::HRESULT {
        todo!("GetBrowserByIndex")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetHistoryObject(
        &self,
        ppole: MutPtr<super::super::System::Ole::IOleObject>,
        pstm: MutPtr<super::super::System::Com::IStream>,
        ppbc: MutPtr<super::super::System::Com::IBindCtx>,
    ) -> crate::core::HRESULT {
        todo!("GetHistoryObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetHistoryObject(
        &self,
        pole: super::super::System::Ole::IOleObject,
        f_is_local_anchor: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetHistoryObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CacheOLEServer(&self, pole: super::super::System::Ole::IOleObject) -> crate::core::HRESULT {
        todo!("CacheOLEServer")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSetCodePage(
        &self,
        pvar_in: ConstPtr<super::super::System::Com::VARIANT>,
        pvar_out: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetSetCodePage")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnHttpEquiv(
        &self,
        psv: IShellView,
        f_done: super::super::Foundation::BOOL,
        pvararg_in: ConstPtr<super::super::System::Com::VARIANT>,
        pvararg_out: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("OnHttpEquiv")
    }
    fn GetPalette(
        &self,
        hpal: MutPtr<super::super::Graphics::Gdi::HPALETTE>,
    ) -> crate::core::HRESULT {
        todo!("GetPalette")
    }
    fn RegisterWindow(
        &self,
        f_force_register: super::super::Foundation::BOOL,
        swc: i32,
    ) -> crate::core::HRESULT {
        todo!("RegisterWindow")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IBrowserService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IBrowserService {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IBrowserService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IBrowserService {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IBrowserService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBrowserService").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IBrowserService {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IBrowserService {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x02ba3b52_0547_11d1_b833_00c04fc9b31f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IBrowserService2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IBrowserService2_Trait: IBrowserService_Trait {
    fn WndProcBS(
        &self,
        hwnd: super::super::Foundation::HWND,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> super::super::Foundation::LRESULT {
        todo!("WndProcBS")
    }
    fn SetAsDefFolderSettings(&self) -> crate::core::HRESULT {
        todo!("SetAsDefFolderSettings")
    }
    fn GetViewRect(&self, prc: MutPtr<super::super::Foundation::RECT>) -> crate::core::HRESULT {
        todo!("GetViewRect")
    }
    fn OnSize(&self, w_param: super::super::Foundation::WPARAM) -> crate::core::HRESULT {
        todo!("OnSize")
    }
    fn OnCreate(
        &self,
        pcs: ConstPtr<super::WindowsAndMessaging::CREATESTRUCTW>,
    ) -> crate::core::HRESULT {
        todo!("OnCreate")
    }
    fn OnCommand(
        &self,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> super::super::Foundation::LRESULT {
        todo!("OnCommand")
    }
    fn OnDestroy(&self) -> crate::core::HRESULT {
        todo!("OnDestroy")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnNotify(&self, pnm: ConstPtr<super::Controls::NMHDR>) -> super::super::Foundation::LRESULT {
        todo!("OnNotify")
    }
    fn OnSetFocus(&self) -> crate::core::HRESULT {
        todo!("OnSetFocus")
    }
    fn OnFrameWindowActivateBS(
        &self,
        f_active: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("OnFrameWindowActivateBS")
    }
    fn ReleaseShellView(&self) -> crate::core::HRESULT {
        todo!("ReleaseShellView")
    }
    fn ActivatePendingView(&self) -> crate::core::HRESULT {
        todo!("ActivatePendingView")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateViewWindow(
        &self,
        psv_new: IShellView,
        psv_old: IShellView,
        prc_view: ConstPtr<super::super::Foundation::RECT>,
        phwnd: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("CreateViewWindow")
    }
    fn CreateBrowserPropSheetExt(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("CreateBrowserPropSheetExt")
    }
    fn GetViewWindow(
        &self,
        phwnd_view: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("GetViewWindow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetBaseBrowserData(
        &self,
        pbbd: MutPtr<ConstPtr<BASEBROWSERDATALH>>,
    ) -> crate::core::HRESULT {
        todo!("GetBaseBrowserData")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PutBaseBrowserData(&self) -> MutPtr<BASEBROWSERDATALH> {
        todo!("PutBaseBrowserData")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InitializeTravelLog(&self, ptl: ITravelLog, dw: u32) -> crate::core::HRESULT {
        todo!("InitializeTravelLog")
    }
    fn SetTopBrowser(&self) -> crate::core::HRESULT {
        todo!("SetTopBrowser")
    }
    fn Offline(&self, i_cmd: i32) -> crate::core::HRESULT {
        todo!("Offline")
    }
    fn AllowViewResize(&self, f: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("AllowViewResize")
    }
    fn SetActivateState(&self, u: u32) -> crate::core::HRESULT {
        todo!("SetActivateState")
    }
    fn UpdateSecureLockIcon(&self, e_secure_lock: i32) -> crate::core::HRESULT {
        todo!("UpdateSecureLockIcon")
    }
    fn InitializeDownloadManager(&self) -> crate::core::HRESULT {
        todo!("InitializeDownloadManager")
    }
    fn InitializeTransitionSite(&self) -> crate::core::HRESULT {
        todo!("InitializeTransitionSite")
    }
    fn _Initialize(
        &self,
        hwnd: super::super::Foundation::HWND,
        pauto: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("_Initialize")
    }
    fn _CancelPendingNavigationAsync(&self) -> crate::core::HRESULT {
        todo!("_CancelPendingNavigationAsync")
    }
    fn _CancelPendingView(&self) -> crate::core::HRESULT {
        todo!("_CancelPendingView")
    }
    fn _MaySaveChanges(&self) -> crate::core::HRESULT {
        todo!("_MaySaveChanges")
    }
    fn _PauseOrResumeView(&self, f_paused: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("_PauseOrResumeView")
    }
    fn _DisableModeless(&self) -> crate::core::HRESULT {
        todo!("_DisableModeless")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn _NavigateToPidl2(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        grf_hlnf: u32,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("_NavigateToPidl2")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn _TryShell2Rename(
        &self,
        psv: IShellView,
        pidl_new: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("_TryShell2Rename")
    }
    fn _SwitchActivationNow(&self) -> crate::core::HRESULT {
        todo!("_SwitchActivationNow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn _ExecChildren(
        &self,
        punk_bar: crate::core::IUnknown,
        f_broadcast: super::super::Foundation::BOOL,
        pguid_cmd_group: ConstPtr<crate::core::GUID>,
        n_cmd_id: u32,
        n_cmdexecopt: u32,
        pvararg_in: ConstPtr<super::super::System::Com::VARIANT>,
        pvararg_out: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("_ExecChildren")
    }
    fn _SendChildren(
        &self,
        hwnd_bar: super::super::Foundation::HWND,
        f_broadcast: super::super::Foundation::BOOL,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("_SendChildren")
    }
    fn GetFolderSetData(&self, pfsd: MutPtr<FOLDERSETDATA>) -> crate::core::HRESULT {
        todo!("GetFolderSetData")
    }
    fn _OnFocusChange(&self, itb: u32) -> crate::core::HRESULT {
        todo!("_OnFocusChange")
    }
    fn v_ShowHideChildWindows(
        &self,
        f_child_only: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("v_ShowHideChildWindows")
    }
    fn _get_itbLastFocus(&self) -> u32 {
        todo!("_get_itbLastFocus")
    }
    fn _put_itbLastFocus(&self, itb_last_focus: u32) -> crate::core::HRESULT {
        todo!("_put_itbLastFocus")
    }
    fn _UIActivateView(&self, u_state: u32) -> crate::core::HRESULT {
        todo!("_UIActivateView")
    }
    fn _GetViewBorderRect(
        &self,
        prc: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("_GetViewBorderRect")
    }
    fn _UpdateViewRectSize(&self) -> crate::core::HRESULT {
        todo!("_UpdateViewRectSize")
    }
    fn _ResizeNextBorder(&self, itb: u32) -> crate::core::HRESULT {
        todo!("_ResizeNextBorder")
    }
    fn _ResizeView(&self) -> crate::core::HRESULT {
        todo!("_ResizeView")
    }
    fn _GetEffectiveClientArea(
        &self,
        lprect_border: MutPtr<super::super::Foundation::RECT>,
        hmon: super::super::Graphics::Gdi::HMONITOR,
    ) -> crate::core::HRESULT {
        todo!("_GetEffectiveClientArea")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn v_GetViewStream(
        &self,
        pidl: MutPtr<Common::ITEMIDLIST>,
        grf_mode: u32,
        pwsz_name: PCWSTR,
    ) -> super::super::System::Com::IStream {
        todo!("v_GetViewStream")
    }
    fn ForwardViewMsg(
        &self,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> super::super::Foundation::LRESULT {
        todo!("ForwardViewMsg")
    }
    fn SetAcceleratorMenu(&self, hacc: super::WindowsAndMessaging::HACCEL) -> crate::core::HRESULT {
        todo!("SetAcceleratorMenu")
    }
    fn _GetToolbarCount(&self) -> i32 {
        todo!("_GetToolbarCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn _GetToolbarItem(&self, itb: i32) -> MutPtr<TOOLBARITEM> {
        todo!("_GetToolbarItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn _SaveToolbars(&self, pstm: super::super::System::Com::IStream) -> crate::core::HRESULT {
        todo!("_SaveToolbars")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn _LoadToolbars(&self, pstm: super::super::System::Com::IStream) -> crate::core::HRESULT {
        todo!("_LoadToolbars")
    }
    fn _CloseAndReleaseToolbars(
        &self,
        f_close: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("_CloseAndReleaseToolbars")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn v_MayGetNextToolbarFocus(
        &self,
        lp_msg: ConstPtr<super::WindowsAndMessaging::MSG>,
        itb_next: u32,
        citb: i32,
        pptbi: MutPtr<ConstPtr<TOOLBARITEM>>,
        phwnd: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("v_MayGetNextToolbarFocus")
    }
    fn _ResizeNextBorderHelper(
        &self,
        itb: u32,
        b_use_hmonitor: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("_ResizeNextBorderHelper")
    }
    fn _FindTBar(&self, punk_src: crate::core::IUnknown) -> u32 {
        todo!("_FindTBar")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn _SetFocus(
        &self,
        ptbi: ConstPtr<TOOLBARITEM>,
        hwnd: super::super::Foundation::HWND,
        lp_msg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("_SetFocus")
    }
    fn v_MayTranslateAccelerator(
        &self,
        pmsg: MutPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("v_MayTranslateAccelerator")
    }
    fn _GetBorderDWHelper(
        &self,
        punk_src: crate::core::IUnknown,
        lprect_border: MutPtr<super::super::Foundation::RECT>,
        b_use_hmonitor: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("_GetBorderDWHelper")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn v_CheckZoneCrossing(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("v_CheckZoneCrossing")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IBrowserService2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IBrowserService2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IBrowserService2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IBrowserService2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IBrowserService2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBrowserService2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IBrowserService2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IBrowserService2 {
    type Super = IBrowserService;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x68bd21cc_438b_11d2_a560_00a0c92dbfe8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IBrowserService3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IBrowserService3_Trait: IBrowserService2_Trait {
    fn _PositionViewWindow(
        &self,
        hwnd: super::super::Foundation::HWND,
        prc: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("_PositionViewWindow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IEParseDisplayNameEx(
        &self,
        ui_cp: u32,
        pwsz_path: PCWSTR,
        dw_flags: u32,
        ppidl_out: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("IEParseDisplayNameEx")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IBrowserService3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IBrowserService3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IBrowserService3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IBrowserService3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IBrowserService3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBrowserService3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IBrowserService3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IBrowserService3 {
    type Super = IBrowserService2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x27d7ce21_762d_48f3_86f3_40e2fd3749c4);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IBrowserService4(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IBrowserService4_Trait: IBrowserService3_Trait {
    fn ActivateView(&self, f_pending_view: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("ActivateView")
    }
    fn SaveViewState(&self) -> crate::core::HRESULT {
        todo!("SaveViewState")
    }
    fn _ResizeAllBorders(&self) -> crate::core::HRESULT {
        todo!("_ResizeAllBorders")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IBrowserService4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IBrowserService4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IBrowserService4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IBrowserService4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IBrowserService4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IBrowserService4").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IBrowserService4 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IBrowserService4 {
    type Super = IBrowserService3;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x639f1bff_e135_4096_abd8_e0f504d649a4);
}
pub struct ICDBurn(pub crate::core::IUnknown);
pub trait ICDBurn_Trait: crate::core::IUnknown_Trait {
    fn GetRecorderDriveLetter(&self, psz_drive: PWSTR, cch: u32) -> crate::core::HRESULT {
        todo!("GetRecorderDriveLetter")
    }
    fn Burn(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("Burn")
    }
    fn HasRecordableDrive(
        &self,
        pf_has_recorder: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("HasRecordableDrive")
    }
}
impl ::core::clone::Clone for ICDBurn {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICDBurn {}
impl ::core::cmp::PartialEq for ICDBurn {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICDBurn {}
impl ::core::fmt::Debug for ICDBurn {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICDBurn").field(&self.0).finish()
    }
}
impl FromIntoMemory for ICDBurn {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICDBurn {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3d73a659_e5d0_4d42_afc0_5121ba425c8d);
}
pub struct ICDBurnExt(pub crate::core::IUnknown);
pub trait ICDBurnExt_Trait: crate::core::IUnknown_Trait {
    fn GetSupportedActionTypes(&self, pdw_actions: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetSupportedActionTypes")
    }
}
impl ::core::clone::Clone for ICDBurnExt {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICDBurnExt {}
impl ::core::cmp::PartialEq for ICDBurnExt {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICDBurnExt {}
impl ::core::fmt::Debug for ICDBurnExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICDBurnExt").field(&self.0).finish()
    }
}
impl FromIntoMemory for ICDBurnExt {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICDBurnExt {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2271dcca_74fc_4414_8fb7_c56b05ace2d7);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICategorizer(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICategorizer_Trait: crate::core::IUnknown_Trait {
    fn GetDescription(&self, psz_desc: PWSTR, cch: u32) -> crate::core::HRESULT {
        todo!("GetDescription")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetCategory(
        &self,
        cidl: u32,
        apidl: ConstPtr<ConstPtr<Common::ITEMIDLIST>>,
        rg_category_ids: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetCategory")
    }
    fn GetCategoryInfo(
        &self,
        dw_category_id: u32,
        pci: MutPtr<CATEGORY_INFO>,
    ) -> crate::core::HRESULT {
        todo!("GetCategoryInfo")
    }
    fn CompareCategory(
        &self,
        csf_flags: CATSORT_FLAGS,
        dw_category_id_1: u32,
        dw_category_id_2: u32,
    ) -> crate::core::HRESULT {
        todo!("CompareCategory")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICategorizer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICategorizer {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICategorizer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICategorizer {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICategorizer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICategorizer").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICategorizer {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICategorizer {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa3b14589_9174_49a8_89a3_06a1ae2b9ba7);
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICategoryProvider(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICategoryProvider_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CanCategorizeOnSCID(
        &self,
        pscid: ConstPtr<PropertiesSystem::PROPERTYKEY>,
    ) -> crate::core::HRESULT {
        todo!("CanCategorizeOnSCID")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDefaultCategory(
        &self,
        pguid: MutPtr<crate::core::GUID>,
        pscid: MutPtr<PropertiesSystem::PROPERTYKEY>,
    ) -> crate::core::HRESULT {
        todo!("GetDefaultCategory")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetCategoryForSCID(
        &self,
        pscid: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pguid: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("GetCategoryForSCID")
    }
    fn EnumCategories(
        &self,
        penum: MutPtr<super::super::System::Com::IEnumGUID>,
    ) -> crate::core::HRESULT {
        todo!("EnumCategories")
    }
    fn GetCategoryName(
        &self,
        pguid: ConstPtr<crate::core::GUID>,
        psz_name: PWSTR,
        cch: u32,
    ) -> crate::core::HRESULT {
        todo!("GetCategoryName")
    }
    fn CreateCategory(
        &self,
        pguid: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("CreateCategory")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICategoryProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICategoryProvider {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICategoryProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICategoryProvider {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICategoryProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICategoryProvider").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICategoryProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICategoryProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9af64809_5864_4c26_a720_c1f78c086ee3);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IColumnManager(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IColumnManager_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetColumnInfo(
        &self,
        propkey: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pcmci: ConstPtr<CM_COLUMNINFO>,
    ) -> crate::core::HRESULT {
        todo!("SetColumnInfo")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetColumnInfo(
        &self,
        propkey: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pcmci: MutPtr<CM_COLUMNINFO>,
    ) -> crate::core::HRESULT {
        todo!("GetColumnInfo")
    }
    fn GetColumnCount(
        &self,
        dw_flags: CM_ENUM_FLAGS,
        pu_count: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetColumnCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetColumns(
        &self,
        dw_flags: CM_ENUM_FLAGS,
        rgkey_order: MutPtr<PropertiesSystem::PROPERTYKEY>,
        c_columns: u32,
    ) -> crate::core::HRESULT {
        todo!("GetColumns")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetColumns(
        &self,
        rgkey_order: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        c_visible: u32,
    ) -> crate::core::HRESULT {
        todo!("SetColumns")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IColumnManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IColumnManager {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IColumnManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IColumnManager {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IColumnManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IColumnManager").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IColumnManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IColumnManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd8ec27bb_3f3b_4042_b10a_4acfd924d453);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IColumnProvider(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IColumnProvider_Trait: crate::core::IUnknown_Trait {
    fn Initialize(&self, psci: ConstPtr<SHCOLUMNINIT>) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetColumnInfo(&self, dw_index: u32, psci: MutPtr<SHCOLUMNINFO>) -> crate::core::HRESULT {
        todo!("GetColumnInfo")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemData(
        &self,
        pscid: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pscd: ConstPtr<SHCOLUMNDATA>,
        pvar_data: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetItemData")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IColumnProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IColumnProvider {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IColumnProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IColumnProvider {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IColumnProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IColumnProvider").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IColumnProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IColumnProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe8025004_1c42_11d2_be2c_00a0c9a83da1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICommDlgBrowser(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICommDlgBrowser_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDefaultCommand(&self, ppshv: IShellView) -> crate::core::HRESULT {
        todo!("OnDefaultCommand")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnStateChange(&self, ppshv: IShellView, u_change: u32) -> crate::core::HRESULT {
        todo!("OnStateChange")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IncludeObject(
        &self,
        ppshv: IShellView,
        pidl: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("IncludeObject")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICommDlgBrowser {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICommDlgBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICommDlgBrowser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICommDlgBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICommDlgBrowser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICommDlgBrowser").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICommDlgBrowser {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICommDlgBrowser {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214f1_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICommDlgBrowser2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICommDlgBrowser2_Trait: ICommDlgBrowser_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Notify(&self, ppshv: IShellView, dw_notify_type: u32) -> crate::core::HRESULT {
        todo!("Notify")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDefaultMenuText(
        &self,
        ppshv: IShellView,
        psz_text: PWSTR,
        cch_max: i32,
    ) -> crate::core::HRESULT {
        todo!("GetDefaultMenuText")
    }
    fn GetViewFlags(&self, pdw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetViewFlags")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICommDlgBrowser2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICommDlgBrowser2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICommDlgBrowser2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICommDlgBrowser2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICommDlgBrowser2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICommDlgBrowser2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICommDlgBrowser2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICommDlgBrowser2 {
    type Super = ICommDlgBrowser;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x10339516_2894_11d2_9039_00c04f8eeb3e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICommDlgBrowser3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICommDlgBrowser3_Trait: ICommDlgBrowser2_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnColumnClicked(&self, ppshv: IShellView, i_column: i32) -> crate::core::HRESULT {
        todo!("OnColumnClicked")
    }
    fn GetCurrentFilter(&self, psz_file_spec: PWSTR, cch_file_spec: i32) -> crate::core::HRESULT {
        todo!("GetCurrentFilter")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnPreViewCreated(&self, ppshv: IShellView) -> crate::core::HRESULT {
        todo!("OnPreViewCreated")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICommDlgBrowser3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICommDlgBrowser3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICommDlgBrowser3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICommDlgBrowser3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICommDlgBrowser3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICommDlgBrowser3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICommDlgBrowser3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICommDlgBrowser3 {
    type Super = ICommDlgBrowser2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc8ad25a1_3294_41ee_8165_71174bd01c57);
}
pub struct IComputerInfoChangeNotify(pub crate::core::IUnknown);
pub trait IComputerInfoChangeNotify_Trait: crate::core::IUnknown_Trait {
    fn ComputerInfoChanged(&self) -> crate::core::HRESULT {
        todo!("ComputerInfoChanged")
    }
}
impl ::core::clone::Clone for IComputerInfoChangeNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IComputerInfoChangeNotify {}
impl ::core::cmp::PartialEq for IComputerInfoChangeNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IComputerInfoChangeNotify {}
impl ::core::fmt::Debug for IComputerInfoChangeNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IComputerInfoChangeNotify")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IComputerInfoChangeNotify {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IComputerInfoChangeNotify {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0df60d92_6818_46d6_b358_d66170dde466);
}
pub struct IConnectableCredentialProviderCredential(pub crate::core::IUnknown);
pub trait IConnectableCredentialProviderCredential_Trait:
    ICredentialProviderCredential_Trait
{
    fn Connect(&self, pqcws: IQueryContinueWithStatus) -> crate::core::HRESULT {
        todo!("Connect")
    }
    fn Disconnect(&self) -> crate::core::HRESULT {
        todo!("Disconnect")
    }
}
impl ::core::clone::Clone for IConnectableCredentialProviderCredential {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IConnectableCredentialProviderCredential {}
impl ::core::cmp::PartialEq for IConnectableCredentialProviderCredential {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IConnectableCredentialProviderCredential {}
impl ::core::fmt::Debug for IConnectableCredentialProviderCredential {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IConnectableCredentialProviderCredential")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IConnectableCredentialProviderCredential {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IConnectableCredentialProviderCredential {
    type Super = ICredentialProviderCredential;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9387928b_ac75_4bf9_8ab2_2b93c4a55290);
}
pub struct IContactManagerInterop(pub crate::core::IUnknown);
pub trait IContactManagerInterop_Trait: crate::core::IUnknown_Trait {
    fn ShowContactCardForWindow(
        &self,
        app_window: super::super::Foundation::HWND,
        contact: crate::core::IUnknown,
        selection: ConstPtr<super::super::Foundation::RECT>,
        preferred_placement: FLYOUT_PLACEMENT,
    ) -> crate::core::HRESULT {
        todo!("ShowContactCardForWindow")
    }
}
impl ::core::clone::Clone for IContactManagerInterop {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IContactManagerInterop {}
impl ::core::cmp::PartialEq for IContactManagerInterop {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IContactManagerInterop {}
impl ::core::fmt::Debug for IContactManagerInterop {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IContactManagerInterop")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IContactManagerInterop {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IContactManagerInterop {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x99eacba7_e073_43b6_a896_55afe48a0833);
}
pub struct IContextMenu(pub crate::core::IUnknown);
pub trait IContextMenu_Trait: crate::core::IUnknown_Trait {
    fn QueryContextMenu(
        &self,
        hmenu: super::WindowsAndMessaging::HMENU,
        index_menu: u32,
        id_cmd_first: u32,
        id_cmd_last: u32,
        u_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("QueryContextMenu")
    }
    fn InvokeCommand(&self, pici: ConstPtr<CMINVOKECOMMANDINFO>) -> crate::core::HRESULT {
        todo!("InvokeCommand")
    }
    fn GetCommandString(
        &self,
        id_cmd: PtrRepr,
        u_type: u32,
        p_reserved: MutPtr<u32>,
        psz_name: PSTR,
        cch_max: u32,
    ) -> crate::core::HRESULT {
        todo!("GetCommandString")
    }
}
impl ::core::clone::Clone for IContextMenu {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IContextMenu {}
impl ::core::cmp::PartialEq for IContextMenu {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IContextMenu {}
impl ::core::fmt::Debug for IContextMenu {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IContextMenu").field(&self.0).finish()
    }
}
impl FromIntoMemory for IContextMenu {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IContextMenu {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e4_0000_0000_c000_000000000046);
}
pub struct IContextMenu2(pub crate::core::IUnknown);
pub trait IContextMenu2_Trait: IContextMenu_Trait {
    fn HandleMenuMsg(
        &self,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("HandleMenuMsg")
    }
}
impl ::core::clone::Clone for IContextMenu2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IContextMenu2 {}
impl ::core::cmp::PartialEq for IContextMenu2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IContextMenu2 {}
impl ::core::fmt::Debug for IContextMenu2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IContextMenu2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IContextMenu2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IContextMenu2 {
    type Super = IContextMenu;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214f4_0000_0000_c000_000000000046);
}
pub struct IContextMenu3(pub crate::core::IUnknown);
pub trait IContextMenu3_Trait: IContextMenu2_Trait {
    fn HandleMenuMsg2(
        &self,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
        pl_result: MutPtr<super::super::Foundation::LRESULT>,
    ) -> crate::core::HRESULT {
        todo!("HandleMenuMsg2")
    }
}
impl ::core::clone::Clone for IContextMenu3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IContextMenu3 {}
impl ::core::cmp::PartialEq for IContextMenu3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IContextMenu3 {}
impl ::core::fmt::Debug for IContextMenu3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IContextMenu3").field(&self.0).finish()
    }
}
impl FromIntoMemory for IContextMenu3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IContextMenu3 {
    type Super = IContextMenu2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xbcfce0a0_ec17_11d0_8d10_00a0c90f2719);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IContextMenuCB(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IContextMenuCB_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CallBack(
        &self,
        psf: IShellFolder,
        hwnd_owner: super::super::Foundation::HWND,
        pdtobj: super::super::System::Com::IDataObject,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("CallBack")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IContextMenuCB {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IContextMenuCB {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IContextMenuCB {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IContextMenuCB {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IContextMenuCB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IContextMenuCB").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IContextMenuCB {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IContextMenuCB {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3409e930_5a39_11d1_83fa_00a0c90dc849);
}
pub struct IContextMenuSite(pub crate::core::IUnknown);
pub trait IContextMenuSite_Trait: crate::core::IUnknown_Trait {
    fn DoContextMenuPopup(
        &self,
        punk_context_menu: crate::core::IUnknown,
        f_flags: u32,
        pt: super::super::Foundation::POINT,
    ) -> crate::core::HRESULT {
        todo!("DoContextMenuPopup")
    }
}
impl ::core::clone::Clone for IContextMenuSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IContextMenuSite {}
impl ::core::cmp::PartialEq for IContextMenuSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IContextMenuSite {}
impl ::core::fmt::Debug for IContextMenuSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IContextMenuSite").field(&self.0).finish()
    }
}
impl FromIntoMemory for IContextMenuSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IContextMenuSite {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0811aebe_0b87_4c54_9e72_548cf649016b);
}
pub struct ICopyHookA(pub crate::core::IUnknown);
pub trait ICopyHookA_Trait: crate::core::IUnknown_Trait {
    fn CopyCallback(
        &self,
        hwnd: super::super::Foundation::HWND,
        w_func: u32,
        w_flags: u32,
        psz_src_file: PCSTR,
        dw_src_attribs: u32,
        psz_dest_file: PCSTR,
        dw_dest_attribs: u32,
    ) -> u32 {
        todo!("CopyCallback")
    }
}
impl ::core::clone::Clone for ICopyHookA {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICopyHookA {}
impl ::core::cmp::PartialEq for ICopyHookA {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICopyHookA {}
impl ::core::fmt::Debug for ICopyHookA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICopyHookA").field(&self.0).finish()
    }
}
impl FromIntoMemory for ICopyHookA {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICopyHookA {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214ef_0000_0000_c000_000000000046);
}
pub struct ICopyHookW(pub crate::core::IUnknown);
pub trait ICopyHookW_Trait: crate::core::IUnknown_Trait {
    fn CopyCallback(
        &self,
        hwnd: super::super::Foundation::HWND,
        w_func: u32,
        w_flags: u32,
        psz_src_file: PCWSTR,
        dw_src_attribs: u32,
        psz_dest_file: PCWSTR,
        dw_dest_attribs: u32,
    ) -> u32 {
        todo!("CopyCallback")
    }
}
impl ::core::clone::Clone for ICopyHookW {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICopyHookW {}
impl ::core::cmp::PartialEq for ICopyHookW {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICopyHookW {}
impl ::core::fmt::Debug for ICopyHookW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICopyHookW").field(&self.0).finish()
    }
}
impl FromIntoMemory for ICopyHookW {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICopyHookW {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214fc_0000_0000_c000_000000000046);
}
pub struct ICreateProcessInputs(pub crate::core::IUnknown);
pub trait ICreateProcessInputs_Trait: crate::core::IUnknown_Trait {
    fn GetCreateFlags(&self, pdw_creation_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCreateFlags")
    }
    fn SetCreateFlags(&self, dw_creation_flags: u32) -> crate::core::HRESULT {
        todo!("SetCreateFlags")
    }
    fn AddCreateFlags(&self, dw_creation_flags: u32) -> crate::core::HRESULT {
        todo!("AddCreateFlags")
    }
    fn SetHotKey(&self, w_hot_key: u16) -> crate::core::HRESULT {
        todo!("SetHotKey")
    }
    fn AddStartupFlags(&self, dw_startup_info_flags: u32) -> crate::core::HRESULT {
        todo!("AddStartupFlags")
    }
    fn SetTitle(&self, psz_title: PCWSTR) -> crate::core::HRESULT {
        todo!("SetTitle")
    }
    fn SetEnvironmentVariable(&self, psz_name: PCWSTR, psz_value: PCWSTR) -> crate::core::HRESULT {
        todo!("SetEnvironmentVariable")
    }
}
impl ::core::clone::Clone for ICreateProcessInputs {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICreateProcessInputs {}
impl ::core::cmp::PartialEq for ICreateProcessInputs {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICreateProcessInputs {}
impl ::core::fmt::Debug for ICreateProcessInputs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICreateProcessInputs")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICreateProcessInputs {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICreateProcessInputs {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf6ef6140_e26f_4d82_bac4_e9ba5fd239a8);
}
pub struct ICreatingProcess(pub crate::core::IUnknown);
pub trait ICreatingProcess_Trait: crate::core::IUnknown_Trait {
    fn OnCreating(&self, pcpi: ICreateProcessInputs) -> crate::core::HRESULT {
        todo!("OnCreating")
    }
}
impl ::core::clone::Clone for ICreatingProcess {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICreatingProcess {}
impl ::core::cmp::PartialEq for ICreatingProcess {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICreatingProcess {}
impl ::core::fmt::Debug for ICreatingProcess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICreatingProcess").field(&self.0).finish()
    }
}
impl FromIntoMemory for ICreatingProcess {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICreatingProcess {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc2b937a9_3110_4398_8a56_f34c6342d244);
}
pub struct ICredentialProvider(pub crate::core::IUnknown);
pub trait ICredentialProvider_Trait: crate::core::IUnknown_Trait {
    fn SetUsageScenario(
        &self,
        cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetUsageScenario")
    }
    fn SetSerialization(
        &self,
        pcpcs: ConstPtr<CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION>,
    ) -> crate::core::HRESULT {
        todo!("SetSerialization")
    }
    fn Advise(
        &self,
        pcpe: ICredentialProviderEvents,
        up_advise_context: PtrRepr,
    ) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn UnAdvise(&self) -> crate::core::HRESULT {
        todo!("UnAdvise")
    }
    fn GetFieldDescriptorCount(&self, pdw_count: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFieldDescriptorCount")
    }
    fn GetFieldDescriptorAt(
        &self,
        dw_index: u32,
        ppcpfd: MutPtr<ConstPtr<CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR>>,
    ) -> crate::core::HRESULT {
        todo!("GetFieldDescriptorAt")
    }
    fn GetCredentialCount(
        &self,
        pdw_count: MutPtr<u32>,
        pdw_default: MutPtr<u32>,
        pb_auto_logon_with_default: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetCredentialCount")
    }
    fn GetCredentialAt(
        &self,
        dw_index: u32,
        ppcpc: MutPtr<ICredentialProviderCredential>,
    ) -> crate::core::HRESULT {
        todo!("GetCredentialAt")
    }
}
impl ::core::clone::Clone for ICredentialProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProvider {}
impl ::core::cmp::PartialEq for ICredentialProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProvider {}
impl ::core::fmt::Debug for ICredentialProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProvider").field(&self.0).finish()
    }
}
impl FromIntoMemory for ICredentialProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd27c3481_5a1c_45b2_8aaa_c20ebbe8229e);
}
pub struct ICredentialProviderCredential(pub crate::core::IUnknown);
pub trait ICredentialProviderCredential_Trait: crate::core::IUnknown_Trait {
    fn Advise(&self, pcpce: ICredentialProviderCredentialEvents) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn UnAdvise(&self) -> crate::core::HRESULT {
        todo!("UnAdvise")
    }
    fn SetSelected(
        &self,
        pb_auto_logon: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("SetSelected")
    }
    fn SetDeselected(&self) -> crate::core::HRESULT {
        todo!("SetDeselected")
    }
    fn GetFieldState(
        &self,
        dw_field_id: u32,
        pcpfs: MutPtr<CREDENTIAL_PROVIDER_FIELD_STATE>,
        pcpfis: MutPtr<CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE>,
    ) -> crate::core::HRESULT {
        todo!("GetFieldState")
    }
    fn GetStringValue(&self, dw_field_id: u32, ppsz: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetStringValue")
    }
    fn GetBitmapValue(
        &self,
        dw_field_id: u32,
        phbmp: MutPtr<super::super::Graphics::Gdi::HBITMAP>,
    ) -> crate::core::HRESULT {
        todo!("GetBitmapValue")
    }
    fn GetCheckboxValue(
        &self,
        dw_field_id: u32,
        pb_checked: MutPtr<super::super::Foundation::BOOL>,
        ppsz_label: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetCheckboxValue")
    }
    fn GetSubmitButtonValue(
        &self,
        dw_field_id: u32,
        pdw_adjacent_to: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetSubmitButtonValue")
    }
    fn GetComboBoxValueCount(
        &self,
        dw_field_id: u32,
        pc_items: MutPtr<u32>,
        pdw_selected_item: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetComboBoxValueCount")
    }
    fn GetComboBoxValueAt(
        &self,
        dw_field_id: u32,
        dw_item: u32,
        ppsz_item: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetComboBoxValueAt")
    }
    fn SetStringValue(&self, dw_field_id: u32, psz: PCWSTR) -> crate::core::HRESULT {
        todo!("SetStringValue")
    }
    fn SetCheckboxValue(
        &self,
        dw_field_id: u32,
        b_checked: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetCheckboxValue")
    }
    fn SetComboBoxSelectedValue(
        &self,
        dw_field_id: u32,
        dw_selected_item: u32,
    ) -> crate::core::HRESULT {
        todo!("SetComboBoxSelectedValue")
    }
    fn CommandLinkClicked(&self, dw_field_id: u32) -> crate::core::HRESULT {
        todo!("CommandLinkClicked")
    }
    fn GetSerialization(
        &self,
        pcpgsr: MutPtr<CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE>,
        pcpcs: MutPtr<CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION>,
        ppsz_optional_status_text: MutPtr<PWSTR>,
        pcpsi_optional_status_icon: MutPtr<CREDENTIAL_PROVIDER_STATUS_ICON>,
    ) -> crate::core::HRESULT {
        todo!("GetSerialization")
    }
    fn ReportResult(
        &self,
        nts_status: super::super::Foundation::NTSTATUS,
        nts_substatus: super::super::Foundation::NTSTATUS,
        ppsz_optional_status_text: MutPtr<PWSTR>,
        pcpsi_optional_status_icon: MutPtr<CREDENTIAL_PROVIDER_STATUS_ICON>,
    ) -> crate::core::HRESULT {
        todo!("ReportResult")
    }
}
impl ::core::clone::Clone for ICredentialProviderCredential {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProviderCredential {}
impl ::core::cmp::PartialEq for ICredentialProviderCredential {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProviderCredential {}
impl ::core::fmt::Debug for ICredentialProviderCredential {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderCredential")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICredentialProviderCredential {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProviderCredential {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x63913a93_40c1_481a_818d_4072ff8c70cc);
}
pub struct ICredentialProviderCredential2(pub crate::core::IUnknown);
pub trait ICredentialProviderCredential2_Trait: ICredentialProviderCredential_Trait {
    fn GetUserSid(&self, sid: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetUserSid")
    }
}
impl ::core::clone::Clone for ICredentialProviderCredential2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProviderCredential2 {}
impl ::core::cmp::PartialEq for ICredentialProviderCredential2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProviderCredential2 {}
impl ::core::fmt::Debug for ICredentialProviderCredential2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderCredential2")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICredentialProviderCredential2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProviderCredential2 {
    type Super = ICredentialProviderCredential;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfd672c54_40ea_4d6e_9b49_cfb1a7507bd7);
}
pub struct ICredentialProviderCredentialEvents(pub crate::core::IUnknown);
pub trait ICredentialProviderCredentialEvents_Trait: crate::core::IUnknown_Trait {
    fn SetFieldState(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        cpfs: CREDENTIAL_PROVIDER_FIELD_STATE,
    ) -> crate::core::HRESULT {
        todo!("SetFieldState")
    }
    fn SetFieldInteractiveState(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        cpfis: CREDENTIAL_PROVIDER_FIELD_INTERACTIVE_STATE,
    ) -> crate::core::HRESULT {
        todo!("SetFieldInteractiveState")
    }
    fn SetFieldString(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        psz: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetFieldString")
    }
    fn SetFieldCheckbox(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        b_checked: super::super::Foundation::BOOL,
        psz_label: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetFieldCheckbox")
    }
    fn SetFieldBitmap(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        hbmp: super::super::Graphics::Gdi::HBITMAP,
    ) -> crate::core::HRESULT {
        todo!("SetFieldBitmap")
    }
    fn SetFieldComboBoxSelectedItem(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        dw_selected_item: u32,
    ) -> crate::core::HRESULT {
        todo!("SetFieldComboBoxSelectedItem")
    }
    fn DeleteFieldComboBoxItem(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        dw_item: u32,
    ) -> crate::core::HRESULT {
        todo!("DeleteFieldComboBoxItem")
    }
    fn AppendFieldComboBoxItem(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        psz_item: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("AppendFieldComboBoxItem")
    }
    fn SetFieldSubmitButton(
        &self,
        pcpc: ICredentialProviderCredential,
        dw_field_id: u32,
        dw_adjacent_to: u32,
    ) -> crate::core::HRESULT {
        todo!("SetFieldSubmitButton")
    }
    fn OnCreatingWindow(
        &self,
        phwnd_owner: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("OnCreatingWindow")
    }
}
impl ::core::clone::Clone for ICredentialProviderCredentialEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProviderCredentialEvents {}
impl ::core::cmp::PartialEq for ICredentialProviderCredentialEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProviderCredentialEvents {}
impl ::core::fmt::Debug for ICredentialProviderCredentialEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderCredentialEvents")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICredentialProviderCredentialEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProviderCredentialEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfa6fa76b_66b7_4b11_95f1_86171118e816);
}
pub struct ICredentialProviderCredentialEvents2(pub crate::core::IUnknown);
pub trait ICredentialProviderCredentialEvents2_Trait:
    ICredentialProviderCredentialEvents_Trait
{
    fn BeginFieldUpdates(&self) -> crate::core::HRESULT {
        todo!("BeginFieldUpdates")
    }
    fn EndFieldUpdates(&self) -> crate::core::HRESULT {
        todo!("EndFieldUpdates")
    }
    fn SetFieldOptions(
        &self,
        credential: ICredentialProviderCredential,
        field_id: u32,
        options: CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS,
    ) -> crate::core::HRESULT {
        todo!("SetFieldOptions")
    }
}
impl ::core::clone::Clone for ICredentialProviderCredentialEvents2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProviderCredentialEvents2 {}
impl ::core::cmp::PartialEq for ICredentialProviderCredentialEvents2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProviderCredentialEvents2 {}
impl ::core::fmt::Debug for ICredentialProviderCredentialEvents2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderCredentialEvents2")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICredentialProviderCredentialEvents2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProviderCredentialEvents2 {
    type Super = ICredentialProviderCredentialEvents;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb53c00b6_9922_4b78_b1f4_ddfe774dc39b);
}
pub struct ICredentialProviderCredentialWithFieldOptions(pub crate::core::IUnknown);
pub trait ICredentialProviderCredentialWithFieldOptions_Trait: crate::core::IUnknown_Trait {
    fn GetFieldOptions(
        &self,
        field_id: u32,
        options: MutPtr<CREDENTIAL_PROVIDER_CREDENTIAL_FIELD_OPTIONS>,
    ) -> crate::core::HRESULT {
        todo!("GetFieldOptions")
    }
}
impl ::core::clone::Clone for ICredentialProviderCredentialWithFieldOptions {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProviderCredentialWithFieldOptions {}
impl ::core::cmp::PartialEq for ICredentialProviderCredentialWithFieldOptions {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProviderCredentialWithFieldOptions {}
impl ::core::fmt::Debug for ICredentialProviderCredentialWithFieldOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderCredentialWithFieldOptions")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICredentialProviderCredentialWithFieldOptions {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProviderCredentialWithFieldOptions {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xdbc6fb30_c843_49e3_a645_573e6f39446a);
}
pub struct ICredentialProviderEvents(pub crate::core::IUnknown);
pub trait ICredentialProviderEvents_Trait: crate::core::IUnknown_Trait {
    fn CredentialsChanged(&self, up_advise_context: PtrRepr) -> crate::core::HRESULT {
        todo!("CredentialsChanged")
    }
}
impl ::core::clone::Clone for ICredentialProviderEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProviderEvents {}
impl ::core::cmp::PartialEq for ICredentialProviderEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProviderEvents {}
impl ::core::fmt::Debug for ICredentialProviderEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderEvents")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICredentialProviderEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProviderEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x34201e5a_a787_41a3_a5a4_bd6dcf2a854e);
}
pub struct ICredentialProviderFilter(pub crate::core::IUnknown);
pub trait ICredentialProviderFilter_Trait: crate::core::IUnknown_Trait {
    fn Filter(
        &self,
        cpus: CREDENTIAL_PROVIDER_USAGE_SCENARIO,
        dw_flags: u32,
        rgclsid_providers: ConstPtr<crate::core::GUID>,
        rgb_allow: MutPtr<super::super::Foundation::BOOL>,
        c_providers: u32,
    ) -> crate::core::HRESULT {
        todo!("Filter")
    }
    fn UpdateRemoteCredential(
        &self,
        pcpcs_in: ConstPtr<CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION>,
        pcpcs_out: MutPtr<CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION>,
    ) -> crate::core::HRESULT {
        todo!("UpdateRemoteCredential")
    }
}
impl ::core::clone::Clone for ICredentialProviderFilter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICredentialProviderFilter {}
impl ::core::cmp::PartialEq for ICredentialProviderFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICredentialProviderFilter {}
impl ::core::fmt::Debug for ICredentialProviderFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderFilter")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICredentialProviderFilter {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICredentialProviderFilter {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa5da53f9_d475_4080_a120_910c4a739880);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICredentialProviderSetUserArray(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICredentialProviderSetUserArray_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetUserArray(&self, users: ICredentialProviderUserArray) -> crate::core::HRESULT {
        todo!("SetUserArray")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICredentialProviderSetUserArray {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICredentialProviderSetUserArray {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICredentialProviderSetUserArray {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICredentialProviderSetUserArray {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICredentialProviderSetUserArray {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderSetUserArray")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICredentialProviderSetUserArray {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICredentialProviderSetUserArray {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x095c1484_1c0c_4388_9c6d_500e61bf84bd);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICredentialProviderUser(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICredentialProviderUser_Trait: crate::core::IUnknown_Trait {
    fn GetSid(&self, sid: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetSid")
    }
    fn GetProviderID(&self, provider_id: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetProviderID")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetStringValue(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        string_value: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetStringValue")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetValue(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        value: MutPtr<super::super::System::Com::StructuredStorage::PROPVARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetValue")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICredentialProviderUser {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICredentialProviderUser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICredentialProviderUser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICredentialProviderUser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICredentialProviderUser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderUser")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICredentialProviderUser {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICredentialProviderUser {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x13793285_3ea6_40fd_b420_15f47da41fbb);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICredentialProviderUserArray(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICredentialProviderUserArray_Trait: crate::core::IUnknown_Trait {
    fn SetProviderFilter(
        &self,
        guid_provider_to_filter_to: ConstPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("SetProviderFilter")
    }
    fn GetAccountOptions(
        &self,
        credential_provider_account_options: MutPtr<CREDENTIAL_PROVIDER_ACCOUNT_OPTIONS>,
    ) -> crate::core::HRESULT {
        todo!("GetAccountOptions")
    }
    fn GetCount(&self, user_count: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetAt(
        &self,
        user_index: u32,
        user: MutPtr<ICredentialProviderUser>,
    ) -> crate::core::HRESULT {
        todo!("GetAt")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICredentialProviderUserArray {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICredentialProviderUserArray {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICredentialProviderUserArray {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICredentialProviderUserArray {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICredentialProviderUserArray {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICredentialProviderUserArray")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICredentialProviderUserArray {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICredentialProviderUserArray {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x90c119ae_0f18_4520_a1f1_114366a40fe8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICurrentItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICurrentItem_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICurrentItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICurrentItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICurrentItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICurrentItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICurrentItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICurrentItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICurrentItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICurrentItem {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x240a7174_d653_4a1d_a6d3_d4943cfbfe3d);
}
pub struct ICurrentWorkingDirectory(pub crate::core::IUnknown);
pub trait ICurrentWorkingDirectory_Trait: crate::core::IUnknown_Trait {
    fn GetDirectory(&self, pwz_path: PWSTR, cch_size: u32) -> crate::core::HRESULT {
        todo!("GetDirectory")
    }
    fn SetDirectory(&self, pwz_path: PCWSTR) -> crate::core::HRESULT {
        todo!("SetDirectory")
    }
}
impl ::core::clone::Clone for ICurrentWorkingDirectory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ICurrentWorkingDirectory {}
impl ::core::cmp::PartialEq for ICurrentWorkingDirectory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICurrentWorkingDirectory {}
impl ::core::fmt::Debug for ICurrentWorkingDirectory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICurrentWorkingDirectory")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ICurrentWorkingDirectory {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ICurrentWorkingDirectory {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x91956d21_9276_11d1_921a_006097df5bd4);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ICustomDestinationList(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ICustomDestinationList_Trait: crate::core::IUnknown_Trait {
    fn SetAppID(&self, psz_app_id: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAppID")
    }
    fn BeginList(
        &self,
        pc_min_slots: MutPtr<u32>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("BeginList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AppendCategory(
        &self,
        psz_category: PCWSTR,
        poa: Common::IObjectArray,
    ) -> crate::core::HRESULT {
        todo!("AppendCategory")
    }
    fn AppendKnownCategory(&self, category: KNOWNDESTCATEGORY) -> crate::core::HRESULT {
        todo!("AppendKnownCategory")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddUserTasks(&self, poa: Common::IObjectArray) -> crate::core::HRESULT {
        todo!("AddUserTasks")
    }
    fn CommitList(&self) -> crate::core::HRESULT {
        todo!("CommitList")
    }
    fn GetRemovedDestinations(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetRemovedDestinations")
    }
    fn DeleteList(&self, psz_app_id: PCWSTR) -> crate::core::HRESULT {
        todo!("DeleteList")
    }
    fn AbortList(&self) -> crate::core::HRESULT {
        todo!("AbortList")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ICustomDestinationList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ICustomDestinationList {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ICustomDestinationList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ICustomDestinationList {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ICustomDestinationList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICustomDestinationList")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ICustomDestinationList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ICustomDestinationList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6332debf_87b5_4670_90c0_5e57b408a49e);
}
pub const IDC_OFFLINE_HAND: u32 = 103u32;
pub const IDC_PANTOOL_HAND_CLOSED: u32 = 105u32;
pub const IDC_PANTOOL_HAND_OPEN: u32 = 104u32;
pub const IDD_WIZEXTN_FIRST: u32 = 20480u32;
pub const IDD_WIZEXTN_LAST: u32 = 20736u32;
pub const IDO_SHGIOI_DEFAULT: u64 = 4294967292u64;
pub const IDO_SHGIOI_LINK: u32 = 268435454u32;
pub const IDO_SHGIOI_SHARE: u32 = 268435455u32;
pub const IDO_SHGIOI_SLOWFILE: u64 = 4294967293u64;
pub const IDS_DESCRIPTION: u32 = 1u32;
pub const ID_APP: u32 = 100u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDataObjectAsyncCapability(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDataObjectAsyncCapability_Trait: crate::core::IUnknown_Trait {
    fn SetAsyncMode(&self, f_do_op_async: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetAsyncMode")
    }
    fn GetAsyncMode(
        &self,
        pf_is_op_async: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetAsyncMode")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn StartOperation(
        &self,
        pbc_reserved: super::super::System::Com::IBindCtx,
    ) -> crate::core::HRESULT {
        todo!("StartOperation")
    }
    fn InOperation(
        &self,
        pf_in_async_op: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("InOperation")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EndOperation(
        &self,
        h_result: crate::core::HRESULT,
        pbc_reserved: super::super::System::Com::IBindCtx,
        dw_effects: u32,
    ) -> crate::core::HRESULT {
        todo!("EndOperation")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDataObjectAsyncCapability {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDataObjectAsyncCapability {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDataObjectAsyncCapability {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDataObjectAsyncCapability {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDataObjectAsyncCapability {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDataObjectAsyncCapability")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDataObjectAsyncCapability {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDataObjectAsyncCapability {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3d8b0590_f691_11d2_8ea9_006097df5bd4);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDataObjectProvider(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDataObjectProvider_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDataObject(
        &self,
        data_object: MutPtr<super::super::System::Com::IDataObject>,
    ) -> crate::core::HRESULT {
        todo!("GetDataObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetDataObject(
        &self,
        data_object: super::super::System::Com::IDataObject,
    ) -> crate::core::HRESULT {
        todo!("SetDataObject")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDataObjectProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDataObjectProvider {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDataObjectProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDataObjectProvider {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDataObjectProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDataObjectProvider").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDataObjectProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDataObjectProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3d25f6d6_4b2a_433c_9184_7c33ad35d001);
}
pub struct IDataTransferManagerInterop(pub crate::core::IUnknown);
pub trait IDataTransferManagerInterop_Trait: crate::core::IUnknown_Trait {
    fn GetForWindow(
        &self,
        app_window: super::super::Foundation::HWND,
        riid: ConstPtr<crate::core::GUID>,
        data_transfer_manager: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetForWindow")
    }
    fn ShowShareUIForWindow(
        &self,
        app_window: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("ShowShareUIForWindow")
    }
}
impl ::core::clone::Clone for IDataTransferManagerInterop {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDataTransferManagerInterop {}
impl ::core::cmp::PartialEq for IDataTransferManagerInterop {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDataTransferManagerInterop {}
impl ::core::fmt::Debug for IDataTransferManagerInterop {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDataTransferManagerInterop")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDataTransferManagerInterop {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDataTransferManagerInterop {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3a3dcd6c_3eab_43dc_bcde_45671ce800c8);
}
pub struct IDefaultExtractIconInit(pub crate::core::IUnknown);
pub trait IDefaultExtractIconInit_Trait: crate::core::IUnknown_Trait {
    fn SetFlags(&self, u_flags: u32) -> crate::core::HRESULT {
        todo!("SetFlags")
    }
    fn SetKey(&self, hkey: super::super::System::Registry::HKEY) -> crate::core::HRESULT {
        todo!("SetKey")
    }
    fn SetNormalIcon(&self, psz_file: PCWSTR, i_icon: i32) -> crate::core::HRESULT {
        todo!("SetNormalIcon")
    }
    fn SetOpenIcon(&self, psz_file: PCWSTR, i_icon: i32) -> crate::core::HRESULT {
        todo!("SetOpenIcon")
    }
    fn SetShortcutIcon(&self, psz_file: PCWSTR, i_icon: i32) -> crate::core::HRESULT {
        todo!("SetShortcutIcon")
    }
    fn SetDefaultIcon(&self, psz_file: PCWSTR, i_icon: i32) -> crate::core::HRESULT {
        todo!("SetDefaultIcon")
    }
}
impl ::core::clone::Clone for IDefaultExtractIconInit {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDefaultExtractIconInit {}
impl ::core::cmp::PartialEq for IDefaultExtractIconInit {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDefaultExtractIconInit {}
impl ::core::fmt::Debug for IDefaultExtractIconInit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDefaultExtractIconInit")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IDefaultExtractIconInit {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDefaultExtractIconInit {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x41ded17d_d6b3_4261_997d_88c60e4b1d58);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDefaultFolderMenuInitialize(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDefaultFolderMenuInitialize_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(
        &self,
        hwnd: super::super::Foundation::HWND,
        pcmcb: IContextMenuCB,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
        psf: IShellFolder,
        cidl: u32,
        apidl: ConstPtr<ConstPtr<Common::ITEMIDLIST>>,
        punk_association: crate::core::IUnknown,
        c_keys: u32,
        a_keys: ConstPtr<super::super::System::Registry::HKEY>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn SetMenuRestrictions(
        &self,
        dfmr_values: DEFAULT_FOLDER_MENU_RESTRICTIONS,
    ) -> crate::core::HRESULT {
        todo!("SetMenuRestrictions")
    }
    fn GetMenuRestrictions(
        &self,
        dfmr_mask: DEFAULT_FOLDER_MENU_RESTRICTIONS,
        pdfmr_values: MutPtr<DEFAULT_FOLDER_MENU_RESTRICTIONS>,
    ) -> crate::core::HRESULT {
        todo!("GetMenuRestrictions")
    }
    fn SetHandlerClsid(&self, rclsid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("SetHandlerClsid")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDefaultFolderMenuInitialize {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDefaultFolderMenuInitialize {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDefaultFolderMenuInitialize {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDefaultFolderMenuInitialize {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDefaultFolderMenuInitialize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDefaultFolderMenuInitialize")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDefaultFolderMenuInitialize {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDefaultFolderMenuInitialize {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7690aa79_f8fc_4615_a327_36f7d18f5d91);
}
pub struct IDelegateFolder(pub crate::core::IUnknown);
pub trait IDelegateFolder_Trait: crate::core::IUnknown_Trait {
    fn SetItemAlloc(&self, pmalloc: super::super::System::Com::IMalloc) -> crate::core::HRESULT {
        todo!("SetItemAlloc")
    }
}
impl ::core::clone::Clone for IDelegateFolder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDelegateFolder {}
impl ::core::cmp::PartialEq for IDelegateFolder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDelegateFolder {}
impl ::core::fmt::Debug for IDelegateFolder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDelegateFolder").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDelegateFolder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDelegateFolder {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xadd8ba80_002b_11d0_8f0f_00c04fd7d062);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDelegateItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDelegateItem_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDelegateItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDelegateItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDelegateItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDelegateItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDelegateItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDelegateItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDelegateItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDelegateItem {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3c5a1c94_c951_4cb7_bb6d_3b93f30cce93);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDeskBand(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDeskBand_Trait: IDockingWindow_Trait {
    fn GetBandInfo(
        &self,
        dw_band_id: u32,
        dw_view_mode: u32,
        pdbi: MutPtr<DESKBANDINFO>,
    ) -> crate::core::HRESULT {
        todo!("GetBandInfo")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDeskBand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDeskBand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDeskBand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDeskBand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDeskBand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDeskBand").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDeskBand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDeskBand {
    type Super = IDockingWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xeb0fe172_1a3a_11d0_89b3_00a0c90a90ac);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDeskBand2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDeskBand2_Trait: IDeskBand_Trait {
    fn CanRenderComposited(
        &self,
        pf_can_render_composited: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("CanRenderComposited")
    }
    fn SetCompositionState(
        &self,
        f_composition_enabled: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetCompositionState")
    }
    fn GetCompositionState(
        &self,
        pf_composition_enabled: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetCompositionState")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDeskBand2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDeskBand2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDeskBand2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDeskBand2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDeskBand2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDeskBand2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDeskBand2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDeskBand2 {
    type Super = IDeskBand;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79d16de4_abee_4021_8d9d_9169b261d657);
}
pub struct IDeskBandInfo(pub crate::core::IUnknown);
pub trait IDeskBandInfo_Trait: crate::core::IUnknown_Trait {
    fn GetDefaultBandWidth(
        &self,
        dw_band_id: u32,
        dw_view_mode: u32,
        pn_width: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetDefaultBandWidth")
    }
}
impl ::core::clone::Clone for IDeskBandInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDeskBandInfo {}
impl ::core::cmp::PartialEq for IDeskBandInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDeskBandInfo {}
impl ::core::fmt::Debug for IDeskBandInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDeskBandInfo").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDeskBandInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDeskBandInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x77e425fc_cbf9_4307_ba6a_bb5727745661);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDeskBar(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDeskBar_Trait: super::super::System::Ole::IOleWindow_Trait {
    fn SetClient(&self, punk_client: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("SetClient")
    }
    fn GetClient(&self, ppunk_client: MutPtr<crate::core::IUnknown>) -> crate::core::HRESULT {
        todo!("GetClient")
    }
    fn OnPosRectChangeDB(
        &self,
        prc: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("OnPosRectChangeDB")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDeskBar {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDeskBar {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDeskBar {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDeskBar {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDeskBar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDeskBar").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDeskBar {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDeskBar {
    type Super = super::super::System::Ole::IOleWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xeb0fe173_1a3a_11d0_89b3_00a0c90a90ac);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDeskBarClient(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDeskBarClient_Trait: super::super::System::Ole::IOleWindow_Trait {
    fn SetDeskBarSite(&self, punk_site: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("SetDeskBarSite")
    }
    fn SetModeDBC(&self, dw_mode: u32) -> crate::core::HRESULT {
        todo!("SetModeDBC")
    }
    fn UIActivateDBC(&self, dw_state: u32) -> crate::core::HRESULT {
        todo!("UIActivateDBC")
    }
    fn GetSize(
        &self,
        dw_which: u32,
        prc: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("GetSize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDeskBarClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDeskBarClient {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDeskBarClient {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDeskBarClient {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDeskBarClient {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDeskBarClient").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDeskBarClient {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDeskBarClient {
    type Super = super::super::System::Ole::IOleWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xeb0fe175_1a3a_11d0_89b3_00a0c90a90ac);
}
pub struct IDesktopGadget(pub crate::core::IUnknown);
pub trait IDesktopGadget_Trait: crate::core::IUnknown_Trait {
    fn RunGadget(&self, gadget_path: PCWSTR) -> crate::core::HRESULT {
        todo!("RunGadget")
    }
}
impl ::core::clone::Clone for IDesktopGadget {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDesktopGadget {}
impl ::core::cmp::PartialEq for IDesktopGadget {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDesktopGadget {}
impl ::core::fmt::Debug for IDesktopGadget {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDesktopGadget").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDesktopGadget {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDesktopGadget {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc1646bc4_f298_4f91_a204_eb2dd1709d1a);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDesktopWallpaper(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDesktopWallpaper_Trait: crate::core::IUnknown_Trait {
    fn SetWallpaper(&self, monitor_id: PCWSTR, wallpaper: PCWSTR) -> crate::core::HRESULT {
        todo!("SetWallpaper")
    }
    fn GetWallpaper(&self, monitor_id: PCWSTR, wallpaper: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetWallpaper")
    }
    fn GetMonitorDevicePathAt(
        &self,
        monitor_index: u32,
        monitor_id: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetMonitorDevicePathAt")
    }
    fn GetMonitorDevicePathCount(&self, count: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetMonitorDevicePathCount")
    }
    fn GetMonitorRECT(
        &self,
        monitor_id: PCWSTR,
        display_rect: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("GetMonitorRECT")
    }
    fn SetBackgroundColor(&self, color: u32) -> crate::core::HRESULT {
        todo!("SetBackgroundColor")
    }
    fn GetBackgroundColor(&self, color: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetBackgroundColor")
    }
    fn SetPosition(&self, position: DESKTOP_WALLPAPER_POSITION) -> crate::core::HRESULT {
        todo!("SetPosition")
    }
    fn GetPosition(&self, position: MutPtr<DESKTOP_WALLPAPER_POSITION>) -> crate::core::HRESULT {
        todo!("GetPosition")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetSlideshow(&self, items: IShellItemArray) -> crate::core::HRESULT {
        todo!("SetSlideshow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSlideshow(&self, items: MutPtr<IShellItemArray>) -> crate::core::HRESULT {
        todo!("GetSlideshow")
    }
    fn SetSlideshowOptions(
        &self,
        options: DESKTOP_SLIDESHOW_OPTIONS,
        slideshow_tick: u32,
    ) -> crate::core::HRESULT {
        todo!("SetSlideshowOptions")
    }
    fn GetSlideshowOptions(
        &self,
        options: MutPtr<DESKTOP_SLIDESHOW_OPTIONS>,
        slideshow_tick: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetSlideshowOptions")
    }
    fn AdvanceSlideshow(
        &self,
        monitor_id: PCWSTR,
        direction: DESKTOP_SLIDESHOW_DIRECTION,
    ) -> crate::core::HRESULT {
        todo!("AdvanceSlideshow")
    }
    fn GetStatus(&self, state: MutPtr<DESKTOP_SLIDESHOW_STATE>) -> crate::core::HRESULT {
        todo!("GetStatus")
    }
    fn Enable(&self, enable: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("Enable")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDesktopWallpaper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDesktopWallpaper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDesktopWallpaper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDesktopWallpaper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDesktopWallpaper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDesktopWallpaper").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDesktopWallpaper {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDesktopWallpaper {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb92b56a9_8b55_4e14_9a89_0199bbb6f93b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDestinationStreamFactory(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDestinationStreamFactory_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDestinationStream(
        &self,
        ppstm: MutPtr<super::super::System::Com::IStream>,
    ) -> crate::core::HRESULT {
        todo!("GetDestinationStream")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDestinationStreamFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDestinationStreamFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDestinationStreamFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDestinationStreamFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDestinationStreamFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDestinationStreamFactory")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDestinationStreamFactory {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDestinationStreamFactory {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8a87781b_39a7_4a1f_aab3_a39b9c34a7d9);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDisplayItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDisplayItem_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDisplayItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDisplayItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDisplayItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDisplayItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDisplayItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDisplayItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDisplayItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDisplayItem {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc6fd5997_9f6b_4888_8703_94e80e8cde3f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDocViewSite(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDocViewSite_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnSetTitle(
        &self,
        pv_title: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("OnSetTitle")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDocViewSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDocViewSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDocViewSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDocViewSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDocViewSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDocViewSite").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDocViewSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDocViewSite {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x87d605e0_c511_11cf_89a9_00a0c9054129);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDockingWindow(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDockingWindow_Trait: super::super::System::Ole::IOleWindow_Trait {
    fn ShowDW(&self, f_show: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("ShowDW")
    }
    fn CloseDW(&self, dw_reserved: u32) -> crate::core::HRESULT {
        todo!("CloseDW")
    }
    fn ResizeBorderDW(
        &self,
        prc_border: ConstPtr<super::super::Foundation::RECT>,
        punk_toolbar_site: crate::core::IUnknown,
        f_reserved: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("ResizeBorderDW")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDockingWindow {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDockingWindow {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDockingWindow {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDockingWindow {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDockingWindow {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDockingWindow").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDockingWindow {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDockingWindow {
    type Super = super::super::System::Ole::IOleWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x012dd920_7b26_11d0_8ca9_00a0c92dbfe8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDockingWindowFrame(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDockingWindowFrame_Trait: super::super::System::Ole::IOleWindow_Trait {
    fn AddToolbar(
        &self,
        punk_src: crate::core::IUnknown,
        pwsz_item: PCWSTR,
        dw_add_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("AddToolbar")
    }
    fn RemoveToolbar(
        &self,
        punk_src: crate::core::IUnknown,
        dw_remove_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("RemoveToolbar")
    }
    fn FindToolbar(
        &self,
        pwsz_item: PCWSTR,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("FindToolbar")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDockingWindowFrame {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDockingWindowFrame {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDockingWindowFrame {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDockingWindowFrame {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDockingWindowFrame {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDockingWindowFrame").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDockingWindowFrame {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDockingWindowFrame {
    type Super = super::super::System::Ole::IOleWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x47d2657a_7b27_11d0_8ca9_00a0c92dbfe8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDockingWindowSite(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDockingWindowSite_Trait: super::super::System::Ole::IOleWindow_Trait {
    fn GetBorderDW(
        &self,
        punk_obj: crate::core::IUnknown,
        prc_border: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("GetBorderDW")
    }
    fn RequestBorderSpaceDW(
        &self,
        punk_obj: crate::core::IUnknown,
        pbw: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("RequestBorderSpaceDW")
    }
    fn SetBorderSpaceDW(
        &self,
        punk_obj: crate::core::IUnknown,
        pbw: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("SetBorderSpaceDW")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDockingWindowSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDockingWindowSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDockingWindowSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDockingWindowSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDockingWindowSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDockingWindowSite").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDockingWindowSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDockingWindowSite {
    type Super = super::super::System::Ole::IOleWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2a342fc2_7b26_11d0_8ca9_00a0c92dbfe8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDragSourceHelper(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDragSourceHelper_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InitializeFromBitmap(
        &self,
        pshdi: ConstPtr<SHDRAGIMAGE>,
        p_data_object: super::super::System::Com::IDataObject,
    ) -> crate::core::HRESULT {
        todo!("InitializeFromBitmap")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InitializeFromWindow(
        &self,
        hwnd: super::super::Foundation::HWND,
        ppt: ConstPtr<super::super::Foundation::POINT>,
        p_data_object: super::super::System::Com::IDataObject,
    ) -> crate::core::HRESULT {
        todo!("InitializeFromWindow")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDragSourceHelper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDragSourceHelper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDragSourceHelper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDragSourceHelper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDragSourceHelper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDragSourceHelper").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDragSourceHelper {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDragSourceHelper {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xde5bf786_477a_11d2_839d_00c04fd918d0);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDragSourceHelper2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDragSourceHelper2_Trait: IDragSourceHelper_Trait {
    fn SetFlags(&self, dw_flags: u32) -> crate::core::HRESULT {
        todo!("SetFlags")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDragSourceHelper2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDragSourceHelper2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDragSourceHelper2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDragSourceHelper2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDragSourceHelper2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDragSourceHelper2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDragSourceHelper2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDragSourceHelper2 {
    type Super = IDragSourceHelper;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x83e07d0d_0c5f_4163_bf1a_60b274051e40);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IDropTargetHelper(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IDropTargetHelper_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn DragEnter(
        &self,
        hwnd_target: super::super::Foundation::HWND,
        p_data_object: super::super::System::Com::IDataObject,
        ppt: ConstPtr<super::super::Foundation::POINT>,
        dw_effect: u32,
    ) -> crate::core::HRESULT {
        todo!("DragEnter")
    }
    fn DragLeave(&self) -> crate::core::HRESULT {
        todo!("DragLeave")
    }
    fn DragOver(
        &self,
        ppt: ConstPtr<super::super::Foundation::POINT>,
        dw_effect: u32,
    ) -> crate::core::HRESULT {
        todo!("DragOver")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Drop(
        &self,
        p_data_object: super::super::System::Com::IDataObject,
        ppt: ConstPtr<super::super::Foundation::POINT>,
        dw_effect: u32,
    ) -> crate::core::HRESULT {
        todo!("Drop")
    }
    fn Show(&self, f_show: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("Show")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IDropTargetHelper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IDropTargetHelper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IDropTargetHelper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IDropTargetHelper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IDropTargetHelper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDropTargetHelper").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IDropTargetHelper {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IDropTargetHelper {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4657278b_411b_11d2_839a_00c04fd918d0);
}
pub struct IDynamicHWHandler(pub crate::core::IUnknown);
pub trait IDynamicHWHandler_Trait: crate::core::IUnknown_Trait {
    fn GetDynamicInfo(
        &self,
        psz_device_id: PCWSTR,
        dw_content_type: u32,
        ppsz_action: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetDynamicInfo")
    }
}
impl ::core::clone::Clone for IDynamicHWHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IDynamicHWHandler {}
impl ::core::cmp::PartialEq for IDynamicHWHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDynamicHWHandler {}
impl ::core::fmt::Debug for IDynamicHWHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDynamicHWHandler").field(&self.0).finish()
    }
}
impl FromIntoMemory for IDynamicHWHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IDynamicHWHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xdc2601d7_059e_42fc_a09d_2afd21b6d5f7);
}
pub const IEIFLAG_ASPECT: u32 = 4u32;
pub const IEIFLAG_ASYNC: u32 = 1u32;
pub const IEIFLAG_CACHE: u32 = 2u32;
pub const IEIFLAG_GLEAM: u32 = 16u32;
pub const IEIFLAG_NOBORDER: u32 = 256u32;
pub const IEIFLAG_NOSTAMP: u32 = 128u32;
pub const IEIFLAG_OFFLINE: u32 = 8u32;
pub const IEIFLAG_ORIGSIZE: u32 = 64u32;
pub const IEIFLAG_QUALITY: u32 = 512u32;
pub const IEIFLAG_REFRESH: u32 = 1024u32;
pub const IEIFLAG_SCREEN: u32 = 32u32;
pub const IEIT_PRIORITY_NORMAL: u32 = 268435456u32;
pub const IEI_PRIORITY_MAX: u32 = 2147483647u32;
pub const IEI_PRIORITY_MIN: u32 = 0u32;
pub const IENamespaceTreeControl: crate::core::GUID =
    crate::core::GUID::from_u128(0xace52d03_e5cd_4b20_82ff_e71b11beae1d);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct IEPDNFLAGS(pub i32);
pub const IEPDN_BINDINGUI: IEPDNFLAGS = IEPDNFLAGS(1i32);
impl ::core::marker::Copy for IEPDNFLAGS {}
impl ::core::clone::Clone for IEPDNFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for IEPDNFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for IEPDNFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEPDNFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEPDNFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct IESHORTCUTFLAGS(pub i32);
pub const IESHORTCUT_NEWBROWSER: IESHORTCUTFLAGS = IESHORTCUTFLAGS(1i32);
pub const IESHORTCUT_OPENNEWTAB: IESHORTCUTFLAGS = IESHORTCUTFLAGS(2i32);
pub const IESHORTCUT_FORCENAVIGATE: IESHORTCUTFLAGS = IESHORTCUTFLAGS(4i32);
pub const IESHORTCUT_BACKGROUNDTAB: IESHORTCUTFLAGS = IESHORTCUTFLAGS(8i32);
impl ::core::marker::Copy for IESHORTCUTFLAGS {}
impl ::core::clone::Clone for IESHORTCUTFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for IESHORTCUTFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for IESHORTCUTFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IESHORTCUTFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for IESHORTCUTFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct IEnumACString(pub crate::core::IUnknown);
pub trait IEnumACString_Trait: super::super::System::Com::IEnumString_Trait {
    fn NextItem(
        &self,
        psz_url: PWSTR,
        cch_max: u32,
        pul_sort_index: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("NextItem")
    }
    fn SetEnumOptions(&self, dw_options: u32) -> crate::core::HRESULT {
        todo!("SetEnumOptions")
    }
    fn GetEnumOptions(&self, pdw_options: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetEnumOptions")
    }
}
impl ::core::clone::Clone for IEnumACString {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumACString {}
impl ::core::cmp::PartialEq for IEnumACString {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumACString {}
impl ::core::fmt::Debug for IEnumACString {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumACString").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumACString {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumACString {
    type Super = super::super::System::Com::IEnumString;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8e74c210_cf9d_4eaf_a403_7356428f0a5a);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IEnumAssocHandlers(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IEnumAssocHandlers_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<IAssocHandler>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IEnumAssocHandlers {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IEnumAssocHandlers {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IEnumAssocHandlers {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IEnumAssocHandlers {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IEnumAssocHandlers {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumAssocHandlers").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IEnumAssocHandlers {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IEnumAssocHandlers {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x973810ae_9599_4b88_9e4d_6ee98c9552da);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IEnumExplorerCommand(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IEnumExplorerCommand_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Next(
        &self,
        celt: u32,
        p_ui_command: MutPtr<IExplorerCommand>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Clone(&self, ppenum: MutPtr<IEnumExplorerCommand>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IEnumExplorerCommand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IEnumExplorerCommand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IEnumExplorerCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IEnumExplorerCommand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IEnumExplorerCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumExplorerCommand")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IEnumExplorerCommand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IEnumExplorerCommand {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa88826f8_186f_4987_aade_ea0cef8fbfe8);
}
pub struct IEnumExtraSearch(pub crate::core::IUnknown);
pub trait IEnumExtraSearch_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<EXTRASEARCH>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, ppenum: MutPtr<IEnumExtraSearch>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for IEnumExtraSearch {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumExtraSearch {}
impl ::core::cmp::PartialEq for IEnumExtraSearch {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumExtraSearch {}
impl ::core::fmt::Debug for IEnumExtraSearch {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumExtraSearch").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumExtraSearch {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumExtraSearch {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0e700be1_9db6_11d1_a1ce_00c04fd75d13);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IEnumFullIDList(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IEnumFullIDList_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Clone(&self, ppenum: MutPtr<IEnumFullIDList>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IEnumFullIDList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IEnumFullIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IEnumFullIDList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IEnumFullIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IEnumFullIDList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumFullIDList").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IEnumFullIDList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IEnumFullIDList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd0191542_7954_4908_bc06_b2360bbe45ba);
}
pub struct IEnumHLITEM(pub crate::core::IUnknown);
pub trait IEnumHLITEM_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<HLITEM>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, ppienumhlitem: MutPtr<IEnumHLITEM>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for IEnumHLITEM {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumHLITEM {}
impl ::core::cmp::PartialEq for IEnumHLITEM {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumHLITEM {}
impl ::core::fmt::Debug for IEnumHLITEM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumHLITEM").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumHLITEM {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumHLITEM {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79eac9c6_baf9_11ce_8c82_00aa004ba90b);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IEnumIDList(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IEnumIDList_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Clone(&self, ppenum: MutPtr<IEnumIDList>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IEnumIDList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IEnumIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IEnumIDList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IEnumIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IEnumIDList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumIDList").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IEnumIDList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IEnumIDList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214f2_0000_0000_c000_000000000046);
}
pub struct IEnumObjects(pub crate::core::IUnknown);
pub trait IEnumObjects_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        celt: u32,
        riid: ConstPtr<crate::core::GUID>,
        rgelt: MutPtr<ConstPtr<::core::ffi::c_void>>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, ppenum: MutPtr<IEnumObjects>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for IEnumObjects {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumObjects {}
impl ::core::cmp::PartialEq for IEnumObjects {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumObjects {}
impl ::core::fmt::Debug for IEnumObjects {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumObjects").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumObjects {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumObjects {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2c1c7e2e_2d0e_4059_831e_1e6f82335c2e);
}
pub struct IEnumPublishedApps(pub crate::core::IUnknown);
pub trait IEnumPublishedApps_Trait: crate::core::IUnknown_Trait {
    fn Next(&self, pia: MutPtr<IPublishedApp>) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
}
impl ::core::clone::Clone for IEnumPublishedApps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumPublishedApps {}
impl ::core::cmp::PartialEq for IEnumPublishedApps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumPublishedApps {}
impl ::core::fmt::Debug for IEnumPublishedApps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumPublishedApps").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumPublishedApps {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumPublishedApps {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0b124f8c_91f0_11d1_b8b5_006008059382);
}
pub struct IEnumReadyCallback(pub crate::core::IUnknown);
pub trait IEnumReadyCallback_Trait: crate::core::IUnknown_Trait {
    fn EnumReady(&self) -> crate::core::HRESULT {
        todo!("EnumReady")
    }
}
impl ::core::clone::Clone for IEnumReadyCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumReadyCallback {}
impl ::core::cmp::PartialEq for IEnumReadyCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumReadyCallback {}
impl ::core::fmt::Debug for IEnumReadyCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumReadyCallback").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumReadyCallback {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumReadyCallback {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x61e00d45_8fff_4e60_924e_6537b61612dd);
}
pub struct IEnumResources(pub crate::core::IUnknown);
pub trait IEnumResources_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        celt: u32,
        psir: MutPtr<SHELL_ITEM_RESOURCE>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, ppenumr: MutPtr<IEnumResources>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for IEnumResources {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumResources {}
impl ::core::cmp::PartialEq for IEnumResources {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumResources {}
impl ::core::fmt::Debug for IEnumResources {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumResources").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumResources {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumResources {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2dd81fe3_a83c_4da9_a330_47249d345ba1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IEnumShellItems(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IEnumShellItems_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<IShellItem>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Clone(&self, ppenum: MutPtr<IEnumShellItems>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IEnumShellItems {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IEnumShellItems {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IEnumShellItems {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IEnumShellItems {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IEnumShellItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumShellItems").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IEnumShellItems {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IEnumShellItems {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x70629033_e363_4a28_a567_0db78006e6d7);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IEnumSyncMgrConflict(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IEnumSyncMgrConflict_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<ISyncMgrConflict>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Clone(&self, ppenum: MutPtr<IEnumSyncMgrConflict>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IEnumSyncMgrConflict {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IEnumSyncMgrConflict {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IEnumSyncMgrConflict {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IEnumSyncMgrConflict {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IEnumSyncMgrConflict {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumSyncMgrConflict")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IEnumSyncMgrConflict {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IEnumSyncMgrConflict {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x82705914_dda3_4893_ba99_49de6c8c8036);
}
pub struct IEnumSyncMgrEvents(pub crate::core::IUnknown);
pub trait IEnumSyncMgrEvents_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<ISyncMgrEvent>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, ppenum: MutPtr<IEnumSyncMgrEvents>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for IEnumSyncMgrEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumSyncMgrEvents {}
impl ::core::cmp::PartialEq for IEnumSyncMgrEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumSyncMgrEvents {}
impl ::core::fmt::Debug for IEnumSyncMgrEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumSyncMgrEvents").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumSyncMgrEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumSyncMgrEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc81a1d4e_8cf7_4683_80e0_bcae88d677b6);
}
pub struct IEnumSyncMgrSyncItems(pub crate::core::IUnknown);
pub trait IEnumSyncMgrSyncItems_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<ISyncMgrSyncItem>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, ppenum: MutPtr<IEnumSyncMgrSyncItems>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for IEnumSyncMgrSyncItems {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumSyncMgrSyncItems {}
impl ::core::cmp::PartialEq for IEnumSyncMgrSyncItems {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumSyncMgrSyncItems {}
impl ::core::fmt::Debug for IEnumSyncMgrSyncItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumSyncMgrSyncItems")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IEnumSyncMgrSyncItems {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumSyncMgrSyncItems {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x54b3abf3_f085_4181_b546_e29c403c726b);
}
pub struct IEnumTravelLogEntry(pub crate::core::IUnknown);
pub trait IEnumTravelLogEntry_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        c_elt: u32,
        rg_elt: MutPtr<ITravelLogEntry>,
        pc_elt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, c_elt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, pp_enum: MutPtr<IEnumTravelLogEntry>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for IEnumTravelLogEntry {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IEnumTravelLogEntry {}
impl ::core::cmp::PartialEq for IEnumTravelLogEntry {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEnumTravelLogEntry {}
impl ::core::fmt::Debug for IEnumTravelLogEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumTravelLogEntry").field(&self.0).finish()
    }
}
impl FromIntoMemory for IEnumTravelLogEntry {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IEnumTravelLogEntry {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7ebfdd85_ad18_11d3_a4c5_00c04f72d6b8);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IEnumerableView(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IEnumerableView_Trait: crate::core::IUnknown_Trait {
    fn SetEnumReadyCallback(&self, percb: IEnumReadyCallback) -> crate::core::HRESULT {
        todo!("SetEnumReadyCallback")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateEnumIDListFromContents(
        &self,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
        dw_enum_flags: u32,
        pp_enum_id_list: MutPtr<IEnumIDList>,
    ) -> crate::core::HRESULT {
        todo!("CreateEnumIDListFromContents")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IEnumerableView {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IEnumerableView {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IEnumerableView {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IEnumerableView {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IEnumerableView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEnumerableView").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IEnumerableView {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IEnumerableView {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8c8bf236_1aec_495f_9894_91d57c3c686f);
}
pub struct IExecuteCommand(pub crate::core::IUnknown);
pub trait IExecuteCommand_Trait: crate::core::IUnknown_Trait {
    fn SetKeyState(&self, grf_key_state: u32) -> crate::core::HRESULT {
        todo!("SetKeyState")
    }
    fn SetParameters(&self, psz_parameters: PCWSTR) -> crate::core::HRESULT {
        todo!("SetParameters")
    }
    fn SetPosition(&self, pt: super::super::Foundation::POINT) -> crate::core::HRESULT {
        todo!("SetPosition")
    }
    fn SetShowWindow(&self, n_show: i32) -> crate::core::HRESULT {
        todo!("SetShowWindow")
    }
    fn SetNoShowUI(&self, f_no_show_ui: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetNoShowUI")
    }
    fn SetDirectory(&self, psz_directory: PCWSTR) -> crate::core::HRESULT {
        todo!("SetDirectory")
    }
    fn Execute(&self) -> crate::core::HRESULT {
        todo!("Execute")
    }
}
impl ::core::clone::Clone for IExecuteCommand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExecuteCommand {}
impl ::core::cmp::PartialEq for IExecuteCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExecuteCommand {}
impl ::core::fmt::Debug for IExecuteCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExecuteCommand").field(&self.0).finish()
    }
}
impl FromIntoMemory for IExecuteCommand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExecuteCommand {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7f9185b0_cb92_43c5_80a9_92277a4f7b54);
}
pub struct IExecuteCommandApplicationHostEnvironment(pub crate::core::IUnknown);
pub trait IExecuteCommandApplicationHostEnvironment_Trait: crate::core::IUnknown_Trait {
    fn GetValue(&self, pahe: MutPtr<AHE_TYPE>) -> crate::core::HRESULT {
        todo!("GetValue")
    }
}
impl ::core::clone::Clone for IExecuteCommandApplicationHostEnvironment {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExecuteCommandApplicationHostEnvironment {}
impl ::core::cmp::PartialEq for IExecuteCommandApplicationHostEnvironment {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExecuteCommandApplicationHostEnvironment {}
impl ::core::fmt::Debug for IExecuteCommandApplicationHostEnvironment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExecuteCommandApplicationHostEnvironment")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IExecuteCommandApplicationHostEnvironment {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExecuteCommandApplicationHostEnvironment {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x18b21aa9_e184_4ff0_9f5e_f882d03771b3);
}
pub struct IExecuteCommandHost(pub crate::core::IUnknown);
pub trait IExecuteCommandHost_Trait: crate::core::IUnknown_Trait {
    fn GetUIMode(&self, p_ui_mode: MutPtr<EC_HOST_UI_MODE>) -> crate::core::HRESULT {
        todo!("GetUIMode")
    }
}
impl ::core::clone::Clone for IExecuteCommandHost {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExecuteCommandHost {}
impl ::core::cmp::PartialEq for IExecuteCommandHost {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExecuteCommandHost {}
impl ::core::fmt::Debug for IExecuteCommandHost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExecuteCommandHost").field(&self.0).finish()
    }
}
impl FromIntoMemory for IExecuteCommandHost {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExecuteCommandHost {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4b6832a2_5f04_4c9d_b89d_727a15d103e7);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IExpDispSupport(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IExpDispSupport_Trait: crate::core::IUnknown_Trait {
    fn FindConnectionPoint(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppccp: MutPtr<super::super::System::Com::IConnectionPoint>,
    ) -> crate::core::HRESULT {
        todo!("FindConnectionPoint")
    }
    fn OnTranslateAccelerator(
        &self,
        p_msg: ConstPtr<super::WindowsAndMessaging::MSG>,
        grf_modifiers: u32,
    ) -> crate::core::HRESULT {
        todo!("OnTranslateAccelerator")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnInvoke(
        &self,
        dispid_member: i32,
        iid: ConstPtr<crate::core::GUID>,
        lcid: u32,
        w_flags: u16,
        pdispparams: ConstPtr<super::super::System::Com::DISPPARAMS>,
        p_var_result: MutPtr<super::super::System::Com::VARIANT>,
        pexcepinfo: MutPtr<super::super::System::Com::EXCEPINFO>,
        pu_arg_err: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("OnInvoke")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IExpDispSupport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IExpDispSupport {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IExpDispSupport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IExpDispSupport {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IExpDispSupport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExpDispSupport").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IExpDispSupport {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IExpDispSupport {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0d7d1d00_6fc0_11d0_a974_00c04fd705a2);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IExpDispSupportXP(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IExpDispSupportXP_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn FindCIE4ConnectionPoint(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppccp: MutPtr<CIE4ConnectionPoint>,
    ) -> crate::core::HRESULT {
        todo!("FindCIE4ConnectionPoint")
    }
    fn OnTranslateAccelerator(
        &self,
        p_msg: ConstPtr<super::WindowsAndMessaging::MSG>,
        grf_modifiers: u32,
    ) -> crate::core::HRESULT {
        todo!("OnTranslateAccelerator")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnInvoke(
        &self,
        dispid_member: i32,
        iid: ConstPtr<crate::core::GUID>,
        lcid: u32,
        w_flags: u16,
        pdispparams: ConstPtr<super::super::System::Com::DISPPARAMS>,
        p_var_result: MutPtr<super::super::System::Com::VARIANT>,
        pexcepinfo: MutPtr<super::super::System::Com::EXCEPINFO>,
        pu_arg_err: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("OnInvoke")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IExpDispSupportXP {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IExpDispSupportXP {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IExpDispSupportXP {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IExpDispSupportXP {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IExpDispSupportXP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExpDispSupportXP").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IExpDispSupportXP {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IExpDispSupportXP {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2f0dd58c_f789_4f14_99fb_9293b3c9c212);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IExplorerBrowser(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IExplorerBrowser_Trait: crate::core::IUnknown_Trait {
    fn Initialize(
        &self,
        hwnd_parent: super::super::Foundation::HWND,
        prc: ConstPtr<super::super::Foundation::RECT>,
        pfs: ConstPtr<FOLDERSETTINGS>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn Destroy(&self) -> crate::core::HRESULT {
        todo!("Destroy")
    }
    fn SetRect(
        &self,
        phdwp: MutPtr<PtrDiffRepr>,
        rc_browser: super::super::Foundation::RECT,
    ) -> crate::core::HRESULT {
        todo!("SetRect")
    }
    fn SetPropertyBag(&self, psz_property_bag: PCWSTR) -> crate::core::HRESULT {
        todo!("SetPropertyBag")
    }
    fn SetEmptyText(&self, psz_empty_text: PCWSTR) -> crate::core::HRESULT {
        todo!("SetEmptyText")
    }
    fn SetFolderSettings(&self, pfs: ConstPtr<FOLDERSETTINGS>) -> crate::core::HRESULT {
        todo!("SetFolderSettings")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Advise(
        &self,
        psbe: IExplorerBrowserEvents,
        pdw_cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn Unadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("Unadvise")
    }
    fn SetOptions(&self, dw_flag: EXPLORER_BROWSER_OPTIONS) -> crate::core::HRESULT {
        todo!("SetOptions")
    }
    fn GetOptions(&self, pdw_flag: MutPtr<EXPLORER_BROWSER_OPTIONS>) -> crate::core::HRESULT {
        todo!("GetOptions")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BrowseToIDList(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        u_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("BrowseToIDList")
    }
    fn BrowseToObject(&self, punk: crate::core::IUnknown, u_flags: u32) -> crate::core::HRESULT {
        todo!("BrowseToObject")
    }
    fn FillFromObject(
        &self,
        punk: crate::core::IUnknown,
        dw_flags: EXPLORER_BROWSER_FILL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("FillFromObject")
    }
    fn RemoveAll(&self) -> crate::core::HRESULT {
        todo!("RemoveAll")
    }
    fn GetCurrentView(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetCurrentView")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IExplorerBrowser {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IExplorerBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IExplorerBrowser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IExplorerBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IExplorerBrowser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExplorerBrowser").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IExplorerBrowser {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IExplorerBrowser {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xdfd3b6b5_c10c_4be9_85f6_a66969f402f6);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IExplorerBrowserEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IExplorerBrowserEvents_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnNavigationPending(
        &self,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("OnNavigationPending")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnViewCreated(&self, psv: IShellView) -> crate::core::HRESULT {
        todo!("OnViewCreated")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnNavigationComplete(
        &self,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("OnNavigationComplete")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnNavigationFailed(
        &self,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("OnNavigationFailed")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IExplorerBrowserEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IExplorerBrowserEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IExplorerBrowserEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IExplorerBrowserEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IExplorerBrowserEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExplorerBrowserEvents")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IExplorerBrowserEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IExplorerBrowserEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x361bbdc7_e6ee_4e13_be58_58e2240c810f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IExplorerCommand(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IExplorerCommand_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetTitle(
        &self,
        psi_item_array: IShellItemArray,
        ppsz_name: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetTitle")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIcon(
        &self,
        psi_item_array: IShellItemArray,
        ppsz_icon: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetIcon")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetToolTip(
        &self,
        psi_item_array: IShellItemArray,
        ppsz_infotip: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetToolTip")
    }
    fn GetCanonicalName(
        &self,
        pguid_command_name: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("GetCanonicalName")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetState(
        &self,
        psi_item_array: IShellItemArray,
        f_ok_to_be_slow: super::super::Foundation::BOOL,
        p_cmd_state: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Invoke(
        &self,
        psi_item_array: IShellItemArray,
        pbc: super::super::System::Com::IBindCtx,
    ) -> crate::core::HRESULT {
        todo!("Invoke")
    }
    fn GetFlags(&self, p_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFlags")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EnumSubCommands(&self, pp_enum: MutPtr<IEnumExplorerCommand>) -> crate::core::HRESULT {
        todo!("EnumSubCommands")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IExplorerCommand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IExplorerCommand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IExplorerCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IExplorerCommand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IExplorerCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExplorerCommand").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IExplorerCommand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IExplorerCommand {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa08ce4d0_fa25_44ab_b57c_c7b1c323e0b9);
}
pub struct IExplorerCommandProvider(pub crate::core::IUnknown);
pub trait IExplorerCommandProvider_Trait: crate::core::IUnknown_Trait {
    fn GetCommands(
        &self,
        punk_site: crate::core::IUnknown,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetCommands")
    }
    fn GetCommand(
        &self,
        rguid_command_id: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetCommand")
    }
}
impl ::core::clone::Clone for IExplorerCommandProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExplorerCommandProvider {}
impl ::core::cmp::PartialEq for IExplorerCommandProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExplorerCommandProvider {}
impl ::core::fmt::Debug for IExplorerCommandProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExplorerCommandProvider")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IExplorerCommandProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExplorerCommandProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x64961751_0835_43c0_8ffe_d57686530e64);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IExplorerCommandState(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IExplorerCommandState_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetState(
        &self,
        psi_item_array: IShellItemArray,
        f_ok_to_be_slow: super::super::Foundation::BOOL,
        p_cmd_state: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetState")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IExplorerCommandState {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IExplorerCommandState {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IExplorerCommandState {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IExplorerCommandState {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IExplorerCommandState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExplorerCommandState")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IExplorerCommandState {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IExplorerCommandState {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xbddacb60_7657_47ae_8445_d23e1acf82ae);
}
pub struct IExplorerPaneVisibility(pub crate::core::IUnknown);
pub trait IExplorerPaneVisibility_Trait: crate::core::IUnknown_Trait {
    fn GetPaneState(
        &self,
        ep: ConstPtr<crate::core::GUID>,
        peps: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetPaneState")
    }
}
impl ::core::clone::Clone for IExplorerPaneVisibility {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExplorerPaneVisibility {}
impl ::core::cmp::PartialEq for IExplorerPaneVisibility {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExplorerPaneVisibility {}
impl ::core::fmt::Debug for IExplorerPaneVisibility {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExplorerPaneVisibility")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IExplorerPaneVisibility {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExplorerPaneVisibility {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe07010ec_bc17_44c0_97b0_46c7c95b9edc);
}
pub struct IExtensionServices(pub crate::core::IUnknown);
pub trait IExtensionServices_Trait: crate::core::IUnknown_Trait {
    fn SetAdditionalHeaders(&self, pwz_additional_headers: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAdditionalHeaders")
    }
    fn SetAuthenticateData(
        &self,
        phwnd: super::super::Foundation::HWND,
        pwz_username: PCWSTR,
        pwz_password: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetAuthenticateData")
    }
}
impl ::core::clone::Clone for IExtensionServices {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExtensionServices {}
impl ::core::cmp::PartialEq for IExtensionServices {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExtensionServices {}
impl ::core::fmt::Debug for IExtensionServices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExtensionServices").field(&self.0).finish()
    }
}
impl FromIntoMemory for IExtensionServices {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExtensionServices {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79eac9cb_baf9_11ce_8c82_00aa004ba90b);
}
pub struct IExtractIconA(pub crate::core::IUnknown);
pub trait IExtractIconA_Trait: crate::core::IUnknown_Trait {
    fn GetIconLocation(
        &self,
        u_flags: u32,
        psz_icon_file: PSTR,
        cch_max: u32,
        pi_index: MutPtr<i32>,
        pw_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetIconLocation")
    }
    fn Extract(
        &self,
        psz_file: PCSTR,
        n_icon_index: u32,
        phicon_large: MutPtr<super::WindowsAndMessaging::HICON>,
        phicon_small: MutPtr<super::WindowsAndMessaging::HICON>,
        n_icon_size: u32,
    ) -> crate::core::HRESULT {
        todo!("Extract")
    }
}
impl ::core::clone::Clone for IExtractIconA {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExtractIconA {}
impl ::core::cmp::PartialEq for IExtractIconA {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExtractIconA {}
impl ::core::fmt::Debug for IExtractIconA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExtractIconA").field(&self.0).finish()
    }
}
impl FromIntoMemory for IExtractIconA {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExtractIconA {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214eb_0000_0000_c000_000000000046);
}
pub struct IExtractIconW(pub crate::core::IUnknown);
pub trait IExtractIconW_Trait: crate::core::IUnknown_Trait {
    fn GetIconLocation(
        &self,
        u_flags: u32,
        psz_icon_file: PWSTR,
        cch_max: u32,
        pi_index: MutPtr<i32>,
        pw_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetIconLocation")
    }
    fn Extract(
        &self,
        psz_file: PCWSTR,
        n_icon_index: u32,
        phicon_large: MutPtr<super::WindowsAndMessaging::HICON>,
        phicon_small: MutPtr<super::WindowsAndMessaging::HICON>,
        n_icon_size: u32,
    ) -> crate::core::HRESULT {
        todo!("Extract")
    }
}
impl ::core::clone::Clone for IExtractIconW {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExtractIconW {}
impl ::core::cmp::PartialEq for IExtractIconW {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExtractIconW {}
impl ::core::fmt::Debug for IExtractIconW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExtractIconW").field(&self.0).finish()
    }
}
impl FromIntoMemory for IExtractIconW {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExtractIconW {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214fa_0000_0000_c000_000000000046);
}
pub struct IExtractImage(pub crate::core::IUnknown);
pub trait IExtractImage_Trait: crate::core::IUnknown_Trait {
    fn GetLocation(
        &self,
        psz_path_buffer: PWSTR,
        cch: u32,
        pdw_priority: MutPtr<u32>,
        prg_size: ConstPtr<super::super::Foundation::SIZE>,
        dw_rec_clr_depth: u32,
        pdw_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetLocation")
    }
    fn Extract(
        &self,
        ph_bmp_thumbnail: MutPtr<super::super::Graphics::Gdi::HBITMAP>,
    ) -> crate::core::HRESULT {
        todo!("Extract")
    }
}
impl ::core::clone::Clone for IExtractImage {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExtractImage {}
impl ::core::cmp::PartialEq for IExtractImage {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExtractImage {}
impl ::core::fmt::Debug for IExtractImage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExtractImage").field(&self.0).finish()
    }
}
impl FromIntoMemory for IExtractImage {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExtractImage {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xbb2e617c_0920_11d1_9a0b_00c04fc2d6c1);
}
pub struct IExtractImage2(pub crate::core::IUnknown);
pub trait IExtractImage2_Trait: IExtractImage_Trait {
    fn GetDateStamp(
        &self,
        p_date_stamp: MutPtr<super::super::Foundation::FILETIME>,
    ) -> crate::core::HRESULT {
        todo!("GetDateStamp")
    }
}
impl ::core::clone::Clone for IExtractImage2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IExtractImage2 {}
impl ::core::cmp::PartialEq for IExtractImage2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IExtractImage2 {}
impl ::core::fmt::Debug for IExtractImage2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IExtractImage2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IExtractImage2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IExtractImage2 {
    type Super = IExtractImage;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x953bb1ee_93b4_11d1_98a3_00c04fb687da);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileDialog(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileDialog_Trait: IModalWindow_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetFileTypes(
        &self,
        c_file_types: u32,
        rg_filter_spec: ConstPtr<Common::COMDLG_FILTERSPEC>,
    ) -> crate::core::HRESULT {
        todo!("SetFileTypes")
    }
    fn SetFileTypeIndex(&self, i_file_type: u32) -> crate::core::HRESULT {
        todo!("SetFileTypeIndex")
    }
    fn GetFileTypeIndex(&self, pi_file_type: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFileTypeIndex")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Advise(&self, pfde: IFileDialogEvents, pdw_cookie: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn Unadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("Unadvise")
    }
    fn SetOptions(&self, fos: FILEOPENDIALOGOPTIONS) -> crate::core::HRESULT {
        todo!("SetOptions")
    }
    fn GetOptions(&self, pfos: MutPtr<FILEOPENDIALOGOPTIONS>) -> crate::core::HRESULT {
        todo!("GetOptions")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetDefaultFolder(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("SetDefaultFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetFolder(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("SetFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetFolder(&self, ppsi: MutPtr<IShellItem>) -> crate::core::HRESULT {
        todo!("GetFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetCurrentSelection(&self, ppsi: MutPtr<IShellItem>) -> crate::core::HRESULT {
        todo!("GetCurrentSelection")
    }
    fn SetFileName(&self, psz_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetFileName")
    }
    fn GetFileName(&self, psz_name: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetFileName")
    }
    fn SetTitle(&self, psz_title: PCWSTR) -> crate::core::HRESULT {
        todo!("SetTitle")
    }
    fn SetOkButtonLabel(&self, psz_text: PCWSTR) -> crate::core::HRESULT {
        todo!("SetOkButtonLabel")
    }
    fn SetFileNameLabel(&self, psz_label: PCWSTR) -> crate::core::HRESULT {
        todo!("SetFileNameLabel")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetResult(&self, ppsi: MutPtr<IShellItem>) -> crate::core::HRESULT {
        todo!("GetResult")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddPlace(&self, psi: IShellItem, fdap: FDAP) -> crate::core::HRESULT {
        todo!("AddPlace")
    }
    fn SetDefaultExtension(&self, psz_default_extension: PCWSTR) -> crate::core::HRESULT {
        todo!("SetDefaultExtension")
    }
    fn Close(&self, hr: crate::core::HRESULT) -> crate::core::HRESULT {
        todo!("Close")
    }
    fn SetClientGuid(&self, guid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("SetClientGuid")
    }
    fn ClearClientData(&self) -> crate::core::HRESULT {
        todo!("ClearClientData")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetFilter(&self, p_filter: IShellItemFilter) -> crate::core::HRESULT {
        todo!("SetFilter")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileDialog {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileDialog {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileDialog {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileDialog").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileDialog {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileDialog {
    type Super = IModalWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x42f85136_db7e_439c_85f1_e4075d135fc8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileDialog2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileDialog2_Trait: IFileDialog_Trait {
    fn SetCancelButtonLabel(&self, psz_label: PCWSTR) -> crate::core::HRESULT {
        todo!("SetCancelButtonLabel")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetNavigationRoot(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("SetNavigationRoot")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileDialog2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileDialog2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileDialog2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileDialog2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileDialog2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileDialog2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileDialog2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileDialog2 {
    type Super = IFileDialog;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x61744fc7_85b5_4791_a9b0_272276309b13);
}
pub struct IFileDialogControlEvents(pub crate::core::IUnknown);
pub trait IFileDialogControlEvents_Trait: crate::core::IUnknown_Trait {
    fn OnItemSelected(
        &self,
        pfdc: IFileDialogCustomize,
        dw_id_ctl: u32,
        dw_id_item: u32,
    ) -> crate::core::HRESULT {
        todo!("OnItemSelected")
    }
    fn OnButtonClicked(&self, pfdc: IFileDialogCustomize, dw_id_ctl: u32) -> crate::core::HRESULT {
        todo!("OnButtonClicked")
    }
    fn OnCheckButtonToggled(
        &self,
        pfdc: IFileDialogCustomize,
        dw_id_ctl: u32,
        b_checked: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("OnCheckButtonToggled")
    }
    fn OnControlActivating(
        &self,
        pfdc: IFileDialogCustomize,
        dw_id_ctl: u32,
    ) -> crate::core::HRESULT {
        todo!("OnControlActivating")
    }
}
impl ::core::clone::Clone for IFileDialogControlEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFileDialogControlEvents {}
impl ::core::cmp::PartialEq for IFileDialogControlEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileDialogControlEvents {}
impl ::core::fmt::Debug for IFileDialogControlEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileDialogControlEvents")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IFileDialogControlEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFileDialogControlEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x36116642_d713_4b97_9b83_7484a9d00433);
}
pub struct IFileDialogCustomize(pub crate::core::IUnknown);
pub trait IFileDialogCustomize_Trait: crate::core::IUnknown_Trait {
    fn EnableOpenDropDown(&self, dw_id_ctl: u32) -> crate::core::HRESULT {
        todo!("EnableOpenDropDown")
    }
    fn AddMenu(&self, dw_id_ctl: u32, psz_label: PCWSTR) -> crate::core::HRESULT {
        todo!("AddMenu")
    }
    fn AddPushButton(&self, dw_id_ctl: u32, psz_label: PCWSTR) -> crate::core::HRESULT {
        todo!("AddPushButton")
    }
    fn AddComboBox(&self, dw_id_ctl: u32) -> crate::core::HRESULT {
        todo!("AddComboBox")
    }
    fn AddRadioButtonList(&self, dw_id_ctl: u32) -> crate::core::HRESULT {
        todo!("AddRadioButtonList")
    }
    fn AddCheckButton(
        &self,
        dw_id_ctl: u32,
        psz_label: PCWSTR,
        b_checked: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("AddCheckButton")
    }
    fn AddEditBox(&self, dw_id_ctl: u32, psz_text: PCWSTR) -> crate::core::HRESULT {
        todo!("AddEditBox")
    }
    fn AddSeparator(&self, dw_id_ctl: u32) -> crate::core::HRESULT {
        todo!("AddSeparator")
    }
    fn AddText(&self, dw_id_ctl: u32, psz_text: PCWSTR) -> crate::core::HRESULT {
        todo!("AddText")
    }
    fn SetControlLabel(&self, dw_id_ctl: u32, psz_label: PCWSTR) -> crate::core::HRESULT {
        todo!("SetControlLabel")
    }
    fn GetControlState(
        &self,
        dw_id_ctl: u32,
        pdw_state: MutPtr<CDCONTROLSTATEF>,
    ) -> crate::core::HRESULT {
        todo!("GetControlState")
    }
    fn SetControlState(&self, dw_id_ctl: u32, dw_state: CDCONTROLSTATEF) -> crate::core::HRESULT {
        todo!("SetControlState")
    }
    fn GetEditBoxText(
        &self,
        dw_id_ctl: u32,
        ppsz_text: MutPtr<ConstPtr<u16>>,
    ) -> crate::core::HRESULT {
        todo!("GetEditBoxText")
    }
    fn SetEditBoxText(&self, dw_id_ctl: u32, psz_text: PCWSTR) -> crate::core::HRESULT {
        todo!("SetEditBoxText")
    }
    fn GetCheckButtonState(
        &self,
        dw_id_ctl: u32,
        pb_checked: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetCheckButtonState")
    }
    fn SetCheckButtonState(
        &self,
        dw_id_ctl: u32,
        b_checked: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetCheckButtonState")
    }
    fn AddControlItem(
        &self,
        dw_id_ctl: u32,
        dw_id_item: u32,
        psz_label: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("AddControlItem")
    }
    fn RemoveControlItem(&self, dw_id_ctl: u32, dw_id_item: u32) -> crate::core::HRESULT {
        todo!("RemoveControlItem")
    }
    fn RemoveAllControlItems(&self, dw_id_ctl: u32) -> crate::core::HRESULT {
        todo!("RemoveAllControlItems")
    }
    fn GetControlItemState(
        &self,
        dw_id_ctl: u32,
        dw_id_item: u32,
        pdw_state: MutPtr<CDCONTROLSTATEF>,
    ) -> crate::core::HRESULT {
        todo!("GetControlItemState")
    }
    fn SetControlItemState(
        &self,
        dw_id_ctl: u32,
        dw_id_item: u32,
        dw_state: CDCONTROLSTATEF,
    ) -> crate::core::HRESULT {
        todo!("SetControlItemState")
    }
    fn GetSelectedControlItem(
        &self,
        dw_id_ctl: u32,
        pdw_id_item: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetSelectedControlItem")
    }
    fn SetSelectedControlItem(&self, dw_id_ctl: u32, dw_id_item: u32) -> crate::core::HRESULT {
        todo!("SetSelectedControlItem")
    }
    fn StartVisualGroup(&self, dw_id_ctl: u32, psz_label: PCWSTR) -> crate::core::HRESULT {
        todo!("StartVisualGroup")
    }
    fn EndVisualGroup(&self) -> crate::core::HRESULT {
        todo!("EndVisualGroup")
    }
    fn MakeProminent(&self, dw_id_ctl: u32) -> crate::core::HRESULT {
        todo!("MakeProminent")
    }
    fn SetControlItemText(
        &self,
        dw_id_ctl: u32,
        dw_id_item: u32,
        psz_label: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetControlItemText")
    }
}
impl ::core::clone::Clone for IFileDialogCustomize {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFileDialogCustomize {}
impl ::core::cmp::PartialEq for IFileDialogCustomize {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileDialogCustomize {}
impl ::core::fmt::Debug for IFileDialogCustomize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileDialogCustomize")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IFileDialogCustomize {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFileDialogCustomize {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe6fdd21a_163f_4975_9c8c_a69f1ba37034);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileDialogEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileDialogEvents_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnFileOk(&self, pfd: IFileDialog) -> crate::core::HRESULT {
        todo!("OnFileOk")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnFolderChanging(&self, pfd: IFileDialog, psi_folder: IShellItem) -> crate::core::HRESULT {
        todo!("OnFolderChanging")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnFolderChange(&self, pfd: IFileDialog) -> crate::core::HRESULT {
        todo!("OnFolderChange")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnSelectionChange(&self, pfd: IFileDialog) -> crate::core::HRESULT {
        todo!("OnSelectionChange")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnShareViolation(
        &self,
        pfd: IFileDialog,
        psi: IShellItem,
        p_response: MutPtr<FDE_SHAREVIOLATION_RESPONSE>,
    ) -> crate::core::HRESULT {
        todo!("OnShareViolation")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnTypeChange(&self, pfd: IFileDialog) -> crate::core::HRESULT {
        todo!("OnTypeChange")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnOverwrite(
        &self,
        pfd: IFileDialog,
        psi: IShellItem,
        p_response: MutPtr<FDE_OVERWRITE_RESPONSE>,
    ) -> crate::core::HRESULT {
        todo!("OnOverwrite")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileDialogEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileDialogEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileDialogEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileDialogEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileDialogEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileDialogEvents").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileDialogEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileDialogEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x973510db_7d7f_452b_8975_74a85828d354);
}
pub struct IFileIsInUse(pub crate::core::IUnknown);
pub trait IFileIsInUse_Trait: crate::core::IUnknown_Trait {
    fn GetAppName(&self, ppsz_name: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetAppName")
    }
    fn GetUsage(&self, pfut: MutPtr<FILE_USAGE_TYPE>) -> crate::core::HRESULT {
        todo!("GetUsage")
    }
    fn GetCapabilities(&self, pdw_cap_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCapabilities")
    }
    fn GetSwitchToHWND(
        &self,
        phwnd: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("GetSwitchToHWND")
    }
    fn CloseFile(&self) -> crate::core::HRESULT {
        todo!("CloseFile")
    }
}
impl ::core::clone::Clone for IFileIsInUse {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFileIsInUse {}
impl ::core::cmp::PartialEq for IFileIsInUse {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileIsInUse {}
impl ::core::fmt::Debug for IFileIsInUse {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileIsInUse").field(&self.0).finish()
    }
}
impl FromIntoMemory for IFileIsInUse {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFileIsInUse {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x64a1cbf0_3a1a_4461_9158_376969693950);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileOpenDialog(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileOpenDialog_Trait: IFileDialog_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetResults(&self, ppenum: MutPtr<IShellItemArray>) -> crate::core::HRESULT {
        todo!("GetResults")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSelectedItems(&self, ppsai: MutPtr<IShellItemArray>) -> crate::core::HRESULT {
        todo!("GetSelectedItems")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileOpenDialog {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileOpenDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileOpenDialog {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileOpenDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileOpenDialog {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileOpenDialog").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileOpenDialog {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileOpenDialog {
    type Super = IFileDialog;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd57c7288_d4ad_4768_be02_9d969532d960);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileOperation(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileOperation_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Advise(
        &self,
        pfops: IFileOperationProgressSink,
        pdw_cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn Unadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("Unadvise")
    }
    fn SetOperationFlags(&self, dw_operation_flags: u32) -> crate::core::HRESULT {
        todo!("SetOperationFlags")
    }
    fn SetProgressMessage(&self, psz_message: PCWSTR) -> crate::core::HRESULT {
        todo!("SetProgressMessage")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetProgressDialog(&self, popd: IOperationsProgressDialog) -> crate::core::HRESULT {
        todo!("SetProgressDialog")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetProperties(
        &self,
        pproparray: PropertiesSystem::IPropertyChangeArray,
    ) -> crate::core::HRESULT {
        todo!("SetProperties")
    }
    fn SetOwnerWindow(&self, hwnd_owner: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("SetOwnerWindow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ApplyPropertiesToItem(&self, psi_item: IShellItem) -> crate::core::HRESULT {
        todo!("ApplyPropertiesToItem")
    }
    fn ApplyPropertiesToItems(&self, punk_items: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("ApplyPropertiesToItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RenameItem(
        &self,
        psi_item: IShellItem,
        psz_new_name: PCWSTR,
        pfops_item: IFileOperationProgressSink,
    ) -> crate::core::HRESULT {
        todo!("RenameItem")
    }
    fn RenameItems(
        &self,
        p_unk_items: crate::core::IUnknown,
        psz_new_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("RenameItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn MoveItem(
        &self,
        psi_item: IShellItem,
        psi_destination_folder: IShellItem,
        psz_new_name: PCWSTR,
        pfops_item: IFileOperationProgressSink,
    ) -> crate::core::HRESULT {
        todo!("MoveItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn MoveItems(
        &self,
        punk_items: crate::core::IUnknown,
        psi_destination_folder: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("MoveItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CopyItem(
        &self,
        psi_item: IShellItem,
        psi_destination_folder: IShellItem,
        psz_copy_name: PCWSTR,
        pfops_item: IFileOperationProgressSink,
    ) -> crate::core::HRESULT {
        todo!("CopyItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CopyItems(
        &self,
        punk_items: crate::core::IUnknown,
        psi_destination_folder: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("CopyItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn DeleteItem(
        &self,
        psi_item: IShellItem,
        pfops_item: IFileOperationProgressSink,
    ) -> crate::core::HRESULT {
        todo!("DeleteItem")
    }
    fn DeleteItems(&self, punk_items: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("DeleteItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn NewItem(
        &self,
        psi_destination_folder: IShellItem,
        dw_file_attributes: u32,
        psz_name: PCWSTR,
        psz_template_name: PCWSTR,
        pfops_item: IFileOperationProgressSink,
    ) -> crate::core::HRESULT {
        todo!("NewItem")
    }
    fn PerformOperations(&self) -> crate::core::HRESULT {
        todo!("PerformOperations")
    }
    fn GetAnyOperationsAborted(
        &self,
        pf_any_operations_aborted: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetAnyOperationsAborted")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileOperation {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileOperation {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileOperation {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileOperation {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileOperation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileOperation").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileOperation {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileOperation {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x947aab5f_0a5c_4c13_b4d6_4bf7836fc9f8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileOperation2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileOperation2_Trait: IFileOperation_Trait {
    fn SetOperationFlags2(&self, operation_flags_2: FILE_OPERATION_FLAGS2) -> crate::core::HRESULT {
        todo!("SetOperationFlags2")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileOperation2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileOperation2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileOperation2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileOperation2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileOperation2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileOperation2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileOperation2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileOperation2 {
    type Super = IFileOperation;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xcd8f23c1_8f61_4916_909d_55bdd0918753);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileOperationProgressSink(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileOperationProgressSink_Trait: crate::core::IUnknown_Trait {
    fn StartOperations(&self) -> crate::core::HRESULT {
        todo!("StartOperations")
    }
    fn FinishOperations(&self, hr_result: crate::core::HRESULT) -> crate::core::HRESULT {
        todo!("FinishOperations")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PreRenameItem(
        &self,
        dw_flags: u32,
        psi_item: IShellItem,
        psz_new_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("PreRenameItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PostRenameItem(
        &self,
        dw_flags: u32,
        psi_item: IShellItem,
        psz_new_name: PCWSTR,
        hr_rename: crate::core::HRESULT,
        psi_newly_created: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("PostRenameItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PreMoveItem(
        &self,
        dw_flags: u32,
        psi_item: IShellItem,
        psi_destination_folder: IShellItem,
        psz_new_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("PreMoveItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PostMoveItem(
        &self,
        dw_flags: u32,
        psi_item: IShellItem,
        psi_destination_folder: IShellItem,
        psz_new_name: PCWSTR,
        hr_move: crate::core::HRESULT,
        psi_newly_created: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("PostMoveItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PreCopyItem(
        &self,
        dw_flags: u32,
        psi_item: IShellItem,
        psi_destination_folder: IShellItem,
        psz_new_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("PreCopyItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PostCopyItem(
        &self,
        dw_flags: u32,
        psi_item: IShellItem,
        psi_destination_folder: IShellItem,
        psz_new_name: PCWSTR,
        hr_copy: crate::core::HRESULT,
        psi_newly_created: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("PostCopyItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PreDeleteItem(&self, dw_flags: u32, psi_item: IShellItem) -> crate::core::HRESULT {
        todo!("PreDeleteItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PostDeleteItem(
        &self,
        dw_flags: u32,
        psi_item: IShellItem,
        hr_delete: crate::core::HRESULT,
        psi_newly_created: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("PostDeleteItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PreNewItem(
        &self,
        dw_flags: u32,
        psi_destination_folder: IShellItem,
        psz_new_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("PreNewItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PostNewItem(
        &self,
        dw_flags: u32,
        psi_destination_folder: IShellItem,
        psz_new_name: PCWSTR,
        psz_template_name: PCWSTR,
        dw_file_attributes: u32,
        hr_new: crate::core::HRESULT,
        psi_new_item: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("PostNewItem")
    }
    fn UpdateProgress(&self, i_work_total: u32, i_work_so_far: u32) -> crate::core::HRESULT {
        todo!("UpdateProgress")
    }
    fn ResetTimer(&self) -> crate::core::HRESULT {
        todo!("ResetTimer")
    }
    fn PauseTimer(&self) -> crate::core::HRESULT {
        todo!("PauseTimer")
    }
    fn ResumeTimer(&self) -> crate::core::HRESULT {
        todo!("ResumeTimer")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileOperationProgressSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileOperationProgressSink {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileOperationProgressSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileOperationProgressSink {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileOperationProgressSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileOperationProgressSink")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileOperationProgressSink {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileOperationProgressSink {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x04b0f1a7_9490_44bc_96e1_4296a31252e2);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileSaveDialog(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileSaveDialog_Trait: IFileDialog_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetSaveAsItem(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("SetSaveAsItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetProperties(&self, p_store: PropertiesSystem::IPropertyStore) -> crate::core::HRESULT {
        todo!("SetProperties")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetCollectedProperties(
        &self,
        p_list: PropertiesSystem::IPropertyDescriptionList,
        f_append_default: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetCollectedProperties")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetProperties(
        &self,
        pp_store: MutPtr<PropertiesSystem::IPropertyStore>,
    ) -> crate::core::HRESULT {
        todo!("GetProperties")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ApplyProperties(
        &self,
        psi: IShellItem,
        p_store: PropertiesSystem::IPropertyStore,
        hwnd: super::super::Foundation::HWND,
        p_sink: IFileOperationProgressSink,
    ) -> crate::core::HRESULT {
        todo!("ApplyProperties")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileSaveDialog {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileSaveDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileSaveDialog {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileSaveDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileSaveDialog {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSaveDialog").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileSaveDialog {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileSaveDialog {
    type Super = IFileDialog;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x84bccd23_5fde_4cdb_aea4_af64b83d78ab);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFileSearchBand(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFileSearchBand_Trait: super::super::System::Com::IDispatch_Trait {
    fn SetFocus(&self) -> crate::core::HRESULT {
        todo!("SetFocus")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetSearchParameters(
        &self,
        pbstr_search_id: ConstPtr<super::super::Foundation::BSTR>,
        b_nav_to_results: i16,
        pvar_scope: ConstPtr<super::super::System::Com::VARIANT>,
        pvar_query_file: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("SetSearchParameters")
    }
    fn get_SearchID(
        &self,
        pbstr_search_id: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_SearchID")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Scope(
        &self,
        pvar_scope: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("get_Scope")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_QueryFile(
        &self,
        pvar_file: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("get_QueryFile")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFileSearchBand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFileSearchBand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFileSearchBand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFileSearchBand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFileSearchBand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSearchBand").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFileSearchBand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFileSearchBand {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2d91eea1_9932_11d2_be86_00a0c9a83da1);
}
pub struct IFileSyncMergeHandler(pub crate::core::IUnknown);
pub trait IFileSyncMergeHandler_Trait: crate::core::IUnknown_Trait {
    fn Merge(
        &self,
        local_file_path: PCWSTR,
        server_file_path: PCWSTR,
        update_status: MutPtr<MERGE_UPDATE_STATUS>,
    ) -> crate::core::HRESULT {
        todo!("Merge")
    }
    fn ShowResolveConflictUIAsync(
        &self,
        local_file_path: PCWSTR,
        monitor_to_display_on: super::super::Graphics::Gdi::HMONITOR,
    ) -> crate::core::HRESULT {
        todo!("ShowResolveConflictUIAsync")
    }
}
impl ::core::clone::Clone for IFileSyncMergeHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFileSyncMergeHandler {}
impl ::core::cmp::PartialEq for IFileSyncMergeHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileSyncMergeHandler {}
impl ::core::fmt::Debug for IFileSyncMergeHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSyncMergeHandler")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IFileSyncMergeHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFileSyncMergeHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd97b5aac_c792_433c_975d_35c4eadc7a9d);
}
pub struct IFileSystemBindData(pub crate::core::IUnknown);
pub trait IFileSystemBindData_Trait: crate::core::IUnknown_Trait {
    fn SetFindData(
        &self,
        pfd: ConstPtr<super::super::Storage::FileSystem::WIN32_FIND_DATAW>,
    ) -> crate::core::HRESULT {
        todo!("SetFindData")
    }
    fn GetFindData(
        &self,
        pfd: MutPtr<super::super::Storage::FileSystem::WIN32_FIND_DATAW>,
    ) -> crate::core::HRESULT {
        todo!("GetFindData")
    }
}
impl ::core::clone::Clone for IFileSystemBindData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFileSystemBindData {}
impl ::core::cmp::PartialEq for IFileSystemBindData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileSystemBindData {}
impl ::core::fmt::Debug for IFileSystemBindData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSystemBindData").field(&self.0).finish()
    }
}
impl FromIntoMemory for IFileSystemBindData {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFileSystemBindData {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x01e18d10_4d8b_11d2_855d_006008059367);
}
pub struct IFileSystemBindData2(pub crate::core::IUnknown);
pub trait IFileSystemBindData2_Trait: IFileSystemBindData_Trait {
    fn SetFileID(&self, li_file_id: i64) -> crate::core::HRESULT {
        todo!("SetFileID")
    }
    fn GetFileID(&self, pli_file_id: MutPtr<i64>) -> crate::core::HRESULT {
        todo!("GetFileID")
    }
    fn SetJunctionCLSID(&self, clsid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("SetJunctionCLSID")
    }
    fn GetJunctionCLSID(&self, pclsid: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetJunctionCLSID")
    }
}
impl ::core::clone::Clone for IFileSystemBindData2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFileSystemBindData2 {}
impl ::core::cmp::PartialEq for IFileSystemBindData2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileSystemBindData2 {}
impl ::core::fmt::Debug for IFileSystemBindData2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileSystemBindData2")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IFileSystemBindData2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFileSystemBindData2 {
    type Super = IFileSystemBindData;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3acf075f_71db_4afa_81f0_3fc4fdf2a5b8);
}
pub struct IFolderBandPriv(pub crate::core::IUnknown);
pub trait IFolderBandPriv_Trait: crate::core::IUnknown_Trait {
    fn SetCascade(&self, f_cascade: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetCascade")
    }
    fn SetAccelerators(
        &self,
        f_accelerators: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetAccelerators")
    }
    fn SetNoIcons(&self, f_no_icons: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetNoIcons")
    }
    fn SetNoText(&self, f_no_text: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetNoText")
    }
}
impl ::core::clone::Clone for IFolderBandPriv {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFolderBandPriv {}
impl ::core::cmp::PartialEq for IFolderBandPriv {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFolderBandPriv {}
impl ::core::fmt::Debug for IFolderBandPriv {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderBandPriv").field(&self.0).finish()
    }
}
impl FromIntoMemory for IFolderBandPriv {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFolderBandPriv {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x47c01f95_e185_412c_b5c5_4f27df965aea);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFolderFilter(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFolderFilter_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ShouldShow(
        &self,
        psf: IShellFolder,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
        pidl_item: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("ShouldShow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetEnumFlags(
        &self,
        psf: IShellFolder,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
        phwnd: MutPtr<super::super::Foundation::HWND>,
        pgrf_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetEnumFlags")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFolderFilter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFolderFilter {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFolderFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFolderFilter {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFolderFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderFilter").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFolderFilter {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFolderFilter {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9cc22886_dc8e_11d2_b1d0_00c04f8eeb3e);
}
pub struct IFolderFilterSite(pub crate::core::IUnknown);
pub trait IFolderFilterSite_Trait: crate::core::IUnknown_Trait {
    fn SetFilter(&self, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("SetFilter")
    }
}
impl ::core::clone::Clone for IFolderFilterSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFolderFilterSite {}
impl ::core::cmp::PartialEq for IFolderFilterSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFolderFilterSite {}
impl ::core::fmt::Debug for IFolderFilterSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderFilterSite").field(&self.0).finish()
    }
}
impl FromIntoMemory for IFolderFilterSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFolderFilterSite {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc0a651f5_b48b_11d2_b5ed_006097c686f6);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFolderView(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFolderView_Trait: crate::core::IUnknown_Trait {
    fn GetCurrentViewMode(&self, p_view_mode: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCurrentViewMode")
    }
    fn SetCurrentViewMode(&self, view_mode: u32) -> crate::core::HRESULT {
        todo!("SetCurrentViewMode")
    }
    fn GetFolder(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Item(
        &self,
        i_item_index: i32,
        ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("Item")
    }
    fn ItemCount(&self, u_flags: u32, pc_items: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("ItemCount")
    }
    fn Items(
        &self,
        u_flags: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("Items")
    }
    fn GetSelectionMarkedItem(&self, pi_item: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetSelectionMarkedItem")
    }
    fn GetFocusedItem(&self, pi_item: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetFocusedItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemPosition(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        ppt: MutPtr<super::super::Foundation::POINT>,
    ) -> crate::core::HRESULT {
        todo!("GetItemPosition")
    }
    fn GetSpacing(&self, ppt: MutPtr<super::super::Foundation::POINT>) -> crate::core::HRESULT {
        todo!("GetSpacing")
    }
    fn GetDefaultSpacing(
        &self,
        ppt: MutPtr<super::super::Foundation::POINT>,
    ) -> crate::core::HRESULT {
        todo!("GetDefaultSpacing")
    }
    fn GetAutoArrange(&self) -> crate::core::HRESULT {
        todo!("GetAutoArrange")
    }
    fn SelectItem(&self, i_item: i32, dw_flags: u32) -> crate::core::HRESULT {
        todo!("SelectItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SelectAndPositionItems(
        &self,
        cidl: u32,
        apidl: ConstPtr<ConstPtr<Common::ITEMIDLIST>>,
        apt: ConstPtr<super::super::Foundation::POINT>,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SelectAndPositionItems")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFolderView {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFolderView {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFolderView {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFolderView {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFolderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderView").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFolderView {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFolderView {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xcde725b0_ccc9_4519_917e_325d72fab4ce);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFolderView2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFolderView2_Trait: IFolderView_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetGroupBy(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        f_ascending: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetGroupBy")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetGroupBy(
        &self,
        pkey: MutPtr<PropertiesSystem::PROPERTYKEY>,
        pf_ascending: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetGroupBy")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetViewProperty(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        propkey: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        propvar: ConstPtr<super::super::System::Com::StructuredStorage::PROPVARIANT>,
    ) -> crate::core::HRESULT {
        todo!("SetViewProperty")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetViewProperty(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        propkey: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        ppropvar: MutPtr<super::super::System::Com::StructuredStorage::PROPVARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetViewProperty")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetTileViewProperties(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        psz_prop_list: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetTileViewProperties")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetExtendedTileViewProperties(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        psz_prop_list: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetExtendedTileViewProperties")
    }
    fn SetText(&self, i_type: FVTEXTTYPE, pwsz_text: PCWSTR) -> crate::core::HRESULT {
        todo!("SetText")
    }
    fn SetCurrentFolderFlags(&self, dw_mask: u32, dw_flags: u32) -> crate::core::HRESULT {
        todo!("SetCurrentFolderFlags")
    }
    fn GetCurrentFolderFlags(&self, pdw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCurrentFolderFlags")
    }
    fn GetSortColumnCount(&self, pc_columns: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetSortColumnCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetSortColumns(
        &self,
        rg_sort_columns: ConstPtr<SORTCOLUMN>,
        c_columns: i32,
    ) -> crate::core::HRESULT {
        todo!("SetSortColumns")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSortColumns(
        &self,
        rg_sort_columns: MutPtr<SORTCOLUMN>,
        c_columns: i32,
    ) -> crate::core::HRESULT {
        todo!("GetSortColumns")
    }
    fn GetItem(
        &self,
        i_item: i32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetItem")
    }
    fn GetVisibleItem(
        &self,
        i_start: i32,
        f_previous: super::super::Foundation::BOOL,
        pi_item: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetVisibleItem")
    }
    fn GetSelectedItem(&self, i_start: i32, pi_item: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetSelectedItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSelection(
        &self,
        f_none_implies_folder: super::super::Foundation::BOOL,
        ppsia: MutPtr<IShellItemArray>,
    ) -> crate::core::HRESULT {
        todo!("GetSelection")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSelectionState(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pdw_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetSelectionState")
    }
    fn InvokeVerbOnSelection(&self, psz_verb: PCSTR) -> crate::core::HRESULT {
        todo!("InvokeVerbOnSelection")
    }
    fn SetViewModeAndIconSize(
        &self,
        u_view_mode: FOLDERVIEWMODE,
        i_image_size: i32,
    ) -> crate::core::HRESULT {
        todo!("SetViewModeAndIconSize")
    }
    fn GetViewModeAndIconSize(
        &self,
        pu_view_mode: MutPtr<FOLDERVIEWMODE>,
        pi_image_size: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetViewModeAndIconSize")
    }
    fn SetGroupSubsetCount(&self, c_visible_rows: u32) -> crate::core::HRESULT {
        todo!("SetGroupSubsetCount")
    }
    fn GetGroupSubsetCount(&self, pc_visible_rows: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetGroupSubsetCount")
    }
    fn SetRedraw(&self, f_redraw_on: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetRedraw")
    }
    fn IsMoveInSameFolder(&self) -> crate::core::HRESULT {
        todo!("IsMoveInSameFolder")
    }
    fn DoRename(&self) -> crate::core::HRESULT {
        todo!("DoRename")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFolderView2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFolderView2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFolderView2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFolderView2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFolderView2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderView2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFolderView2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFolderView2 {
    type Super = IFolderView;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1af3a467_214f_4298_908e_06b03e0b39f9);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFolderViewHost(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFolderViewHost_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(
        &self,
        hwnd_parent: super::super::Foundation::HWND,
        pdo: super::super::System::Com::IDataObject,
        prc: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFolderViewHost {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFolderViewHost {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFolderViewHost {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFolderViewHost {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFolderViewHost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderViewHost").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFolderViewHost {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFolderViewHost {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1ea58f02_d55a_411d_b09e_9e65ac21605b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFolderViewOC(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFolderViewOC_Trait: super::super::System::Com::IDispatch_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetFolderView(&self, pdisp: super::super::System::Com::IDispatch) -> crate::core::HRESULT {
        todo!("SetFolderView")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFolderViewOC {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFolderViewOC {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFolderViewOC {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFolderViewOC {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFolderViewOC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderViewOC").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFolderViewOC {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFolderViewOC {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9ba05970_f6a8_11cf_a442_00a0c90a8f39);
}
pub struct IFolderViewOptions(pub crate::core::IUnknown);
pub trait IFolderViewOptions_Trait: crate::core::IUnknown_Trait {
    fn SetFolderViewOptions(
        &self,
        fvo_mask: FOLDERVIEWOPTIONS,
        fvo_flags: FOLDERVIEWOPTIONS,
    ) -> crate::core::HRESULT {
        todo!("SetFolderViewOptions")
    }
    fn GetFolderViewOptions(&self, pfvo_flags: MutPtr<FOLDERVIEWOPTIONS>) -> crate::core::HRESULT {
        todo!("GetFolderViewOptions")
    }
}
impl ::core::clone::Clone for IFolderViewOptions {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFolderViewOptions {}
impl ::core::cmp::PartialEq for IFolderViewOptions {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFolderViewOptions {}
impl ::core::fmt::Debug for IFolderViewOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderViewOptions").field(&self.0).finish()
    }
}
impl FromIntoMemory for IFolderViewOptions {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFolderViewOptions {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3cc974d2_b302_4d36_ad3e_06d93f695d3f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IFolderViewSettings(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IFolderViewSettings_Trait: crate::core::IUnknown_Trait {
    fn GetColumnPropertyList(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetColumnPropertyList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetGroupByProperty(
        &self,
        pkey: MutPtr<PropertiesSystem::PROPERTYKEY>,
        pf_group_ascending: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetGroupByProperty")
    }
    fn GetViewMode(&self, plvm: MutPtr<FOLDERLOGICALVIEWMODE>) -> crate::core::HRESULT {
        todo!("GetViewMode")
    }
    fn GetIconSize(&self, pu_icon_size: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetIconSize")
    }
    fn GetFolderFlags(
        &self,
        pfolder_mask: MutPtr<FOLDERFLAGS>,
        pfolder_flags: MutPtr<FOLDERFLAGS>,
    ) -> crate::core::HRESULT {
        todo!("GetFolderFlags")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSortColumns(
        &self,
        rg_sort_columns: MutPtr<SORTCOLUMN>,
        c_columns_in: u32,
        pc_columns_out: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetSortColumns")
    }
    fn GetGroupSubsetCount(&self, pc_visible_rows: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetGroupSubsetCount")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IFolderViewSettings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IFolderViewSettings {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IFolderViewSettings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IFolderViewSettings {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IFolderViewSettings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFolderViewSettings").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IFolderViewSettings {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IFolderViewSettings {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xae8c987d_8797_4ed3_be72_2a47dd938db0);
}
pub struct IFrameworkInputPane(pub crate::core::IUnknown);
pub trait IFrameworkInputPane_Trait: crate::core::IUnknown_Trait {
    fn Advise(
        &self,
        p_window: crate::core::IUnknown,
        p_handler: IFrameworkInputPaneHandler,
        pdw_cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn AdviseWithHWND(
        &self,
        hwnd: super::super::Foundation::HWND,
        p_handler: IFrameworkInputPaneHandler,
        pdw_cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("AdviseWithHWND")
    }
    fn Unadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("Unadvise")
    }
    fn Location(
        &self,
        prc_input_pane_screen_location: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("Location")
    }
}
impl ::core::clone::Clone for IFrameworkInputPane {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFrameworkInputPane {}
impl ::core::cmp::PartialEq for IFrameworkInputPane {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFrameworkInputPane {}
impl ::core::fmt::Debug for IFrameworkInputPane {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFrameworkInputPane").field(&self.0).finish()
    }
}
impl FromIntoMemory for IFrameworkInputPane {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFrameworkInputPane {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x5752238b_24f0_495a_82f1_2fd593056796);
}
pub struct IFrameworkInputPaneHandler(pub crate::core::IUnknown);
pub trait IFrameworkInputPaneHandler_Trait: crate::core::IUnknown_Trait {
    fn Showing(
        &self,
        prc_input_pane_screen_location: ConstPtr<super::super::Foundation::RECT>,
        f_ensure_focused_element_in_view: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("Showing")
    }
    fn Hiding(
        &self,
        f_ensure_focused_element_in_view: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("Hiding")
    }
}
impl ::core::clone::Clone for IFrameworkInputPaneHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IFrameworkInputPaneHandler {}
impl ::core::cmp::PartialEq for IFrameworkInputPaneHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFrameworkInputPaneHandler {}
impl ::core::fmt::Debug for IFrameworkInputPaneHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFrameworkInputPaneHandler")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IFrameworkInputPaneHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IFrameworkInputPaneHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x226c537b_1e76_4d9e_a760_33db29922f18);
}
pub struct IGetServiceIds(pub crate::core::IUnknown);
pub trait IGetServiceIds_Trait: crate::core::IUnknown_Trait {
    fn GetServiceIds(
        &self,
        service_id_count: MutPtr<u32>,
        service_ids: MutPtr<ConstPtr<crate::core::GUID>>,
    ) -> crate::core::HRESULT {
        todo!("GetServiceIds")
    }
}
impl ::core::clone::Clone for IGetServiceIds {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IGetServiceIds {}
impl ::core::cmp::PartialEq for IGetServiceIds {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IGetServiceIds {}
impl ::core::fmt::Debug for IGetServiceIds {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IGetServiceIds").field(&self.0).finish()
    }
}
impl FromIntoMemory for IGetServiceIds {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IGetServiceIds {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4a073526_6103_4e21_b7bc_f519d1524e5d);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHWEventHandler(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHWEventHandler_Trait: crate::core::IUnknown_Trait {
    fn Initialize(&self, psz_params: PCWSTR) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn HandleEvent(
        &self,
        psz_device_id: PCWSTR,
        psz_alt_device_id: PCWSTR,
        psz_event_type: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("HandleEvent")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn HandleEventWithContent(
        &self,
        psz_device_id: PCWSTR,
        psz_alt_device_id: PCWSTR,
        psz_event_type: PCWSTR,
        psz_content_type_handler: PCWSTR,
        pdataobject: super::super::System::Com::IDataObject,
    ) -> crate::core::HRESULT {
        todo!("HandleEventWithContent")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHWEventHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHWEventHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHWEventHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHWEventHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHWEventHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHWEventHandler").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHWEventHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHWEventHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc1fb73d0_ec3a_4ba2_b512_8cdb9187b6d1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHWEventHandler2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHWEventHandler2_Trait: IHWEventHandler_Trait {
    fn HandleEventWithHWND(
        &self,
        psz_device_id: PCWSTR,
        psz_alt_device_id: PCWSTR,
        psz_event_type: PCWSTR,
        hwnd_owner: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("HandleEventWithHWND")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHWEventHandler2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHWEventHandler2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHWEventHandler2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHWEventHandler2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHWEventHandler2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHWEventHandler2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHWEventHandler2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHWEventHandler2 {
    type Super = IHWEventHandler;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xcfcc809f_295d_42e8_9ffc_424b33c487e6);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHandlerActivationHost(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHandlerActivationHost_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BeforeCoCreateInstance(
        &self,
        clsid_handler: ConstPtr<crate::core::GUID>,
        items_being_activated: IShellItemArray,
        handler_info: IHandlerInfo,
    ) -> crate::core::HRESULT {
        todo!("BeforeCoCreateInstance")
    }
    fn BeforeCreateProcess(
        &self,
        application_path: PCWSTR,
        command_line: PCWSTR,
        handler_info: IHandlerInfo,
    ) -> crate::core::HRESULT {
        todo!("BeforeCreateProcess")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHandlerActivationHost {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHandlerActivationHost {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHandlerActivationHost {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHandlerActivationHost {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHandlerActivationHost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHandlerActivationHost")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHandlerActivationHost {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHandlerActivationHost {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x35094a87_8bb1_4237_96c6_c417eebdb078);
}
pub struct IHandlerInfo(pub crate::core::IUnknown);
pub trait IHandlerInfo_Trait: crate::core::IUnknown_Trait {
    fn GetApplicationDisplayName(&self, value: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetApplicationDisplayName")
    }
    fn GetApplicationPublisher(&self, value: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetApplicationPublisher")
    }
    fn GetApplicationIconReference(&self, value: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetApplicationIconReference")
    }
}
impl ::core::clone::Clone for IHandlerInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IHandlerInfo {}
impl ::core::cmp::PartialEq for IHandlerInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IHandlerInfo {}
impl ::core::fmt::Debug for IHandlerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHandlerInfo").field(&self.0).finish()
    }
}
impl FromIntoMemory for IHandlerInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IHandlerInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x997706ef_f880_453b_8118_39e1a2d2655a);
}
pub struct IHandlerInfo2(pub crate::core::IUnknown);
pub trait IHandlerInfo2_Trait: IHandlerInfo_Trait {
    fn GetApplicationId(&self, value: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetApplicationId")
    }
}
impl ::core::clone::Clone for IHandlerInfo2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IHandlerInfo2 {}
impl ::core::cmp::PartialEq for IHandlerInfo2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IHandlerInfo2 {}
impl ::core::fmt::Debug for IHandlerInfo2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHandlerInfo2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IHandlerInfo2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IHandlerInfo2 {
    type Super = IHandlerInfo;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x31cca04c_04d3_4ea9_90de_97b15e87a532);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHlink(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHlink_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetHlinkSite(&self, pihl_site: IHlinkSite, dw_site_data: u32) -> crate::core::HRESULT {
        todo!("SetHlinkSite")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetHlinkSite(
        &self,
        ppihl_site: MutPtr<IHlinkSite>,
        pdw_site_data: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetHlinkSite")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetMonikerReference(
        &self,
        grf_hlsetf: u32,
        pimk_target: super::super::System::Com::IMoniker,
        pwz_location: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetMonikerReference")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetMonikerReference(
        &self,
        dw_which_ref: u32,
        ppimk_target: MutPtr<super::super::System::Com::IMoniker>,
        ppwz_location: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetMonikerReference")
    }
    fn SetStringReference(
        &self,
        grf_hlsetf: u32,
        pwz_target: PCWSTR,
        pwz_location: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetStringReference")
    }
    fn GetStringReference(
        &self,
        dw_which_ref: u32,
        ppwz_target: MutPtr<PWSTR>,
        ppwz_location: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetStringReference")
    }
    fn SetFriendlyName(&self, pwz_friendly_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetFriendlyName")
    }
    fn GetFriendlyName(
        &self,
        grf_hlfnamef: u32,
        ppwz_friendly_name: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetFriendlyName")
    }
    fn SetTargetFrameName(&self, pwz_target_frame_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetTargetFrameName")
    }
    fn GetTargetFrameName(&self, ppwz_target_frame_name: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetTargetFrameName")
    }
    fn GetMiscStatus(&self, pdw_status: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetMiscStatus")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Navigate(
        &self,
        grf_hlnf: u32,
        pibc: super::super::System::Com::IBindCtx,
        pibsc: super::super::System::Com::IBindStatusCallback,
        pihlbc: IHlinkBrowseContext,
    ) -> crate::core::HRESULT {
        todo!("Navigate")
    }
    fn SetAdditionalParams(&self, pwz_additional_params: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAdditionalParams")
    }
    fn GetAdditionalParams(&self, ppwz_additional_params: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetAdditionalParams")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHlink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHlink {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHlink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHlink {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHlink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHlink").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHlink {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHlink {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79eac9c3_baf9_11ce_8c82_00aa004ba90b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHlinkBrowseContext(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHlinkBrowseContext_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Register(
        &self,
        reserved: u32,
        piunk: crate::core::IUnknown,
        pimk: super::super::System::Com::IMoniker,
        pdw_register: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Register")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetObject(
        &self,
        pimk: super::super::System::Com::IMoniker,
        f_bind_if_root_registered: super::super::Foundation::BOOL,
        ppiunk: MutPtr<crate::core::IUnknown>,
    ) -> crate::core::HRESULT {
        todo!("GetObject")
    }
    fn Revoke(&self, dw_register: u32) -> crate::core::HRESULT {
        todo!("Revoke")
    }
    fn SetBrowseWindowInfo(&self, phlbwi: ConstPtr<HLBWINFO>) -> crate::core::HRESULT {
        todo!("SetBrowseWindowInfo")
    }
    fn GetBrowseWindowInfo(&self, phlbwi: MutPtr<HLBWINFO>) -> crate::core::HRESULT {
        todo!("GetBrowseWindowInfo")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetInitialHlink(
        &self,
        pimk_target: super::super::System::Com::IMoniker,
        pwz_location: PCWSTR,
        pwz_friendly_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetInitialHlink")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnNavigateHlink(
        &self,
        grf_hlnf: u32,
        pimk_target: super::super::System::Com::IMoniker,
        pwz_location: PCWSTR,
        pwz_friendly_name: PCWSTR,
        pu_hlid: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("OnNavigateHlink")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn UpdateHlink(
        &self,
        u_hlid: u32,
        pimk_target: super::super::System::Com::IMoniker,
        pwz_location: PCWSTR,
        pwz_friendly_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("UpdateHlink")
    }
    fn EnumNavigationStack(
        &self,
        dw_reserved: u32,
        grf_hlfnamef: u32,
        ppienumhlitem: MutPtr<IEnumHLITEM>,
    ) -> crate::core::HRESULT {
        todo!("EnumNavigationStack")
    }
    fn QueryHlink(&self, grf_hlqf: u32, u_hlid: u32) -> crate::core::HRESULT {
        todo!("QueryHlink")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetHlink(&self, u_hlid: u32, ppihl: MutPtr<IHlink>) -> crate::core::HRESULT {
        todo!("GetHlink")
    }
    fn SetCurrentHlink(&self, u_hlid: u32) -> crate::core::HRESULT {
        todo!("SetCurrentHlink")
    }
    fn Clone(
        &self,
        piunk_outer: crate::core::IUnknown,
        riid: ConstPtr<crate::core::GUID>,
        ppiunk_obj: MutPtr<crate::core::IUnknown>,
    ) -> crate::core::HRESULT {
        todo!("Clone")
    }
    fn Close(&self, reserved: u32) -> crate::core::HRESULT {
        todo!("Close")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHlinkBrowseContext {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHlinkBrowseContext {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHlinkBrowseContext {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHlinkBrowseContext {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHlinkBrowseContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHlinkBrowseContext").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHlinkBrowseContext {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHlinkBrowseContext {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79eac9c7_baf9_11ce_8c82_00aa004ba90b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHlinkFrame(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHlinkFrame_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetBrowseContext(&self, pihlbc: IHlinkBrowseContext) -> crate::core::HRESULT {
        todo!("SetBrowseContext")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetBrowseContext(&self, ppihlbc: MutPtr<IHlinkBrowseContext>) -> crate::core::HRESULT {
        todo!("GetBrowseContext")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Navigate(
        &self,
        grf_hlnf: u32,
        pbc: super::super::System::Com::IBindCtx,
        pibsc: super::super::System::Com::IBindStatusCallback,
        pihl_navigate: IHlink,
    ) -> crate::core::HRESULT {
        todo!("Navigate")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnNavigate(
        &self,
        grf_hlnf: u32,
        pimk_target: super::super::System::Com::IMoniker,
        pwz_location: PCWSTR,
        pwz_friendly_name: PCWSTR,
        dwreserved: u32,
    ) -> crate::core::HRESULT {
        todo!("OnNavigate")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn UpdateHlink(
        &self,
        u_hlid: u32,
        pimk_target: super::super::System::Com::IMoniker,
        pwz_location: PCWSTR,
        pwz_friendly_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("UpdateHlink")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHlinkFrame {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHlinkFrame {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHlinkFrame {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHlinkFrame {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHlinkFrame {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHlinkFrame").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHlinkFrame {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHlinkFrame {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79eac9c5_baf9_11ce_8c82_00aa004ba90b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHlinkSite(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHlinkSite_Trait: crate::core::IUnknown_Trait {
    fn QueryService(
        &self,
        dw_site_data: u32,
        guid_service: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppiunk: MutPtr<crate::core::IUnknown>,
    ) -> crate::core::HRESULT {
        todo!("QueryService")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetMoniker(
        &self,
        dw_site_data: u32,
        dw_assign: u32,
        dw_which: u32,
        ppimk: MutPtr<super::super::System::Com::IMoniker>,
    ) -> crate::core::HRESULT {
        todo!("GetMoniker")
    }
    fn ReadyToNavigate(&self, dw_site_data: u32, dw_reserved: u32) -> crate::core::HRESULT {
        todo!("ReadyToNavigate")
    }
    fn OnNavigationComplete(
        &self,
        dw_site_data: u32,
        dwreserved: u32,
        hr_error: crate::core::HRESULT,
        pwz_error: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("OnNavigationComplete")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHlinkSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHlinkSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHlinkSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHlinkSite {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHlinkSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHlinkSite").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHlinkSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHlinkSite {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79eac9c2_baf9_11ce_8c82_00aa004ba90b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IHlinkTarget(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IHlinkTarget_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetBrowseContext(&self, pihlbc: IHlinkBrowseContext) -> crate::core::HRESULT {
        todo!("SetBrowseContext")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetBrowseContext(&self, ppihlbc: MutPtr<IHlinkBrowseContext>) -> crate::core::HRESULT {
        todo!("GetBrowseContext")
    }
    fn Navigate(&self, grf_hlnf: u32, pwz_jump_location: PCWSTR) -> crate::core::HRESULT {
        todo!("Navigate")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetMoniker(
        &self,
        pwz_location: PCWSTR,
        dw_assign: u32,
        ppimk_location: MutPtr<super::super::System::Com::IMoniker>,
    ) -> crate::core::HRESULT {
        todo!("GetMoniker")
    }
    fn GetFriendlyName(
        &self,
        pwz_location: PCWSTR,
        ppwz_friendly_name: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetFriendlyName")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IHlinkTarget {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IHlinkTarget {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IHlinkTarget {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IHlinkTarget {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IHlinkTarget {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHlinkTarget").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IHlinkTarget {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.Security', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IHlinkTarget {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x79eac9c4_baf9_11ce_8c82_00aa004ba90b);
}
pub struct IHomeGroup(pub crate::core::IUnknown);
pub trait IHomeGroup_Trait: crate::core::IUnknown_Trait {
    fn IsMember(&self, member: MutPtr<super::super::Foundation::BOOL>) -> crate::core::HRESULT {
        todo!("IsMember")
    }
    fn ShowSharingWizard(
        &self,
        owner: super::super::Foundation::HWND,
        sharingchoices: MutPtr<HOMEGROUPSHARINGCHOICES>,
    ) -> crate::core::HRESULT {
        todo!("ShowSharingWizard")
    }
}
impl ::core::clone::Clone for IHomeGroup {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IHomeGroup {}
impl ::core::cmp::PartialEq for IHomeGroup {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IHomeGroup {}
impl ::core::fmt::Debug for IHomeGroup {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IHomeGroup").field(&self.0).finish()
    }
}
impl FromIntoMemory for IHomeGroup {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IHomeGroup {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7a3bd1d9_35a9_4fb3_a467_f48cac35e2d0);
}
pub struct IIOCancelInformation(pub crate::core::IUnknown);
pub trait IIOCancelInformation_Trait: crate::core::IUnknown_Trait {
    fn SetCancelInformation(&self, dw_thread_id: u32, u_msg_cancel: u32) -> crate::core::HRESULT {
        todo!("SetCancelInformation")
    }
    fn GetCancelInformation(
        &self,
        pdw_thread_id: MutPtr<u32>,
        pu_msg_cancel: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetCancelInformation")
    }
}
impl ::core::clone::Clone for IIOCancelInformation {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IIOCancelInformation {}
impl ::core::cmp::PartialEq for IIOCancelInformation {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IIOCancelInformation {}
impl ::core::fmt::Debug for IIOCancelInformation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIOCancelInformation")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IIOCancelInformation {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IIOCancelInformation {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf5b0bf81_8cb5_4b1b_9449_1a159e0c733c);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IIdentityName(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IIdentityName_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IIdentityName {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IIdentityName {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IIdentityName {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IIdentityName {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IIdentityName {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IIdentityName").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IIdentityName {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IIdentityName {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7d903fca_d6f9_4810_8332_946c0177e247);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IImageRecompress(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IImageRecompress_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RecompressImage(
        &self,
        psi: IShellItem,
        cx: i32,
        cy: i32,
        i_quality: i32,
        pstg: super::super::System::Com::StructuredStorage::IStorage,
        ppstrm_out: MutPtr<super::super::System::Com::IStream>,
    ) -> crate::core::HRESULT {
        todo!("RecompressImage")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IImageRecompress {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IImageRecompress {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IImageRecompress {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IImageRecompress {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IImageRecompress {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IImageRecompress").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IImageRecompress {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IImageRecompress {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x505f1513_6b3e_4892_a272_59f8889a4d3e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IInitializeCommand(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IInitializeCommand_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(
        &self,
        psz_command_name: PCWSTR,
        ppb: super::super::System::Com::StructuredStorage::IPropertyBag,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IInitializeCommand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IInitializeCommand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IInitializeCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IInitializeCommand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IInitializeCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInitializeCommand").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IInitializeCommand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IInitializeCommand {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x85075acf_231f_40ea_9610_d26b7b58f638);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IInitializeNetworkFolder(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IInitializeNetworkFolder_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pidl_target: ConstPtr<Common::ITEMIDLIST>,
        u_display_type: u32,
        psz_res_name: PCWSTR,
        psz_provider: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IInitializeNetworkFolder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IInitializeNetworkFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IInitializeNetworkFolder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IInitializeNetworkFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IInitializeNetworkFolder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInitializeNetworkFolder")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IInitializeNetworkFolder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IInitializeNetworkFolder {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6e0f9881_42a8_4f2a_97f8_8af4e026d92d);
}
pub struct IInitializeObject(pub crate::core::IUnknown);
pub trait IInitializeObject_Trait: crate::core::IUnknown_Trait {
    fn Initialize(&self) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
impl ::core::clone::Clone for IInitializeObject {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IInitializeObject {}
impl ::core::cmp::PartialEq for IInitializeObject {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IInitializeObject {}
impl ::core::fmt::Debug for IInitializeObject {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInitializeObject").field(&self.0).finish()
    }
}
impl FromIntoMemory for IInitializeObject {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IInitializeObject {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4622ad16_ff23_11d0_8d34_00a0c90f2719);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IInitializeWithBindCtx(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IInitializeWithBindCtx_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(&self, pbc: super::super::System::Com::IBindCtx) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IInitializeWithBindCtx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IInitializeWithBindCtx {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IInitializeWithBindCtx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IInitializeWithBindCtx {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IInitializeWithBindCtx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInitializeWithBindCtx")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IInitializeWithBindCtx {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IInitializeWithBindCtx {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x71c0d2bc_726d_45cc_a6c0_2e31c1db2159);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IInitializeWithItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IInitializeWithItem_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(&self, psi: IShellItem, grf_mode: u32) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IInitializeWithItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IInitializeWithItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IInitializeWithItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IInitializeWithItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IInitializeWithItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInitializeWithItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IInitializeWithItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IInitializeWithItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7f73be3f_fb79_493c_a6c7_7ee14e245841);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IInitializeWithPropertyStore(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IInitializeWithPropertyStore_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(&self, pps: PropertiesSystem::IPropertyStore) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IInitializeWithPropertyStore {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IInitializeWithPropertyStore {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IInitializeWithPropertyStore {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IInitializeWithPropertyStore {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IInitializeWithPropertyStore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInitializeWithPropertyStore")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IInitializeWithPropertyStore {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IInitializeWithPropertyStore {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc3e12eb5_7d8d_44f8_b6dd_0e77b34d6de4);
}
pub struct IInitializeWithWindow(pub crate::core::IUnknown);
pub trait IInitializeWithWindow_Trait: crate::core::IUnknown_Trait {
    fn Initialize(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
impl ::core::clone::Clone for IInitializeWithWindow {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IInitializeWithWindow {}
impl ::core::cmp::PartialEq for IInitializeWithWindow {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IInitializeWithWindow {}
impl ::core::fmt::Debug for IInitializeWithWindow {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInitializeWithWindow")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IInitializeWithWindow {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IInitializeWithWindow {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3e68d4bd_7135_4d10_8018_9fb6d9f33fa1);
}
pub struct IInputObject(pub crate::core::IUnknown);
pub trait IInputObject_Trait: crate::core::IUnknown_Trait {
    fn UIActivateIO(
        &self,
        f_activate: super::super::Foundation::BOOL,
        p_msg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("UIActivateIO")
    }
    fn HasFocusIO(&self) -> crate::core::HRESULT {
        todo!("HasFocusIO")
    }
    fn TranslateAcceleratorIO(
        &self,
        p_msg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("TranslateAcceleratorIO")
    }
}
impl ::core::clone::Clone for IInputObject {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IInputObject {}
impl ::core::cmp::PartialEq for IInputObject {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IInputObject {}
impl ::core::fmt::Debug for IInputObject {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInputObject").field(&self.0).finish()
    }
}
impl FromIntoMemory for IInputObject {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IInputObject {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x68284faa_6a48_11d0_8c78_00c04fd918b4);
}
pub struct IInputObject2(pub crate::core::IUnknown);
pub trait IInputObject2_Trait: IInputObject_Trait {
    fn TranslateAcceleratorGlobal(
        &self,
        p_msg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("TranslateAcceleratorGlobal")
    }
}
impl ::core::clone::Clone for IInputObject2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IInputObject2 {}
impl ::core::cmp::PartialEq for IInputObject2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IInputObject2 {}
impl ::core::fmt::Debug for IInputObject2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInputObject2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IInputObject2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IInputObject2 {
    type Super = IInputObject;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6915c085_510b_44cd_94af_28dfa56cf92b);
}
pub struct IInputObjectSite(pub crate::core::IUnknown);
pub trait IInputObjectSite_Trait: crate::core::IUnknown_Trait {
    fn OnFocusChangeIS(
        &self,
        punk_obj: crate::core::IUnknown,
        f_set_focus: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("OnFocusChangeIS")
    }
}
impl ::core::clone::Clone for IInputObjectSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IInputObjectSite {}
impl ::core::cmp::PartialEq for IInputObjectSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IInputObjectSite {}
impl ::core::fmt::Debug for IInputObjectSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInputObjectSite").field(&self.0).finish()
    }
}
impl FromIntoMemory for IInputObjectSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IInputObjectSite {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf1db8392_7331_11d0_8c99_00a0c92dbfe8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IInputPaneAnimationCoordinator(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IInputPaneAnimationCoordinator_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddAnimation(
        &self,
        device: crate::core::IUnknown,
        animation: super::super::Graphics::DirectComposition::IDCompositionAnimation,
    ) -> crate::core::HRESULT {
        todo!("AddAnimation")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IInputPaneAnimationCoordinator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IInputPaneAnimationCoordinator {}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IInputPaneAnimationCoordinator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IInputPaneAnimationCoordinator {}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IInputPaneAnimationCoordinator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInputPaneAnimationCoordinator")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IInputPaneAnimationCoordinator {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Graphics.DirectComposition'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IInputPaneAnimationCoordinator {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2af16ba9_2de5_4b75_82d9_01372afbffb4);
}
pub struct IInputPanelConfiguration(pub crate::core::IUnknown);
pub trait IInputPanelConfiguration_Trait: crate::core::IUnknown_Trait {
    fn EnableFocusTracking(&self) -> crate::core::HRESULT {
        todo!("EnableFocusTracking")
    }
}
impl ::core::clone::Clone for IInputPanelConfiguration {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IInputPanelConfiguration {}
impl ::core::cmp::PartialEq for IInputPanelConfiguration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IInputPanelConfiguration {}
impl ::core::fmt::Debug for IInputPanelConfiguration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInputPanelConfiguration")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IInputPanelConfiguration {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IInputPanelConfiguration {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x41c81592_514c_48bd_a22e_e6af638521a6);
}
pub struct IInputPanelInvocationConfiguration(pub crate::core::IUnknown);
pub trait IInputPanelInvocationConfiguration_Trait: crate::core::IUnknown_Trait {
    fn RequireTouchInEditControl(&self) -> crate::core::HRESULT {
        todo!("RequireTouchInEditControl")
    }
}
impl ::core::clone::Clone for IInputPanelInvocationConfiguration {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IInputPanelInvocationConfiguration {}
impl ::core::cmp::PartialEq for IInputPanelInvocationConfiguration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IInputPanelInvocationConfiguration {}
impl ::core::fmt::Debug for IInputPanelInvocationConfiguration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInputPanelInvocationConfiguration")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IInputPanelInvocationConfiguration {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IInputPanelInvocationConfiguration {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa213f136_3b45_4362_a332_efb6547cd432);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IInsertItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IInsertItem_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InsertItem(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("InsertItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IInsertItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IInsertItem {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IInsertItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IInsertItem {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IInsertItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IInsertItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IInsertItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IInsertItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd2b57227_3d23_4b95_93c0_492bd454c356);
}
pub struct IItemNameLimits(pub crate::core::IUnknown);
pub trait IItemNameLimits_Trait: crate::core::IUnknown_Trait {
    fn GetValidCharacters(
        &self,
        ppwsz_valid_chars: MutPtr<PWSTR>,
        ppwsz_invalid_chars: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetValidCharacters")
    }
    fn GetMaxLength(&self, psz_name: PCWSTR, pi_max_name_len: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetMaxLength")
    }
}
impl ::core::clone::Clone for IItemNameLimits {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IItemNameLimits {}
impl ::core::cmp::PartialEq for IItemNameLimits {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IItemNameLimits {}
impl ::core::fmt::Debug for IItemNameLimits {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IItemNameLimits").field(&self.0).finish()
    }
}
impl FromIntoMemory for IItemNameLimits {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IItemNameLimits {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1df0d7f1_b267_4d28_8b10_12e23202a5c4);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IKnownFolder(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IKnownFolder_Trait: crate::core::IUnknown_Trait {
    fn GetId(&self, pkfid: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetId")
    }
    fn GetCategory(&self, p_category: MutPtr<KF_CATEGORY>) -> crate::core::HRESULT {
        todo!("GetCategory")
    }
    fn GetShellItem(
        &self,
        dw_flags: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetShellItem")
    }
    fn GetPath(&self, dw_flags: u32, ppsz_path: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetPath")
    }
    fn SetPath(&self, dw_flags: u32, psz_path: PCWSTR) -> crate::core::HRESULT {
        todo!("SetPath")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIDList(
        &self,
        dw_flags: u32,
        ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("GetIDList")
    }
    fn GetFolderType(&self, pftid: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetFolderType")
    }
    fn GetRedirectionCapabilities(&self, p_capabilities: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetRedirectionCapabilities")
    }
    fn GetFolderDefinition(&self, p_kfd: MutPtr<KNOWNFOLDER_DEFINITION>) -> crate::core::HRESULT {
        todo!("GetFolderDefinition")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IKnownFolder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IKnownFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IKnownFolder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IKnownFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IKnownFolder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IKnownFolder").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IKnownFolder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IKnownFolder {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x3aa7af7e_9b36_420c_a8e3_f77d4674a488);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IKnownFolderManager(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IKnownFolderManager_Trait: crate::core::IUnknown_Trait {
    fn FolderIdFromCsidl(
        &self,
        n_csidl: i32,
        pfid: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("FolderIdFromCsidl")
    }
    fn FolderIdToCsidl(
        &self,
        rfid: ConstPtr<crate::core::GUID>,
        pn_csidl: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("FolderIdToCsidl")
    }
    fn GetFolderIds(
        &self,
        pp_kf_id: MutPtr<ConstPtr<crate::core::GUID>>,
        p_count: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetFolderIds")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetFolder(
        &self,
        rfid: ConstPtr<crate::core::GUID>,
        ppkf: MutPtr<IKnownFolder>,
    ) -> crate::core::HRESULT {
        todo!("GetFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetFolderByName(
        &self,
        psz_canonical_name: PCWSTR,
        ppkf: MutPtr<IKnownFolder>,
    ) -> crate::core::HRESULT {
        todo!("GetFolderByName")
    }
    fn RegisterFolder(
        &self,
        rfid: ConstPtr<crate::core::GUID>,
        p_kfd: ConstPtr<KNOWNFOLDER_DEFINITION>,
    ) -> crate::core::HRESULT {
        todo!("RegisterFolder")
    }
    fn UnregisterFolder(&self, rfid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("UnregisterFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn FindFolderFromPath(
        &self,
        psz_path: PCWSTR,
        mode: FFFP_MODE,
        ppkf: MutPtr<IKnownFolder>,
    ) -> crate::core::HRESULT {
        todo!("FindFolderFromPath")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn FindFolderFromIDList(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        ppkf: MutPtr<IKnownFolder>,
    ) -> crate::core::HRESULT {
        todo!("FindFolderFromIDList")
    }
    fn Redirect(
        &self,
        rfid: ConstPtr<crate::core::GUID>,
        hwnd: super::super::Foundation::HWND,
        flags: u32,
        psz_target_path: PCWSTR,
        c_folders: u32,
        p_exclusion: ConstPtr<crate::core::GUID>,
        ppsz_error: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("Redirect")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IKnownFolderManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IKnownFolderManager {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IKnownFolderManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IKnownFolderManager {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IKnownFolderManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IKnownFolderManager").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IKnownFolderManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IKnownFolderManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8be2d872_86aa_4d47_b776_32cca40c7018);
}
pub const ILMM_IE4: u32 = 0u32;
pub struct ILaunchSourceAppUserModelId(pub crate::core::IUnknown);
pub trait ILaunchSourceAppUserModelId_Trait: crate::core::IUnknown_Trait {
    fn GetAppUserModelId(&self, launching_app: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetAppUserModelId")
    }
}
impl ::core::clone::Clone for ILaunchSourceAppUserModelId {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ILaunchSourceAppUserModelId {}
impl ::core::cmp::PartialEq for ILaunchSourceAppUserModelId {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ILaunchSourceAppUserModelId {}
impl ::core::fmt::Debug for ILaunchSourceAppUserModelId {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILaunchSourceAppUserModelId")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ILaunchSourceAppUserModelId {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ILaunchSourceAppUserModelId {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x989191ac_28ff_4cf0_9584_e0d078bc2396);
}
pub struct ILaunchSourceViewSizePreference(pub crate::core::IUnknown);
pub trait ILaunchSourceViewSizePreference_Trait: crate::core::IUnknown_Trait {
    fn GetSourceViewToPosition(
        &self,
        hwnd: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("GetSourceViewToPosition")
    }
    fn GetSourceViewSizePreference(
        &self,
        source_size_after_launch: MutPtr<APPLICATION_VIEW_SIZE_PREFERENCE>,
    ) -> crate::core::HRESULT {
        todo!("GetSourceViewSizePreference")
    }
}
impl ::core::clone::Clone for ILaunchSourceViewSizePreference {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ILaunchSourceViewSizePreference {}
impl ::core::cmp::PartialEq for ILaunchSourceViewSizePreference {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ILaunchSourceViewSizePreference {}
impl ::core::fmt::Debug for ILaunchSourceViewSizePreference {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILaunchSourceViewSizePreference")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ILaunchSourceViewSizePreference {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ILaunchSourceViewSizePreference {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe5aa01f7_1fb8_4830_8720_4e6734cbd5f3);
}
pub struct ILaunchTargetMonitor(pub crate::core::IUnknown);
pub trait ILaunchTargetMonitor_Trait: crate::core::IUnknown_Trait {
    fn GetMonitor(
        &self,
        monitor: MutPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> crate::core::HRESULT {
        todo!("GetMonitor")
    }
}
impl ::core::clone::Clone for ILaunchTargetMonitor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ILaunchTargetMonitor {}
impl ::core::cmp::PartialEq for ILaunchTargetMonitor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ILaunchTargetMonitor {}
impl ::core::fmt::Debug for ILaunchTargetMonitor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILaunchTargetMonitor")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ILaunchTargetMonitor {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ILaunchTargetMonitor {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x266fbc7e_490d_46ed_a96b_2274db252003);
}
pub struct ILaunchTargetViewSizePreference(pub crate::core::IUnknown);
pub trait ILaunchTargetViewSizePreference_Trait: crate::core::IUnknown_Trait {
    fn GetTargetViewSizePreference(
        &self,
        target_size_on_launch: MutPtr<APPLICATION_VIEW_SIZE_PREFERENCE>,
    ) -> crate::core::HRESULT {
        todo!("GetTargetViewSizePreference")
    }
}
impl ::core::clone::Clone for ILaunchTargetViewSizePreference {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ILaunchTargetViewSizePreference {}
impl ::core::cmp::PartialEq for ILaunchTargetViewSizePreference {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ILaunchTargetViewSizePreference {}
impl ::core::fmt::Debug for ILaunchTargetViewSizePreference {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILaunchTargetViewSizePreference")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ILaunchTargetViewSizePreference {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ILaunchTargetViewSizePreference {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2f0666c6_12f7_4360_b511_a394a0553725);
}
pub struct ILaunchUIContext(pub crate::core::IUnknown);
pub trait ILaunchUIContext_Trait: crate::core::IUnknown_Trait {
    fn SetAssociatedWindow(&self, value: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("SetAssociatedWindow")
    }
    fn SetTabGroupingPreference(&self, value: u32) -> crate::core::HRESULT {
        todo!("SetTabGroupingPreference")
    }
}
impl ::core::clone::Clone for ILaunchUIContext {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ILaunchUIContext {}
impl ::core::cmp::PartialEq for ILaunchUIContext {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ILaunchUIContext {}
impl ::core::fmt::Debug for ILaunchUIContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILaunchUIContext").field(&self.0).finish()
    }
}
impl FromIntoMemory for ILaunchUIContext {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ILaunchUIContext {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1791e8f6_21c7_4340_882a_a6a93e3fd73b);
}
pub struct ILaunchUIContextProvider(pub crate::core::IUnknown);
pub trait ILaunchUIContextProvider_Trait: crate::core::IUnknown_Trait {
    fn UpdateContext(&self, context: ILaunchUIContext) -> crate::core::HRESULT {
        todo!("UpdateContext")
    }
}
impl ::core::clone::Clone for ILaunchUIContextProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ILaunchUIContextProvider {}
impl ::core::cmp::PartialEq for ILaunchUIContextProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ILaunchUIContextProvider {}
impl ::core::fmt::Debug for ILaunchUIContextProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ILaunchUIContextProvider")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ILaunchUIContextProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ILaunchUIContextProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0d12c4c8_a3d9_4e24_94c1_0e20c5a956c4);
}
pub const IMM_ACC_DOCKING_E_DOCKOCCUPIED: crate::core::HRESULT =
    crate::core::HRESULT(-2144927183i32);
pub const IMM_ACC_DOCKING_E_INSUFFICIENTHEIGHT: crate::core::HRESULT =
    crate::core::HRESULT(-2144927184i32);
pub const IMSC_E_SHELL_COMPONENT_STARTUP_FAILURE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927181i32);
pub struct IMenuBand(pub crate::core::IUnknown);
pub trait IMenuBand_Trait: crate::core::IUnknown_Trait {
    fn IsMenuMessage(
        &self,
        pmsg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("IsMenuMessage")
    }
    fn TranslateMenuMessage(
        &self,
        pmsg: MutPtr<super::WindowsAndMessaging::MSG>,
        pl_ret: MutPtr<super::super::Foundation::LRESULT>,
    ) -> crate::core::HRESULT {
        todo!("TranslateMenuMessage")
    }
}
impl ::core::clone::Clone for IMenuBand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IMenuBand {}
impl ::core::cmp::PartialEq for IMenuBand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMenuBand {}
impl ::core::fmt::Debug for IMenuBand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMenuBand").field(&self.0).finish()
    }
}
impl FromIntoMemory for IMenuBand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IMenuBand {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x568804cd_cbd7_11d0_9816_00c04fd91972);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IMenuPopup(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IMenuPopup_Trait: IDeskBar_Trait {
    fn Popup(
        &self,
        ppt: ConstPtr<super::super::Foundation::POINTL>,
        prc_exclude: ConstPtr<super::super::Foundation::RECTL>,
        dw_flags: i32,
    ) -> crate::core::HRESULT {
        todo!("Popup")
    }
    fn OnSelect(&self, dw_select_type: u32) -> crate::core::HRESULT {
        todo!("OnSelect")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetSubMenu(
        &self,
        pmp: IMenuPopup,
        f_set: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetSubMenu")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IMenuPopup {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IMenuPopup {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IMenuPopup {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IMenuPopup {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IMenuPopup {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMenuPopup").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IMenuPopup {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IMenuPopup {
    type Super = IDeskBar;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd1e7afeb_6a2e_11d0_8c78_00c04fd918b4);
}
pub struct IModalWindow(pub crate::core::IUnknown);
pub trait IModalWindow_Trait: crate::core::IUnknown_Trait {
    fn Show(&self, hwnd_owner: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("Show")
    }
}
impl ::core::clone::Clone for IModalWindow {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IModalWindow {}
impl ::core::cmp::PartialEq for IModalWindow {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IModalWindow {}
impl ::core::fmt::Debug for IModalWindow {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IModalWindow").field(&self.0).finish()
    }
}
impl FromIntoMemory for IModalWindow {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IModalWindow {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb4db1657_70d7_485e_8e3e_6fcb5a5c1802);
}
pub const INTERNET_MAX_PATH_LENGTH: u32 = 2048u32;
pub const INTERNET_MAX_SCHEME_LENGTH: u32 = 32u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INameSpaceTreeAccessible(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INameSpaceTreeAccessible_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnGetDefaultAccessibilityAction(
        &self,
        psi: IShellItem,
        pbstr_default_action: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("OnGetDefaultAccessibilityAction")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDoDefaultAccessibilityAction(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnDoDefaultAccessibilityAction")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnGetAccessibilityRole(
        &self,
        psi: IShellItem,
        pvar_role: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("OnGetAccessibilityRole")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INameSpaceTreeAccessible {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INameSpaceTreeAccessible {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INameSpaceTreeAccessible {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INameSpaceTreeAccessible {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INameSpaceTreeAccessible {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INameSpaceTreeAccessible")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INameSpaceTreeAccessible {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INameSpaceTreeAccessible {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x71f312de_43ed_4190_8477_e9536b82350b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INameSpaceTreeControl(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INameSpaceTreeControl_Trait: crate::core::IUnknown_Trait {
    fn Initialize(
        &self,
        hwnd_parent: super::super::Foundation::HWND,
        prc: ConstPtr<super::super::Foundation::RECT>,
        nscts_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn TreeAdvise(
        &self,
        punk: crate::core::IUnknown,
        pdw_cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("TreeAdvise")
    }
    fn TreeUnadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("TreeUnadvise")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AppendRoot(
        &self,
        psi_root: IShellItem,
        grf_enum_flags: u32,
        grf_root_style: u32,
        pif: IShellItemFilter,
    ) -> crate::core::HRESULT {
        todo!("AppendRoot")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InsertRoot(
        &self,
        i_index: i32,
        psi_root: IShellItem,
        grf_enum_flags: u32,
        grf_root_style: u32,
        pif: IShellItemFilter,
    ) -> crate::core::HRESULT {
        todo!("InsertRoot")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveRoot(&self, psi_root: IShellItem) -> crate::core::HRESULT {
        todo!("RemoveRoot")
    }
    fn RemoveAllRoots(&self) -> crate::core::HRESULT {
        todo!("RemoveAllRoots")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetRootItems(&self, ppsia_root_items: MutPtr<IShellItemArray>) -> crate::core::HRESULT {
        todo!("GetRootItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetItemState(
        &self,
        psi: IShellItem,
        nstcis_mask: u32,
        nstcis_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetItemState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemState(
        &self,
        psi: IShellItem,
        nstcis_mask: u32,
        pnstcis_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetItemState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSelectedItems(&self, psia_items: MutPtr<IShellItemArray>) -> crate::core::HRESULT {
        todo!("GetSelectedItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemCustomState(
        &self,
        psi: IShellItem,
        pi_state_number: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetItemCustomState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetItemCustomState(&self, psi: IShellItem, i_state_number: i32) -> crate::core::HRESULT {
        todo!("SetItemCustomState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EnsureItemVisible(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("EnsureItemVisible")
    }
    fn SetTheme(&self, psz_theme: PCWSTR) -> crate::core::HRESULT {
        todo!("SetTheme")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetNextItem(
        &self,
        psi: IShellItem,
        nstcgi: NSTCGNI,
        ppsi_next: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("GetNextItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn HitTest(
        &self,
        ppt: ConstPtr<super::super::Foundation::POINT>,
        ppsi_out: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("HitTest")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemRect(
        &self,
        psi: IShellItem,
        prect: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("GetItemRect")
    }
    fn CollapseAll(&self) -> crate::core::HRESULT {
        todo!("CollapseAll")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INameSpaceTreeControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INameSpaceTreeControl {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INameSpaceTreeControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INameSpaceTreeControl {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INameSpaceTreeControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INameSpaceTreeControl")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INameSpaceTreeControl {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INameSpaceTreeControl {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x028212a3_b627_47e9_8856_c14265554e4f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INameSpaceTreeControl2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INameSpaceTreeControl2_Trait: INameSpaceTreeControl_Trait {
    fn SetControlStyle(&self, nstcs_mask: u32, nstcs_style: u32) -> crate::core::HRESULT {
        todo!("SetControlStyle")
    }
    fn GetControlStyle(&self, nstcs_mask: u32, pnstcs_style: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetControlStyle")
    }
    fn SetControlStyle2(
        &self,
        nstcs_mask: NSTCSTYLE2,
        nstcs_style: NSTCSTYLE2,
    ) -> crate::core::HRESULT {
        todo!("SetControlStyle2")
    }
    fn GetControlStyle2(
        &self,
        nstcs_mask: NSTCSTYLE2,
        pnstcs_style: MutPtr<NSTCSTYLE2>,
    ) -> crate::core::HRESULT {
        todo!("GetControlStyle2")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INameSpaceTreeControl2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INameSpaceTreeControl2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INameSpaceTreeControl2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INameSpaceTreeControl2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INameSpaceTreeControl2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INameSpaceTreeControl2")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INameSpaceTreeControl2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INameSpaceTreeControl2 {
    type Super = INameSpaceTreeControl;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7cc7aed8_290e_49bc_8945_c1401cc9306c);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INameSpaceTreeControlCustomDraw(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INameSpaceTreeControlCustomDraw_Trait: crate::core::IUnknown_Trait {
    fn PrePaint(
        &self,
        hdc: super::super::Graphics::Gdi::HDC,
        prc: ConstPtr<super::super::Foundation::RECT>,
        plres: MutPtr<super::super::Foundation::LRESULT>,
    ) -> crate::core::HRESULT {
        todo!("PrePaint")
    }
    fn PostPaint(
        &self,
        hdc: super::super::Graphics::Gdi::HDC,
        prc: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("PostPaint")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ItemPrePaint(
        &self,
        hdc: super::super::Graphics::Gdi::HDC,
        prc: ConstPtr<super::super::Foundation::RECT>,
        pnstccd_item: ConstPtr<NSTCCUSTOMDRAW>,
        pclr_text: MutPtr<u32>,
        pclr_text_bk: MutPtr<u32>,
        plres: MutPtr<super::super::Foundation::LRESULT>,
    ) -> crate::core::HRESULT {
        todo!("ItemPrePaint")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ItemPostPaint(
        &self,
        hdc: super::super::Graphics::Gdi::HDC,
        prc: ConstPtr<super::super::Foundation::RECT>,
        pnstccd_item: ConstPtr<NSTCCUSTOMDRAW>,
    ) -> crate::core::HRESULT {
        todo!("ItemPostPaint")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INameSpaceTreeControlCustomDraw {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INameSpaceTreeControlCustomDraw {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INameSpaceTreeControlCustomDraw {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INameSpaceTreeControlCustomDraw {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INameSpaceTreeControlCustomDraw {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INameSpaceTreeControlCustomDraw")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INameSpaceTreeControlCustomDraw {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INameSpaceTreeControlCustomDraw {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2d3ba758_33ee_42d5_bb7b_5f3431d86c78);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INameSpaceTreeControlDropHandler(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INameSpaceTreeControlDropHandler_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDragEnter(
        &self,
        psi_over: IShellItem,
        psia_data: IShellItemArray,
        f_outside_source: super::super::Foundation::BOOL,
        grf_key_state: u32,
        pdw_effect: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("OnDragEnter")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDragOver(
        &self,
        psi_over: IShellItem,
        psia_data: IShellItemArray,
        grf_key_state: u32,
        pdw_effect: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("OnDragOver")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDragPosition(
        &self,
        psi_over: IShellItem,
        psia_data: IShellItemArray,
        i_new_position: i32,
        i_old_position: i32,
    ) -> crate::core::HRESULT {
        todo!("OnDragPosition")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDrop(
        &self,
        psi_over: IShellItem,
        psia_data: IShellItemArray,
        i_position: i32,
        grf_key_state: u32,
        pdw_effect: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("OnDrop")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDropPosition(
        &self,
        psi_over: IShellItem,
        psia_data: IShellItemArray,
        i_new_position: i32,
        i_old_position: i32,
    ) -> crate::core::HRESULT {
        todo!("OnDropPosition")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnDragLeave(&self, psi_over: IShellItem) -> crate::core::HRESULT {
        todo!("OnDragLeave")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INameSpaceTreeControlDropHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INameSpaceTreeControlDropHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INameSpaceTreeControlDropHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INameSpaceTreeControlDropHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INameSpaceTreeControlDropHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INameSpaceTreeControlDropHandler")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INameSpaceTreeControlDropHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INameSpaceTreeControlDropHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf9c665d6_c2f2_4c19_bf33_8322d7352f51);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INameSpaceTreeControlEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INameSpaceTreeControlEvents_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnItemClick(
        &self,
        psi: IShellItem,
        nstce_hit_test: u32,
        nstce_click_type: u32,
    ) -> crate::core::HRESULT {
        todo!("OnItemClick")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnPropertyItemCommit(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnPropertyItemCommit")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnItemStateChanging(
        &self,
        psi: IShellItem,
        nstcis_mask: u32,
        nstcis_state: u32,
    ) -> crate::core::HRESULT {
        todo!("OnItemStateChanging")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnItemStateChanged(
        &self,
        psi: IShellItem,
        nstcis_mask: u32,
        nstcis_state: u32,
    ) -> crate::core::HRESULT {
        todo!("OnItemStateChanged")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnSelectionChanged(&self, psia_selection: IShellItemArray) -> crate::core::HRESULT {
        todo!("OnSelectionChanged")
    }
    fn OnKeyboardInput(
        &self,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("OnKeyboardInput")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnBeforeExpand(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnBeforeExpand")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnAfterExpand(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnAfterExpand")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnBeginLabelEdit(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnBeginLabelEdit")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnEndLabelEdit(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnEndLabelEdit")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnGetToolTip(&self, psi: IShellItem, psz_tip: PWSTR, cch_tip: i32) -> crate::core::HRESULT {
        todo!("OnGetToolTip")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnBeforeItemDelete(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnBeforeItemDelete")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnItemAdded(
        &self,
        psi: IShellItem,
        f_is_root: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("OnItemAdded")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnItemDeleted(
        &self,
        psi: IShellItem,
        f_is_root: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("OnItemDeleted")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnBeforeContextMenu(
        &self,
        psi: IShellItem,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("OnBeforeContextMenu")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnAfterContextMenu(
        &self,
        psi: IShellItem,
        pcm_in: IContextMenu,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("OnAfterContextMenu")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnBeforeStateImageChange(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("OnBeforeStateImageChange")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnGetDefaultIconIndex(
        &self,
        psi: IShellItem,
        pi_default_icon: MutPtr<i32>,
        pi_open_icon: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("OnGetDefaultIconIndex")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INameSpaceTreeControlEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INameSpaceTreeControlEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INameSpaceTreeControlEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INameSpaceTreeControlEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INameSpaceTreeControlEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INameSpaceTreeControlEvents")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INameSpaceTreeControlEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INameSpaceTreeControlEvents {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x93d77985_b3d8_4484_8318_672cdda002ce);
}
pub struct INameSpaceTreeControlFolderCapabilities(pub crate::core::IUnknown);
pub trait INameSpaceTreeControlFolderCapabilities_Trait: crate::core::IUnknown_Trait {
    fn GetFolderCapabilities(
        &self,
        nfc_mask: NSTCFOLDERCAPABILITIES,
        pnfc_value: MutPtr<NSTCFOLDERCAPABILITIES>,
    ) -> crate::core::HRESULT {
        todo!("GetFolderCapabilities")
    }
}
impl ::core::clone::Clone for INameSpaceTreeControlFolderCapabilities {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for INameSpaceTreeControlFolderCapabilities {}
impl ::core::cmp::PartialEq for INameSpaceTreeControlFolderCapabilities {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for INameSpaceTreeControlFolderCapabilities {}
impl ::core::fmt::Debug for INameSpaceTreeControlFolderCapabilities {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INameSpaceTreeControlFolderCapabilities")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for INameSpaceTreeControlFolderCapabilities {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for INameSpaceTreeControlFolderCapabilities {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe9701183_e6b3_4ff2_8568_813615fec7be);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INamedPropertyBag(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INamedPropertyBag_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ReadPropertyNPB(
        &self,
        psz_bagname: PCWSTR,
        psz_prop_name: PCWSTR,
        p_var: MutPtr<super::super::System::Com::StructuredStorage::PROPVARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ReadPropertyNPB")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn WritePropertyNPB(
        &self,
        psz_bagname: PCWSTR,
        psz_prop_name: PCWSTR,
        p_var: ConstPtr<super::super::System::Com::StructuredStorage::PROPVARIANT>,
    ) -> crate::core::HRESULT {
        todo!("WritePropertyNPB")
    }
    fn RemovePropertyNPB(
        &self,
        psz_bagname: PCWSTR,
        psz_prop_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("RemovePropertyNPB")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INamedPropertyBag {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INamedPropertyBag {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INamedPropertyBag {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INamedPropertyBag {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INamedPropertyBag {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INamedPropertyBag").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INamedPropertyBag {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INamedPropertyBag {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfb700430_952c_11d1_946f_000000000000);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INamespaceWalk(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INamespaceWalk_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Walk(
        &self,
        punk_to_walk: crate::core::IUnknown,
        dw_flags: u32,
        c_depth: i32,
        pnswcb: INamespaceWalkCB,
    ) -> crate::core::HRESULT {
        todo!("Walk")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIDArrayResult(
        &self,
        pc_items: MutPtr<u32>,
        prgpidl: MutPtr<ConstPtr<ConstPtr<Common::ITEMIDLIST>>>,
    ) -> crate::core::HRESULT {
        todo!("GetIDArrayResult")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INamespaceWalk {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INamespaceWalk {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INamespaceWalk {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INamespaceWalk {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INamespaceWalk {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INamespaceWalk").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INamespaceWalk {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INamespaceWalk {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x57ced8a7_3f4a_432c_9350_30f24483f74f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INamespaceWalkCB(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INamespaceWalkCB_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn FoundItem(
        &self,
        psf: IShellFolder,
        pidl: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("FoundItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EnterFolder(
        &self,
        psf: IShellFolder,
        pidl: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("EnterFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn LeaveFolder(
        &self,
        psf: IShellFolder,
        pidl: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("LeaveFolder")
    }
    fn InitializeProgressDialog(
        &self,
        ppsz_title: MutPtr<PWSTR>,
        ppsz_cancel: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("InitializeProgressDialog")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INamespaceWalkCB {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INamespaceWalkCB {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INamespaceWalkCB {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INamespaceWalkCB {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INamespaceWalkCB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INamespaceWalkCB").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INamespaceWalkCB {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INamespaceWalkCB {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd92995f8_cf5e_4a76_bf59_ead39ea2b97e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INamespaceWalkCB2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INamespaceWalkCB2_Trait: INamespaceWalkCB_Trait {
    fn WalkComplete(&self, hr: crate::core::HRESULT) -> crate::core::HRESULT {
        todo!("WalkComplete")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INamespaceWalkCB2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INamespaceWalkCB2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INamespaceWalkCB2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INamespaceWalkCB2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INamespaceWalkCB2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INamespaceWalkCB2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INamespaceWalkCB2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INamespaceWalkCB2 {
    type Super = INamespaceWalkCB;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7ac7492b_c38e_438a_87db_68737844ff70);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INetworkFolderInternal(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INetworkFolderInternal_Trait: crate::core::IUnknown_Trait {
    fn GetResourceDisplayType(&self, display_type: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetResourceDisplayType")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIDList(&self, id_list: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetIDList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetProvider(
        &self,
        item_id_count: u32,
        item_ids: ConstPtr<ConstPtr<Common::ITEMIDLIST>>,
        provider_max_length: u32,
        provider: PWSTR,
    ) -> crate::core::HRESULT {
        todo!("GetProvider")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INetworkFolderInternal {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INetworkFolderInternal {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INetworkFolderInternal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INetworkFolderInternal {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INetworkFolderInternal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INetworkFolderInternal")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INetworkFolderInternal {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INetworkFolderInternal {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xceb38218_c971_47bb_a703_f0bc99ccdb81);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INewMenuClient(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INewMenuClient_Trait: crate::core::IUnknown_Trait {
    fn IncludeItems(&self, pflags: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("IncludeItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SelectAndEditItem(
        &self,
        pidl_item: ConstPtr<Common::ITEMIDLIST>,
        flags: i32,
    ) -> crate::core::HRESULT {
        todo!("SelectAndEditItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INewMenuClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INewMenuClient {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INewMenuClient {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INewMenuClient {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INewMenuClient {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INewMenuClient").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INewMenuClient {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INewMenuClient {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xdcb07fdc_3bb5_451c_90be_966644fed7b0);
}
pub struct INewShortcutHookA(pub crate::core::IUnknown);
pub trait INewShortcutHookA_Trait: crate::core::IUnknown_Trait {
    fn SetReferent(
        &self,
        pcsz_referent: PCSTR,
        hwnd: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("SetReferent")
    }
    fn GetReferent(&self, psz_referent: PSTR, cch_referent: i32) -> crate::core::HRESULT {
        todo!("GetReferent")
    }
    fn SetFolder(&self, pcsz_folder: PCSTR) -> crate::core::HRESULT {
        todo!("SetFolder")
    }
    fn GetFolder(&self, psz_folder: PSTR, cch_folder: i32) -> crate::core::HRESULT {
        todo!("GetFolder")
    }
    fn GetName(&self, psz_name: PSTR, cch_name: i32) -> crate::core::HRESULT {
        todo!("GetName")
    }
    fn GetExtension(&self, psz_extension: PSTR, cch_extension: i32) -> crate::core::HRESULT {
        todo!("GetExtension")
    }
}
impl ::core::clone::Clone for INewShortcutHookA {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for INewShortcutHookA {}
impl ::core::cmp::PartialEq for INewShortcutHookA {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for INewShortcutHookA {}
impl ::core::fmt::Debug for INewShortcutHookA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INewShortcutHookA").field(&self.0).finish()
    }
}
impl FromIntoMemory for INewShortcutHookA {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for INewShortcutHookA {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e1_0000_0000_c000_000000000046);
}
pub struct INewShortcutHookW(pub crate::core::IUnknown);
pub trait INewShortcutHookW_Trait: crate::core::IUnknown_Trait {
    fn SetReferent(
        &self,
        pcsz_referent: PCWSTR,
        hwnd: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("SetReferent")
    }
    fn GetReferent(&self, psz_referent: PWSTR, cch_referent: i32) -> crate::core::HRESULT {
        todo!("GetReferent")
    }
    fn SetFolder(&self, pcsz_folder: PCWSTR) -> crate::core::HRESULT {
        todo!("SetFolder")
    }
    fn GetFolder(&self, psz_folder: PWSTR, cch_folder: i32) -> crate::core::HRESULT {
        todo!("GetFolder")
    }
    fn GetName(&self, psz_name: PWSTR, cch_name: i32) -> crate::core::HRESULT {
        todo!("GetName")
    }
    fn GetExtension(&self, psz_extension: PWSTR, cch_extension: i32) -> crate::core::HRESULT {
        todo!("GetExtension")
    }
}
impl ::core::clone::Clone for INewShortcutHookW {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for INewShortcutHookW {}
impl ::core::cmp::PartialEq for INewShortcutHookW {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for INewShortcutHookW {}
impl ::core::fmt::Debug for INewShortcutHookW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INewShortcutHookW").field(&self.0).finish()
    }
}
impl FromIntoMemory for INewShortcutHookW {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for INewShortcutHookW {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214f7_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INewWDEvents(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INewWDEvents_Trait: IWebWizardHost_Trait {
    fn PassportAuthenticate(
        &self,
        bstr_sign_in_url: super::super::Foundation::BSTR,
        pvf_authenitcated: MutPtr<i16>,
    ) -> crate::core::HRESULT {
        todo!("PassportAuthenticate")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INewWDEvents {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INewWDEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INewWDEvents {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INewWDEvents {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INewWDEvents {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INewWDEvents").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INewWDEvents {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INewWDEvents {
    type Super = IWebWizardHost;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0751c551_7568_41c9_8e5b_e22e38919236);
}
pub struct INewWindowManager(pub crate::core::IUnknown);
pub trait INewWindowManager_Trait: crate::core::IUnknown_Trait {
    fn EvaluateNewWindow(
        &self,
        psz_url: PCWSTR,
        psz_name: PCWSTR,
        psz_url_context: PCWSTR,
        psz_features: PCWSTR,
        f_replace: super::super::Foundation::BOOL,
        dw_flags: u32,
        dw_user_action_time: u32,
    ) -> crate::core::HRESULT {
        todo!("EvaluateNewWindow")
    }
}
impl ::core::clone::Clone for INewWindowManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for INewWindowManager {}
impl ::core::cmp::PartialEq for INewWindowManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for INewWindowManager {}
impl ::core::fmt::Debug for INewWindowManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INewWindowManager").field(&self.0).finish()
    }
}
impl FromIntoMemory for INewWindowManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for INewWindowManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd2bc4c84_3f72_4a52_a604_7bcbf3982cbb);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct INotifyReplica(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait INotifyReplica_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn YouAreAReplica(
        &self,
        ulc_other_replicas: u32,
        rgpmk_other_replicas: MutPtr<super::super::System::Com::IMoniker>,
    ) -> crate::core::HRESULT {
        todo!("YouAreAReplica")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for INotifyReplica {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for INotifyReplica {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for INotifyReplica {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for INotifyReplica {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for INotifyReplica {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("INotifyReplica").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for INotifyReplica {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for INotifyReplica {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x99180163_da16_101a_935c_444553540000);
}
pub struct IObjMgr(pub crate::core::IUnknown);
pub trait IObjMgr_Trait: crate::core::IUnknown_Trait {
    fn Append(&self, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("Append")
    }
    fn Remove(&self, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("Remove")
    }
}
impl ::core::clone::Clone for IObjMgr {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IObjMgr {}
impl ::core::cmp::PartialEq for IObjMgr {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IObjMgr {}
impl ::core::fmt::Debug for IObjMgr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjMgr").field(&self.0).finish()
    }
}
impl FromIntoMemory for IObjMgr {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IObjMgr {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x00bb2761_6a77_11d0_a535_00c04fd7d062);
}
pub struct IObjectProvider(pub crate::core::IUnknown);
pub trait IObjectProvider_Trait: crate::core::IUnknown_Trait {
    fn QueryObject(
        &self,
        guid_object: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv_out: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("QueryObject")
    }
}
impl ::core::clone::Clone for IObjectProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IObjectProvider {}
impl ::core::cmp::PartialEq for IObjectProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IObjectProvider {}
impl ::core::fmt::Debug for IObjectProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjectProvider").field(&self.0).finish()
    }
}
impl FromIntoMemory for IObjectProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IObjectProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa6087428_3be3_4d73_b308_7c04a540bf1a);
}
pub struct IObjectWithAppUserModelID(pub crate::core::IUnknown);
pub trait IObjectWithAppUserModelID_Trait: crate::core::IUnknown_Trait {
    fn SetAppID(&self, psz_app_id: PCWSTR) -> crate::core::HRESULT {
        todo!("SetAppID")
    }
    fn GetAppID(&self, ppsz_app_id: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetAppID")
    }
}
impl ::core::clone::Clone for IObjectWithAppUserModelID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IObjectWithAppUserModelID {}
impl ::core::cmp::PartialEq for IObjectWithAppUserModelID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IObjectWithAppUserModelID {}
impl ::core::fmt::Debug for IObjectWithAppUserModelID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjectWithAppUserModelID")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IObjectWithAppUserModelID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IObjectWithAppUserModelID {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x36db0196_9665_46d1_9ba7_d3709eecf9ed);
}
pub struct IObjectWithBackReferences(pub crate::core::IUnknown);
pub trait IObjectWithBackReferences_Trait: crate::core::IUnknown_Trait {
    fn RemoveBackReferences(&self) -> crate::core::HRESULT {
        todo!("RemoveBackReferences")
    }
}
impl ::core::clone::Clone for IObjectWithBackReferences {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IObjectWithBackReferences {}
impl ::core::cmp::PartialEq for IObjectWithBackReferences {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IObjectWithBackReferences {}
impl ::core::fmt::Debug for IObjectWithBackReferences {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjectWithBackReferences")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IObjectWithBackReferences {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IObjectWithBackReferences {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x321a6a6a_d61f_4bf3_97ae_14be2986bb36);
}
pub struct IObjectWithCancelEvent(pub crate::core::IUnknown);
pub trait IObjectWithCancelEvent_Trait: crate::core::IUnknown_Trait {
    fn GetCancelEvent(
        &self,
        ph_event: MutPtr<super::super::Foundation::HANDLE>,
    ) -> crate::core::HRESULT {
        todo!("GetCancelEvent")
    }
}
impl ::core::clone::Clone for IObjectWithCancelEvent {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IObjectWithCancelEvent {}
impl ::core::cmp::PartialEq for IObjectWithCancelEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IObjectWithCancelEvent {}
impl ::core::fmt::Debug for IObjectWithCancelEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjectWithCancelEvent")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IObjectWithCancelEvent {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IObjectWithCancelEvent {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf279b885_0ae9_4b85_ac06_ddecf9408941);
}
pub struct IObjectWithFolderEnumMode(pub crate::core::IUnknown);
pub trait IObjectWithFolderEnumMode_Trait: crate::core::IUnknown_Trait {
    fn SetMode(&self, fe_mode: FOLDER_ENUM_MODE) -> crate::core::HRESULT {
        todo!("SetMode")
    }
    fn GetMode(&self, pfe_mode: MutPtr<FOLDER_ENUM_MODE>) -> crate::core::HRESULT {
        todo!("GetMode")
    }
}
impl ::core::clone::Clone for IObjectWithFolderEnumMode {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IObjectWithFolderEnumMode {}
impl ::core::cmp::PartialEq for IObjectWithFolderEnumMode {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IObjectWithFolderEnumMode {}
impl ::core::fmt::Debug for IObjectWithFolderEnumMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjectWithFolderEnumMode")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IObjectWithFolderEnumMode {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IObjectWithFolderEnumMode {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6a9d9026_0e6e_464c_b000_42ecc07de673);
}
pub struct IObjectWithProgID(pub crate::core::IUnknown);
pub trait IObjectWithProgID_Trait: crate::core::IUnknown_Trait {
    fn SetProgID(&self, psz_prog_id: PCWSTR) -> crate::core::HRESULT {
        todo!("SetProgID")
    }
    fn GetProgID(&self, ppsz_prog_id: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetProgID")
    }
}
impl ::core::clone::Clone for IObjectWithProgID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IObjectWithProgID {}
impl ::core::cmp::PartialEq for IObjectWithProgID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IObjectWithProgID {}
impl ::core::fmt::Debug for IObjectWithProgID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjectWithProgID").field(&self.0).finish()
    }
}
impl FromIntoMemory for IObjectWithProgID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IObjectWithProgID {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x71e806fb_8dee_46fc_bf8c_7748a8a1ae13);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IObjectWithSelection(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IObjectWithSelection_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetSelection(&self, psia: IShellItemArray) -> crate::core::HRESULT {
        todo!("SetSelection")
    }
    fn GetSelection(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetSelection")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IObjectWithSelection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IObjectWithSelection {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IObjectWithSelection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IObjectWithSelection {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IObjectWithSelection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IObjectWithSelection")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IObjectWithSelection {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IObjectWithSelection {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1c9cd5bb_98e9_4491_a60f_31aacc72b83c);
}
pub struct IOpenControlPanel(pub crate::core::IUnknown);
pub trait IOpenControlPanel_Trait: crate::core::IUnknown_Trait {
    fn Open(
        &self,
        psz_name: PCWSTR,
        psz_page: PCWSTR,
        punk_site: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("Open")
    }
    fn GetPath(&self, psz_name: PCWSTR, psz_path: PWSTR, cch_path: u32) -> crate::core::HRESULT {
        todo!("GetPath")
    }
    fn GetCurrentView(&self, p_view: MutPtr<CPVIEW>) -> crate::core::HRESULT {
        todo!("GetCurrentView")
    }
}
impl ::core::clone::Clone for IOpenControlPanel {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IOpenControlPanel {}
impl ::core::cmp::PartialEq for IOpenControlPanel {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IOpenControlPanel {}
impl ::core::fmt::Debug for IOpenControlPanel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IOpenControlPanel").field(&self.0).finish()
    }
}
impl FromIntoMemory for IOpenControlPanel {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IOpenControlPanel {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd11ad862_66de_4df4_bf6c_1f5621996af1);
}
pub struct IOpenSearchSource(pub crate::core::IUnknown);
pub trait IOpenSearchSource_Trait: crate::core::IUnknown_Trait {
    fn GetResults(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_query: PCWSTR,
        dw_start_index: u32,
        dw_count: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetResults")
    }
}
impl ::core::clone::Clone for IOpenSearchSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IOpenSearchSource {}
impl ::core::cmp::PartialEq for IOpenSearchSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IOpenSearchSource {}
impl ::core::fmt::Debug for IOpenSearchSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IOpenSearchSource").field(&self.0).finish()
    }
}
impl FromIntoMemory for IOpenSearchSource {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IOpenSearchSource {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf0ee7333_e6fc_479b_9f25_a860c234a38e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IOperationsProgressDialog(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IOperationsProgressDialog_Trait: crate::core::IUnknown_Trait {
    fn StartProgressDialog(
        &self,
        hwnd_owner: super::super::Foundation::HWND,
        flags: u32,
    ) -> crate::core::HRESULT {
        todo!("StartProgressDialog")
    }
    fn StopProgressDialog(&self) -> crate::core::HRESULT {
        todo!("StopProgressDialog")
    }
    fn SetOperation(&self, action: SPACTION) -> crate::core::HRESULT {
        todo!("SetOperation")
    }
    fn SetMode(&self, mode: u32) -> crate::core::HRESULT {
        todo!("SetMode")
    }
    fn UpdateProgress(
        &self,
        ull_points_current: u64,
        ull_points_total: u64,
        ull_size_current: u64,
        ull_size_total: u64,
        ull_items_current: u64,
        ull_items_total: u64,
    ) -> crate::core::HRESULT {
        todo!("UpdateProgress")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn UpdateLocations(
        &self,
        psi_source: IShellItem,
        psi_target: IShellItem,
        psi_item: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("UpdateLocations")
    }
    fn ResetTimer(&self) -> crate::core::HRESULT {
        todo!("ResetTimer")
    }
    fn PauseTimer(&self) -> crate::core::HRESULT {
        todo!("PauseTimer")
    }
    fn ResumeTimer(&self) -> crate::core::HRESULT {
        todo!("ResumeTimer")
    }
    fn GetMilliseconds(
        &self,
        pull_elapsed: MutPtr<u64>,
        pull_remaining: MutPtr<u64>,
    ) -> crate::core::HRESULT {
        todo!("GetMilliseconds")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetOperationStatus(
        &self,
        popstatus: MutPtr<PropertiesSystem::PDOPSTATUS>,
    ) -> crate::core::HRESULT {
        todo!("GetOperationStatus")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IOperationsProgressDialog {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IOperationsProgressDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IOperationsProgressDialog {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IOperationsProgressDialog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IOperationsProgressDialog {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IOperationsProgressDialog")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IOperationsProgressDialog {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IOperationsProgressDialog {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0c9fb851_e5c9_43eb_a370_f0677b13874c);
}
pub struct IPackageDebugSettings(pub crate::core::IUnknown);
pub trait IPackageDebugSettings_Trait: crate::core::IUnknown_Trait {
    fn EnableDebugging(
        &self,
        package_full_name: PCWSTR,
        debugger_command_line: PCWSTR,
        environment: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("EnableDebugging")
    }
    fn DisableDebugging(&self, package_full_name: PCWSTR) -> crate::core::HRESULT {
        todo!("DisableDebugging")
    }
    fn Suspend(&self, package_full_name: PCWSTR) -> crate::core::HRESULT {
        todo!("Suspend")
    }
    fn Resume(&self, package_full_name: PCWSTR) -> crate::core::HRESULT {
        todo!("Resume")
    }
    fn TerminateAllProcesses(&self, package_full_name: PCWSTR) -> crate::core::HRESULT {
        todo!("TerminateAllProcesses")
    }
    fn SetTargetSessionId(&self, session_id: u32) -> crate::core::HRESULT {
        todo!("SetTargetSessionId")
    }
    fn EnumerateBackgroundTasks(
        &self,
        package_full_name: PCWSTR,
        task_count: MutPtr<u32>,
        task_ids: MutPtr<ConstPtr<crate::core::GUID>>,
        task_names: MutPtr<ConstPtr<PWSTR>>,
    ) -> crate::core::HRESULT {
        todo!("EnumerateBackgroundTasks")
    }
    fn ActivateBackgroundTask(&self, task_id: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("ActivateBackgroundTask")
    }
    fn StartServicing(&self, package_full_name: PCWSTR) -> crate::core::HRESULT {
        todo!("StartServicing")
    }
    fn StopServicing(&self, package_full_name: PCWSTR) -> crate::core::HRESULT {
        todo!("StopServicing")
    }
    fn StartSessionRedirection(
        &self,
        package_full_name: PCWSTR,
        session_id: u32,
    ) -> crate::core::HRESULT {
        todo!("StartSessionRedirection")
    }
    fn StopSessionRedirection(&self, package_full_name: PCWSTR) -> crate::core::HRESULT {
        todo!("StopSessionRedirection")
    }
    fn GetPackageExecutionState(
        &self,
        package_full_name: PCWSTR,
        package_execution_state: MutPtr<PACKAGE_EXECUTION_STATE>,
    ) -> crate::core::HRESULT {
        todo!("GetPackageExecutionState")
    }
    fn RegisterForPackageStateChanges(
        &self,
        package_full_name: PCWSTR,
        p_package_execution_state_change_notification: IPackageExecutionStateChangeNotification,
        pdw_cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("RegisterForPackageStateChanges")
    }
    fn UnregisterForPackageStateChanges(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("UnregisterForPackageStateChanges")
    }
}
impl ::core::clone::Clone for IPackageDebugSettings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPackageDebugSettings {}
impl ::core::cmp::PartialEq for IPackageDebugSettings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPackageDebugSettings {}
impl ::core::fmt::Debug for IPackageDebugSettings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPackageDebugSettings")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IPackageDebugSettings {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPackageDebugSettings {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf27c3930_8029_4ad1_94e3_3dba417810c1);
}
pub struct IPackageDebugSettings2(pub crate::core::IUnknown);
pub trait IPackageDebugSettings2_Trait: IPackageDebugSettings_Trait {
    fn EnumerateApps(
        &self,
        package_full_name: PCWSTR,
        app_count: MutPtr<u32>,
        app_user_model_ids: MutPtr<ConstPtr<PWSTR>>,
        app_display_names: MutPtr<ConstPtr<PWSTR>>,
    ) -> crate::core::HRESULT {
        todo!("EnumerateApps")
    }
}
impl ::core::clone::Clone for IPackageDebugSettings2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPackageDebugSettings2 {}
impl ::core::cmp::PartialEq for IPackageDebugSettings2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPackageDebugSettings2 {}
impl ::core::fmt::Debug for IPackageDebugSettings2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPackageDebugSettings2")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IPackageDebugSettings2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPackageDebugSettings2 {
    type Super = IPackageDebugSettings;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6e3194bb_ab82_4d22_93f5_fabda40e7b16);
}
pub struct IPackageExecutionStateChangeNotification(pub crate::core::IUnknown);
pub trait IPackageExecutionStateChangeNotification_Trait: crate::core::IUnknown_Trait {
    fn OnStateChanged(
        &self,
        psz_package_full_name: PCWSTR,
        pes_new_state: PACKAGE_EXECUTION_STATE,
    ) -> crate::core::HRESULT {
        todo!("OnStateChanged")
    }
}
impl ::core::clone::Clone for IPackageExecutionStateChangeNotification {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPackageExecutionStateChangeNotification {}
impl ::core::cmp::PartialEq for IPackageExecutionStateChangeNotification {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPackageExecutionStateChangeNotification {}
impl ::core::fmt::Debug for IPackageExecutionStateChangeNotification {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPackageExecutionStateChangeNotification")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IPackageExecutionStateChangeNotification {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPackageExecutionStateChangeNotification {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1bb12a62_2ad8_432b_8ccf_0c2c52afcd5b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IParentAndItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IParentAndItem_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetParentAndItem(
        &self,
        pidl_parent: ConstPtr<Common::ITEMIDLIST>,
        psf: IShellFolder,
        pidl_child: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("SetParentAndItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetParentAndItem(
        &self,
        ppidl_parent: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
        ppsf: MutPtr<IShellFolder>,
        ppidl_child: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("GetParentAndItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IParentAndItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IParentAndItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IParentAndItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IParentAndItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IParentAndItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IParentAndItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IParentAndItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IParentAndItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb3a4b685_b685_4805_99d9_5dead2873236);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IParseAndCreateItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IParseAndCreateItem_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetItem(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("SetItem")
    }
    fn GetItem(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IParseAndCreateItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IParseAndCreateItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IParseAndCreateItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IParseAndCreateItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IParseAndCreateItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IParseAndCreateItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IParseAndCreateItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IParseAndCreateItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x67efed0e_e827_4408_b493_78f3982b685c);
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IPersistFolder(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IPersistFolder_Trait: super::super::System::Com::IPersist_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IPersistFolder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IPersistFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IPersistFolder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IPersistFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IPersistFolder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistFolder").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IPersistFolder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IPersistFolder {
    type Super = super::super::System::Com::IPersist;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214ea_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IPersistFolder2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IPersistFolder2_Trait: IPersistFolder_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetCurFolder(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetCurFolder")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IPersistFolder2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IPersistFolder2 {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IPersistFolder2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IPersistFolder2 {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IPersistFolder2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistFolder2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IPersistFolder2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IPersistFolder2 {
    type Super = IPersistFolder;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1ac3d9f0_175c_11d1_95be_00609797ea4f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IPersistFolder3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IPersistFolder3_Trait: IPersistFolder2_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InitializeEx(
        &self,
        pbc: super::super::System::Com::IBindCtx,
        pidl_root: ConstPtr<Common::ITEMIDLIST>,
        ppfti: ConstPtr<PERSIST_FOLDER_TARGET_INFO>,
    ) -> crate::core::HRESULT {
        todo!("InitializeEx")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetFolderTargetInfo(
        &self,
        ppfti: MutPtr<PERSIST_FOLDER_TARGET_INFO>,
    ) -> crate::core::HRESULT {
        todo!("GetFolderTargetInfo")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IPersistFolder3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IPersistFolder3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IPersistFolder3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IPersistFolder3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IPersistFolder3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistFolder3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IPersistFolder3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IPersistFolder3 {
    type Super = IPersistFolder2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xcef04fdf_fe72_11d2_87a5_00c04f6837cf);
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IPersistIDList(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IPersistIDList_Trait: super::super::System::Com::IPersist_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetIDList(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("SetIDList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIDList(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetIDList")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IPersistIDList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IPersistIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IPersistIDList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IPersistIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IPersistIDList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPersistIDList").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IPersistIDList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.System.Com', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IPersistIDList {
    type Super = super::super::System::Com::IPersist;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1079acfc_29bd_11d3_8e0d_00c04f6837d5);
}
pub struct IPreviewHandler(pub crate::core::IUnknown);
pub trait IPreviewHandler_Trait: crate::core::IUnknown_Trait {
    fn SetWindow(
        &self,
        hwnd: super::super::Foundation::HWND,
        prc: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("SetWindow")
    }
    fn SetRect(&self, prc: ConstPtr<super::super::Foundation::RECT>) -> crate::core::HRESULT {
        todo!("SetRect")
    }
    fn DoPreview(&self) -> crate::core::HRESULT {
        todo!("DoPreview")
    }
    fn Unload(&self) -> crate::core::HRESULT {
        todo!("Unload")
    }
    fn SetFocus(&self) -> crate::core::HRESULT {
        todo!("SetFocus")
    }
    fn QueryFocus(&self, phwnd: MutPtr<super::super::Foundation::HWND>) -> crate::core::HRESULT {
        todo!("QueryFocus")
    }
    fn TranslateAccelerator(
        &self,
        pmsg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("TranslateAccelerator")
    }
}
impl ::core::clone::Clone for IPreviewHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPreviewHandler {}
impl ::core::cmp::PartialEq for IPreviewHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPreviewHandler {}
impl ::core::fmt::Debug for IPreviewHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPreviewHandler").field(&self.0).finish()
    }
}
impl FromIntoMemory for IPreviewHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPreviewHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8895b1c6_b41f_4c1c_a562_0d564250836f);
}
pub struct IPreviewHandlerFrame(pub crate::core::IUnknown);
pub trait IPreviewHandlerFrame_Trait: crate::core::IUnknown_Trait {
    fn GetWindowContext(&self, pinfo: MutPtr<PREVIEWHANDLERFRAMEINFO>) -> crate::core::HRESULT {
        todo!("GetWindowContext")
    }
    fn TranslateAccelerator(
        &self,
        pmsg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("TranslateAccelerator")
    }
}
impl ::core::clone::Clone for IPreviewHandlerFrame {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPreviewHandlerFrame {}
impl ::core::cmp::PartialEq for IPreviewHandlerFrame {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPreviewHandlerFrame {}
impl ::core::fmt::Debug for IPreviewHandlerFrame {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPreviewHandlerFrame")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IPreviewHandlerFrame {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPreviewHandlerFrame {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfec87aaf_35f9_447a_adb7_20234491401a);
}
pub struct IPreviewHandlerVisuals(pub crate::core::IUnknown);
pub trait IPreviewHandlerVisuals_Trait: crate::core::IUnknown_Trait {
    fn SetBackgroundColor(&self, color: u32) -> crate::core::HRESULT {
        todo!("SetBackgroundColor")
    }
    fn SetFont(
        &self,
        plf: ConstPtr<super::super::Graphics::Gdi::LOGFONTW>,
    ) -> crate::core::HRESULT {
        todo!("SetFont")
    }
    fn SetTextColor(&self, color: u32) -> crate::core::HRESULT {
        todo!("SetTextColor")
    }
}
impl ::core::clone::Clone for IPreviewHandlerVisuals {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPreviewHandlerVisuals {}
impl ::core::cmp::PartialEq for IPreviewHandlerVisuals {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPreviewHandlerVisuals {}
impl ::core::fmt::Debug for IPreviewHandlerVisuals {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPreviewHandlerVisuals")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IPreviewHandlerVisuals {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPreviewHandlerVisuals {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x196bf9a5_b346_4ef0_aa1e_5dcdb76768b1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IPreviewItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IPreviewItem_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IPreviewItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IPreviewItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IPreviewItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IPreviewItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IPreviewItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPreviewItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IPreviewItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IPreviewItem {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x36149969_0a8f_49c8_8b00_4aecb20222fb);
}
pub struct IPreviousVersionsInfo(pub crate::core::IUnknown);
pub trait IPreviousVersionsInfo_Trait: crate::core::IUnknown_Trait {
    fn AreSnapshotsAvailable(
        &self,
        psz_path: PCWSTR,
        f_ok_to_be_slow: super::super::Foundation::BOOL,
        pf_available: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("AreSnapshotsAvailable")
    }
}
impl ::core::clone::Clone for IPreviousVersionsInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPreviousVersionsInfo {}
impl ::core::cmp::PartialEq for IPreviousVersionsInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPreviousVersionsInfo {}
impl ::core::fmt::Debug for IPreviousVersionsInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPreviousVersionsInfo")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IPreviousVersionsInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPreviousVersionsInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x76e54780_ad74_48e3_a695_3ba9a0aff10d);
}
pub struct IProfferService(pub crate::core::IUnknown);
pub trait IProfferService_Trait: crate::core::IUnknown_Trait {
    fn ProfferService(
        &self,
        service_id: ConstPtr<crate::core::GUID>,
        service_provider: super::super::System::Com::IServiceProvider,
        cookie: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("ProfferService")
    }
    fn RevokeService(&self, cookie: u32) -> crate::core::HRESULT {
        todo!("RevokeService")
    }
}
impl ::core::clone::Clone for IProfferService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IProfferService {}
impl ::core::cmp::PartialEq for IProfferService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IProfferService {}
impl ::core::fmt::Debug for IProfferService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IProfferService").field(&self.0).finish()
    }
}
impl FromIntoMemory for IProfferService {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IProfferService {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xcb728b20_f786_11ce_92ad_00aa00a74cd0);
}
pub struct IProgressDialog(pub crate::core::IUnknown);
pub trait IProgressDialog_Trait: crate::core::IUnknown_Trait {
    fn StartProgressDialog(
        &self,
        hwnd_parent: super::super::Foundation::HWND,
        punk_enable_modless: crate::core::IUnknown,
        dw_flags: u32,
        pv_resevered: ConstPtr<::core::ffi::c_void>,
    ) -> crate::core::HRESULT {
        todo!("StartProgressDialog")
    }
    fn StopProgressDialog(&self) -> crate::core::HRESULT {
        todo!("StopProgressDialog")
    }
    fn SetTitle(&self, pwz_title: PCWSTR) -> crate::core::HRESULT {
        todo!("SetTitle")
    }
    fn SetAnimation(
        &self,
        h_inst_animation: super::super::Foundation::HINSTANCE,
        id_animation: u32,
    ) -> crate::core::HRESULT {
        todo!("SetAnimation")
    }
    fn HasUserCancelled(&self) -> super::super::Foundation::BOOL {
        todo!("HasUserCancelled")
    }
    fn SetProgress(&self, dw_completed: u32, dw_total: u32) -> crate::core::HRESULT {
        todo!("SetProgress")
    }
    fn SetProgress64(&self, ull_completed: u64, ull_total: u64) -> crate::core::HRESULT {
        todo!("SetProgress64")
    }
    fn SetLine(
        &self,
        dw_line_num: u32,
        pwz_string: PCWSTR,
        f_compact_path: super::super::Foundation::BOOL,
        pv_resevered: ConstPtr<::core::ffi::c_void>,
    ) -> crate::core::HRESULT {
        todo!("SetLine")
    }
    fn SetCancelMsg(
        &self,
        pwz_cancel_msg: PCWSTR,
        pv_resevered: ConstPtr<::core::ffi::c_void>,
    ) -> crate::core::HRESULT {
        todo!("SetCancelMsg")
    }
    fn Timer(
        &self,
        dw_timer_action: u32,
        pv_resevered: ConstPtr<::core::ffi::c_void>,
    ) -> crate::core::HRESULT {
        todo!("Timer")
    }
}
impl ::core::clone::Clone for IProgressDialog {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IProgressDialog {}
impl ::core::cmp::PartialEq for IProgressDialog {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IProgressDialog {}
impl ::core::fmt::Debug for IProgressDialog {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IProgressDialog").field(&self.0).finish()
    }
}
impl FromIntoMemory for IProgressDialog {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IProgressDialog {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xebbc7c04_315e_11d2_b62f_006097df5bd4);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IPropertyKeyStore(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IPropertyKeyStore_Trait: crate::core::IUnknown_Trait {
    fn GetKeyCount(&self, key_count: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetKeyCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetKeyAt(
        &self,
        index: i32,
        pkey: MutPtr<PropertiesSystem::PROPERTYKEY>,
    ) -> crate::core::HRESULT {
        todo!("GetKeyAt")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AppendKey(&self, key: ConstPtr<PropertiesSystem::PROPERTYKEY>) -> crate::core::HRESULT {
        todo!("AppendKey")
    }
    fn DeleteKey(&self, index: i32) -> crate::core::HRESULT {
        todo!("DeleteKey")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IsKeyInStore(&self, key: ConstPtr<PropertiesSystem::PROPERTYKEY>) -> crate::core::HRESULT {
        todo!("IsKeyInStore")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveKey(&self, key: ConstPtr<PropertiesSystem::PROPERTYKEY>) -> crate::core::HRESULT {
        todo!("RemoveKey")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IPropertyKeyStore {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IPropertyKeyStore {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IPropertyKeyStore {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IPropertyKeyStore {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IPropertyKeyStore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPropertyKeyStore").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IPropertyKeyStore {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IPropertyKeyStore {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x75bd59aa_f23b_4963_aba4_0b355752a91b);
}
pub struct IPublishedApp(pub crate::core::IUnknown);
pub trait IPublishedApp_Trait: IShellApp_Trait {
    fn Install(
        &self,
        pst_install: ConstPtr<super::super::Foundation::SYSTEMTIME>,
    ) -> crate::core::HRESULT {
        todo!("Install")
    }
    fn GetPublishedAppInfo(&self, ppai: MutPtr<PUBAPPINFO>) -> crate::core::HRESULT {
        todo!("GetPublishedAppInfo")
    }
    fn Unschedule(&self) -> crate::core::HRESULT {
        todo!("Unschedule")
    }
}
impl ::core::clone::Clone for IPublishedApp {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPublishedApp {}
impl ::core::cmp::PartialEq for IPublishedApp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPublishedApp {}
impl ::core::fmt::Debug for IPublishedApp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPublishedApp").field(&self.0).finish()
    }
}
impl FromIntoMemory for IPublishedApp {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPublishedApp {
    type Super = IShellApp;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x1bc752e0_9046_11d1_b8b3_006008059382);
}
pub struct IPublishedApp2(pub crate::core::IUnknown);
pub trait IPublishedApp2_Trait: IPublishedApp_Trait {
    fn Install2(
        &self,
        pst_install: ConstPtr<super::super::Foundation::SYSTEMTIME>,
        hwnd_parent: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("Install2")
    }
}
impl ::core::clone::Clone for IPublishedApp2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IPublishedApp2 {}
impl ::core::cmp::PartialEq for IPublishedApp2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPublishedApp2 {}
impl ::core::fmt::Debug for IPublishedApp2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPublishedApp2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IPublishedApp2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IPublishedApp2 {
    type Super = IPublishedApp;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x12b81347_1b3a_4a04_aa61_3f768b67fd7e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IPublishingWizard(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IPublishingWizard_Trait: IWizardExtension_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(
        &self,
        pdo: super::super::System::Com::IDataObject,
        dw_options: u32,
        psz_service_scope: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetTransferManifest(
        &self,
        phr_from_transfer: MutPtr<crate::core::HRESULT>,
        pdoc_manifest: MutPtr<super::super::Data::Xml::MsXml::IXMLDOMDocument>,
    ) -> crate::core::HRESULT {
        todo!("GetTransferManifest")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IPublishingWizard {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IPublishingWizard {}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IPublishingWizard {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IPublishingWizard {}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IPublishingWizard {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPublishingWizard").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IPublishingWizard {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Data.Xml.MsXml', 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IPublishingWizard {
    type Super = IWizardExtension;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xaa9198bb_ccec_472d_beed_19a4f6733f7a);
}
pub struct IQueryAssociations(pub crate::core::IUnknown);
pub trait IQueryAssociations_Trait: crate::core::IUnknown_Trait {
    fn Init(
        &self,
        flags: u32,
        psz_assoc: PCWSTR,
        hk_progid: super::super::System::Registry::HKEY,
        hwnd: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("Init")
    }
    fn GetString(
        &self,
        flags: u32,
        str: ASSOCSTR,
        psz_extra: PCWSTR,
        psz_out: PWSTR,
        pcch_out: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetString")
    }
    fn GetKey(
        &self,
        flags: u32,
        key: ASSOCKEY,
        psz_extra: PCWSTR,
        phkey_out: MutPtr<super::super::System::Registry::HKEY>,
    ) -> crate::core::HRESULT {
        todo!("GetKey")
    }
    fn GetData(
        &self,
        flags: u32,
        data: ASSOCDATA,
        psz_extra: PCWSTR,
        pv_out: MutPtr<::core::ffi::c_void>,
        pcb_out: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetData")
    }
    fn GetEnum(
        &self,
        flags: u32,
        assocenum: ASSOCENUM,
        psz_extra: PCWSTR,
        riid: ConstPtr<crate::core::GUID>,
        ppv_out: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetEnum")
    }
}
impl ::core::clone::Clone for IQueryAssociations {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IQueryAssociations {}
impl ::core::cmp::PartialEq for IQueryAssociations {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQueryAssociations {}
impl ::core::fmt::Debug for IQueryAssociations {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQueryAssociations").field(&self.0).finish()
    }
}
impl FromIntoMemory for IQueryAssociations {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IQueryAssociations {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc46ca590_3c3f_11d2_bee6_0000f805ca57);
}
pub struct IQueryCancelAutoPlay(pub crate::core::IUnknown);
pub trait IQueryCancelAutoPlay_Trait: crate::core::IUnknown_Trait {
    fn AllowAutoPlay(
        &self,
        psz_path: PCWSTR,
        dw_content_type: u32,
        psz_label: PCWSTR,
        dw_serial_number: u32,
    ) -> crate::core::HRESULT {
        todo!("AllowAutoPlay")
    }
}
impl ::core::clone::Clone for IQueryCancelAutoPlay {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IQueryCancelAutoPlay {}
impl ::core::cmp::PartialEq for IQueryCancelAutoPlay {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQueryCancelAutoPlay {}
impl ::core::fmt::Debug for IQueryCancelAutoPlay {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQueryCancelAutoPlay")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IQueryCancelAutoPlay {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IQueryCancelAutoPlay {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xddefe873_6997_4e68_be26_39b633adbe12);
}
pub struct IQueryCodePage(pub crate::core::IUnknown);
pub trait IQueryCodePage_Trait: crate::core::IUnknown_Trait {
    fn GetCodePage(&self, pui_code_page: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCodePage")
    }
    fn SetCodePage(&self, ui_code_page: u32) -> crate::core::HRESULT {
        todo!("SetCodePage")
    }
}
impl ::core::clone::Clone for IQueryCodePage {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IQueryCodePage {}
impl ::core::cmp::PartialEq for IQueryCodePage {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQueryCodePage {}
impl ::core::fmt::Debug for IQueryCodePage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQueryCodePage").field(&self.0).finish()
    }
}
impl FromIntoMemory for IQueryCodePage {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IQueryCodePage {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc7b236ce_ee80_11d0_985f_006008059382);
}
pub struct IQueryContinue(pub crate::core::IUnknown);
pub trait IQueryContinue_Trait: crate::core::IUnknown_Trait {
    fn QueryContinue(&self) -> crate::core::HRESULT {
        todo!("QueryContinue")
    }
}
impl ::core::clone::Clone for IQueryContinue {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IQueryContinue {}
impl ::core::cmp::PartialEq for IQueryContinue {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQueryContinue {}
impl ::core::fmt::Debug for IQueryContinue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQueryContinue").field(&self.0).finish()
    }
}
impl FromIntoMemory for IQueryContinue {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IQueryContinue {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7307055c_b24a_486b_9f25_163e597a28a9);
}
pub struct IQueryContinueWithStatus(pub crate::core::IUnknown);
pub trait IQueryContinueWithStatus_Trait: IQueryContinue_Trait {
    fn SetStatusMessage(&self, psz: PCWSTR) -> crate::core::HRESULT {
        todo!("SetStatusMessage")
    }
}
impl ::core::clone::Clone for IQueryContinueWithStatus {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IQueryContinueWithStatus {}
impl ::core::cmp::PartialEq for IQueryContinueWithStatus {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQueryContinueWithStatus {}
impl ::core::fmt::Debug for IQueryContinueWithStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQueryContinueWithStatus")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IQueryContinueWithStatus {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IQueryContinueWithStatus {
    type Super = IQueryContinue;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9090be5b_502b_41fb_bccc_0049a6c7254b);
}
pub struct IQueryInfo(pub crate::core::IUnknown);
pub trait IQueryInfo_Trait: crate::core::IUnknown_Trait {
    fn GetInfoTip(&self, dw_flags: QITIPF_FLAGS, ppwsz_tip: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetInfoTip")
    }
    fn GetInfoFlags(&self, pdw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetInfoFlags")
    }
}
impl ::core::clone::Clone for IQueryInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IQueryInfo {}
impl ::core::cmp::PartialEq for IQueryInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IQueryInfo {}
impl ::core::fmt::Debug for IQueryInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IQueryInfo").field(&self.0).finish()
    }
}
impl FromIntoMemory for IQueryInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IQueryInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x00021500_0000_0000_c000_000000000046);
}
pub const IRTIR_TASK_FINISHED: u32 = 4u32;
pub const IRTIR_TASK_NOT_RUNNING: u32 = 0u32;
pub const IRTIR_TASK_PENDING: u32 = 3u32;
pub const IRTIR_TASK_RUNNING: u32 = 1u32;
pub const IRTIR_TASK_SUSPENDED: u32 = 2u32;
pub struct IRegTreeItem(pub crate::core::IUnknown);
pub trait IRegTreeItem_Trait: crate::core::IUnknown_Trait {
    fn GetCheckState(
        &self,
        pb_check: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetCheckState")
    }
    fn SetCheckState(&self, b_check: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetCheckState")
    }
}
impl ::core::clone::Clone for IRegTreeItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IRegTreeItem {}
impl ::core::cmp::PartialEq for IRegTreeItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IRegTreeItem {}
impl ::core::fmt::Debug for IRegTreeItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IRegTreeItem").field(&self.0).finish()
    }
}
impl FromIntoMemory for IRegTreeItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IRegTreeItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa9521922_0812_4d44_9ec3_7fd38c726f3d);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IRelatedItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IRelatedItem_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemIDList(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetItemIDList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItem(&self, ppsi: MutPtr<IShellItem>) -> crate::core::HRESULT {
        todo!("GetItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IRelatedItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IRelatedItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IRelatedItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IRelatedItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IRelatedItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IRelatedItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IRelatedItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IRelatedItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa73ce67a_8ab1_44f1_8d43_d2fcbf6b1cd0);
}
pub struct IRemoteComputer(pub crate::core::IUnknown);
pub trait IRemoteComputer_Trait: crate::core::IUnknown_Trait {
    fn Initialize(
        &self,
        psz_machine: PCWSTR,
        b_enumerating: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
impl ::core::clone::Clone for IRemoteComputer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IRemoteComputer {}
impl ::core::cmp::PartialEq for IRemoteComputer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IRemoteComputer {}
impl ::core::fmt::Debug for IRemoteComputer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IRemoteComputer").field(&self.0).finish()
    }
}
impl FromIntoMemory for IRemoteComputer {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IRemoteComputer {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214fe_0000_0000_c000_000000000046);
}
pub struct IResolveShellLink(pub crate::core::IUnknown);
pub trait IResolveShellLink_Trait: crate::core::IUnknown_Trait {
    fn ResolveShellLink(
        &self,
        punk_link: crate::core::IUnknown,
        hwnd: super::super::Foundation::HWND,
        f_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("ResolveShellLink")
    }
}
impl ::core::clone::Clone for IResolveShellLink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IResolveShellLink {}
impl ::core::cmp::PartialEq for IResolveShellLink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IResolveShellLink {}
impl ::core::fmt::Debug for IResolveShellLink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IResolveShellLink").field(&self.0).finish()
    }
}
impl FromIntoMemory for IResolveShellLink {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IResolveShellLink {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x5cd52983_9449_11d2_963a_00c04f79adf0);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IResultsFolder(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IResultsFolder_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddItem(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("AddItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddIDList(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        ppidl_added: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("AddIDList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveItem(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("RemoveItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveIDList(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("RemoveIDList")
    }
    fn RemoveAll(&self) -> crate::core::HRESULT {
        todo!("RemoveAll")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IResultsFolder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IResultsFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IResultsFolder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IResultsFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IResultsFolder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IResultsFolder").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IResultsFolder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IResultsFolder {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x96e5ae6d_6ae1_4b1c_900c_c6480eaa8828);
}
pub struct IRunnableTask(pub crate::core::IUnknown);
pub trait IRunnableTask_Trait: crate::core::IUnknown_Trait {
    fn Run(&self) -> crate::core::HRESULT {
        todo!("Run")
    }
    fn Kill(&self, b_wait: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("Kill")
    }
    fn Suspend(&self) -> crate::core::HRESULT {
        todo!("Suspend")
    }
    fn Resume(&self) -> crate::core::HRESULT {
        todo!("Resume")
    }
    fn IsRunning(&self) -> u32 {
        todo!("IsRunning")
    }
}
impl ::core::clone::Clone for IRunnableTask {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IRunnableTask {}
impl ::core::cmp::PartialEq for IRunnableTask {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IRunnableTask {}
impl ::core::fmt::Debug for IRunnableTask {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IRunnableTask").field(&self.0).finish()
    }
}
impl FromIntoMemory for IRunnableTask {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IRunnableTask {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x85788d00_6807_11d0_b810_00c04fd706ec);
}
pub const ISFBVIEWMODE_LARGEICONS: u32 = 2u32;
pub const ISFBVIEWMODE_LOGOS: u32 = 3u32;
pub const ISFBVIEWMODE_SMALLICONS: u32 = 1u32;
pub const ISFB_MASK_BKCOLOR: u32 = 2u32;
pub const ISFB_MASK_COLORS: u32 = 32u32;
pub const ISFB_MASK_IDLIST: u32 = 16u32;
pub const ISFB_MASK_SHELLFOLDER: u32 = 8u32;
pub const ISFB_MASK_STATE: u32 = 1u32;
pub const ISFB_MASK_VIEWMODE: u32 = 4u32;
pub const ISFB_STATE_ALLOWRENAME: u32 = 2u32;
pub const ISFB_STATE_BTNMINSIZE: u32 = 256u32;
pub const ISFB_STATE_CHANNELBAR: u32 = 16u32;
pub const ISFB_STATE_DEBOSSED: u32 = 1u32;
pub const ISFB_STATE_DEFAULT: u32 = 0u32;
pub const ISFB_STATE_FULLOPEN: u32 = 64u32;
pub const ISFB_STATE_NONAMESORT: u32 = 128u32;
pub const ISFB_STATE_NOSHOWTEXT: u32 = 4u32;
pub const ISFB_STATE_QLINKSMODE: u32 = 32u32;
pub const ISHCUTCMDID_COMMITHISTORY: i32 = 2i32;
pub const ISHCUTCMDID_DOWNLOADICON: i32 = 0i32;
pub const ISHCUTCMDID_INTSHORTCUTCREATE: i32 = 1i32;
pub const ISHCUTCMDID_SETUSERAWURL: i32 = 3i32;
pub const ISIOI_ICONFILE: u32 = 1u32;
pub const ISIOI_ICONINDEX: u32 = 2u32;
pub const IS_E_EXEC_FAILED: crate::core::HRESULT = crate::core::HRESULT(-2147213310i32);
pub const IS_FULLSCREEN: u32 = 2u32;
pub const IS_NORMAL: u32 = 1u32;
pub const IS_SPLIT: u32 = 4u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IScriptErrorList(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IScriptErrorList_Trait: super::super::System::Com::IDispatch_Trait {
    fn advanceError(&self) -> crate::core::HRESULT {
        todo!("advanceError")
    }
    fn retreatError(&self) -> crate::core::HRESULT {
        todo!("retreatError")
    }
    fn canAdvanceError(
        &self,
        pf_can_advance: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("canAdvanceError")
    }
    fn canRetreatError(
        &self,
        pf_can_retreat: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("canRetreatError")
    }
    fn getErrorLine(&self, pl_line: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("getErrorLine")
    }
    fn getErrorChar(&self, pl_char: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("getErrorChar")
    }
    fn getErrorCode(&self, pl_code: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("getErrorCode")
    }
    fn getErrorMsg(&self, pstr: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("getErrorMsg")
    }
    fn getErrorUrl(&self, pstr: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("getErrorUrl")
    }
    fn getAlwaysShowLockState(
        &self,
        pf_always_show_locked: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("getAlwaysShowLockState")
    }
    fn getDetailsPaneOpen(
        &self,
        pf_details_pane_open: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("getDetailsPaneOpen")
    }
    fn setDetailsPaneOpen(
        &self,
        f_details_pane_open: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("setDetailsPaneOpen")
    }
    fn getPerErrorDisplay(
        &self,
        pf_per_error_display: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("getPerErrorDisplay")
    }
    fn setPerErrorDisplay(
        &self,
        f_per_error_display: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("setPerErrorDisplay")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IScriptErrorList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IScriptErrorList {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IScriptErrorList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IScriptErrorList {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IScriptErrorList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IScriptErrorList").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IScriptErrorList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IScriptErrorList {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf3470f24_15fd_11d2_bb2e_00805ff7efca);
}
pub struct ISearchBoxInfo(pub crate::core::IUnknown);
pub trait ISearchBoxInfo_Trait: crate::core::IUnknown_Trait {
    fn GetCondition(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetCondition")
    }
    fn GetText(&self, ppsz: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetText")
    }
}
impl ::core::clone::Clone for ISearchBoxInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISearchBoxInfo {}
impl ::core::cmp::PartialEq for ISearchBoxInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISearchBoxInfo {}
impl ::core::fmt::Debug for ISearchBoxInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISearchBoxInfo").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISearchBoxInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISearchBoxInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6af6e03f_d664_4ef4_9626_f7e0ed36755e);
}
pub struct ISearchContext(pub crate::core::IUnknown);
pub trait ISearchContext_Trait: crate::core::IUnknown_Trait {
    fn GetSearchUrl(
        &self,
        pbstr_search_url: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetSearchUrl")
    }
    fn GetSearchText(
        &self,
        pbstr_search_text: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetSearchText")
    }
    fn GetSearchStyle(&self, pdw_search_style: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetSearchStyle")
    }
}
impl ::core::clone::Clone for ISearchContext {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISearchContext {}
impl ::core::cmp::PartialEq for ISearchContext {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISearchContext {}
impl ::core::fmt::Debug for ISearchContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISearchContext").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISearchContext {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISearchContext {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x09f656a2_41af_480c_88f7_16cc0d164615);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISearchFolderItemFactory(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISearchFolderItemFactory_Trait: crate::core::IUnknown_Trait {
    fn SetDisplayName(&self, psz_display_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetDisplayName")
    }
    fn SetFolderTypeID(&self, ftid: crate::core::GUID) -> crate::core::HRESULT {
        todo!("SetFolderTypeID")
    }
    fn SetFolderLogicalViewMode(&self, flvm: FOLDERLOGICALVIEWMODE) -> crate::core::HRESULT {
        todo!("SetFolderLogicalViewMode")
    }
    fn SetIconSize(&self, i_icon_size: i32) -> crate::core::HRESULT {
        todo!("SetIconSize")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetVisibleColumns(
        &self,
        c_visible_columns: u32,
        rg_key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
    ) -> crate::core::HRESULT {
        todo!("SetVisibleColumns")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetSortColumns(
        &self,
        c_sort_columns: u32,
        rg_sort_columns: ConstPtr<SORTCOLUMN>,
    ) -> crate::core::HRESULT {
        todo!("SetSortColumns")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetGroupColumn(
        &self,
        key_group: ConstPtr<PropertiesSystem::PROPERTYKEY>,
    ) -> crate::core::HRESULT {
        todo!("SetGroupColumn")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetStacks(
        &self,
        c_stack_keys: u32,
        rg_stack_keys: ConstPtr<PropertiesSystem::PROPERTYKEY>,
    ) -> crate::core::HRESULT {
        todo!("SetStacks")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetScope(&self, psia_scope: IShellItemArray) -> crate::core::HRESULT {
        todo!("SetScope")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetCondition(
        &self,
        p_condition: super::super::System::Search::ICondition,
    ) -> crate::core::HRESULT {
        todo!("SetCondition")
    }
    fn GetShellItem(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetShellItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIDList(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetIDList")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISearchFolderItemFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISearchFolderItemFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISearchFolderItemFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISearchFolderItemFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISearchFolderItemFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISearchFolderItemFactory")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISearchFolderItemFactory {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.System.Search.Common', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISearchFolderItemFactory {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa0ffbc28_5482_4366_be27_3e81e78e06c2);
}
pub struct ISharedBitmap(pub crate::core::IUnknown);
pub trait ISharedBitmap_Trait: crate::core::IUnknown_Trait {
    fn GetSharedBitmap(
        &self,
        phbm: MutPtr<super::super::Graphics::Gdi::HBITMAP>,
    ) -> crate::core::HRESULT {
        todo!("GetSharedBitmap")
    }
    fn GetSize(&self, p_size: MutPtr<super::super::Foundation::SIZE>) -> crate::core::HRESULT {
        todo!("GetSize")
    }
    fn GetFormat(&self, pat: MutPtr<WTS_ALPHATYPE>) -> crate::core::HRESULT {
        todo!("GetFormat")
    }
    fn InitializeBitmap(
        &self,
        hbm: super::super::Graphics::Gdi::HBITMAP,
        wts_at: WTS_ALPHATYPE,
    ) -> crate::core::HRESULT {
        todo!("InitializeBitmap")
    }
    fn Detach(&self, phbm: MutPtr<super::super::Graphics::Gdi::HBITMAP>) -> crate::core::HRESULT {
        todo!("Detach")
    }
}
impl ::core::clone::Clone for ISharedBitmap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISharedBitmap {}
impl ::core::cmp::PartialEq for ISharedBitmap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISharedBitmap {}
impl ::core::fmt::Debug for ISharedBitmap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISharedBitmap").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISharedBitmap {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISharedBitmap {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x091162a4_bc96_411f_aae8_c5122cd03363);
}
pub struct ISharingConfigurationManager(pub crate::core::IUnknown);
pub trait ISharingConfigurationManager_Trait: crate::core::IUnknown_Trait {
    fn CreateShare(&self, dsid: DEF_SHARE_ID, role: SHARE_ROLE) -> crate::core::HRESULT {
        todo!("CreateShare")
    }
    fn DeleteShare(&self, dsid: DEF_SHARE_ID) -> crate::core::HRESULT {
        todo!("DeleteShare")
    }
    fn ShareExists(&self, dsid: DEF_SHARE_ID) -> crate::core::HRESULT {
        todo!("ShareExists")
    }
    fn GetSharePermissions(
        &self,
        dsid: DEF_SHARE_ID,
        p_role: MutPtr<SHARE_ROLE>,
    ) -> crate::core::HRESULT {
        todo!("GetSharePermissions")
    }
    fn SharePrinters(&self) -> crate::core::HRESULT {
        todo!("SharePrinters")
    }
    fn StopSharingPrinters(&self) -> crate::core::HRESULT {
        todo!("StopSharingPrinters")
    }
    fn ArePrintersShared(&self) -> crate::core::HRESULT {
        todo!("ArePrintersShared")
    }
}
impl ::core::clone::Clone for ISharingConfigurationManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISharingConfigurationManager {}
impl ::core::cmp::PartialEq for ISharingConfigurationManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISharingConfigurationManager {}
impl ::core::fmt::Debug for ISharingConfigurationManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISharingConfigurationManager")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISharingConfigurationManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISharingConfigurationManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb4cd448a_9c86_4466_9201_2e62105b87ae);
}
pub struct IShellApp(pub crate::core::IUnknown);
pub trait IShellApp_Trait: crate::core::IUnknown_Trait {
    fn GetAppInfo(&self, pai: MutPtr<APPINFODATA>) -> crate::core::HRESULT {
        todo!("GetAppInfo")
    }
    fn GetPossibleActions(&self, pdw_actions: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetPossibleActions")
    }
    fn GetSlowAppInfo(&self, psaid: MutPtr<SLOWAPPINFO>) -> crate::core::HRESULT {
        todo!("GetSlowAppInfo")
    }
    fn GetCachedSlowAppInfo(&self, psaid: MutPtr<SLOWAPPINFO>) -> crate::core::HRESULT {
        todo!("GetCachedSlowAppInfo")
    }
    fn IsInstalled(&self) -> crate::core::HRESULT {
        todo!("IsInstalled")
    }
}
impl ::core::clone::Clone for IShellApp {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellApp {}
impl ::core::cmp::PartialEq for IShellApp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellApp {}
impl ::core::fmt::Debug for IShellApp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellApp").field(&self.0).finish()
    }
}
impl FromIntoMemory for IShellApp {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellApp {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa3e14960_935f_11d1_b8b8_006008059382);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellBrowser(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellBrowser_Trait: super::super::System::Ole::IOleWindow_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.System.Ole', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InsertMenusSB(
        &self,
        hmenu_shared: super::WindowsAndMessaging::HMENU,
        lp_menu_widths: MutPtr<super::super::System::Ole::OleMenuGroupWidths>,
    ) -> crate::core::HRESULT {
        todo!("InsertMenusSB")
    }
    fn SetMenuSB(
        &self,
        hmenu_shared: super::WindowsAndMessaging::HMENU,
        holemenu_res: PtrDiffRepr,
        hwnd_active_object: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("SetMenuSB")
    }
    fn RemoveMenusSB(
        &self,
        hmenu_shared: super::WindowsAndMessaging::HMENU,
    ) -> crate::core::HRESULT {
        todo!("RemoveMenusSB")
    }
    fn SetStatusTextSB(&self, psz_status_text: PCWSTR) -> crate::core::HRESULT {
        todo!("SetStatusTextSB")
    }
    fn EnableModelessSB(&self, f_enable: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("EnableModelessSB")
    }
    fn TranslateAcceleratorSB(
        &self,
        pmsg: ConstPtr<super::WindowsAndMessaging::MSG>,
        w_id: u16,
    ) -> crate::core::HRESULT {
        todo!("TranslateAcceleratorSB")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BrowseObject(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        w_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("BrowseObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetViewStateStream(
        &self,
        grf_mode: u32,
        pp_strm: MutPtr<super::super::System::Com::IStream>,
    ) -> crate::core::HRESULT {
        todo!("GetViewStateStream")
    }
    fn GetControlWindow(
        &self,
        id: u32,
        phwnd: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("GetControlWindow")
    }
    fn SendControlMsg(
        &self,
        id: u32,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
        pret: MutPtr<super::super::Foundation::LRESULT>,
    ) -> crate::core::HRESULT {
        todo!("SendControlMsg")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn QueryActiveShellView(&self, ppshv: MutPtr<IShellView>) -> crate::core::HRESULT {
        todo!("QueryActiveShellView")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnViewWindowActive(&self, pshv: IShellView) -> crate::core::HRESULT {
        todo!("OnViewWindowActive")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetToolbarItems(
        &self,
        lp_buttons: ConstPtr<super::Controls::TBBUTTON>,
        n_buttons: u32,
        u_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetToolbarItems")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellBrowser {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellBrowser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellBrowser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellBrowser").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellBrowser {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellBrowser {
    type Super = super::super::System::Ole::IOleWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e2_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellChangeNotify(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellChangeNotify_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnChange(
        &self,
        l_event: i32,
        pidl_1: ConstPtr<Common::ITEMIDLIST>,
        pidl_2: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("OnChange")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellChangeNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellChangeNotify {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellChangeNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellChangeNotify {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellChangeNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellChangeNotify").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellChangeNotify {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellChangeNotify {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd82be2b1_5764_11d0_a96e_00c04fd705a2);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellDetails(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellDetails_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDetailsOf(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        i_column: u32,
        p_details: MutPtr<Common::SHELLDETAILS>,
    ) -> crate::core::HRESULT {
        todo!("GetDetailsOf")
    }
    fn ColumnClick(&self, i_column: u32) -> crate::core::HRESULT {
        todo!("ColumnClick")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellDetails {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellDetails {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellDetails {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellDetails {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellDetails {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellDetails").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellDetails {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellDetails {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214ec_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellDispatch(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellDispatch_Trait: super::super::System::Com::IDispatch_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn NameSpace(
        &self,
        v_dir: super::super::System::Com::VARIANT,
        ppsdf: MutPtr<Folder>,
    ) -> crate::core::HRESULT {
        todo!("NameSpace")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BrowseForFolder(
        &self,
        hwnd: i32,
        title: super::super::Foundation::BSTR,
        options: i32,
        root_folder: super::super::System::Com::VARIANT,
        ppsdf: MutPtr<Folder>,
    ) -> crate::core::HRESULT {
        todo!("BrowseForFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Windows(&self, ppid: MutPtr<super::super::System::Com::IDispatch>) -> crate::core::HRESULT {
        todo!("Windows")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Open(&self, v_dir: super::super::System::Com::VARIANT) -> crate::core::HRESULT {
        todo!("Open")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Explore(&self, v_dir: super::super::System::Com::VARIANT) -> crate::core::HRESULT {
        todo!("Explore")
    }
    fn MinimizeAll(&self) -> crate::core::HRESULT {
        todo!("MinimizeAll")
    }
    fn UndoMinimizeALL(&self) -> crate::core::HRESULT {
        todo!("UndoMinimizeALL")
    }
    fn FileRun(&self) -> crate::core::HRESULT {
        todo!("FileRun")
    }
    fn CascadeWindows(&self) -> crate::core::HRESULT {
        todo!("CascadeWindows")
    }
    fn TileVertically(&self) -> crate::core::HRESULT {
        todo!("TileVertically")
    }
    fn TileHorizontally(&self) -> crate::core::HRESULT {
        todo!("TileHorizontally")
    }
    fn ShutdownWindows(&self) -> crate::core::HRESULT {
        todo!("ShutdownWindows")
    }
    fn Suspend(&self) -> crate::core::HRESULT {
        todo!("Suspend")
    }
    fn EjectPC(&self) -> crate::core::HRESULT {
        todo!("EjectPC")
    }
    fn SetTime(&self) -> crate::core::HRESULT {
        todo!("SetTime")
    }
    fn TrayProperties(&self) -> crate::core::HRESULT {
        todo!("TrayProperties")
    }
    fn Help(&self) -> crate::core::HRESULT {
        todo!("Help")
    }
    fn FindFiles(&self) -> crate::core::HRESULT {
        todo!("FindFiles")
    }
    fn FindComputer(&self) -> crate::core::HRESULT {
        todo!("FindComputer")
    }
    fn RefreshMenu(&self) -> crate::core::HRESULT {
        todo!("RefreshMenu")
    }
    fn ControlPanelItem(&self, bstr_dir: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("ControlPanelItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellDispatch {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellDispatch {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellDispatch {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellDispatch {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellDispatch {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellDispatch").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellDispatch {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellDispatch {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd8f015c0_c278_11ce_a49e_444553540000);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellDispatch2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellDispatch2_Trait: IShellDispatch_Trait {
    fn IsRestricted(
        &self,
        group: super::super::Foundation::BSTR,
        restriction: super::super::Foundation::BSTR,
        pl_restrict_value: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("IsRestricted")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ShellExecute(
        &self,
        file: super::super::Foundation::BSTR,
        v_args: super::super::System::Com::VARIANT,
        v_dir: super::super::System::Com::VARIANT,
        v_operation: super::super::System::Com::VARIANT,
        v_show: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("ShellExecute")
    }
    fn FindPrinter(
        &self,
        name: super::super::Foundation::BSTR,
        location: super::super::Foundation::BSTR,
        model: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("FindPrinter")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSystemInformation(
        &self,
        name: super::super::Foundation::BSTR,
        pv: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetSystemInformation")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ServiceStart(
        &self,
        service_name: super::super::Foundation::BSTR,
        persistent: super::super::System::Com::VARIANT,
        p_success: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ServiceStart")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ServiceStop(
        &self,
        service_name: super::super::Foundation::BSTR,
        persistent: super::super::System::Com::VARIANT,
        p_success: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ServiceStop")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IsServiceRunning(
        &self,
        service_name: super::super::Foundation::BSTR,
        p_running: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("IsServiceRunning")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CanStartStopService(
        &self,
        service_name: super::super::Foundation::BSTR,
        p_can_start_stop: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("CanStartStopService")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ShowBrowserBar(
        &self,
        bstr_clsid: super::super::Foundation::BSTR,
        b_show: super::super::System::Com::VARIANT,
        p_success: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ShowBrowserBar")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellDispatch2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellDispatch2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellDispatch2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellDispatch2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellDispatch2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellDispatch2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellDispatch2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellDispatch2 {
    type Super = IShellDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa4c6892c_3ba9_11d2_9dea_00c04fb16162);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellDispatch3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellDispatch3_Trait: IShellDispatch2_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddToRecent(
        &self,
        var_file: super::super::System::Com::VARIANT,
        bstr_category: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("AddToRecent")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellDispatch3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellDispatch3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellDispatch3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellDispatch3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellDispatch3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellDispatch3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellDispatch3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellDispatch3 {
    type Super = IShellDispatch2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x177160ca_bb5a_411c_841d_bd38facdeaa0);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellDispatch4(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellDispatch4_Trait: IShellDispatch3_Trait {
    fn WindowsSecurity(&self) -> crate::core::HRESULT {
        todo!("WindowsSecurity")
    }
    fn ToggleDesktop(&self) -> crate::core::HRESULT {
        todo!("ToggleDesktop")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ExplorerPolicy(
        &self,
        bstr_policy_name: super::super::Foundation::BSTR,
        p_value: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ExplorerPolicy")
    }
    fn GetSetting(&self, l_setting: i32, p_result: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("GetSetting")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellDispatch4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellDispatch4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellDispatch4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellDispatch4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellDispatch4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellDispatch4").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellDispatch4 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellDispatch4 {
    type Super = IShellDispatch3;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xefd84b2d_4bcf_4298_be25_eb542a59fbda);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellDispatch5(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellDispatch5_Trait: IShellDispatch4_Trait {
    fn WindowSwitcher(&self) -> crate::core::HRESULT {
        todo!("WindowSwitcher")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellDispatch5 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellDispatch5 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellDispatch5 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellDispatch5 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellDispatch5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellDispatch5").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellDispatch5 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellDispatch5 {
    type Super = IShellDispatch4;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x866738b9_6cf2_4de8_8767_f794ebe74f4e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellDispatch6(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellDispatch6_Trait: IShellDispatch5_Trait {
    fn SearchCommand(&self) -> crate::core::HRESULT {
        todo!("SearchCommand")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellDispatch6 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellDispatch6 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellDispatch6 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellDispatch6 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellDispatch6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellDispatch6").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellDispatch6 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellDispatch6 {
    type Super = IShellDispatch5;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x286e6f1b_7113_4355_9562_96b7e9d64c54);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellExtInit(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellExtInit_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(
        &self,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
        pdtobj: super::super::System::Com::IDataObject,
        hkey_prog_id: super::super::System::Registry::HKEY,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellExtInit {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellExtInit {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellExtInit {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellExtInit {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellExtInit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellExtInit").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellExtInit {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellExtInit {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e8_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFavoritesNameSpace(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFavoritesNameSpace_Trait: super::super::System::Com::IDispatch_Trait {
    fn MoveSelectionUp(&self) -> crate::core::HRESULT {
        todo!("MoveSelectionUp")
    }
    fn MoveSelectionDown(&self) -> crate::core::HRESULT {
        todo!("MoveSelectionDown")
    }
    fn ResetSort(&self) -> crate::core::HRESULT {
        todo!("ResetSort")
    }
    fn NewFolder(&self) -> crate::core::HRESULT {
        todo!("NewFolder")
    }
    fn Synchronize(&self) -> crate::core::HRESULT {
        todo!("Synchronize")
    }
    fn Import(&self) -> crate::core::HRESULT {
        todo!("Import")
    }
    fn Export(&self) -> crate::core::HRESULT {
        todo!("Export")
    }
    fn InvokeContextMenuCommand(
        &self,
        str_command: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("InvokeContextMenuCommand")
    }
    fn MoveSelectionTo(&self) -> crate::core::HRESULT {
        todo!("MoveSelectionTo")
    }
    fn get_SubscriptionsEnabled(&self, p_bool: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_SubscriptionsEnabled")
    }
    fn CreateSubscriptionForSelection(&self, p_bool: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("CreateSubscriptionForSelection")
    }
    fn DeleteSubscriptionForSelection(&self, p_bool: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("DeleteSubscriptionForSelection")
    }
    fn SetRoot(&self, bstr_full_path: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("SetRoot")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFavoritesNameSpace {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFavoritesNameSpace {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFavoritesNameSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFavoritesNameSpace {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFavoritesNameSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFavoritesNameSpace")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFavoritesNameSpace {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFavoritesNameSpace {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x55136804_b2de_11d1_b9f2_00a0c98bc547);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFolder(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFolder_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ParseDisplayName(
        &self,
        hwnd: super::super::Foundation::HWND,
        pbc: super::super::System::Com::IBindCtx,
        psz_display_name: PCWSTR,
        pch_eaten: MutPtr<u32>,
        ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
        pdw_attributes: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("ParseDisplayName")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EnumObjects(
        &self,
        hwnd: super::super::Foundation::HWND,
        grf_flags: u32,
        ppenum_id_list: MutPtr<IEnumIDList>,
    ) -> crate::core::HRESULT {
        todo!("EnumObjects")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BindToObject(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pbc: super::super::System::Com::IBindCtx,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("BindToObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BindToStorage(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pbc: super::super::System::Com::IBindCtx,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("BindToStorage")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CompareIDs(
        &self,
        l_param: super::super::Foundation::LPARAM,
        pidl_1: ConstPtr<Common::ITEMIDLIST>,
        pidl_2: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("CompareIDs")
    }
    fn CreateViewObject(
        &self,
        hwnd_owner: super::super::Foundation::HWND,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("CreateViewObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetAttributesOf(
        &self,
        cidl: u32,
        apidl: ConstPtr<ConstPtr<Common::ITEMIDLIST>>,
        rgf_in_out: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetAttributesOf")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetUIObjectOf(
        &self,
        hwnd_owner: super::super::Foundation::HWND,
        cidl: u32,
        apidl: ConstPtr<ConstPtr<Common::ITEMIDLIST>>,
        riid: ConstPtr<crate::core::GUID>,
        rgf_reserved: MutPtr<u32>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetUIObjectOf")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDisplayNameOf(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        u_flags: u32,
        p_name: MutPtr<Common::STRRET>,
    ) -> crate::core::HRESULT {
        todo!("GetDisplayNameOf")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetNameOf(
        &self,
        hwnd: super::super::Foundation::HWND,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        psz_name: PCWSTR,
        u_flags: u32,
        ppidl_out: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("SetNameOf")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFolder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFolder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFolder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolder").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFolder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFolder {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e6_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFolder2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFolder2_Trait: IShellFolder_Trait {
    fn GetDefaultSearchGUID(&self, pguid: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetDefaultSearchGUID")
    }
    fn EnumSearches(&self, ppenum: MutPtr<IEnumExtraSearch>) -> crate::core::HRESULT {
        todo!("EnumSearches")
    }
    fn GetDefaultColumn(
        &self,
        dw_res: u32,
        p_sort: MutPtr<u32>,
        p_display: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetDefaultColumn")
    }
    fn GetDefaultColumnState(&self, i_column: u32, pcs_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetDefaultColumnState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDetailsEx(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pscid: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pv: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetDetailsEx")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDetailsOf(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        i_column: u32,
        psd: MutPtr<Common::SHELLDETAILS>,
    ) -> crate::core::HRESULT {
        todo!("GetDetailsOf")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn MapColumnToSCID(
        &self,
        i_column: u32,
        pscid: MutPtr<PropertiesSystem::PROPERTYKEY>,
    ) -> crate::core::HRESULT {
        todo!("MapColumnToSCID")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFolder2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFolder2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFolder2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFolder2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFolder2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolder2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFolder2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFolder2 {
    type Super = IShellFolder;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x93f2f68c_1d1b_11d3_a30e_00c04f79abd1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFolderBand(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFolderBand_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InitializeSFB(
        &self,
        psf: IShellFolder,
        pidl: ConstPtr<Common::ITEMIDLIST>,
    ) -> crate::core::HRESULT {
        todo!("InitializeSFB")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetBandInfoSFB(&self, pbi: ConstPtr<BANDINFOSFB>) -> crate::core::HRESULT {
        todo!("SetBandInfoSFB")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetBandInfoSFB(&self, pbi: MutPtr<BANDINFOSFB>) -> crate::core::HRESULT {
        todo!("GetBandInfoSFB")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFolderBand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFolderBand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFolderBand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFolderBand {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFolderBand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolderBand").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFolderBand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFolderBand {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7fe80cc8_c247_11d0_b93a_00a0c90312e1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFolderView(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFolderView_Trait: crate::core::IUnknown_Trait {
    fn Rearrange(&self, l_param_sort: super::super::Foundation::LPARAM) -> crate::core::HRESULT {
        todo!("Rearrange")
    }
    fn GetArrangeParam(
        &self,
        pl_param_sort: MutPtr<super::super::Foundation::LPARAM>,
    ) -> crate::core::HRESULT {
        todo!("GetArrangeParam")
    }
    fn ArrangeGrid(&self) -> crate::core::HRESULT {
        todo!("ArrangeGrid")
    }
    fn AutoArrange(&self) -> crate::core::HRESULT {
        todo!("AutoArrange")
    }
    fn GetAutoArrange(&self) -> crate::core::HRESULT {
        todo!("GetAutoArrange")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddObject(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pu_item: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("AddObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetObject(
        &self,
        ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
        u_item: u32,
    ) -> crate::core::HRESULT {
        todo!("GetObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveObject(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pu_item: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("RemoveObject")
    }
    fn GetObjectCount(&self, pu_count: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetObjectCount")
    }
    fn SetObjectCount(&self, u_count: u32, dw_flags: u32) -> crate::core::HRESULT {
        todo!("SetObjectCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn UpdateObject(
        &self,
        pidl_old: ConstPtr<Common::ITEMIDLIST>,
        pidl_new: ConstPtr<Common::ITEMIDLIST>,
        pu_item: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("UpdateObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RefreshObject(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        pu_item: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("RefreshObject")
    }
    fn SetRedraw(&self, b_redraw: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetRedraw")
    }
    fn GetSelectedCount(&self, pu_selected: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetSelectedCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetSelectedObjects(
        &self,
        pppidl: MutPtr<ConstPtr<ConstPtr<Common::ITEMIDLIST>>>,
        pu_items: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetSelectedObjects")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IsDropOnSource(
        &self,
        p_drop_target: super::super::System::Ole::IDropTarget,
    ) -> crate::core::HRESULT {
        todo!("IsDropOnSource")
    }
    fn GetDragPoint(&self, ppt: MutPtr<super::super::Foundation::POINT>) -> crate::core::HRESULT {
        todo!("GetDragPoint")
    }
    fn GetDropPoint(&self, ppt: MutPtr<super::super::Foundation::POINT>) -> crate::core::HRESULT {
        todo!("GetDropPoint")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn MoveIcons(
        &self,
        p_data_object: super::super::System::Com::IDataObject,
    ) -> crate::core::HRESULT {
        todo!("MoveIcons")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetItemPos(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        ppt: ConstPtr<super::super::Foundation::POINT>,
    ) -> crate::core::HRESULT {
        todo!("SetItemPos")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IsBkDropTarget(
        &self,
        p_drop_target: super::super::System::Ole::IDropTarget,
    ) -> crate::core::HRESULT {
        todo!("IsBkDropTarget")
    }
    fn SetClipboard(&self, b_move: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("SetClipboard")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetPoints(
        &self,
        p_data_object: super::super::System::Com::IDataObject,
    ) -> crate::core::HRESULT {
        todo!("SetPoints")
    }
    fn GetItemSpacing(&self, p_spacing: MutPtr<ITEMSPACING>) -> crate::core::HRESULT {
        todo!("GetItemSpacing")
    }
    fn SetCallback(
        &self,
        p_new_cb: IShellFolderViewCB,
        pp_old_cb: MutPtr<IShellFolderViewCB>,
    ) -> crate::core::HRESULT {
        todo!("SetCallback")
    }
    fn Select(&self, dw_flags: SFVS_SELECT) -> crate::core::HRESULT {
        todo!("Select")
    }
    fn QuerySupport(&self, pdw_support: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("QuerySupport")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetAutomationObject(
        &self,
        pdisp: super::super::System::Com::IDispatch,
    ) -> crate::core::HRESULT {
        todo!("SetAutomationObject")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFolderView {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFolderView {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFolderView {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFolderView {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFolderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolderView").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFolderView {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFolderView {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x37a378c0_f82d_11ce_ae65_08002b2e1262);
}
pub struct IShellFolderViewCB(pub crate::core::IUnknown);
pub trait IShellFolderViewCB_Trait: crate::core::IUnknown_Trait {
    fn MessageSFVCB(
        &self,
        u_msg: SFVM_MESSAGE_ID,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("MessageSFVCB")
    }
}
impl ::core::clone::Clone for IShellFolderViewCB {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellFolderViewCB {}
impl ::core::cmp::PartialEq for IShellFolderViewCB {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellFolderViewCB {}
impl ::core::fmt::Debug for IShellFolderViewCB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolderViewCB").field(&self.0).finish()
    }
}
impl FromIntoMemory for IShellFolderViewCB {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellFolderViewCB {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2047e320_f2a9_11ce_ae65_08002b2e1262);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFolderViewDual(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFolderViewDual_Trait: super::super::System::Com::IDispatch_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Folder(&self, ppid: MutPtr<Folder>) -> crate::core::HRESULT {
        todo!("get_Folder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SelectedItems(&self, ppid: MutPtr<FolderItems>) -> crate::core::HRESULT {
        todo!("SelectedItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_FocusedItem(&self, ppid: MutPtr<FolderItem>) -> crate::core::HRESULT {
        todo!("get_FocusedItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SelectItem(
        &self,
        pvfi: ConstPtr<super::super::System::Com::VARIANT>,
        dw_flags: i32,
    ) -> crate::core::HRESULT {
        todo!("SelectItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PopupItemMenu(
        &self,
        pfi: FolderItem,
        vx: super::super::System::Com::VARIANT,
        vy: super::super::System::Com::VARIANT,
        pbs: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("PopupItemMenu")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Script(
        &self,
        pp_disp: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Script")
    }
    fn get_ViewOptions(&self, pl_view_options: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_ViewOptions")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFolderViewDual {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFolderViewDual {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFolderViewDual {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFolderViewDual {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFolderViewDual {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolderViewDual")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFolderViewDual {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFolderViewDual {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe7a1af80_4d96_11cf_960c_0080c7f4ee85);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFolderViewDual2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFolderViewDual2_Trait: IShellFolderViewDual_Trait {
    fn get_CurrentViewMode(&self, p_view_mode: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("get_CurrentViewMode")
    }
    fn put_CurrentViewMode(&self, view_mode: u32) -> crate::core::HRESULT {
        todo!("put_CurrentViewMode")
    }
    fn SelectItemRelative(&self, i_relative: i32) -> crate::core::HRESULT {
        todo!("SelectItemRelative")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFolderViewDual2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFolderViewDual2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFolderViewDual2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFolderViewDual2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFolderViewDual2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolderViewDual2")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFolderViewDual2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFolderViewDual2 {
    type Super = IShellFolderViewDual;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x31c147b6_0ade_4a3c_b514_ddf932ef6d17);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellFolderViewDual3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellFolderViewDual3_Trait: IShellFolderViewDual2_Trait {
    fn get_GroupBy(
        &self,
        pbstr_group_by: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_GroupBy")
    }
    fn put_GroupBy(&self, bstr_group_by: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_GroupBy")
    }
    fn get_FolderFlags(&self, pdw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("get_FolderFlags")
    }
    fn put_FolderFlags(&self, dw_flags: u32) -> crate::core::HRESULT {
        todo!("put_FolderFlags")
    }
    fn get_SortColumns(
        &self,
        pbstr_sort_columns: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_SortColumns")
    }
    fn put_SortColumns(
        &self,
        bstr_sort_columns: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("put_SortColumns")
    }
    fn put_IconSize(&self, i_icon_size: i32) -> crate::core::HRESULT {
        todo!("put_IconSize")
    }
    fn get_IconSize(&self, pi_icon_size: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_IconSize")
    }
    fn FilterView(&self, bstr_filter_text: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("FilterView")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellFolderViewDual3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellFolderViewDual3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellFolderViewDual3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellFolderViewDual3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellFolderViewDual3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellFolderViewDual3")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellFolderViewDual3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellFolderViewDual3 {
    type Super = IShellFolderViewDual2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x29ec8e6c_46d3_411f_baaa_611a6c9cac66);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellIcon(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellIcon_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIconOf(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        flags: u32,
        p_icon_index: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetIconOf")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellIcon {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellIcon {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellIcon {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellIcon {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellIcon {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellIcon").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellIcon {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellIcon {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e5_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellIconOverlay(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellIconOverlay_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetOverlayIndex(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        p_index: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayIndex")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetOverlayIconIndex(
        &self,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        p_icon_index: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayIconIndex")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellIconOverlay {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellIconOverlay {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellIconOverlay {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellIconOverlay {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellIconOverlay {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellIconOverlay").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellIconOverlay {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellIconOverlay {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7d688a70_c613_11d0_999b_00c04fd655e1);
}
pub struct IShellIconOverlayIdentifier(pub crate::core::IUnknown);
pub trait IShellIconOverlayIdentifier_Trait: crate::core::IUnknown_Trait {
    fn IsMemberOf(&self, pwsz_path: PCWSTR, dw_attrib: u32) -> crate::core::HRESULT {
        todo!("IsMemberOf")
    }
    fn GetOverlayInfo(
        &self,
        pwsz_icon_file: PWSTR,
        cch_max: i32,
        p_index: MutPtr<i32>,
        pdw_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetOverlayInfo")
    }
    fn GetPriority(&self, p_priority: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetPriority")
    }
}
impl ::core::clone::Clone for IShellIconOverlayIdentifier {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellIconOverlayIdentifier {}
impl ::core::cmp::PartialEq for IShellIconOverlayIdentifier {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellIconOverlayIdentifier {}
impl ::core::fmt::Debug for IShellIconOverlayIdentifier {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellIconOverlayIdentifier")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IShellIconOverlayIdentifier {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellIconOverlayIdentifier {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0c6c4200_c589_11d0_999a_00c04fd655e1);
}
pub struct IShellIconOverlayManager(pub crate::core::IUnknown);
pub trait IShellIconOverlayManager_Trait: crate::core::IUnknown_Trait {
    fn GetFileOverlayInfo(
        &self,
        pwsz_path: PCWSTR,
        dw_attrib: u32,
        p_index: MutPtr<i32>,
        dwflags: u32,
    ) -> crate::core::HRESULT {
        todo!("GetFileOverlayInfo")
    }
    fn GetReservedOverlayInfo(
        &self,
        pwsz_path: PCWSTR,
        dw_attrib: u32,
        p_index: MutPtr<i32>,
        dwflags: u32,
        i_reserved_id: i32,
    ) -> crate::core::HRESULT {
        todo!("GetReservedOverlayInfo")
    }
    fn RefreshOverlayImages(&self, dw_flags: u32) -> crate::core::HRESULT {
        todo!("RefreshOverlayImages")
    }
    fn LoadNonloadedOverlayIdentifiers(&self) -> crate::core::HRESULT {
        todo!("LoadNonloadedOverlayIdentifiers")
    }
    fn OverlayIndexFromImageIndex(
        &self,
        i_image: i32,
        pi_index: MutPtr<i32>,
        f_add: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("OverlayIndexFromImageIndex")
    }
}
impl ::core::clone::Clone for IShellIconOverlayManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellIconOverlayManager {}
impl ::core::cmp::PartialEq for IShellIconOverlayManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellIconOverlayManager {}
impl ::core::fmt::Debug for IShellIconOverlayManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellIconOverlayManager")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IShellIconOverlayManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellIconOverlayManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf10b5e34_dd3b_42a7_aa7d_2f4ec54bb09b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellImageData(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellImageData_Trait: crate::core::IUnknown_Trait {
    fn Decode(&self, dw_flags: u32, cx_desired: u32, cy_desired: u32) -> crate::core::HRESULT {
        todo!("Decode")
    }
    fn Draw(
        &self,
        hdc: super::super::Graphics::Gdi::HDC,
        prc_dest: MutPtr<super::super::Foundation::RECT>,
        prc_src: MutPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("Draw")
    }
    fn NextFrame(&self) -> crate::core::HRESULT {
        todo!("NextFrame")
    }
    fn NextPage(&self) -> crate::core::HRESULT {
        todo!("NextPage")
    }
    fn PrevPage(&self) -> crate::core::HRESULT {
        todo!("PrevPage")
    }
    fn IsTransparent(&self) -> crate::core::HRESULT {
        todo!("IsTransparent")
    }
    fn IsAnimated(&self) -> crate::core::HRESULT {
        todo!("IsAnimated")
    }
    fn IsVector(&self) -> crate::core::HRESULT {
        todo!("IsVector")
    }
    fn IsMultipage(&self) -> crate::core::HRESULT {
        todo!("IsMultipage")
    }
    fn IsEditable(&self) -> crate::core::HRESULT {
        todo!("IsEditable")
    }
    fn IsPrintable(&self) -> crate::core::HRESULT {
        todo!("IsPrintable")
    }
    fn IsDecoded(&self) -> crate::core::HRESULT {
        todo!("IsDecoded")
    }
    fn GetCurrentPage(&self, pn_page: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCurrentPage")
    }
    fn GetPageCount(&self, pc_pages: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetPageCount")
    }
    fn SelectPage(&self, i_page: u32) -> crate::core::HRESULT {
        todo!("SelectPage")
    }
    fn GetSize(&self, p_size: MutPtr<super::super::Foundation::SIZE>) -> crate::core::HRESULT {
        todo!("GetSize")
    }
    fn GetRawDataFormat(&self, p_data_format: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetRawDataFormat")
    }
    fn GetPixelFormat(&self, p_format: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetPixelFormat")
    }
    fn GetDelay(&self, pdw_delay: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetDelay")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetProperties(
        &self,
        dw_mode: u32,
        pp_prop_set: MutPtr<super::super::System::Com::StructuredStorage::IPropertySetStorage>,
    ) -> crate::core::HRESULT {
        todo!("GetProperties")
    }
    fn Rotate(&self, dw_angle: u32) -> crate::core::HRESULT {
        todo!("Rotate")
    }
    fn Scale(&self, cx: u32, cy: u32, hints: u32) -> crate::core::HRESULT {
        todo!("Scale")
    }
    fn DiscardEdit(&self) -> crate::core::HRESULT {
        todo!("DiscardEdit")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetEncoderParams(
        &self,
        pbag_enc: super::super::System::Com::StructuredStorage::IPropertyBag,
    ) -> crate::core::HRESULT {
        todo!("SetEncoderParams")
    }
    fn DisplayName(&self, wsz_name: PCWSTR, cch: u32) -> crate::core::HRESULT {
        todo!("DisplayName")
    }
    fn GetResolution(
        &self,
        pu_resolution_x: MutPtr<u32>,
        pu_resolution_y: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetResolution")
    }
    fn GetEncoderParams(
        &self,
        pguid_fmt: MutPtr<crate::core::GUID>,
        pp_enc_params: MutPtr<ConstPtr<u8>>,
    ) -> crate::core::HRESULT {
        todo!("GetEncoderParams")
    }
    fn RegisterAbort(
        &self,
        p_abort: IShellImageDataAbort,
        pp_abort_prev: MutPtr<IShellImageDataAbort>,
    ) -> crate::core::HRESULT {
        todo!("RegisterAbort")
    }
    fn CloneFrame(&self, pp_img: MutPtr<ConstPtr<u8>>) -> crate::core::HRESULT {
        todo!("CloneFrame")
    }
    fn ReplaceFrame(&self, p_img: MutPtr<u8>) -> crate::core::HRESULT {
        todo!("ReplaceFrame")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellImageData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellImageData {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellImageData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellImageData {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellImageData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellImageData").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellImageData {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellImageData {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xbfdeec12_8040_4403_a5ea_9e07dafcf530);
}
pub struct IShellImageDataAbort(pub crate::core::IUnknown);
pub trait IShellImageDataAbort_Trait: crate::core::IUnknown_Trait {
    fn QueryAbort(&self) -> crate::core::HRESULT {
        todo!("QueryAbort")
    }
}
impl ::core::clone::Clone for IShellImageDataAbort {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellImageDataAbort {}
impl ::core::cmp::PartialEq for IShellImageDataAbort {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellImageDataAbort {}
impl ::core::fmt::Debug for IShellImageDataAbort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellImageDataAbort")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IShellImageDataAbort {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellImageDataAbort {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x53fb8e58_50c0_4003_b4aa_0c8df28e7f3a);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellImageDataFactory(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellImageDataFactory_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateIShellImageData(&self, ppshimg: MutPtr<IShellImageData>) -> crate::core::HRESULT {
        todo!("CreateIShellImageData")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateImageFromFile(
        &self,
        psz_path: PCWSTR,
        ppshimg: MutPtr<IShellImageData>,
    ) -> crate::core::HRESULT {
        todo!("CreateImageFromFile")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateImageFromStream(
        &self,
        p_stream: super::super::System::Com::IStream,
        ppshimg: MutPtr<IShellImageData>,
    ) -> crate::core::HRESULT {
        todo!("CreateImageFromStream")
    }
    fn GetDataFormatFromPath(
        &self,
        psz_path: PCWSTR,
        p_data_format: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("GetDataFormatFromPath")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellImageDataFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellImageDataFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellImageDataFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellImageDataFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellImageDataFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellImageDataFactory")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellImageDataFactory {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellImageDataFactory {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9be8ed5c_edab_4d75_90f3_bd5bdbb21c82);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellItem_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BindToHandler(
        &self,
        pbc: super::super::System::Com::IBindCtx,
        bhid: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("BindToHandler")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetParent(&self, ppsi: MutPtr<IShellItem>) -> crate::core::HRESULT {
        todo!("GetParent")
    }
    fn GetDisplayName(&self, sigdn_name: SIGDN, ppsz_name: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetDisplayName")
    }
    fn GetAttributes(&self, sfgao_mask: u32, psfgao_attribs: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetAttributes")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Compare(&self, psi: IShellItem, hint: u32, pi_order: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("Compare")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x43826d1e_e718_42ee_bc55_a1e261c37bfe);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellItem2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellItem2_Trait: IShellItem_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyStore(
        &self,
        flags: PropertiesSystem::GETPROPERTYSTOREFLAGS,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyStore")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyStoreWithCreateObject(
        &self,
        flags: PropertiesSystem::GETPROPERTYSTOREFLAGS,
        punk_create_object: crate::core::IUnknown,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyStoreWithCreateObject")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyStoreForKeys(
        &self,
        rg_keys: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        c_keys: u32,
        flags: PropertiesSystem::GETPROPERTYSTOREFLAGS,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyStoreForKeys")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyDescriptionList(
        &self,
        key_type: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyDescriptionList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Update(&self, pbc: super::super::System::Com::IBindCtx) -> crate::core::HRESULT {
        todo!("Update")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetProperty(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        ppropvar: MutPtr<super::super::System::Com::StructuredStorage::PROPVARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetProperty")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetCLSID(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pclsid: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("GetCLSID")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetFileTime(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pft: MutPtr<super::super::Foundation::FILETIME>,
    ) -> crate::core::HRESULT {
        todo!("GetFileTime")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetInt32(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pi: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetInt32")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetString(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        ppsz: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetString")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetUInt32(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pui: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetUInt32")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetUInt64(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pull: MutPtr<u64>,
    ) -> crate::core::HRESULT {
        todo!("GetUInt64")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetBool(
        &self,
        key: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        pf: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetBool")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellItem2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellItem2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellItem2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellItem2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellItem2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellItem2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellItem2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellItem2 {
    type Super = IShellItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7e9fb0d3_919f_4307_ab2e_9b1860310c93);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellItemArray(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellItemArray_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn BindToHandler(
        &self,
        pbc: super::super::System::Com::IBindCtx,
        bhid: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv_out: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("BindToHandler")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyStore(
        &self,
        flags: PropertiesSystem::GETPROPERTYSTOREFLAGS,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyStore")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyDescriptionList(
        &self,
        key_type: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyDescriptionList")
    }
    fn GetAttributes(
        &self,
        attrib_flags: SIATTRIBFLAGS,
        sfgao_mask: u32,
        psfgao_attribs: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetAttributes")
    }
    fn GetCount(&self, pdw_num_items: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemAt(&self, dw_index: u32, ppsi: MutPtr<IShellItem>) -> crate::core::HRESULT {
        todo!("GetItemAt")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EnumItems(&self, ppenum_shell_items: MutPtr<IEnumShellItems>) -> crate::core::HRESULT {
        todo!("EnumItems")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellItemArray {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellItemArray {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellItemArray {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellItemArray {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellItemArray {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellItemArray").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellItemArray {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellItemArray {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb63ea76d_1f85_456f_a19c_48159efa858b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellItemFilter(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellItemFilter_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn IncludeItem(&self, psi: IShellItem) -> crate::core::HRESULT {
        todo!("IncludeItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetEnumFlagsForItem(
        &self,
        psi: IShellItem,
        pgrf_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetEnumFlagsForItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellItemFilter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellItemFilter {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellItemFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellItemFilter {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellItemFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellItemFilter").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellItemFilter {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellItemFilter {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2659b475_eeb8_48b7_8f07_b378810f48cf);
}
pub struct IShellItemImageFactory(pub crate::core::IUnknown);
pub trait IShellItemImageFactory_Trait: crate::core::IUnknown_Trait {
    fn GetImage(
        &self,
        size: super::super::Foundation::SIZE,
        flags: SIIGBF,
        phbm: MutPtr<super::super::Graphics::Gdi::HBITMAP>,
    ) -> crate::core::HRESULT {
        todo!("GetImage")
    }
}
impl ::core::clone::Clone for IShellItemImageFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellItemImageFactory {}
impl ::core::cmp::PartialEq for IShellItemImageFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellItemImageFactory {}
impl ::core::fmt::Debug for IShellItemImageFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellItemImageFactory")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IShellItemImageFactory {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellItemImageFactory {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xbcc18b79_ba16_442f_80c4_8a59c30c463b);
}
pub struct IShellItemResources(pub crate::core::IUnknown);
pub trait IShellItemResources_Trait: crate::core::IUnknown_Trait {
    fn GetAttributes(&self, pdw_attributes: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetAttributes")
    }
    fn GetSize(&self, pull_size: MutPtr<u64>) -> crate::core::HRESULT {
        todo!("GetSize")
    }
    fn GetTimes(
        &self,
        pft_creation: MutPtr<super::super::Foundation::FILETIME>,
        pft_write: MutPtr<super::super::Foundation::FILETIME>,
        pft_access: MutPtr<super::super::Foundation::FILETIME>,
    ) -> crate::core::HRESULT {
        todo!("GetTimes")
    }
    fn SetTimes(
        &self,
        pft_creation: ConstPtr<super::super::Foundation::FILETIME>,
        pft_write: ConstPtr<super::super::Foundation::FILETIME>,
        pft_access: ConstPtr<super::super::Foundation::FILETIME>,
    ) -> crate::core::HRESULT {
        todo!("SetTimes")
    }
    fn GetResourceDescription(
        &self,
        pcsir: ConstPtr<SHELL_ITEM_RESOURCE>,
        ppsz_description: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetResourceDescription")
    }
    fn EnumResources(&self, ppenumr: MutPtr<IEnumResources>) -> crate::core::HRESULT {
        todo!("EnumResources")
    }
    fn SupportsResource(&self, pcsir: ConstPtr<SHELL_ITEM_RESOURCE>) -> crate::core::HRESULT {
        todo!("SupportsResource")
    }
    fn OpenResource(
        &self,
        pcsir: ConstPtr<SHELL_ITEM_RESOURCE>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("OpenResource")
    }
    fn CreateResource(
        &self,
        pcsir: ConstPtr<SHELL_ITEM_RESOURCE>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("CreateResource")
    }
    fn MarkForDelete(&self) -> crate::core::HRESULT {
        todo!("MarkForDelete")
    }
}
impl ::core::clone::Clone for IShellItemResources {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellItemResources {}
impl ::core::cmp::PartialEq for IShellItemResources {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellItemResources {}
impl ::core::fmt::Debug for IShellItemResources {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellItemResources").field(&self.0).finish()
    }
}
impl FromIntoMemory for IShellItemResources {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellItemResources {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xff5693be_2ce0_4d48_b5c5_40817d1acdb9);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellLibrary(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellLibrary_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn LoadLibraryFromItem(&self, psi_library: IShellItem, grf_mode: u32) -> crate::core::HRESULT {
        todo!("LoadLibraryFromItem")
    }
    fn LoadLibraryFromKnownFolder(
        &self,
        kfid_library: ConstPtr<crate::core::GUID>,
        grf_mode: u32,
    ) -> crate::core::HRESULT {
        todo!("LoadLibraryFromKnownFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddFolder(&self, psi_location: IShellItem) -> crate::core::HRESULT {
        todo!("AddFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveFolder(&self, psi_location: IShellItem) -> crate::core::HRESULT {
        todo!("RemoveFolder")
    }
    fn GetFolders(
        &self,
        lff: LIBRARYFOLDERFILTER,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetFolders")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ResolveFolder(
        &self,
        psi_folder_to_resolve: IShellItem,
        dw_timeout: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("ResolveFolder")
    }
    fn GetDefaultSaveFolder(
        &self,
        dsft: DEFAULTSAVEFOLDERTYPE,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetDefaultSaveFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetDefaultSaveFolder(
        &self,
        dsft: DEFAULTSAVEFOLDERTYPE,
        psi: IShellItem,
    ) -> crate::core::HRESULT {
        todo!("SetDefaultSaveFolder")
    }
    fn GetOptions(&self, plof_options: MutPtr<LIBRARYOPTIONFLAGS>) -> crate::core::HRESULT {
        todo!("GetOptions")
    }
    fn SetOptions(
        &self,
        lof_mask: LIBRARYOPTIONFLAGS,
        lof_options: LIBRARYOPTIONFLAGS,
    ) -> crate::core::HRESULT {
        todo!("SetOptions")
    }
    fn GetFolderType(&self, pftid: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetFolderType")
    }
    fn SetFolderType(&self, ftid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("SetFolderType")
    }
    fn GetIcon(&self, ppsz_icon: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetIcon")
    }
    fn SetIcon(&self, psz_icon: PCWSTR) -> crate::core::HRESULT {
        todo!("SetIcon")
    }
    fn Commit(&self) -> crate::core::HRESULT {
        todo!("Commit")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Save(
        &self,
        psi_folder_to_save_in: IShellItem,
        psz_library_name: PCWSTR,
        lsf: LIBRARYSAVEFLAGS,
        ppsi_saved_to: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("Save")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SaveInKnownFolder(
        &self,
        kfid_to_save_in: ConstPtr<crate::core::GUID>,
        psz_library_name: PCWSTR,
        lsf: LIBRARYSAVEFLAGS,
        ppsi_saved_to: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("SaveInKnownFolder")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellLibrary {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellLibrary {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellLibrary {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellLibrary {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellLibrary {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellLibrary").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellLibrary {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellLibrary {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x11a66efa_382e_451a_9234_1e0e12ef3085);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellLinkA(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellLinkA_Trait: crate::core::IUnknown_Trait {
    fn GetPath(
        &self,
        psz_file: PSTR,
        cch: i32,
        pfd: MutPtr<super::super::Storage::FileSystem::WIN32_FIND_DATAA>,
        f_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("GetPath")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIDList(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetIDList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetIDList(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("SetIDList")
    }
    fn GetDescription(&self, psz_name: PSTR, cch: i32) -> crate::core::HRESULT {
        todo!("GetDescription")
    }
    fn SetDescription(&self, psz_name: PCSTR) -> crate::core::HRESULT {
        todo!("SetDescription")
    }
    fn GetWorkingDirectory(&self, psz_dir: PSTR, cch: i32) -> crate::core::HRESULT {
        todo!("GetWorkingDirectory")
    }
    fn SetWorkingDirectory(&self, psz_dir: PCSTR) -> crate::core::HRESULT {
        todo!("SetWorkingDirectory")
    }
    fn GetArguments(&self, psz_args: PSTR, cch: i32) -> crate::core::HRESULT {
        todo!("GetArguments")
    }
    fn SetArguments(&self, psz_args: PCSTR) -> crate::core::HRESULT {
        todo!("SetArguments")
    }
    fn GetHotkey(&self, pw_hotkey: MutPtr<u16>) -> crate::core::HRESULT {
        todo!("GetHotkey")
    }
    fn SetHotkey(&self, w_hotkey: u16) -> crate::core::HRESULT {
        todo!("SetHotkey")
    }
    fn GetShowCmd(&self, pi_show_cmd: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetShowCmd")
    }
    fn SetShowCmd(&self, i_show_cmd: i32) -> crate::core::HRESULT {
        todo!("SetShowCmd")
    }
    fn GetIconLocation(
        &self,
        psz_icon_path: PSTR,
        cch: i32,
        pi_icon: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetIconLocation")
    }
    fn SetIconLocation(&self, psz_icon_path: PCSTR, i_icon: i32) -> crate::core::HRESULT {
        todo!("SetIconLocation")
    }
    fn SetRelativePath(&self, psz_path_rel: PCSTR, dw_reserved: u32) -> crate::core::HRESULT {
        todo!("SetRelativePath")
    }
    fn Resolve(&self, hwnd: super::super::Foundation::HWND, f_flags: u32) -> crate::core::HRESULT {
        todo!("Resolve")
    }
    fn SetPath(&self, psz_file: PCSTR) -> crate::core::HRESULT {
        todo!("SetPath")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellLinkA {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellLinkA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellLinkA {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellLinkA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellLinkA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellLinkA").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellLinkA {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellLinkA {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214ee_0000_0000_c000_000000000046);
}
pub struct IShellLinkDataList(pub crate::core::IUnknown);
pub trait IShellLinkDataList_Trait: crate::core::IUnknown_Trait {
    fn AddDataBlock(&self, p_data_block: ConstPtr<::core::ffi::c_void>) -> crate::core::HRESULT {
        todo!("AddDataBlock")
    }
    fn CopyDataBlock(
        &self,
        dw_sig: u32,
        pp_data_block: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("CopyDataBlock")
    }
    fn RemoveDataBlock(&self, dw_sig: u32) -> crate::core::HRESULT {
        todo!("RemoveDataBlock")
    }
    fn GetFlags(&self, pdw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetFlags")
    }
    fn SetFlags(&self, dw_flags: u32) -> crate::core::HRESULT {
        todo!("SetFlags")
    }
}
impl ::core::clone::Clone for IShellLinkDataList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellLinkDataList {}
impl ::core::cmp::PartialEq for IShellLinkDataList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellLinkDataList {}
impl ::core::fmt::Debug for IShellLinkDataList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellLinkDataList").field(&self.0).finish()
    }
}
impl FromIntoMemory for IShellLinkDataList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellLinkDataList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x45e2b4ae_b1c3_11d0_b92f_00a0c90312e1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellLinkDual(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellLinkDual_Trait: super::super::System::Com::IDispatch_Trait {
    fn get_Path(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Path")
    }
    fn put_Path(&self, bs: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_Path")
    }
    fn get_Description(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Description")
    }
    fn put_Description(&self, bs: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_Description")
    }
    fn get_WorkingDirectory(
        &self,
        pbs: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_WorkingDirectory")
    }
    fn put_WorkingDirectory(&self, bs: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_WorkingDirectory")
    }
    fn get_Arguments(&self, pbs: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Arguments")
    }
    fn put_Arguments(&self, bs: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_Arguments")
    }
    fn get_Hotkey(&self, pi_hk: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Hotkey")
    }
    fn put_Hotkey(&self, i_hk: i32) -> crate::core::HRESULT {
        todo!("put_Hotkey")
    }
    fn get_ShowCommand(&self, pi_show_command: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_ShowCommand")
    }
    fn put_ShowCommand(&self, i_show_command: i32) -> crate::core::HRESULT {
        todo!("put_ShowCommand")
    }
    fn Resolve(&self, f_flags: i32) -> crate::core::HRESULT {
        todo!("Resolve")
    }
    fn GetIconLocation(
        &self,
        pbs: MutPtr<super::super::Foundation::BSTR>,
        pi_icon: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetIconLocation")
    }
    fn SetIconLocation(
        &self,
        bs: super::super::Foundation::BSTR,
        i_icon: i32,
    ) -> crate::core::HRESULT {
        todo!("SetIconLocation")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Save(&self, v_where: super::super::System::Com::VARIANT) -> crate::core::HRESULT {
        todo!("Save")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellLinkDual {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellLinkDual {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellLinkDual {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellLinkDual {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellLinkDual {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellLinkDual").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellLinkDual {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellLinkDual {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x88a05c00_f000_11ce_8350_444553540000);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellLinkDual2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellLinkDual2_Trait: IShellLinkDual_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Target(&self, ppfi: MutPtr<FolderItem>) -> crate::core::HRESULT {
        todo!("get_Target")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellLinkDual2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellLinkDual2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellLinkDual2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellLinkDual2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellLinkDual2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellLinkDual2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellLinkDual2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellLinkDual2 {
    type Super = IShellLinkDual;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x317ee249_f12e_11d2_b1e4_00c04f8eeb3e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellLinkW(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellLinkW_Trait: crate::core::IUnknown_Trait {
    fn GetPath(
        &self,
        psz_file: PWSTR,
        cch: i32,
        pfd: MutPtr<super::super::Storage::FileSystem::WIN32_FIND_DATAW>,
        f_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("GetPath")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetIDList(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetIDList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetIDList(&self, pidl: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("SetIDList")
    }
    fn GetDescription(&self, psz_name: PWSTR, cch: i32) -> crate::core::HRESULT {
        todo!("GetDescription")
    }
    fn SetDescription(&self, psz_name: PCWSTR) -> crate::core::HRESULT {
        todo!("SetDescription")
    }
    fn GetWorkingDirectory(&self, psz_dir: PWSTR, cch: i32) -> crate::core::HRESULT {
        todo!("GetWorkingDirectory")
    }
    fn SetWorkingDirectory(&self, psz_dir: PCWSTR) -> crate::core::HRESULT {
        todo!("SetWorkingDirectory")
    }
    fn GetArguments(&self, psz_args: PWSTR, cch: i32) -> crate::core::HRESULT {
        todo!("GetArguments")
    }
    fn SetArguments(&self, psz_args: PCWSTR) -> crate::core::HRESULT {
        todo!("SetArguments")
    }
    fn GetHotkey(&self, pw_hotkey: MutPtr<u16>) -> crate::core::HRESULT {
        todo!("GetHotkey")
    }
    fn SetHotkey(&self, w_hotkey: u16) -> crate::core::HRESULT {
        todo!("SetHotkey")
    }
    fn GetShowCmd(&self, pi_show_cmd: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetShowCmd")
    }
    fn SetShowCmd(&self, i_show_cmd: i32) -> crate::core::HRESULT {
        todo!("SetShowCmd")
    }
    fn GetIconLocation(
        &self,
        psz_icon_path: PWSTR,
        cch: i32,
        pi_icon: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("GetIconLocation")
    }
    fn SetIconLocation(&self, psz_icon_path: PCWSTR, i_icon: i32) -> crate::core::HRESULT {
        todo!("SetIconLocation")
    }
    fn SetRelativePath(&self, psz_path_rel: PCWSTR, dw_reserved: u32) -> crate::core::HRESULT {
        todo!("SetRelativePath")
    }
    fn Resolve(&self, hwnd: super::super::Foundation::HWND, f_flags: u32) -> crate::core::HRESULT {
        todo!("Resolve")
    }
    fn SetPath(&self, psz_file: PCWSTR) -> crate::core::HRESULT {
        todo!("SetPath")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellLinkW {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellLinkW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellLinkW {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellLinkW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellLinkW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellLinkW").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellLinkW {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellLinkW {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214f9_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellMenu(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellMenu_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Initialize(
        &self,
        psmc: IShellMenuCallback,
        u_id: u32,
        u_id_ancestor: u32,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetMenuInfo(
        &self,
        ppsmc: MutPtr<IShellMenuCallback>,
        pu_id: MutPtr<u32>,
        pu_id_ancestor: MutPtr<u32>,
        pdw_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetMenuInfo")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetShellFolder(
        &self,
        psf: IShellFolder,
        pidl_folder: ConstPtr<Common::ITEMIDLIST>,
        h_key: super::super::System::Registry::HKEY,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetShellFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetShellFolder(
        &self,
        pdw_flags: MutPtr<u32>,
        ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetShellFolder")
    }
    fn SetMenu(
        &self,
        hmenu: super::WindowsAndMessaging::HMENU,
        hwnd: super::super::Foundation::HWND,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetMenu")
    }
    fn GetMenu(
        &self,
        phmenu: MutPtr<super::WindowsAndMessaging::HMENU>,
        phwnd: MutPtr<super::super::Foundation::HWND>,
        pdw_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetMenu")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn InvalidateItem(&self, psmd: ConstPtr<SMDATA>, dw_flags: u32) -> crate::core::HRESULT {
        todo!("InvalidateItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetState(&self, psmd: MutPtr<SMDATA>) -> crate::core::HRESULT {
        todo!("GetState")
    }
    fn SetMenuToolbar(&self, punk: crate::core::IUnknown, dw_flags: u32) -> crate::core::HRESULT {
        todo!("SetMenuToolbar")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellMenu {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellMenu {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellMenu {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellMenu {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellMenu {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellMenu").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellMenu {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellMenu {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xee1f7637_e138_11d1_8379_00c04fd918d0);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellMenuCallback(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellMenuCallback_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CallbackSM(
        &self,
        psmd: MutPtr<SMDATA>,
        u_msg: u32,
        w_param: super::super::Foundation::WPARAM,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("CallbackSM")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellMenuCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellMenuCallback {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellMenuCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellMenuCallback {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellMenuCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellMenuCallback").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellMenuCallback {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellMenuCallback {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4ca300a1_9b8d_11d1_8b22_00c04fd918d0);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellNameSpace(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellNameSpace_Trait: IShellFavoritesNameSpace_Trait {
    fn get_EnumOptions(&self, pgrf_enum_flags: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_EnumOptions")
    }
    fn put_EnumOptions(&self, l_val: i32) -> crate::core::HRESULT {
        todo!("put_EnumOptions")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_SelectedItem(
        &self,
        p_item: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_SelectedItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn put_SelectedItem(
        &self,
        p_item: super::super::System::Com::IDispatch,
    ) -> crate::core::HRESULT {
        todo!("put_SelectedItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Root(&self, pvar: MutPtr<super::super::System::Com::VARIANT>) -> crate::core::HRESULT {
        todo!("get_Root")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn put_Root(&self, var: super::super::System::Com::VARIANT) -> crate::core::HRESULT {
        todo!("put_Root")
    }
    fn get_Depth(&self, pi_depth: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Depth")
    }
    fn put_Depth(&self, i_depth: i32) -> crate::core::HRESULT {
        todo!("put_Depth")
    }
    fn get_Mode(&self, pu_mode: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("get_Mode")
    }
    fn put_Mode(&self, u_mode: u32) -> crate::core::HRESULT {
        todo!("put_Mode")
    }
    fn get_Flags(&self, pdw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("get_Flags")
    }
    fn put_Flags(&self, dw_flags: u32) -> crate::core::HRESULT {
        todo!("put_Flags")
    }
    fn put_TVFlags(&self, dw_flags: u32) -> crate::core::HRESULT {
        todo!("put_TVFlags")
    }
    fn get_TVFlags(&self, dw_flags: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("get_TVFlags")
    }
    fn get_Columns(
        &self,
        bstr_columns: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_Columns")
    }
    fn put_Columns(&self, bstr_columns: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_Columns")
    }
    fn get_CountViewTypes(&self, pi_types: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_CountViewTypes")
    }
    fn SetViewType(&self, i_type: i32) -> crate::core::HRESULT {
        todo!("SetViewType")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SelectedItems(
        &self,
        ppid: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("SelectedItems")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Expand(
        &self,
        var: super::super::System::Com::VARIANT,
        i_depth: i32,
    ) -> crate::core::HRESULT {
        todo!("Expand")
    }
    fn UnselectAll(&self) -> crate::core::HRESULT {
        todo!("UnselectAll")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellNameSpace {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellNameSpace {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellNameSpace {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellNameSpace {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellNameSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellNameSpace").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellNameSpace {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellNameSpace {
    type Super = IShellFavoritesNameSpace;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe572d3c9_37be_4ae2_825d_d521763e3108);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellPropSheetExt(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellPropSheetExt_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddPages(
        &self,
        pfn_add_page: super::Controls::LPFNSVADDPROPSHEETPAGE,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("AddPages")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ReplacePage(
        &self,
        u_page_id: u32,
        pfn_replace_with: super::Controls::LPFNSVADDPROPSHEETPAGE,
        l_param: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("ReplacePage")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellPropSheetExt {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellPropSheetExt {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellPropSheetExt {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellPropSheetExt {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellPropSheetExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellPropSheetExt").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellPropSheetExt {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellPropSheetExt {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e9_0000_0000_c000_000000000046);
}
pub struct IShellRunDll(pub crate::core::IUnknown);
pub trait IShellRunDll_Trait: crate::core::IUnknown_Trait {
    fn Run(&self, psz_args: PCWSTR) -> crate::core::HRESULT {
        todo!("Run")
    }
}
impl ::core::clone::Clone for IShellRunDll {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellRunDll {}
impl ::core::cmp::PartialEq for IShellRunDll {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellRunDll {}
impl ::core::fmt::Debug for IShellRunDll {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellRunDll").field(&self.0).finish()
    }
}
impl FromIntoMemory for IShellRunDll {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellRunDll {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfce4bde0_4b68_4b80_8e9c_7426315a7388);
}
pub struct IShellService(pub crate::core::IUnknown);
pub trait IShellService_Trait: crate::core::IUnknown_Trait {
    fn SetOwner(&self, punk_owner: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("SetOwner")
    }
}
impl ::core::clone::Clone for IShellService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellService {}
impl ::core::cmp::PartialEq for IShellService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellService {}
impl ::core::fmt::Debug for IShellService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellService").field(&self.0).finish()
    }
}
impl FromIntoMemory for IShellService {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellService {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x5836fb00_8187_11cf_a12b_00aa004ae837);
}
pub struct IShellTaskScheduler(pub crate::core::IUnknown);
pub trait IShellTaskScheduler_Trait: crate::core::IUnknown_Trait {
    fn AddTask(
        &self,
        prt: IRunnableTask,
        rtoid: ConstPtr<crate::core::GUID>,
        l_param: PtrRepr,
        dw_priority: u32,
    ) -> crate::core::HRESULT {
        todo!("AddTask")
    }
    fn RemoveTasks(
        &self,
        rtoid: ConstPtr<crate::core::GUID>,
        l_param: PtrRepr,
        b_wait_if_running: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("RemoveTasks")
    }
    fn CountTasks(&self, rtoid: ConstPtr<crate::core::GUID>) -> u32 {
        todo!("CountTasks")
    }
    fn Status(&self, dw_release_status: u32, dw_thread_timeout: u32) -> crate::core::HRESULT {
        todo!("Status")
    }
}
impl ::core::clone::Clone for IShellTaskScheduler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IShellTaskScheduler {}
impl ::core::cmp::PartialEq for IShellTaskScheduler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IShellTaskScheduler {}
impl ::core::fmt::Debug for IShellTaskScheduler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellTaskScheduler").field(&self.0).finish()
    }
}
impl FromIntoMemory for IShellTaskScheduler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IShellTaskScheduler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6ccb7be0_6807_11d0_b810_00c04fd706ec);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper_Trait: super::super::System::Com::IDispatch_Trait {
    fn ResetFirstBootMode(&self) -> crate::core::HRESULT {
        todo!("ResetFirstBootMode")
    }
    fn ResetSafeMode(&self) -> crate::core::HRESULT {
        todo!("ResetSafeMode")
    }
    fn RefreshOfflineDesktop(&self) -> crate::core::HRESULT {
        todo!("RefreshOfflineDesktop")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddFavorite(
        &self,
        url: super::super::Foundation::BSTR,
        title: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("AddFavorite")
    }
    fn AddChannel(&self, url: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("AddChannel")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddDesktopComponent(
        &self,
        url: super::super::Foundation::BSTR,
        r#type: super::super::Foundation::BSTR,
        left: ConstPtr<super::super::System::Com::VARIANT>,
        top: ConstPtr<super::super::System::Com::VARIANT>,
        width: ConstPtr<super::super::System::Com::VARIANT>,
        height: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("AddDesktopComponent")
    }
    fn IsSubscribed(
        &self,
        url: super::super::Foundation::BSTR,
        p_bool: MutPtr<i16>,
    ) -> crate::core::HRESULT {
        todo!("IsSubscribed")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn NavigateAndFind(
        &self,
        url: super::super::Foundation::BSTR,
        str_query: super::super::Foundation::BSTR,
        var_target_frame: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("NavigateAndFind")
    }
    fn ImportExportFavorites(
        &self,
        f_import: i16,
        str_imp_exp_path: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("ImportExportFavorites")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AutoCompleteSaveForm(
        &self,
        form: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("AutoCompleteSaveForm")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AutoScan(
        &self,
        str_search: super::super::Foundation::BSTR,
        str_failure_url: super::super::Foundation::BSTR,
        pvar_target_frame: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("AutoScan")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AutoCompleteAttach(
        &self,
        reserved: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("AutoCompleteAttach")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ShowBrowserUI(
        &self,
        bstr_name: super::super::Foundation::BSTR,
        pvar_in: ConstPtr<super::super::System::Com::VARIANT>,
        pvar_out: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ShowBrowserUI")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x729fe2f8_1ea8_11d1_8f85_00c04fc2fbe1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper2_Trait: IShellUIHelper_Trait {
    fn AddSearchProvider(&self, url: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("AddSearchProvider")
    }
    fn RunOnceShown(&self) -> crate::core::HRESULT {
        todo!("RunOnceShown")
    }
    fn SkipRunOnce(&self) -> crate::core::HRESULT {
        todo!("SkipRunOnce")
    }
    fn CustomizeSettings(
        &self,
        f_sqm: i16,
        f_phishing: i16,
        bstr_locale: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("CustomizeSettings")
    }
    fn SqmEnabled(&self, pf_enabled: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("SqmEnabled")
    }
    fn PhishingEnabled(&self, pf_enabled: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("PhishingEnabled")
    }
    fn BrandImageUri(
        &self,
        pbstr_uri: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("BrandImageUri")
    }
    fn SkipTabsWelcome(&self) -> crate::core::HRESULT {
        todo!("SkipTabsWelcome")
    }
    fn DiagnoseConnection(&self) -> crate::core::HRESULT {
        todo!("DiagnoseConnection")
    }
    fn CustomizeClearType(&self, f_set: i16) -> crate::core::HRESULT {
        todo!("CustomizeClearType")
    }
    fn IsSearchProviderInstalled(
        &self,
        url: super::super::Foundation::BSTR,
        pdw_result: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("IsSearchProviderInstalled")
    }
    fn IsSearchMigrated(&self, pf_migrated: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("IsSearchMigrated")
    }
    fn DefaultSearchProvider(
        &self,
        pbstr_name: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("DefaultSearchProvider")
    }
    fn RunOnceRequiredSettingsComplete(&self, f_complete: i16) -> crate::core::HRESULT {
        todo!("RunOnceRequiredSettingsComplete")
    }
    fn RunOnceHasShown(&self, pf_shown: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("RunOnceHasShown")
    }
    fn SearchGuideUrl(
        &self,
        pbstr_url: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("SearchGuideUrl")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper2 {
    type Super = IShellUIHelper;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa7fe6eda_1932_4281_b881_87b31b8bc52c);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper3_Trait: IShellUIHelper2_Trait {
    fn AddService(&self, url: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("AddService")
    }
    fn IsServiceInstalled(
        &self,
        url: super::super::Foundation::BSTR,
        verb: super::super::Foundation::BSTR,
        pdw_result: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("IsServiceInstalled")
    }
    fn InPrivateFilteringEnabled(&self, pf_enabled: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("InPrivateFilteringEnabled")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddToFavoritesBar(
        &self,
        url: super::super::Foundation::BSTR,
        title: super::super::Foundation::BSTR,
        r#type: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("AddToFavoritesBar")
    }
    fn BuildNewTabPage(&self) -> crate::core::HRESULT {
        todo!("BuildNewTabPage")
    }
    fn SetRecentlyClosedVisible(&self, f_visible: i16) -> crate::core::HRESULT {
        todo!("SetRecentlyClosedVisible")
    }
    fn SetActivitiesVisible(&self, f_visible: i16) -> crate::core::HRESULT {
        todo!("SetActivitiesVisible")
    }
    fn ContentDiscoveryReset(&self) -> crate::core::HRESULT {
        todo!("ContentDiscoveryReset")
    }
    fn IsSuggestedSitesEnabled(&self, pf_enabled: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("IsSuggestedSitesEnabled")
    }
    fn EnableSuggestedSites(&self, f_enable: i16) -> crate::core::HRESULT {
        todo!("EnableSuggestedSites")
    }
    fn NavigateToSuggestedSites(
        &self,
        bstr_relative_url: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("NavigateToSuggestedSites")
    }
    fn ShowTabsHelp(&self) -> crate::core::HRESULT {
        todo!("ShowTabsHelp")
    }
    fn ShowInPrivateHelp(&self) -> crate::core::HRESULT {
        todo!("ShowInPrivateHelp")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper3 {
    type Super = IShellUIHelper2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x528df2ec_d419_40bc_9b6d_dcdbf9c1b25d);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper4(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper4_Trait: IShellUIHelper3_Trait {
    fn msIsSiteMode(&self, pf_site_mode: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("msIsSiteMode")
    }
    fn msSiteModeShowThumbBar(&self) -> crate::core::HRESULT {
        todo!("msSiteModeShowThumbBar")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msSiteModeAddThumbBarButton(
        &self,
        bstr_icon_url: super::super::Foundation::BSTR,
        bstr_tooltip: super::super::Foundation::BSTR,
        pvar_button_id: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("msSiteModeAddThumbBarButton")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msSiteModeUpdateThumbBarButton(
        &self,
        button_id: super::super::System::Com::VARIANT,
        f_enabled: i16,
        f_visible: i16,
    ) -> crate::core::HRESULT {
        todo!("msSiteModeUpdateThumbBarButton")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msSiteModeSetIconOverlay(
        &self,
        icon_url: super::super::Foundation::BSTR,
        pvar_description: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("msSiteModeSetIconOverlay")
    }
    fn msSiteModeClearIconOverlay(&self) -> crate::core::HRESULT {
        todo!("msSiteModeClearIconOverlay")
    }
    fn msAddSiteMode(&self) -> crate::core::HRESULT {
        todo!("msAddSiteMode")
    }
    fn msSiteModeCreateJumpList(
        &self,
        bstr_header: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("msSiteModeCreateJumpList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msSiteModeAddJumpListItem(
        &self,
        bstr_name: super::super::Foundation::BSTR,
        bstr_action_uri: super::super::Foundation::BSTR,
        bstr_icon_uri: super::super::Foundation::BSTR,
        pvar_window_type: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("msSiteModeAddJumpListItem")
    }
    fn msSiteModeClearJumpList(&self) -> crate::core::HRESULT {
        todo!("msSiteModeClearJumpList")
    }
    fn msSiteModeShowJumpList(&self) -> crate::core::HRESULT {
        todo!("msSiteModeShowJumpList")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msSiteModeAddButtonStyle(
        &self,
        ui_button_id: super::super::System::Com::VARIANT,
        bstr_icon_url: super::super::Foundation::BSTR,
        bstr_tooltip: super::super::Foundation::BSTR,
        pvar_style_id: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("msSiteModeAddButtonStyle")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msSiteModeShowButtonStyle(
        &self,
        ui_button_id: super::super::System::Com::VARIANT,
        ui_style_id: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("msSiteModeShowButtonStyle")
    }
    fn msSiteModeActivate(&self) -> crate::core::HRESULT {
        todo!("msSiteModeActivate")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msIsSiteModeFirstRun(
        &self,
        f_preserve_state: i16,
        pui_first_run: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("msIsSiteModeFirstRun")
    }
    fn msAddTrackingProtectionList(
        &self,
        url: super::super::Foundation::BSTR,
        bstr_filter_name: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("msAddTrackingProtectionList")
    }
    fn msTrackingProtectionEnabled(&self, pf_enabled: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("msTrackingProtectionEnabled")
    }
    fn msActiveXFilteringEnabled(&self, pf_enabled: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("msActiveXFilteringEnabled")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper4").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper4 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper4 {
    type Super = IShellUIHelper3;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb36e6a53_8073_499e_824c_d776330a333e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper5(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper5_Trait: IShellUIHelper4_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msProvisionNetworks(
        &self,
        bstr_provisioning_xml: super::super::Foundation::BSTR,
        pui_result: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("msProvisionNetworks")
    }
    fn msReportSafeUrl(&self) -> crate::core::HRESULT {
        todo!("msReportSafeUrl")
    }
    fn msSiteModeRefreshBadge(&self) -> crate::core::HRESULT {
        todo!("msSiteModeRefreshBadge")
    }
    fn msSiteModeClearBadge(&self) -> crate::core::HRESULT {
        todo!("msSiteModeClearBadge")
    }
    fn msDiagnoseConnectionUILess(&self) -> crate::core::HRESULT {
        todo!("msDiagnoseConnectionUILess")
    }
    fn msLaunchNetworkClientHelp(&self) -> crate::core::HRESULT {
        todo!("msLaunchNetworkClientHelp")
    }
    fn msChangeDefaultBrowser(&self, f_change: i16) -> crate::core::HRESULT {
        todo!("msChangeDefaultBrowser")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper5 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper5 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper5 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper5 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper5").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper5 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper5 {
    type Super = IShellUIHelper4;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa2a08b09_103d_4d3f_b91c_ea455ca82efa);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper6(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper6_Trait: IShellUIHelper5_Trait {
    fn msStopPeriodicTileUpdate(&self) -> crate::core::HRESULT {
        todo!("msStopPeriodicTileUpdate")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msStartPeriodicTileUpdate(
        &self,
        polling_uris: super::super::System::Com::VARIANT,
        start_time: super::super::System::Com::VARIANT,
        ui_update_recurrence: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("msStartPeriodicTileUpdate")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msStartPeriodicTileUpdateBatch(
        &self,
        polling_uris: super::super::System::Com::VARIANT,
        start_time: super::super::System::Com::VARIANT,
        ui_update_recurrence: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("msStartPeriodicTileUpdateBatch")
    }
    fn msClearTile(&self) -> crate::core::HRESULT {
        todo!("msClearTile")
    }
    fn msEnableTileNotificationQueue(&self, f_change: i16) -> crate::core::HRESULT {
        todo!("msEnableTileNotificationQueue")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msPinnedSiteState(
        &self,
        pvar_site_state: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("msPinnedSiteState")
    }
    fn msEnableTileNotificationQueueForSquare150x150(&self, f_change: i16) -> crate::core::HRESULT {
        todo!("msEnableTileNotificationQueueForSquare150x150")
    }
    fn msEnableTileNotificationQueueForWide310x150(&self, f_change: i16) -> crate::core::HRESULT {
        todo!("msEnableTileNotificationQueueForWide310x150")
    }
    fn msEnableTileNotificationQueueForSquare310x310(&self, f_change: i16) -> crate::core::HRESULT {
        todo!("msEnableTileNotificationQueueForSquare310x310")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msScheduledTileNotification(
        &self,
        bstr_notification_xml: super::super::Foundation::BSTR,
        bstr_notification_id: super::super::Foundation::BSTR,
        bstr_notification_tag: super::super::Foundation::BSTR,
        start_time: super::super::System::Com::VARIANT,
        expiration_time: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("msScheduledTileNotification")
    }
    fn msRemoveScheduledTileNotification(
        &self,
        bstr_notification_id: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("msRemoveScheduledTileNotification")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn msStartPeriodicBadgeUpdate(
        &self,
        polling_uri: super::super::Foundation::BSTR,
        start_time: super::super::System::Com::VARIANT,
        ui_update_recurrence: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("msStartPeriodicBadgeUpdate")
    }
    fn msStopPeriodicBadgeUpdate(&self) -> crate::core::HRESULT {
        todo!("msStopPeriodicBadgeUpdate")
    }
    fn msLaunchInternetOptions(&self) -> crate::core::HRESULT {
        todo!("msLaunchInternetOptions")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper6 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper6 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper6 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper6 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper6").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper6 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper6 {
    type Super = IShellUIHelper5;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x987a573e_46ee_4e89_96ab_ddf7f8fdc98c);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper7(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper7_Trait: IShellUIHelper6_Trait {
    fn SetExperimentalFlag(
        &self,
        bstr_flag_string: super::super::Foundation::BSTR,
        vf_flag: i16,
    ) -> crate::core::HRESULT {
        todo!("SetExperimentalFlag")
    }
    fn GetExperimentalFlag(
        &self,
        bstr_flag_string: super::super::Foundation::BSTR,
        vf_flag: MutPtr<i16>,
    ) -> crate::core::HRESULT {
        todo!("GetExperimentalFlag")
    }
    fn SetExperimentalValue(
        &self,
        bstr_value_string: super::super::Foundation::BSTR,
        dw_value: u32,
    ) -> crate::core::HRESULT {
        todo!("SetExperimentalValue")
    }
    fn GetExperimentalValue(
        &self,
        bstr_value_string: super::super::Foundation::BSTR,
        pdw_value: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetExperimentalValue")
    }
    fn ResetAllExperimentalFlagsAndValues(&self) -> crate::core::HRESULT {
        todo!("ResetAllExperimentalFlagsAndValues")
    }
    fn GetNeedIEAutoLaunchFlag(
        &self,
        bstr_url: super::super::Foundation::BSTR,
        flag: MutPtr<i16>,
    ) -> crate::core::HRESULT {
        todo!("GetNeedIEAutoLaunchFlag")
    }
    fn SetNeedIEAutoLaunchFlag(
        &self,
        bstr_url: super::super::Foundation::BSTR,
        flag: i16,
    ) -> crate::core::HRESULT {
        todo!("SetNeedIEAutoLaunchFlag")
    }
    fn HasNeedIEAutoLaunchFlag(
        &self,
        bstr_url: super::super::Foundation::BSTR,
        exists: MutPtr<i16>,
    ) -> crate::core::HRESULT {
        todo!("HasNeedIEAutoLaunchFlag")
    }
    fn LaunchIE(
        &self,
        bstr_url: super::super::Foundation::BSTR,
        automated: i16,
    ) -> crate::core::HRESULT {
        todo!("LaunchIE")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper7 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper7 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper7 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper7 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper7").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper7 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper7 {
    type Super = IShellUIHelper6;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x60e567c8_9573_4ab2_a264_637c6c161cb1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper8(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper8_Trait: IShellUIHelper7_Trait {
    fn GetCVListData(
        &self,
        pbstr_result: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetCVListData")
    }
    fn GetCVListLocalData(
        &self,
        pbstr_result: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetCVListLocalData")
    }
    fn GetEMIEListData(
        &self,
        pbstr_result: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetEMIEListData")
    }
    fn GetEMIEListLocalData(
        &self,
        pbstr_result: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetEMIEListLocalData")
    }
    fn OpenFavoritesPane(&self) -> crate::core::HRESULT {
        todo!("OpenFavoritesPane")
    }
    fn OpenFavoritesSettings(&self) -> crate::core::HRESULT {
        todo!("OpenFavoritesSettings")
    }
    fn LaunchInHVSI(&self, bstr_url: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("LaunchInHVSI")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper8 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper8 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper8 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper8 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper8").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper8 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper8 {
    type Super = IShellUIHelper7;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x66debcf2_05b0_4f07_b49b_b96241a65db2);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellUIHelper9(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellUIHelper9_Trait: IShellUIHelper8_Trait {
    fn GetOSSku(&self, pdw_result: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetOSSku")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellUIHelper9 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellUIHelper9 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellUIHelper9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellUIHelper9 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellUIHelper9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellUIHelper9").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellUIHelper9 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellUIHelper9 {
    type Super = IShellUIHelper8;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6cdf73b0_7f2f_451f_bc0f_63e0f3284e54);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellView(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellView_Trait: super::super::System::Ole::IOleWindow_Trait {
    fn TranslateAccelerator(
        &self,
        pmsg: ConstPtr<super::WindowsAndMessaging::MSG>,
    ) -> crate::core::HRESULT {
        todo!("TranslateAccelerator")
    }
    fn EnableModeless(&self, f_enable: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("EnableModeless")
    }
    fn UIActivate(&self, u_state: u32) -> crate::core::HRESULT {
        todo!("UIActivate")
    }
    fn Refresh(&self) -> crate::core::HRESULT {
        todo!("Refresh")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateViewWindow(
        &self,
        psv_previous: IShellView,
        pfs: ConstPtr<FOLDERSETTINGS>,
        psb: IShellBrowser,
        prc_view: ConstPtr<super::super::Foundation::RECT>,
        ph_wnd: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("CreateViewWindow")
    }
    fn DestroyViewWindow(&self) -> crate::core::HRESULT {
        todo!("DestroyViewWindow")
    }
    fn GetCurrentInfo(&self, pfs: MutPtr<FOLDERSETTINGS>) -> crate::core::HRESULT {
        todo!("GetCurrentInfo")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddPropertySheetPages(
        &self,
        dw_reserved: u32,
        pfn: super::Controls::LPFNSVADDPROPSHEETPAGE,
        lparam: super::super::Foundation::LPARAM,
    ) -> crate::core::HRESULT {
        todo!("AddPropertySheetPages")
    }
    fn SaveViewState(&self) -> crate::core::HRESULT {
        todo!("SaveViewState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SelectItem(
        &self,
        pidl_item: ConstPtr<Common::ITEMIDLIST>,
        u_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SelectItem")
    }
    fn GetItemObject(
        &self,
        u_item: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetItemObject")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellView {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellView {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellView {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellView {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellView").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellView {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellView {
    type Super = super::super::System::Ole::IOleWindow;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x000214e3_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellView2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellView2_Trait: IShellView_Trait {
    fn GetView(&self, pvid: MutPtr<crate::core::GUID>, u_view: u32) -> crate::core::HRESULT {
        todo!("GetView")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateViewWindow2(&self, lp_params: ConstPtr<SV2CVW2_PARAMS>) -> crate::core::HRESULT {
        todo!("CreateViewWindow2")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn HandleRename(&self, pidl_new: ConstPtr<Common::ITEMIDLIST>) -> crate::core::HRESULT {
        todo!("HandleRename")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SelectAndPositionItem(
        &self,
        pidl_item: ConstPtr<Common::ITEMIDLIST>,
        u_flags: u32,
        ppt: ConstPtr<super::super::Foundation::POINT>,
    ) -> crate::core::HRESULT {
        todo!("SelectAndPositionItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellView2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellView2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellView2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellView2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellView2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellView2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellView2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellView2 {
    type Super = IShellView;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x88e39e80_3578_11cf_ae69_08002b2e1262);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellView3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellView3_Trait: IShellView2_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn CreateViewWindow3(
        &self,
        psb_owner: IShellBrowser,
        psv_prev: IShellView,
        dw_view_flags: u32,
        dw_mask: FOLDERFLAGS,
        dw_flags: FOLDERFLAGS,
        fv_mode: FOLDERVIEWMODE,
        pvid: ConstPtr<crate::core::GUID>,
        prc_view: ConstPtr<super::super::Foundation::RECT>,
        phwnd_view: MutPtr<super::super::Foundation::HWND>,
    ) -> crate::core::HRESULT {
        todo!("CreateViewWindow3")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellView3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellView3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellView3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellView3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellView3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellView3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellView3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellView3 {
    type Super = IShellView2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xec39fa88_f8af_41c5_8421_38bed28f4673);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IShellWindows(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IShellWindows_Trait: super::super::System::Com::IDispatch_Trait {
    fn get_Count(&self, count: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Count")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Item(
        &self,
        index: super::super::System::Com::VARIANT,
        folder: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("Item")
    }
    fn _NewEnum(&self, ppunk: MutPtr<crate::core::IUnknown>) -> crate::core::HRESULT {
        todo!("_NewEnum")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Register(
        &self,
        pid: super::super::System::Com::IDispatch,
        hwnd: i32,
        sw_class: i32,
        pl_cookie: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("Register")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RegisterPending(
        &self,
        l_thread_id: i32,
        pvarloc: ConstPtr<super::super::System::Com::VARIANT>,
        pvarloc_root: ConstPtr<super::super::System::Com::VARIANT>,
        sw_class: i32,
        pl_cookie: MutPtr<i32>,
    ) -> crate::core::HRESULT {
        todo!("RegisterPending")
    }
    fn Revoke(&self, l_cookie: i32) -> crate::core::HRESULT {
        todo!("Revoke")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OnNavigate(
        &self,
        l_cookie: i32,
        pvar_loc: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("OnNavigate")
    }
    fn OnActivated(&self, l_cookie: i32, f_active: i16) -> crate::core::HRESULT {
        todo!("OnActivated")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn FindWindowSW(
        &self,
        pvar_loc: ConstPtr<super::super::System::Com::VARIANT>,
        pvar_loc_root: ConstPtr<super::super::System::Com::VARIANT>,
        sw_class: i32,
        phwnd: MutPtr<i32>,
        swfw_options: i32,
        ppdisp_out: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("FindWindowSW")
    }
    fn OnCreated(&self, l_cookie: i32, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("OnCreated")
    }
    fn ProcessAttachDetach(&self, f_attach: i16) -> crate::core::HRESULT {
        todo!("ProcessAttachDetach")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IShellWindows {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IShellWindows {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IShellWindows {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IShellWindows {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IShellWindows {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IShellWindows").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IShellWindows {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IShellWindows {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x85cb6900_4d95_11cf_960c_0080c7f4ee85);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISortColumnArray(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISortColumnArray_Trait: crate::core::IUnknown_Trait {
    fn GetCount(&self, column_count: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetAt(&self, index: u32, sortcolumn: MutPtr<SORTCOLUMN>) -> crate::core::HRESULT {
        todo!("GetAt")
    }
    fn GetSortType(&self, r#type: MutPtr<SORT_ORDER_TYPE>) -> crate::core::HRESULT {
        todo!("GetSortType")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISortColumnArray {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISortColumnArray {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISortColumnArray {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISortColumnArray {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISortColumnArray {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISortColumnArray").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISortColumnArray {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISortColumnArray {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6dfc60fb_f2e9_459b_beb5_288f1a7c7d54);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IStartMenuPinnedList(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IStartMenuPinnedList_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveFromList(&self, pitem: IShellItem) -> crate::core::HRESULT {
        todo!("RemoveFromList")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IStartMenuPinnedList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IStartMenuPinnedList {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IStartMenuPinnedList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IStartMenuPinnedList {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IStartMenuPinnedList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStartMenuPinnedList")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IStartMenuPinnedList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IStartMenuPinnedList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4cd19ada_25a5_4a32_b3b7_347bee5be36b);
}
pub struct IStorageProviderBanners(pub crate::core::IUnknown);
pub trait IStorageProviderBanners_Trait: crate::core::IUnknown_Trait {
    fn SetBanner(
        &self,
        provider_identity: PCWSTR,
        subscription_id: PCWSTR,
        content_id: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetBanner")
    }
    fn ClearBanner(
        &self,
        provider_identity: PCWSTR,
        subscription_id: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("ClearBanner")
    }
    fn ClearAllBanners(&self, provider_identity: PCWSTR) -> crate::core::HRESULT {
        todo!("ClearAllBanners")
    }
    fn GetBanner(
        &self,
        provider_identity: PCWSTR,
        subscription_id: PCWSTR,
        content_id: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetBanner")
    }
}
impl ::core::clone::Clone for IStorageProviderBanners {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IStorageProviderBanners {}
impl ::core::cmp::PartialEq for IStorageProviderBanners {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStorageProviderBanners {}
impl ::core::fmt::Debug for IStorageProviderBanners {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStorageProviderBanners")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IStorageProviderBanners {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IStorageProviderBanners {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x5efb46d7_47c0_4b68_acda_ded47c90ec91);
}
pub struct IStorageProviderCopyHook(pub crate::core::IUnknown);
pub trait IStorageProviderCopyHook_Trait: crate::core::IUnknown_Trait {
    fn CopyCallback(
        &self,
        hwnd: super::super::Foundation::HWND,
        operation: u32,
        flags: u32,
        src_file: PCWSTR,
        src_attribs: u32,
        dest_file: PCWSTR,
        dest_attribs: u32,
        result: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("CopyCallback")
    }
}
impl ::core::clone::Clone for IStorageProviderCopyHook {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IStorageProviderCopyHook {}
impl ::core::cmp::PartialEq for IStorageProviderCopyHook {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStorageProviderCopyHook {}
impl ::core::fmt::Debug for IStorageProviderCopyHook {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStorageProviderCopyHook")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IStorageProviderCopyHook {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IStorageProviderCopyHook {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7bf992a9_af7a_4dba_b2e5_4d080b1ecbc6);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IStorageProviderHandler(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IStorageProviderHandler_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyHandlerFromPath(
        &self,
        path: PCWSTR,
        property_handler: MutPtr<IStorageProviderPropertyHandler>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyHandlerFromPath")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyHandlerFromUri(
        &self,
        uri: PCWSTR,
        property_handler: MutPtr<IStorageProviderPropertyHandler>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyHandlerFromUri")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPropertyHandlerFromFileId(
        &self,
        file_id: PCWSTR,
        property_handler: MutPtr<IStorageProviderPropertyHandler>,
    ) -> crate::core::HRESULT {
        todo!("GetPropertyHandlerFromFileId")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IStorageProviderHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IStorageProviderHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IStorageProviderHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IStorageProviderHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IStorageProviderHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStorageProviderHandler")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IStorageProviderHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IStorageProviderHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x162c6fb5_44d3_435b_903d_e613fa093fb5);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IStorageProviderPropertyHandler(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IStorageProviderPropertyHandler_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RetrieveProperties(
        &self,
        properties_to_retrieve: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        properties_to_retrieve_count: u32,
        retrieved_properties: MutPtr<PropertiesSystem::IPropertyStore>,
    ) -> crate::core::HRESULT {
        todo!("RetrieveProperties")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SaveProperties(
        &self,
        properties_to_save: PropertiesSystem::IPropertyStore,
    ) -> crate::core::HRESULT {
        todo!("SaveProperties")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IStorageProviderPropertyHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IStorageProviderPropertyHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IStorageProviderPropertyHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IStorageProviderPropertyHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IStorageProviderPropertyHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStorageProviderPropertyHandler")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IStorageProviderPropertyHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IStorageProviderPropertyHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x301dfbe5_524c_4b0f_8b2d_21c40b3a2988);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IStreamAsync(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IStreamAsync_Trait: super::super::System::Com::IStream_Trait {
    fn ReadAsync(
        &self,
        pv: MutPtr<::core::ffi::c_void>,
        cb: u32,
        pcb_read: MutPtr<u32>,
        lp_overlapped: ConstPtr<super::super::System::IO::OVERLAPPED>,
    ) -> crate::core::HRESULT {
        todo!("ReadAsync")
    }
    fn WriteAsync(
        &self,
        lp_buffer: ConstPtr<::core::ffi::c_void>,
        cb: u32,
        pcb_written: MutPtr<u32>,
        lp_overlapped: ConstPtr<super::super::System::IO::OVERLAPPED>,
    ) -> crate::core::HRESULT {
        todo!("WriteAsync")
    }
    fn OverlappedResult(
        &self,
        lp_overlapped: ConstPtr<super::super::System::IO::OVERLAPPED>,
        lp_number_of_bytes_transferred: MutPtr<u32>,
        b_wait: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("OverlappedResult")
    }
    fn CancelIo(&self) -> crate::core::HRESULT {
        todo!("CancelIo")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IStreamAsync {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IStreamAsync {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IStreamAsync {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IStreamAsync {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IStreamAsync {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamAsync").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IStreamAsync {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.IO'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IStreamAsync {
    type Super = super::super::System::Com::IStream;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfe0b6665_e0ca_49b9_a178_2b5cb48d92a5);
}
pub struct IStreamUnbufferedInfo(pub crate::core::IUnknown);
pub trait IStreamUnbufferedInfo_Trait: crate::core::IUnknown_Trait {
    fn GetSectorSize(&self, pcb_sector_size: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetSectorSize")
    }
}
impl ::core::clone::Clone for IStreamUnbufferedInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IStreamUnbufferedInfo {}
impl ::core::cmp::PartialEq for IStreamUnbufferedInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IStreamUnbufferedInfo {}
impl ::core::fmt::Debug for IStreamUnbufferedInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IStreamUnbufferedInfo")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IStreamUnbufferedInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IStreamUnbufferedInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8a68fdda_1fdc_4c20_8ceb_416643b5a625);
}
pub struct ISuspensionDependencyManager(pub crate::core::IUnknown);
pub trait ISuspensionDependencyManager_Trait: crate::core::IUnknown_Trait {
    fn RegisterAsChild(
        &self,
        process_handle: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("RegisterAsChild")
    }
    fn GroupChildWithParent(
        &self,
        child_process_handle: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("GroupChildWithParent")
    }
    fn UngroupChildFromParent(
        &self,
        child_process_handle: super::super::Foundation::HANDLE,
    ) -> crate::core::HRESULT {
        todo!("UngroupChildFromParent")
    }
}
impl ::core::clone::Clone for ISuspensionDependencyManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISuspensionDependencyManager {}
impl ::core::cmp::PartialEq for ISuspensionDependencyManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISuspensionDependencyManager {}
impl ::core::fmt::Debug for ISuspensionDependencyManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISuspensionDependencyManager")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISuspensionDependencyManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISuspensionDependencyManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x52b83a42_2543_416a_81d9_c0de7969c8b3);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISyncMgrConflict(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISyncMgrConflict_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetProperty(
        &self,
        propkey: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        ppropvar: MutPtr<super::super::System::Com::StructuredStorage::PROPVARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetProperty")
    }
    fn GetConflictIdInfo(
        &self,
        p_conflict_id_info: MutPtr<SYNCMGR_CONFLICT_ID_INFO>,
    ) -> crate::core::HRESULT {
        todo!("GetConflictIdInfo")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItemsArray(&self, pp_array: MutPtr<ISyncMgrConflictItems>) -> crate::core::HRESULT {
        todo!("GetItemsArray")
    }
    fn Resolve(&self, p_resolve_info: ISyncMgrConflictResolveInfo) -> crate::core::HRESULT {
        todo!("Resolve")
    }
    fn GetResolutionHandler(
        &self,
        riid: ConstPtr<crate::core::GUID>,
        ppv_resolution_handler: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetResolutionHandler")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISyncMgrConflict {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISyncMgrConflict {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISyncMgrConflict {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISyncMgrConflict {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISyncMgrConflict {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrConflict").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISyncMgrConflict {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISyncMgrConflict {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9c204249_c443_4ba4_85ed_c972681db137);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISyncMgrConflictFolder(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISyncMgrConflictFolder_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetConflictIDList(
        &self,
        p_conflict: ISyncMgrConflict,
        ppidl_conflict: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("GetConflictIDList")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISyncMgrConflictFolder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISyncMgrConflictFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISyncMgrConflictFolder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISyncMgrConflictFolder {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISyncMgrConflictFolder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrConflictFolder")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISyncMgrConflictFolder {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISyncMgrConflictFolder {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x59287f5e_bc81_4fca_a7f1_e5a8ecdb1d69);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISyncMgrConflictItems(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISyncMgrConflictItems_Trait: crate::core::IUnknown_Trait {
    fn GetCount(&self, p_count: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCount")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetItem(
        &self,
        i_index: u32,
        p_item_info: MutPtr<CONFIRM_CONFLICT_ITEM>,
    ) -> crate::core::HRESULT {
        todo!("GetItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISyncMgrConflictItems {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISyncMgrConflictItems {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISyncMgrConflictItems {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISyncMgrConflictItems {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISyncMgrConflictItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrConflictItems")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISyncMgrConflictItems {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISyncMgrConflictItems {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9c7ead52_8023_4936_a4db_d2a9a99e436a);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISyncMgrConflictPresenter(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISyncMgrConflictPresenter_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PresentConflict(
        &self,
        p_conflict: ISyncMgrConflict,
        p_resolve_info: ISyncMgrConflictResolveInfo,
    ) -> crate::core::HRESULT {
        todo!("PresentConflict")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISyncMgrConflictPresenter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISyncMgrConflictPresenter {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISyncMgrConflictPresenter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISyncMgrConflictPresenter {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISyncMgrConflictPresenter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrConflictPresenter")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISyncMgrConflictPresenter {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISyncMgrConflictPresenter {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0b4f5353_fd2b_42cd_8763_4779f2d508a3);
}
pub struct ISyncMgrConflictResolutionItems(pub crate::core::IUnknown);
pub trait ISyncMgrConflictResolutionItems_Trait: crate::core::IUnknown_Trait {
    fn GetCount(&self, p_count: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCount")
    }
    fn GetItem(
        &self,
        i_index: u32,
        p_item_info: MutPtr<CONFIRM_CONFLICT_RESULT_INFO>,
    ) -> crate::core::HRESULT {
        todo!("GetItem")
    }
}
impl ::core::clone::Clone for ISyncMgrConflictResolutionItems {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrConflictResolutionItems {}
impl ::core::cmp::PartialEq for ISyncMgrConflictResolutionItems {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrConflictResolutionItems {}
impl ::core::fmt::Debug for ISyncMgrConflictResolutionItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrConflictResolutionItems")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrConflictResolutionItems {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrConflictResolutionItems {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x458725b9_129d_4135_a998_9ceafec27007);
}
pub struct ISyncMgrConflictResolveInfo(pub crate::core::IUnknown);
pub trait ISyncMgrConflictResolveInfo_Trait: crate::core::IUnknown_Trait {
    fn GetIterationInfo(
        &self,
        pn_current_conflict: MutPtr<u32>,
        pc_conflicts: MutPtr<u32>,
        pc_remaining_for_apply_to_all: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetIterationInfo")
    }
    fn GetPresenterNextStep(
        &self,
        pn_presenter_next_step: MutPtr<SYNCMGR_PRESENTER_NEXT_STEP>,
    ) -> crate::core::HRESULT {
        todo!("GetPresenterNextStep")
    }
    fn GetPresenterChoice(
        &self,
        pn_presenter_choice: MutPtr<SYNCMGR_PRESENTER_CHOICE>,
        pf_apply_to_all: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("GetPresenterChoice")
    }
    fn GetItemChoiceCount(&self, pc_choices: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetItemChoiceCount")
    }
    fn GetItemChoice(&self, i_choice: u32, pi_choice_index: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetItemChoice")
    }
    fn SetPresenterNextStep(
        &self,
        n_presenter_next_step: SYNCMGR_PRESENTER_NEXT_STEP,
    ) -> crate::core::HRESULT {
        todo!("SetPresenterNextStep")
    }
    fn SetPresenterChoice(
        &self,
        n_presenter_choice: SYNCMGR_PRESENTER_CHOICE,
        f_apply_to_all: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetPresenterChoice")
    }
    fn SetItemChoices(
        &self,
        prgi_conflict_item_indexes: MutPtr<u32>,
        c_choices: u32,
    ) -> crate::core::HRESULT {
        todo!("SetItemChoices")
    }
}
impl ::core::clone::Clone for ISyncMgrConflictResolveInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrConflictResolveInfo {}
impl ::core::cmp::PartialEq for ISyncMgrConflictResolveInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrConflictResolveInfo {}
impl ::core::fmt::Debug for ISyncMgrConflictResolveInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrConflictResolveInfo")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrConflictResolveInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrConflictResolveInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc405a219_25a2_442e_8743_b845a2cee93f);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISyncMgrConflictStore(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISyncMgrConflictStore_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EnumConflicts(
        &self,
        psz_handler_id: PCWSTR,
        psz_item_id: PCWSTR,
        pp_enum: MutPtr<IEnumSyncMgrConflict>,
    ) -> crate::core::HRESULT {
        todo!("EnumConflicts")
    }
    fn BindToConflict(
        &self,
        p_conflict_id_info: ConstPtr<SYNCMGR_CONFLICT_ID_INFO>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("BindToConflict")
    }
    fn RemoveConflicts(
        &self,
        rg_conflict_id_info: ConstPtr<SYNCMGR_CONFLICT_ID_INFO>,
        c_conflicts: u32,
    ) -> crate::core::HRESULT {
        todo!("RemoveConflicts")
    }
    fn GetCount(
        &self,
        psz_handler_id: PCWSTR,
        psz_item_id: PCWSTR,
        pn_conflicts: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetCount")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISyncMgrConflictStore {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISyncMgrConflictStore {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISyncMgrConflictStore {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISyncMgrConflictStore {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISyncMgrConflictStore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrConflictStore")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISyncMgrConflictStore {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISyncMgrConflictStore {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xcf8fc579_c396_4774_85f1_d908a831156e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISyncMgrControl(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISyncMgrControl_Trait: crate::core::IUnknown_Trait {
    fn StartHandlerSync(
        &self,
        psz_handler_id: PCWSTR,
        hwnd_owner: super::super::Foundation::HWND,
        punk: crate::core::IUnknown,
        n_sync_control_flags: SYNCMGR_SYNC_CONTROL_FLAGS,
        p_result: ISyncMgrSyncResult,
    ) -> crate::core::HRESULT {
        todo!("StartHandlerSync")
    }
    fn StartItemSync(
        &self,
        psz_handler_id: PCWSTR,
        ppsz_item_i_ds: ConstPtr<PWSTR>,
        c_items: u32,
        hwnd_owner: super::super::Foundation::HWND,
        punk: crate::core::IUnknown,
        n_sync_control_flags: SYNCMGR_SYNC_CONTROL_FLAGS,
        p_result: ISyncMgrSyncResult,
    ) -> crate::core::HRESULT {
        todo!("StartItemSync")
    }
    fn StartSyncAll(&self, hwnd_owner: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("StartSyncAll")
    }
    fn StopHandlerSync(&self, psz_handler_id: PCWSTR) -> crate::core::HRESULT {
        todo!("StopHandlerSync")
    }
    fn StopItemSync(
        &self,
        psz_handler_id: PCWSTR,
        ppsz_item_i_ds: ConstPtr<PWSTR>,
        c_items: u32,
    ) -> crate::core::HRESULT {
        todo!("StopItemSync")
    }
    fn StopSyncAll(&self) -> crate::core::HRESULT {
        todo!("StopSyncAll")
    }
    fn UpdateHandlerCollection(
        &self,
        rclsid_collection_id: ConstPtr<crate::core::GUID>,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("UpdateHandlerCollection")
    }
    fn UpdateHandler(
        &self,
        psz_handler_id: PCWSTR,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("UpdateHandler")
    }
    fn UpdateItem(
        &self,
        psz_handler_id: PCWSTR,
        psz_item_id: PCWSTR,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("UpdateItem")
    }
    fn UpdateEvents(
        &self,
        psz_handler_id: PCWSTR,
        psz_item_id: PCWSTR,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("UpdateEvents")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn UpdateConflict(
        &self,
        psz_handler_id: PCWSTR,
        psz_item_id: PCWSTR,
        p_conflict: ISyncMgrConflict,
        n_reason: SYNCMGR_UPDATE_REASON,
    ) -> crate::core::HRESULT {
        todo!("UpdateConflict")
    }
    fn UpdateConflicts(
        &self,
        psz_handler_id: PCWSTR,
        psz_item_id: PCWSTR,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("UpdateConflicts")
    }
    fn ActivateHandler(
        &self,
        f_activate: super::super::Foundation::BOOL,
        psz_handler_id: PCWSTR,
        hwnd_owner: super::super::Foundation::HWND,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("ActivateHandler")
    }
    fn EnableHandler(
        &self,
        f_enable: super::super::Foundation::BOOL,
        psz_handler_id: PCWSTR,
        hwnd_owner: super::super::Foundation::HWND,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("EnableHandler")
    }
    fn EnableItem(
        &self,
        f_enable: super::super::Foundation::BOOL,
        psz_handler_id: PCWSTR,
        psz_item_id: PCWSTR,
        hwnd_owner: super::super::Foundation::HWND,
        n_control_flags: SYNCMGR_CONTROL_FLAGS,
    ) -> crate::core::HRESULT {
        todo!("EnableItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISyncMgrControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISyncMgrControl {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISyncMgrControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISyncMgrControl {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISyncMgrControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrControl").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISyncMgrControl {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISyncMgrControl {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9b63616c_36b2_46bc_959f_c1593952d19b);
}
pub struct ISyncMgrEnumItems(pub crate::core::IUnknown);
pub trait ISyncMgrEnumItems_Trait: crate::core::IUnknown_Trait {
    fn Next(
        &self,
        celt: u32,
        rgelt: MutPtr<SYNCMGRITEM>,
        pcelt_fetched: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("Next")
    }
    fn Skip(&self, celt: u32) -> crate::core::HRESULT {
        todo!("Skip")
    }
    fn Reset(&self) -> crate::core::HRESULT {
        todo!("Reset")
    }
    fn Clone(&self, ppenum: MutPtr<ISyncMgrEnumItems>) -> crate::core::HRESULT {
        todo!("Clone")
    }
}
impl ::core::clone::Clone for ISyncMgrEnumItems {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrEnumItems {}
impl ::core::cmp::PartialEq for ISyncMgrEnumItems {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrEnumItems {}
impl ::core::fmt::Debug for ISyncMgrEnumItems {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrEnumItems").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrEnumItems {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrEnumItems {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6295df2a_35ee_11d1_8707_00c04fd93327);
}
pub struct ISyncMgrEvent(pub crate::core::IUnknown);
pub trait ISyncMgrEvent_Trait: crate::core::IUnknown_Trait {
    fn GetEventID(&self, pguid_event_id: MutPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("GetEventID")
    }
    fn GetHandlerID(&self, ppsz_handler_id: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetHandlerID")
    }
    fn GetItemID(&self, ppsz_item_id: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetItemID")
    }
    fn GetLevel(&self, pn_level: MutPtr<SYNCMGR_EVENT_LEVEL>) -> crate::core::HRESULT {
        todo!("GetLevel")
    }
    fn GetFlags(&self, pn_flags: MutPtr<SYNCMGR_EVENT_FLAGS>) -> crate::core::HRESULT {
        todo!("GetFlags")
    }
    fn GetTime(
        &self,
        pf_creation_time: MutPtr<super::super::Foundation::FILETIME>,
    ) -> crate::core::HRESULT {
        todo!("GetTime")
    }
    fn GetName(&self, ppsz_name: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetName")
    }
    fn GetDescription(&self, ppsz_description: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetDescription")
    }
    fn GetLinkText(&self, ppsz_link_text: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetLinkText")
    }
    fn GetLinkReference(&self, ppsz_link_reference: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetLinkReference")
    }
    fn GetContext(&self, ppsz_context: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetContext")
    }
}
impl ::core::clone::Clone for ISyncMgrEvent {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrEvent {}
impl ::core::cmp::PartialEq for ISyncMgrEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrEvent {}
impl ::core::fmt::Debug for ISyncMgrEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrEvent").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrEvent {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrEvent {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfee0ef8b_46bd_4db4_b7e6_ff2c687313bc);
}
pub struct ISyncMgrEventLinkUIOperation(pub crate::core::IUnknown);
pub trait ISyncMgrEventLinkUIOperation_Trait: ISyncMgrUIOperation_Trait {
    fn Init(
        &self,
        rguid_event_id: ConstPtr<crate::core::GUID>,
        p_event: ISyncMgrEvent,
    ) -> crate::core::HRESULT {
        todo!("Init")
    }
}
impl ::core::clone::Clone for ISyncMgrEventLinkUIOperation {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrEventLinkUIOperation {}
impl ::core::cmp::PartialEq for ISyncMgrEventLinkUIOperation {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrEventLinkUIOperation {}
impl ::core::fmt::Debug for ISyncMgrEventLinkUIOperation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrEventLinkUIOperation")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrEventLinkUIOperation {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrEventLinkUIOperation {
    type Super = ISyncMgrUIOperation;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x64522e52_848b_4015_89ce_5a36f00b94ff);
}
pub struct ISyncMgrEventStore(pub crate::core::IUnknown);
pub trait ISyncMgrEventStore_Trait: crate::core::IUnknown_Trait {
    fn GetEventEnumerator(&self, ppenum: MutPtr<IEnumSyncMgrEvents>) -> crate::core::HRESULT {
        todo!("GetEventEnumerator")
    }
    fn GetEventCount(&self, pc_events: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetEventCount")
    }
    fn GetEvent(
        &self,
        rguid_event_id: ConstPtr<crate::core::GUID>,
        pp_event: MutPtr<ISyncMgrEvent>,
    ) -> crate::core::HRESULT {
        todo!("GetEvent")
    }
    fn RemoveEvent(
        &self,
        pguid_event_i_ds: ConstPtr<crate::core::GUID>,
        c_events: u32,
    ) -> crate::core::HRESULT {
        todo!("RemoveEvent")
    }
}
impl ::core::clone::Clone for ISyncMgrEventStore {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrEventStore {}
impl ::core::cmp::PartialEq for ISyncMgrEventStore {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrEventStore {}
impl ::core::fmt::Debug for ISyncMgrEventStore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrEventStore").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrEventStore {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrEventStore {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x37e412f9_016e_44c2_81ff_db3add774266);
}
pub struct ISyncMgrHandler(pub crate::core::IUnknown);
pub trait ISyncMgrHandler_Trait: crate::core::IUnknown_Trait {
    fn GetName(&self, ppsz_name: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetName")
    }
    fn GetHandlerInfo(&self, pp_handler_info: MutPtr<ISyncMgrHandlerInfo>) -> crate::core::HRESULT {
        todo!("GetHandlerInfo")
    }
    fn GetObject(
        &self,
        rguid_object_id: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetObject")
    }
    fn GetCapabilities(
        &self,
        pm_capabilities: MutPtr<SYNCMGR_HANDLER_CAPABILITIES>,
    ) -> crate::core::HRESULT {
        todo!("GetCapabilities")
    }
    fn GetPolicies(&self, pm_policies: MutPtr<SYNCMGR_HANDLER_POLICIES>) -> crate::core::HRESULT {
        todo!("GetPolicies")
    }
    fn Activate(&self, f_activate: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("Activate")
    }
    fn Enable(&self, f_enable: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("Enable")
    }
    fn Synchronize(
        &self,
        ppsz_item_i_ds: ConstPtr<PWSTR>,
        c_items: u32,
        hwnd_owner: super::super::Foundation::HWND,
        p_session_creator: ISyncMgrSessionCreator,
        punk: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("Synchronize")
    }
}
impl ::core::clone::Clone for ISyncMgrHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrHandler {}
impl ::core::cmp::PartialEq for ISyncMgrHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrHandler {}
impl ::core::fmt::Debug for ISyncMgrHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrHandler").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x04ec2e43_ac77_49f9_9b98_0307ef7a72a2);
}
pub struct ISyncMgrHandlerCollection(pub crate::core::IUnknown);
pub trait ISyncMgrHandlerCollection_Trait: crate::core::IUnknown_Trait {
    fn GetHandlerEnumerator(
        &self,
        ppenum: MutPtr<super::super::System::Com::IEnumString>,
    ) -> crate::core::HRESULT {
        todo!("GetHandlerEnumerator")
    }
    fn BindToHandler(
        &self,
        psz_handler_id: PCWSTR,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("BindToHandler")
    }
}
impl ::core::clone::Clone for ISyncMgrHandlerCollection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrHandlerCollection {}
impl ::core::cmp::PartialEq for ISyncMgrHandlerCollection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrHandlerCollection {}
impl ::core::fmt::Debug for ISyncMgrHandlerCollection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrHandlerCollection")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrHandlerCollection {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrHandlerCollection {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa7f337a3_d20b_45cb_9ed7_87d094ca5045);
}
pub struct ISyncMgrHandlerInfo(pub crate::core::IUnknown);
pub trait ISyncMgrHandlerInfo_Trait: crate::core::IUnknown_Trait {
    fn GetType(&self, pn_type: MutPtr<SYNCMGR_HANDLER_TYPE>) -> crate::core::HRESULT {
        todo!("GetType")
    }
    fn GetTypeLabel(&self, ppsz_type_label: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetTypeLabel")
    }
    fn GetComment(&self, ppsz_comment: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetComment")
    }
    fn GetLastSyncTime(
        &self,
        pft_last_sync: MutPtr<super::super::Foundation::FILETIME>,
    ) -> crate::core::HRESULT {
        todo!("GetLastSyncTime")
    }
    fn IsActive(&self) -> crate::core::HRESULT {
        todo!("IsActive")
    }
    fn IsEnabled(&self) -> crate::core::HRESULT {
        todo!("IsEnabled")
    }
    fn IsConnected(&self) -> crate::core::HRESULT {
        todo!("IsConnected")
    }
}
impl ::core::clone::Clone for ISyncMgrHandlerInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrHandlerInfo {}
impl ::core::cmp::PartialEq for ISyncMgrHandlerInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrHandlerInfo {}
impl ::core::fmt::Debug for ISyncMgrHandlerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrHandlerInfo").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrHandlerInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrHandlerInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4ff1d798_ecf7_4524_aa81_1e362a0aef3a);
}
pub struct ISyncMgrRegister(pub crate::core::IUnknown);
pub trait ISyncMgrRegister_Trait: crate::core::IUnknown_Trait {
    fn RegisterSyncMgrHandler(
        &self,
        clsid_handler: ConstPtr<crate::core::GUID>,
        pwsz_description: PCWSTR,
        dw_sync_mgr_register_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("RegisterSyncMgrHandler")
    }
    fn UnregisterSyncMgrHandler(
        &self,
        clsid_handler: ConstPtr<crate::core::GUID>,
        dw_reserved: u32,
    ) -> crate::core::HRESULT {
        todo!("UnregisterSyncMgrHandler")
    }
    fn GetHandlerRegistrationInfo(
        &self,
        clsid_handler: ConstPtr<crate::core::GUID>,
        pdw_sync_mgr_register_flags: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("GetHandlerRegistrationInfo")
    }
}
impl ::core::clone::Clone for ISyncMgrRegister {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrRegister {}
impl ::core::cmp::PartialEq for ISyncMgrRegister {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrRegister {}
impl ::core::fmt::Debug for ISyncMgrRegister {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrRegister").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrRegister {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrRegister {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6295df42_35ee_11d1_8707_00c04fd93327);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ISyncMgrResolutionHandler(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ISyncMgrResolutionHandler_Trait: crate::core::IUnknown_Trait {
    fn QueryAbilities(&self, pdw_abilities: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("QueryAbilities")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn KeepOther(
        &self,
        psi_other: IShellItem,
        p_feedback: MutPtr<SYNCMGR_RESOLUTION_FEEDBACK>,
    ) -> crate::core::HRESULT {
        todo!("KeepOther")
    }
    fn KeepRecent(&self, p_feedback: MutPtr<SYNCMGR_RESOLUTION_FEEDBACK>) -> crate::core::HRESULT {
        todo!("KeepRecent")
    }
    fn RemoveFromSyncSet(
        &self,
        p_feedback: MutPtr<SYNCMGR_RESOLUTION_FEEDBACK>,
    ) -> crate::core::HRESULT {
        todo!("RemoveFromSyncSet")
    }
    fn KeepItems(
        &self,
        p_array: ISyncMgrConflictResolutionItems,
        p_feedback: MutPtr<SYNCMGR_RESOLUTION_FEEDBACK>,
    ) -> crate::core::HRESULT {
        todo!("KeepItems")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ISyncMgrResolutionHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ISyncMgrResolutionHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ISyncMgrResolutionHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ISyncMgrResolutionHandler {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ISyncMgrResolutionHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrResolutionHandler")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ISyncMgrResolutionHandler {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ISyncMgrResolutionHandler {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x40a3d052_8bff_4c4b_a338_d4a395700de9);
}
pub struct ISyncMgrScheduleWizardUIOperation(pub crate::core::IUnknown);
pub trait ISyncMgrScheduleWizardUIOperation_Trait: ISyncMgrUIOperation_Trait {
    fn InitWizard(&self, psz_handler_id: PCWSTR) -> crate::core::HRESULT {
        todo!("InitWizard")
    }
}
impl ::core::clone::Clone for ISyncMgrScheduleWizardUIOperation {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrScheduleWizardUIOperation {}
impl ::core::cmp::PartialEq for ISyncMgrScheduleWizardUIOperation {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrScheduleWizardUIOperation {}
impl ::core::fmt::Debug for ISyncMgrScheduleWizardUIOperation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrScheduleWizardUIOperation")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrScheduleWizardUIOperation {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrScheduleWizardUIOperation {
    type Super = ISyncMgrUIOperation;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x459a6c84_21d2_4ddc_8a53_f023a46066f2);
}
pub struct ISyncMgrSessionCreator(pub crate::core::IUnknown);
pub trait ISyncMgrSessionCreator_Trait: crate::core::IUnknown_Trait {
    fn CreateSession(
        &self,
        psz_handler_id: PCWSTR,
        ppsz_item_i_ds: ConstPtr<PWSTR>,
        c_items: u32,
        pp_callback: MutPtr<ISyncMgrSyncCallback>,
    ) -> crate::core::HRESULT {
        todo!("CreateSession")
    }
}
impl ::core::clone::Clone for ISyncMgrSessionCreator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSessionCreator {}
impl ::core::cmp::PartialEq for ISyncMgrSessionCreator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSessionCreator {}
impl ::core::fmt::Debug for ISyncMgrSessionCreator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSessionCreator")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrSessionCreator {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSessionCreator {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x17f48517_f305_4321_a08d_b25a834918fd);
}
pub struct ISyncMgrSyncCallback(pub crate::core::IUnknown);
pub trait ISyncMgrSyncCallback_Trait: crate::core::IUnknown_Trait {
    fn ReportProgress(
        &self,
        psz_item_id: PCWSTR,
        psz_progress_text: PCWSTR,
        n_status: SYNCMGR_PROGRESS_STATUS,
        u_current_step: u32,
        u_max_step: u32,
        pn_cancel_request: MutPtr<SYNCMGR_CANCEL_REQUEST>,
    ) -> crate::core::HRESULT {
        todo!("ReportProgress")
    }
    fn SetHandlerProgressText(
        &self,
        psz_progress_text: PCWSTR,
        pn_cancel_request: MutPtr<SYNCMGR_CANCEL_REQUEST>,
    ) -> crate::core::HRESULT {
        todo!("SetHandlerProgressText")
    }
    fn ReportEvent(
        &self,
        psz_item_id: PCWSTR,
        n_level: SYNCMGR_EVENT_LEVEL,
        n_flags: SYNCMGR_EVENT_FLAGS,
        psz_name: PCWSTR,
        psz_description: PCWSTR,
        psz_link_text: PCWSTR,
        psz_link_reference: PCWSTR,
        psz_context: PCWSTR,
        pguid_event_id: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("ReportEvent")
    }
    fn CanContinue(&self, psz_item_id: PCWSTR) -> crate::core::HRESULT {
        todo!("CanContinue")
    }
    fn QueryForAdditionalItems(
        &self,
        ppenum_item_i_ds: MutPtr<super::super::System::Com::IEnumString>,
        ppenum_punks: MutPtr<super::super::System::Com::IEnumUnknown>,
    ) -> crate::core::HRESULT {
        todo!("QueryForAdditionalItems")
    }
    fn AddItemToSession(&self, psz_item_id: PCWSTR) -> crate::core::HRESULT {
        todo!("AddItemToSession")
    }
    fn AddIUnknownToSession(&self, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("AddIUnknownToSession")
    }
    fn ProposeItem(&self, p_new_item: ISyncMgrSyncItem) -> crate::core::HRESULT {
        todo!("ProposeItem")
    }
    fn CommitItem(&self, psz_item_id: PCWSTR) -> crate::core::HRESULT {
        todo!("CommitItem")
    }
    fn ReportManualSync(&self) -> crate::core::HRESULT {
        todo!("ReportManualSync")
    }
}
impl ::core::clone::Clone for ISyncMgrSyncCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSyncCallback {}
impl ::core::cmp::PartialEq for ISyncMgrSyncCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSyncCallback {}
impl ::core::fmt::Debug for ISyncMgrSyncCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSyncCallback")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrSyncCallback {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSyncCallback {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x884ccd87_b139_4937_a4ba_4f8e19513fbe);
}
pub struct ISyncMgrSyncItem(pub crate::core::IUnknown);
pub trait ISyncMgrSyncItem_Trait: crate::core::IUnknown_Trait {
    fn GetItemID(&self, ppsz_item_id: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetItemID")
    }
    fn GetName(&self, ppsz_name: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetName")
    }
    fn GetItemInfo(&self, pp_item_info: MutPtr<ISyncMgrSyncItemInfo>) -> crate::core::HRESULT {
        todo!("GetItemInfo")
    }
    fn GetObject(
        &self,
        rguid_object_id: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetObject")
    }
    fn GetCapabilities(
        &self,
        pm_capabilities: MutPtr<SYNCMGR_ITEM_CAPABILITIES>,
    ) -> crate::core::HRESULT {
        todo!("GetCapabilities")
    }
    fn GetPolicies(&self, pm_policies: MutPtr<SYNCMGR_ITEM_POLICIES>) -> crate::core::HRESULT {
        todo!("GetPolicies")
    }
    fn Enable(&self, f_enable: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("Enable")
    }
    fn Delete(&self) -> crate::core::HRESULT {
        todo!("Delete")
    }
}
impl ::core::clone::Clone for ISyncMgrSyncItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSyncItem {}
impl ::core::cmp::PartialEq for ISyncMgrSyncItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSyncItem {}
impl ::core::fmt::Debug for ISyncMgrSyncItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSyncItem").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrSyncItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSyncItem {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xb20b24ce_2593_4f04_bd8b_7ad6c45051cd);
}
pub struct ISyncMgrSyncItemContainer(pub crate::core::IUnknown);
pub trait ISyncMgrSyncItemContainer_Trait: crate::core::IUnknown_Trait {
    fn GetSyncItem(
        &self,
        psz_item_id: PCWSTR,
        pp_item: MutPtr<ISyncMgrSyncItem>,
    ) -> crate::core::HRESULT {
        todo!("GetSyncItem")
    }
    fn GetSyncItemEnumerator(&self, ppenum: MutPtr<IEnumSyncMgrSyncItems>) -> crate::core::HRESULT {
        todo!("GetSyncItemEnumerator")
    }
    fn GetSyncItemCount(&self, pc_items: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetSyncItemCount")
    }
}
impl ::core::clone::Clone for ISyncMgrSyncItemContainer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSyncItemContainer {}
impl ::core::cmp::PartialEq for ISyncMgrSyncItemContainer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSyncItemContainer {}
impl ::core::fmt::Debug for ISyncMgrSyncItemContainer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSyncItemContainer")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrSyncItemContainer {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSyncItemContainer {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x90701133_be32_4129_a65c_99e616cafff4);
}
pub struct ISyncMgrSyncItemInfo(pub crate::core::IUnknown);
pub trait ISyncMgrSyncItemInfo_Trait: crate::core::IUnknown_Trait {
    fn GetTypeLabel(&self, ppsz_type_label: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetTypeLabel")
    }
    fn GetComment(&self, ppsz_comment: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetComment")
    }
    fn GetLastSyncTime(
        &self,
        pft_last_sync: MutPtr<super::super::Foundation::FILETIME>,
    ) -> crate::core::HRESULT {
        todo!("GetLastSyncTime")
    }
    fn IsEnabled(&self) -> crate::core::HRESULT {
        todo!("IsEnabled")
    }
    fn IsConnected(&self) -> crate::core::HRESULT {
        todo!("IsConnected")
    }
}
impl ::core::clone::Clone for ISyncMgrSyncItemInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSyncItemInfo {}
impl ::core::cmp::PartialEq for ISyncMgrSyncItemInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSyncItemInfo {}
impl ::core::fmt::Debug for ISyncMgrSyncItemInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSyncItemInfo")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrSyncItemInfo {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSyncItemInfo {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe7fd9502_be0c_4464_90a1_2b5277031232);
}
pub struct ISyncMgrSyncResult(pub crate::core::IUnknown);
pub trait ISyncMgrSyncResult_Trait: crate::core::IUnknown_Trait {
    fn Result(
        &self,
        n_status: SYNCMGR_PROGRESS_STATUS,
        c_error: u32,
        c_conflicts: u32,
    ) -> crate::core::HRESULT {
        todo!("Result")
    }
}
impl ::core::clone::Clone for ISyncMgrSyncResult {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSyncResult {}
impl ::core::cmp::PartialEq for ISyncMgrSyncResult {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSyncResult {}
impl ::core::fmt::Debug for ISyncMgrSyncResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSyncResult").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrSyncResult {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSyncResult {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x2b90f17e_5a3e_4b33_bb7f_1bc48056b94d);
}
pub struct ISyncMgrSynchronize(pub crate::core::IUnknown);
pub trait ISyncMgrSynchronize_Trait: crate::core::IUnknown_Trait {
    fn Initialize(
        &self,
        dw_reserved: u32,
        dw_sync_mgr_flags: u32,
        cb_cookie: u32,
        lp_cookie: ConstPtr<u8>,
    ) -> crate::core::HRESULT {
        todo!("Initialize")
    }
    fn GetHandlerInfo(
        &self,
        pp_sync_mgr_handler_info: MutPtr<ConstPtr<SYNCMGRHANDLERINFO>>,
    ) -> crate::core::HRESULT {
        todo!("GetHandlerInfo")
    }
    fn EnumSyncMgrItems(
        &self,
        pp_sync_mgr_enum_items: MutPtr<ISyncMgrEnumItems>,
    ) -> crate::core::HRESULT {
        todo!("EnumSyncMgrItems")
    }
    fn GetItemObject(
        &self,
        item_id: ConstPtr<crate::core::GUID>,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetItemObject")
    }
    fn ShowProperties(
        &self,
        h_wnd_parent: super::super::Foundation::HWND,
        item_id: ConstPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("ShowProperties")
    }
    fn SetProgressCallback(
        &self,
        lp_call_back: ISyncMgrSynchronizeCallback,
    ) -> crate::core::HRESULT {
        todo!("SetProgressCallback")
    }
    fn PrepareForSync(
        &self,
        cb_num_items: u32,
        p_item_i_ds: ConstPtr<crate::core::GUID>,
        h_wnd_parent: super::super::Foundation::HWND,
        dw_reserved: u32,
    ) -> crate::core::HRESULT {
        todo!("PrepareForSync")
    }
    fn Synchronize(&self, h_wnd_parent: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("Synchronize")
    }
    fn SetItemStatus(
        &self,
        p_item_id: ConstPtr<crate::core::GUID>,
        dw_sync_mgr_status: u32,
    ) -> crate::core::HRESULT {
        todo!("SetItemStatus")
    }
    fn ShowError(
        &self,
        h_wnd_parent: super::super::Foundation::HWND,
        error_id: ConstPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("ShowError")
    }
}
impl ::core::clone::Clone for ISyncMgrSynchronize {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSynchronize {}
impl ::core::cmp::PartialEq for ISyncMgrSynchronize {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSynchronize {}
impl ::core::fmt::Debug for ISyncMgrSynchronize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSynchronize").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrSynchronize {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSynchronize {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6295df40_35ee_11d1_8707_00c04fd93327);
}
pub struct ISyncMgrSynchronizeCallback(pub crate::core::IUnknown);
pub trait ISyncMgrSynchronizeCallback_Trait: crate::core::IUnknown_Trait {
    fn ShowPropertiesCompleted(&self, hr: crate::core::HRESULT) -> crate::core::HRESULT {
        todo!("ShowPropertiesCompleted")
    }
    fn PrepareForSyncCompleted(&self, hr: crate::core::HRESULT) -> crate::core::HRESULT {
        todo!("PrepareForSyncCompleted")
    }
    fn SynchronizeCompleted(&self, hr: crate::core::HRESULT) -> crate::core::HRESULT {
        todo!("SynchronizeCompleted")
    }
    fn ShowErrorCompleted(
        &self,
        hr: crate::core::HRESULT,
        c_items: u32,
        p_item_i_ds: ConstPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("ShowErrorCompleted")
    }
    fn EnableModeless(&self, f_enable: super::super::Foundation::BOOL) -> crate::core::HRESULT {
        todo!("EnableModeless")
    }
    fn Progress(
        &self,
        item_id: ConstPtr<crate::core::GUID>,
        p_sync_progress_item: ConstPtr<SYNCMGRPROGRESSITEM>,
    ) -> crate::core::HRESULT {
        todo!("Progress")
    }
    fn LogError(
        &self,
        dw_error_level: u32,
        psz_error_text: PCWSTR,
        p_sync_log_error: ConstPtr<SYNCMGRLOGERRORINFO>,
    ) -> crate::core::HRESULT {
        todo!("LogError")
    }
    fn DeleteLogError(
        &self,
        error_id: ConstPtr<crate::core::GUID>,
        dw_reserved: u32,
    ) -> crate::core::HRESULT {
        todo!("DeleteLogError")
    }
    fn EstablishConnection(
        &self,
        pwsz_connection: PCWSTR,
        dw_reserved: u32,
    ) -> crate::core::HRESULT {
        todo!("EstablishConnection")
    }
}
impl ::core::clone::Clone for ISyncMgrSynchronizeCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSynchronizeCallback {}
impl ::core::cmp::PartialEq for ISyncMgrSynchronizeCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSynchronizeCallback {}
impl ::core::fmt::Debug for ISyncMgrSynchronizeCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSynchronizeCallback")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrSynchronizeCallback {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSynchronizeCallback {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6295df41_35ee_11d1_8707_00c04fd93327);
}
pub struct ISyncMgrSynchronizeInvoke(pub crate::core::IUnknown);
pub trait ISyncMgrSynchronizeInvoke_Trait: crate::core::IUnknown_Trait {
    fn UpdateItems(
        &self,
        dw_invoke_flags: u32,
        clsid: ConstPtr<crate::core::GUID>,
        cb_cookie: u32,
        p_cookie: ConstPtr<u8>,
    ) -> crate::core::HRESULT {
        todo!("UpdateItems")
    }
    fn UpdateAll(&self) -> crate::core::HRESULT {
        todo!("UpdateAll")
    }
}
impl ::core::clone::Clone for ISyncMgrSynchronizeInvoke {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrSynchronizeInvoke {}
impl ::core::cmp::PartialEq for ISyncMgrSynchronizeInvoke {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrSynchronizeInvoke {}
impl ::core::fmt::Debug for ISyncMgrSynchronizeInvoke {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrSynchronizeInvoke")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ISyncMgrSynchronizeInvoke {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrSynchronizeInvoke {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6295df2c_35ee_11d1_8707_00c04fd93327);
}
pub struct ISyncMgrUIOperation(pub crate::core::IUnknown);
pub trait ISyncMgrUIOperation_Trait: crate::core::IUnknown_Trait {
    fn Run(&self, hwnd_owner: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("Run")
    }
}
impl ::core::clone::Clone for ISyncMgrUIOperation {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ISyncMgrUIOperation {}
impl ::core::cmp::PartialEq for ISyncMgrUIOperation {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ISyncMgrUIOperation {}
impl ::core::fmt::Debug for ISyncMgrUIOperation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ISyncMgrUIOperation").field(&self.0).finish()
    }
}
impl FromIntoMemory for ISyncMgrUIOperation {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ISyncMgrUIOperation {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfc7cfa47_dfe1_45b5_a049_8cfd82bec271);
}
pub struct ITEMSPACING {
    pub cxSmall: i32,
    pub cySmall: i32,
    pub cxLarge: i32,
    pub cyLarge: i32,
}
impl ::core::marker::Copy for ITEMSPACING {}
impl ::core::clone::Clone for ITEMSPACING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ITEMSPACING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ITEMSPACING")
            .field("cxSmall", &self.cxSmall)
            .field("cySmall", &self.cySmall)
            .field("cxLarge", &self.cxLarge)
            .field("cyLarge", &self.cyLarge)
            .finish()
    }
}
impl ::core::cmp::PartialEq for ITEMSPACING {
    fn eq(&self, other: &Self) -> bool {
        self.cxSmall == other.cxSmall
            && self.cySmall == other.cySmall
            && self.cxLarge == other.cxLarge
            && self.cyLarge == other.cyLarge
    }
}
impl ::core::cmp::Eq for ITEMSPACING {}
impl FromIntoMemory for ITEMSPACING {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_cxSmall = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_cySmall = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cxLarge = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_cyLarge = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            cxSmall: f_cxSmall,
            cySmall: f_cySmall,
            cxLarge: f_cxLarge,
            cyLarge: f_cyLarge,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.cxSmall, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.cySmall, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cxLarge, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.cyLarge, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub const ITSAT_DEFAULT_PRIORITY: u32 = 268435456u32;
pub const ITSAT_MAX_PRIORITY: u32 = 2147483647u32;
pub const ITSAT_MIN_PRIORITY: u32 = 0u32;
pub const ITSSFLAG_COMPLETE_ON_DESTROY: u32 = 0u32;
pub const ITSSFLAG_FLAGS_MASK: u32 = 3u32;
pub const ITSSFLAG_KILL_ON_DESTROY: u32 = 1u32;
pub struct ITaskbarList(pub crate::core::IUnknown);
pub trait ITaskbarList_Trait: crate::core::IUnknown_Trait {
    fn HrInit(&self) -> crate::core::HRESULT {
        todo!("HrInit")
    }
    fn AddTab(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("AddTab")
    }
    fn DeleteTab(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("DeleteTab")
    }
    fn ActivateTab(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("ActivateTab")
    }
    fn SetActiveAlt(&self, hwnd: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("SetActiveAlt")
    }
}
impl ::core::clone::Clone for ITaskbarList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ITaskbarList {}
impl ::core::cmp::PartialEq for ITaskbarList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITaskbarList {}
impl ::core::fmt::Debug for ITaskbarList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITaskbarList").field(&self.0).finish()
    }
}
impl FromIntoMemory for ITaskbarList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ITaskbarList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x56fdf342_fd6d_11d0_958a_006097c9a090);
}
pub struct ITaskbarList2(pub crate::core::IUnknown);
pub trait ITaskbarList2_Trait: ITaskbarList_Trait {
    fn MarkFullscreenWindow(
        &self,
        hwnd: super::super::Foundation::HWND,
        f_fullscreen: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("MarkFullscreenWindow")
    }
}
impl ::core::clone::Clone for ITaskbarList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ITaskbarList2 {}
impl ::core::cmp::PartialEq for ITaskbarList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITaskbarList2 {}
impl ::core::fmt::Debug for ITaskbarList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITaskbarList2").field(&self.0).finish()
    }
}
impl FromIntoMemory for ITaskbarList2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ITaskbarList2 {
    type Super = ITaskbarList;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x602d4995_b13a_429b_a66e_1935e44f4317);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITaskbarList3(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITaskbarList3_Trait: ITaskbarList2_Trait {
    fn SetProgressValue(
        &self,
        hwnd: super::super::Foundation::HWND,
        ull_completed: u64,
        ull_total: u64,
    ) -> crate::core::HRESULT {
        todo!("SetProgressValue")
    }
    fn SetProgressState(
        &self,
        hwnd: super::super::Foundation::HWND,
        tbp_flags: TBPFLAG,
    ) -> crate::core::HRESULT {
        todo!("SetProgressState")
    }
    fn RegisterTab(
        &self,
        hwnd_tab: super::super::Foundation::HWND,
        hwnd_mdi: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("RegisterTab")
    }
    fn UnregisterTab(&self, hwnd_tab: super::super::Foundation::HWND) -> crate::core::HRESULT {
        todo!("UnregisterTab")
    }
    fn SetTabOrder(
        &self,
        hwnd_tab: super::super::Foundation::HWND,
        hwnd_insert_before: super::super::Foundation::HWND,
    ) -> crate::core::HRESULT {
        todo!("SetTabOrder")
    }
    fn SetTabActive(
        &self,
        hwnd_tab: super::super::Foundation::HWND,
        hwnd_mdi: super::super::Foundation::HWND,
        dw_reserved: u32,
    ) -> crate::core::HRESULT {
        todo!("SetTabActive")
    }
    fn ThumbBarAddButtons(
        &self,
        hwnd: super::super::Foundation::HWND,
        c_buttons: u32,
        p_button: ConstPtr<THUMBBUTTON>,
    ) -> crate::core::HRESULT {
        todo!("ThumbBarAddButtons")
    }
    fn ThumbBarUpdateButtons(
        &self,
        hwnd: super::super::Foundation::HWND,
        c_buttons: u32,
        p_button: ConstPtr<THUMBBUTTON>,
    ) -> crate::core::HRESULT {
        todo!("ThumbBarUpdateButtons")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ThumbBarSetImageList(
        &self,
        hwnd: super::super::Foundation::HWND,
        himl: super::Controls::HIMAGELIST,
    ) -> crate::core::HRESULT {
        todo!("ThumbBarSetImageList")
    }
    fn SetOverlayIcon(
        &self,
        hwnd: super::super::Foundation::HWND,
        h_icon: super::WindowsAndMessaging::HICON,
        psz_description: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetOverlayIcon")
    }
    fn SetThumbnailTooltip(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_tip: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetThumbnailTooltip")
    }
    fn SetThumbnailClip(
        &self,
        hwnd: super::super::Foundation::HWND,
        prc_clip: ConstPtr<super::super::Foundation::RECT>,
    ) -> crate::core::HRESULT {
        todo!("SetThumbnailClip")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITaskbarList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITaskbarList3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITaskbarList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITaskbarList3 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITaskbarList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITaskbarList3").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITaskbarList3 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITaskbarList3 {
    type Super = ITaskbarList2;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xea1afb91_9e28_4b86_90e9_9e9f8a5eefaf);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITaskbarList4(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITaskbarList4_Trait: ITaskbarList3_Trait {
    fn SetTabProperties(
        &self,
        hwnd_tab: super::super::Foundation::HWND,
        stp_flags: STPFLAG,
    ) -> crate::core::HRESULT {
        todo!("SetTabProperties")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITaskbarList4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITaskbarList4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITaskbarList4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITaskbarList4 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITaskbarList4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITaskbarList4").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITaskbarList4 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITaskbarList4 {
    type Super = ITaskbarList3;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc43dc798_95d1_4bea_9030_bb99e2983a1a);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IThumbnailCache(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IThumbnailCache_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetThumbnail(
        &self,
        p_shell_item: IShellItem,
        cxy_requested_thumb_size: u32,
        flags: WTS_FLAGS,
        ppv_thumb: MutPtr<ISharedBitmap>,
        p_out_flags: MutPtr<WTS_CACHEFLAGS>,
        p_thumbnail_id: MutPtr<WTS_THUMBNAILID>,
    ) -> crate::core::HRESULT {
        todo!("GetThumbnail")
    }
    fn GetThumbnailByID(
        &self,
        thumbnail_id: WTS_THUMBNAILID,
        cxy_requested_thumb_size: u32,
        ppv_thumb: MutPtr<ISharedBitmap>,
        p_out_flags: MutPtr<WTS_CACHEFLAGS>,
    ) -> crate::core::HRESULT {
        todo!("GetThumbnailByID")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IThumbnailCache {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IThumbnailCache {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IThumbnailCache {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IThumbnailCache {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IThumbnailCache {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IThumbnailCache").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IThumbnailCache {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IThumbnailCache {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf676c15d_596a_4ce2_8234_33996f445db1);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IThumbnailCachePrimer(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IThumbnailCachePrimer_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PageInThumbnail(
        &self,
        psi: IShellItem,
        wts_flags: WTS_FLAGS,
        cxy_requested_thumb_size: u32,
    ) -> crate::core::HRESULT {
        todo!("PageInThumbnail")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IThumbnailCachePrimer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IThumbnailCachePrimer {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IThumbnailCachePrimer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IThumbnailCachePrimer {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IThumbnailCachePrimer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IThumbnailCachePrimer")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IThumbnailCachePrimer {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IThumbnailCachePrimer {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0f03f8fe_2b26_46f0_965a_212aa8d66b76);
}
pub struct IThumbnailCapture(pub crate::core::IUnknown);
pub trait IThumbnailCapture_Trait: crate::core::IUnknown_Trait {
    fn CaptureThumbnail(
        &self,
        p_max_size: ConstPtr<super::super::Foundation::SIZE>,
        p_html_doc_2: crate::core::IUnknown,
        phbm_thumbnail: MutPtr<super::super::Graphics::Gdi::HBITMAP>,
    ) -> crate::core::HRESULT {
        todo!("CaptureThumbnail")
    }
}
impl ::core::clone::Clone for IThumbnailCapture {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IThumbnailCapture {}
impl ::core::cmp::PartialEq for IThumbnailCapture {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IThumbnailCapture {}
impl ::core::fmt::Debug for IThumbnailCapture {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IThumbnailCapture").field(&self.0).finish()
    }
}
impl FromIntoMemory for IThumbnailCapture {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IThumbnailCapture {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x4ea39266_7211_409f_b622_f63dbd16c533);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IThumbnailHandlerFactory(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IThumbnailHandlerFactory_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetThumbnailHandler(
        &self,
        pidl_child: ConstPtr<Common::ITEMIDLIST>,
        pbc: super::super::System::Com::IBindCtx,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("GetThumbnailHandler")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IThumbnailHandlerFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IThumbnailHandlerFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IThumbnailHandlerFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IThumbnailHandlerFactory {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IThumbnailHandlerFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IThumbnailHandlerFactory")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IThumbnailHandlerFactory {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IThumbnailHandlerFactory {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe35b4b2e_00da_4bc1_9f13_38bc11f5d417);
}
pub struct IThumbnailProvider(pub crate::core::IUnknown);
pub trait IThumbnailProvider_Trait: crate::core::IUnknown_Trait {
    fn GetThumbnail(
        &self,
        cx: u32,
        phbmp: MutPtr<super::super::Graphics::Gdi::HBITMAP>,
        pdw_alpha: MutPtr<WTS_ALPHATYPE>,
    ) -> crate::core::HRESULT {
        todo!("GetThumbnail")
    }
}
impl ::core::clone::Clone for IThumbnailProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IThumbnailProvider {}
impl ::core::cmp::PartialEq for IThumbnailProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IThumbnailProvider {}
impl ::core::fmt::Debug for IThumbnailProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IThumbnailProvider").field(&self.0).finish()
    }
}
impl FromIntoMemory for IThumbnailProvider {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IThumbnailProvider {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe357fccd_a995_4576_b01f_234630154e96);
}
pub struct IThumbnailSettings(pub crate::core::IUnknown);
pub trait IThumbnailSettings_Trait: crate::core::IUnknown_Trait {
    fn SetContext(&self, dw_context: WTS_CONTEXTFLAGS) -> crate::core::HRESULT {
        todo!("SetContext")
    }
}
impl ::core::clone::Clone for IThumbnailSettings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IThumbnailSettings {}
impl ::core::cmp::PartialEq for IThumbnailSettings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IThumbnailSettings {}
impl ::core::fmt::Debug for IThumbnailSettings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IThumbnailSettings").field(&self.0).finish()
    }
}
impl FromIntoMemory for IThumbnailSettings {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IThumbnailSettings {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf4376f00_bef5_4d45_80f3_1e023bbf1209);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IThumbnailStreamCache(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IThumbnailStreamCache_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetThumbnailStream(
        &self,
        path: PCWSTR,
        cache_id: u64,
        options: ThumbnailStreamCacheOptions,
        requested_thumbnail_size: u32,
        thumbnail_size: MutPtr<super::super::Foundation::SIZE>,
        thumbnail_stream: MutPtr<super::super::System::Com::IStream>,
    ) -> crate::core::HRESULT {
        todo!("GetThumbnailStream")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetThumbnailStream(
        &self,
        path: PCWSTR,
        cache_id: u64,
        thumbnail_size: super::super::Foundation::SIZE,
        thumbnail_stream: super::super::System::Com::IStream,
    ) -> crate::core::HRESULT {
        todo!("SetThumbnailStream")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IThumbnailStreamCache {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IThumbnailStreamCache {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IThumbnailStreamCache {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IThumbnailStreamCache {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IThumbnailStreamCache {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IThumbnailStreamCache")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IThumbnailStreamCache {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IThumbnailStreamCache {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x90e11430_9569_41d8_ae75_6d4d2ae7cca0);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITrackShellMenu(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITrackShellMenu_Trait: IShellMenu_Trait {
    fn SetObscured(
        &self,
        hwnd_tb: super::super::Foundation::HWND,
        punk_band: crate::core::IUnknown,
        dw_sm_set_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetObscured")
    }
    fn Popup(
        &self,
        hwnd: super::super::Foundation::HWND,
        ppt: MutPtr<super::super::Foundation::POINTL>,
        prc_exclude: MutPtr<super::super::Foundation::RECTL>,
        dw_flags: i32,
    ) -> crate::core::HRESULT {
        todo!("Popup")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITrackShellMenu {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITrackShellMenu {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITrackShellMenu {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITrackShellMenu {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITrackShellMenu {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITrackShellMenu").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITrackShellMenu {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Registry', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITrackShellMenu {
    type Super = IShellMenu;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x8278f932_2a3e_11d2_838f_00c04fd918d0);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITranscodeImage(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITranscodeImage_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn TranscodeImage(
        &self,
        p_shell_item: IShellItem,
        ui_max_width: u32,
        ui_max_height: u32,
        flags: u32,
        pv_image: super::super::System::Com::IStream,
        pui_width: MutPtr<u32>,
        pui_height: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("TranscodeImage")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITranscodeImage {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITranscodeImage {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITranscodeImage {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITranscodeImage {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITranscodeImage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITranscodeImage").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITranscodeImage {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITranscodeImage {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xbae86ddd_dc11_421c_b7ab_cc55d1d65c44);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITransferAdviseSink(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITransferAdviseSink_Trait: crate::core::IUnknown_Trait {
    fn UpdateProgress(
        &self,
        ull_size_current: u64,
        ull_size_total: u64,
        n_files_current: i32,
        n_files_total: i32,
        n_folders_current: i32,
        n_folders_total: i32,
    ) -> crate::core::HRESULT {
        todo!("UpdateProgress")
    }
    fn UpdateTransferState(&self, ts: u32) -> crate::core::HRESULT {
        todo!("UpdateTransferState")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ConfirmOverwrite(
        &self,
        psi_source: IShellItem,
        psi_dest_parent: IShellItem,
        psz_name: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("ConfirmOverwrite")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ConfirmEncryptionLoss(&self, psi_source: IShellItem) -> crate::core::HRESULT {
        todo!("ConfirmEncryptionLoss")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn FileFailure(
        &self,
        psi: IShellItem,
        psz_item: PCWSTR,
        hr_error: crate::core::HRESULT,
        psz_rename: PWSTR,
        cch_rename: u32,
    ) -> crate::core::HRESULT {
        todo!("FileFailure")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SubStreamFailure(
        &self,
        psi: IShellItem,
        psz_stream_name: PCWSTR,
        hr_error: crate::core::HRESULT,
    ) -> crate::core::HRESULT {
        todo!("SubStreamFailure")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PropertyFailure(
        &self,
        psi: IShellItem,
        pkey: ConstPtr<PropertiesSystem::PROPERTYKEY>,
        hr_error: crate::core::HRESULT,
    ) -> crate::core::HRESULT {
        todo!("PropertyFailure")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITransferAdviseSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITransferAdviseSink {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITransferAdviseSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITransferAdviseSink {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITransferAdviseSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITransferAdviseSink").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITransferAdviseSink {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITransferAdviseSink {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd594d0d8_8da7_457b_b3b4_ce5dbaac0b88);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITransferDestination(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITransferDestination_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Advise(&self, psink: ITransferAdviseSink, pdw_cookie: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn Unadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("Unadvise")
    }
    fn CreateItem(
        &self,
        psz_name: PCWSTR,
        dw_attributes: u32,
        ull_size: u64,
        flags: u32,
        riid_item: ConstPtr<crate::core::GUID>,
        ppv_item: MutPtr<ConstPtr<::core::ffi::c_void>>,
        riid_resources: ConstPtr<crate::core::GUID>,
        ppv_resources: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("CreateItem")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITransferDestination {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITransferDestination {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITransferDestination {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITransferDestination {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITransferDestination {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITransferDestination")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITransferDestination {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITransferDestination {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x48addd32_3ca5_4124_abe3_b5a72531b207);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITransferMediumItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITransferMediumItem_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITransferMediumItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITransferMediumItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITransferMediumItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITransferMediumItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITransferMediumItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITransferMediumItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITransferMediumItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITransferMediumItem {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x77f295d5_2d6f_4e19_b8ae_322f3e721ab5);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITransferSource(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITransferSource_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Advise(&self, psink: ITransferAdviseSink, pdw_cookie: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("Advise")
    }
    fn Unadvise(&self, dw_cookie: u32) -> crate::core::HRESULT {
        todo!("Unadvise")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn SetProperties(
        &self,
        pproparray: PropertiesSystem::IPropertyChangeArray,
    ) -> crate::core::HRESULT {
        todo!("SetProperties")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn OpenItem(
        &self,
        psi: IShellItem,
        flags: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("OpenItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn MoveItem(
        &self,
        psi: IShellItem,
        psi_parent_dst: IShellItem,
        psz_name_dst: PCWSTR,
        flags: u32,
        ppsi_new: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("MoveItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RecycleItem(
        &self,
        psi_source: IShellItem,
        psi_parent_dest: IShellItem,
        flags: u32,
        ppsi_new_dest: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("RecycleItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RemoveItem(&self, psi_source: IShellItem, flags: u32) -> crate::core::HRESULT {
        todo!("RemoveItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn RenameItem(
        &self,
        psi_source: IShellItem,
        psz_new_name: PCWSTR,
        flags: u32,
        ppsi_new_dest: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("RenameItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn LinkItem(
        &self,
        psi_source: IShellItem,
        psi_parent_dest: IShellItem,
        psz_new_name: PCWSTR,
        flags: u32,
        ppsi_new_dest: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("LinkItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ApplyPropertiesToItem(
        &self,
        psi_source: IShellItem,
        ppsi_new: MutPtr<IShellItem>,
    ) -> crate::core::HRESULT {
        todo!("ApplyPropertiesToItem")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetDefaultDestinationName(
        &self,
        psi_source: IShellItem,
        psi_parent_dest: IShellItem,
        ppsz_destination_name: MutPtr<PWSTR>,
    ) -> crate::core::HRESULT {
        todo!("GetDefaultDestinationName")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn EnterFolder(&self, psi_child_folder_dest: IShellItem) -> crate::core::HRESULT {
        todo!("EnterFolder")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn LeaveFolder(&self, psi_child_folder_dest: IShellItem) -> crate::core::HRESULT {
        todo!("LeaveFolder")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITransferSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITransferSource {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITransferSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITransferSource {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITransferSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITransferSource").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITransferSource {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITransferSource {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x00adb003_bde9_45c6_8e29_d09f9353e108);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITravelEntry(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITravelEntry_Trait: crate::core::IUnknown_Trait {
    fn Invoke(&self, punk: crate::core::IUnknown) -> crate::core::HRESULT {
        todo!("Invoke")
    }
    fn Update(
        &self,
        punk: crate::core::IUnknown,
        f_is_local_anchor: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("Update")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPidl(&self, ppidl: MutPtr<ConstPtr<Common::ITEMIDLIST>>) -> crate::core::HRESULT {
        todo!("GetPidl")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITravelEntry {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITravelEntry {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITravelEntry {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITravelEntry {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITravelEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITravelEntry").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITravelEntry {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITravelEntry {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf46edb3b_bc2f_11d0_9412_00aa00a3ebd3);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITravelLog(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITravelLog_Trait: crate::core::IUnknown_Trait {
    fn AddEntry(
        &self,
        punk: crate::core::IUnknown,
        f_is_local_anchor: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("AddEntry")
    }
    fn UpdateEntry(
        &self,
        punk: crate::core::IUnknown,
        f_is_local_anchor: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("UpdateEntry")
    }
    fn UpdateExternal(
        &self,
        punk: crate::core::IUnknown,
        punk_hl_browse_context: crate::core::IUnknown,
    ) -> crate::core::HRESULT {
        todo!("UpdateExternal")
    }
    fn Travel(&self, punk: crate::core::IUnknown, i_offset: i32) -> crate::core::HRESULT {
        todo!("Travel")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetTravelEntry(
        &self,
        punk: crate::core::IUnknown,
        i_offset: i32,
        ppte: MutPtr<ITravelEntry>,
    ) -> crate::core::HRESULT {
        todo!("GetTravelEntry")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn FindTravelEntry(
        &self,
        punk: crate::core::IUnknown,
        pidl: ConstPtr<Common::ITEMIDLIST>,
        ppte: MutPtr<ITravelEntry>,
    ) -> crate::core::HRESULT {
        todo!("FindTravelEntry")
    }
    fn GetToolTipText(
        &self,
        punk: crate::core::IUnknown,
        i_offset: i32,
        ids_template: i32,
        pwz_text: PWSTR,
        cch_text: u32,
    ) -> crate::core::HRESULT {
        todo!("GetToolTipText")
    }
    fn InsertMenuEntries(
        &self,
        punk: crate::core::IUnknown,
        hmenu: super::WindowsAndMessaging::HMENU,
        n_pos: i32,
        id_first: i32,
        id_last: i32,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("InsertMenuEntries")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Clone(&self, pptl: MutPtr<ITravelLog>) -> crate::core::HRESULT {
        todo!("Clone")
    }
    fn CountEntries(&self, punk: crate::core::IUnknown) -> u32 {
        todo!("CountEntries")
    }
    fn Revert(&self) -> crate::core::HRESULT {
        todo!("Revert")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITravelLog {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITravelLog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITravelLog {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITravelLog {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITravelLog {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITravelLog").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITravelLog {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITravelLog {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x66a9cb08_4802_11d2_a561_00a0c92dbfe8);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct ITravelLogClient(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait ITravelLogClient_Trait: crate::core::IUnknown_Trait {
    fn FindWindowByIndex(
        &self,
        dw_id: u32,
        ppunk: MutPtr<crate::core::IUnknown>,
    ) -> crate::core::HRESULT {
        todo!("FindWindowByIndex")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetWindowData(
        &self,
        p_stream: super::super::System::Com::IStream,
        p_win_data: MutPtr<WINDOWDATA>,
    ) -> crate::core::HRESULT {
        todo!("GetWindowData")
    }
    fn LoadHistoryPosition(
        &self,
        psz_url_location: PCWSTR,
        dw_position: u32,
    ) -> crate::core::HRESULT {
        todo!("LoadHistoryPosition")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for ITravelLogClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for ITravelLogClient {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for ITravelLogClient {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for ITravelLogClient {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for ITravelLogClient {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITravelLogClient").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for ITravelLogClient {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for ITravelLogClient {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x241c033e_e659_43da_aa4d_4086dbc4758d);
}
pub struct ITravelLogEntry(pub crate::core::IUnknown);
pub trait ITravelLogEntry_Trait: crate::core::IUnknown_Trait {
    fn GetTitle(&self, ppsz_title: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetTitle")
    }
    fn GetURL(&self, ppsz_url: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetURL")
    }
}
impl ::core::clone::Clone for ITravelLogEntry {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ITravelLogEntry {}
impl ::core::cmp::PartialEq for ITravelLogEntry {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITravelLogEntry {}
impl ::core::fmt::Debug for ITravelLogEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITravelLogEntry").field(&self.0).finish()
    }
}
impl FromIntoMemory for ITravelLogEntry {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ITravelLogEntry {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7ebfdd87_ad18_11d3_a4c5_00c04f72d6b8);
}
pub struct ITravelLogStg(pub crate::core::IUnknown);
pub trait ITravelLogStg_Trait: crate::core::IUnknown_Trait {
    fn CreateEntry(
        &self,
        psz_url: PCWSTR,
        psz_title: PCWSTR,
        ptle_relative_to: ITravelLogEntry,
        f_prepend: super::super::Foundation::BOOL,
        pptle: MutPtr<ITravelLogEntry>,
    ) -> crate::core::HRESULT {
        todo!("CreateEntry")
    }
    fn TravelTo(&self, ptle: ITravelLogEntry) -> crate::core::HRESULT {
        todo!("TravelTo")
    }
    fn EnumEntries(
        &self,
        flags: TLENUMF,
        ppenum: MutPtr<IEnumTravelLogEntry>,
    ) -> crate::core::HRESULT {
        todo!("EnumEntries")
    }
    fn FindEntries(
        &self,
        flags: TLENUMF,
        psz_url: PCWSTR,
        ppenum: MutPtr<IEnumTravelLogEntry>,
    ) -> crate::core::HRESULT {
        todo!("FindEntries")
    }
    fn GetCount(&self, flags: TLENUMF, pc_entries: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetCount")
    }
    fn RemoveEntry(&self, ptle: ITravelLogEntry) -> crate::core::HRESULT {
        todo!("RemoveEntry")
    }
    fn GetRelativeEntry(
        &self,
        i_offset: i32,
        ptle: MutPtr<ITravelLogEntry>,
    ) -> crate::core::HRESULT {
        todo!("GetRelativeEntry")
    }
}
impl ::core::clone::Clone for ITravelLogStg {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ITravelLogStg {}
impl ::core::cmp::PartialEq for ITravelLogStg {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITravelLogStg {}
impl ::core::fmt::Debug for ITravelLogStg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITravelLogStg").field(&self.0).finish()
    }
}
impl FromIntoMemory for ITravelLogStg {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ITravelLogStg {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x7ebfdd80_ad18_11d3_a4c5_00c04f72d6b8);
}
pub struct ITrayDeskBand(pub crate::core::IUnknown);
pub trait ITrayDeskBand_Trait: crate::core::IUnknown_Trait {
    fn ShowDeskBand(&self, clsid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("ShowDeskBand")
    }
    fn HideDeskBand(&self, clsid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("HideDeskBand")
    }
    fn IsDeskBandShown(&self, clsid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("IsDeskBandShown")
    }
    fn DeskBandRegistrationChanged(&self) -> crate::core::HRESULT {
        todo!("DeskBandRegistrationChanged")
    }
}
impl ::core::clone::Clone for ITrayDeskBand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for ITrayDeskBand {}
impl ::core::cmp::PartialEq for ITrayDeskBand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITrayDeskBand {}
impl ::core::fmt::Debug for ITrayDeskBand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITrayDeskBand").field(&self.0).finish()
    }
}
impl FromIntoMemory for ITrayDeskBand {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for ITrayDeskBand {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6d67e846_5b9c_4db8_9cbc_dde12f4254f1);
}
pub struct IURLSearchHook(pub crate::core::IUnknown);
pub trait IURLSearchHook_Trait: crate::core::IUnknown_Trait {
    fn Translate(&self, pwsz_search_url: PWSTR, cch_buffer_size: u32) -> crate::core::HRESULT {
        todo!("Translate")
    }
}
impl ::core::clone::Clone for IURLSearchHook {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IURLSearchHook {}
impl ::core::cmp::PartialEq for IURLSearchHook {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IURLSearchHook {}
impl ::core::fmt::Debug for IURLSearchHook {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IURLSearchHook").field(&self.0).finish()
    }
}
impl FromIntoMemory for IURLSearchHook {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IURLSearchHook {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xac60f6a0_0fd9_11d0_99cb_00c04fd64497);
}
pub struct IURLSearchHook2(pub crate::core::IUnknown);
pub trait IURLSearchHook2_Trait: IURLSearchHook_Trait {
    fn TranslateWithSearchContext(
        &self,
        pwsz_search_url: PWSTR,
        cch_buffer_size: u32,
        p_search_context: ISearchContext,
    ) -> crate::core::HRESULT {
        todo!("TranslateWithSearchContext")
    }
}
impl ::core::clone::Clone for IURLSearchHook2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IURLSearchHook2 {}
impl ::core::cmp::PartialEq for IURLSearchHook2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IURLSearchHook2 {}
impl ::core::fmt::Debug for IURLSearchHook2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IURLSearchHook2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IURLSearchHook2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IURLSearchHook2 {
    type Super = IURLSearchHook;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x5ee44da4_6d32_46e3_86bc_07540dedd0e0);
}
pub struct IUniformResourceLocatorA(pub crate::core::IUnknown);
pub trait IUniformResourceLocatorA_Trait: crate::core::IUnknown_Trait {
    fn SetURL(&self, pcsz_url: PCSTR, dw_in_flags: u32) -> crate::core::HRESULT {
        todo!("SetURL")
    }
    fn GetURL(&self, ppsz_url: MutPtr<PSTR>) -> crate::core::HRESULT {
        todo!("GetURL")
    }
    fn InvokeCommand(&self, purlici: MutPtr<urlinvokecommandinfoA>) -> crate::core::HRESULT {
        todo!("InvokeCommand")
    }
}
impl ::core::clone::Clone for IUniformResourceLocatorA {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IUniformResourceLocatorA {}
impl ::core::cmp::PartialEq for IUniformResourceLocatorA {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IUniformResourceLocatorA {}
impl ::core::fmt::Debug for IUniformResourceLocatorA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUniformResourceLocatorA")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IUniformResourceLocatorA {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IUniformResourceLocatorA {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xfbf23b80_e3f0_101b_8488_00aa003e56f8);
}
pub struct IUniformResourceLocatorW(pub crate::core::IUnknown);
pub trait IUniformResourceLocatorW_Trait: crate::core::IUnknown_Trait {
    fn SetURL(&self, pcsz_url: PCWSTR, dw_in_flags: u32) -> crate::core::HRESULT {
        todo!("SetURL")
    }
    fn GetURL(&self, ppsz_url: MutPtr<PWSTR>) -> crate::core::HRESULT {
        todo!("GetURL")
    }
    fn InvokeCommand(&self, purlici: MutPtr<urlinvokecommandinfoW>) -> crate::core::HRESULT {
        todo!("InvokeCommand")
    }
}
impl ::core::clone::Clone for IUniformResourceLocatorW {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IUniformResourceLocatorW {}
impl ::core::cmp::PartialEq for IUniformResourceLocatorW {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IUniformResourceLocatorW {}
impl ::core::fmt::Debug for IUniformResourceLocatorW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUniformResourceLocatorW")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IUniformResourceLocatorW {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IUniformResourceLocatorW {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xcabb0da0_da57_11cf_9974_0020afd79762);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IUpdateIDList(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IUpdateIDList_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Update(
        &self,
        pbc: super::super::System::Com::IBindCtx,
        pidl_in: ConstPtr<Common::ITEMIDLIST>,
        ppidl_out: MutPtr<ConstPtr<Common::ITEMIDLIST>>,
    ) -> crate::core::HRESULT {
        todo!("Update")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IUpdateIDList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IUpdateIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IUpdateIDList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IUpdateIDList {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IUpdateIDList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUpdateIDList").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IUpdateIDList {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IUpdateIDList {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x6589b6d2_5f8d_4b9e_b7e0_23cdd9717d8c);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IUseToBrowseItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IUseToBrowseItem_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IUseToBrowseItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IUseToBrowseItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IUseToBrowseItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IUseToBrowseItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IUseToBrowseItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUseToBrowseItem").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IUseToBrowseItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IUseToBrowseItem {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x05edda5c_98a3_4717_8adb_c5e7da991eb1);
}
pub struct IUserAccountChangeCallback(pub crate::core::IUnknown);
pub trait IUserAccountChangeCallback_Trait: crate::core::IUnknown_Trait {
    fn OnPictureChange(&self, psz_user_name: PCWSTR) -> crate::core::HRESULT {
        todo!("OnPictureChange")
    }
}
impl ::core::clone::Clone for IUserAccountChangeCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IUserAccountChangeCallback {}
impl ::core::cmp::PartialEq for IUserAccountChangeCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IUserAccountChangeCallback {}
impl ::core::fmt::Debug for IUserAccountChangeCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUserAccountChangeCallback")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IUserAccountChangeCallback {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IUserAccountChangeCallback {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa561e69a_b4b8_4113_91a5_64c6bcca3430);
}
pub struct IUserNotification(pub crate::core::IUnknown);
pub trait IUserNotification_Trait: crate::core::IUnknown_Trait {
    fn SetBalloonInfo(
        &self,
        psz_title: PCWSTR,
        psz_text: PCWSTR,
        dw_info_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetBalloonInfo")
    }
    fn SetBalloonRetry(
        &self,
        dw_show_time: u32,
        dw_interval: u32,
        c_retry_count: u32,
    ) -> crate::core::HRESULT {
        todo!("SetBalloonRetry")
    }
    fn SetIconInfo(
        &self,
        h_icon: super::WindowsAndMessaging::HICON,
        psz_tool_tip: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetIconInfo")
    }
    fn Show(&self, pqc: IQueryContinue, dw_continue_poll_interval: u32) -> crate::core::HRESULT {
        todo!("Show")
    }
    fn PlaySound(&self, psz_sound_name: PCWSTR) -> crate::core::HRESULT {
        todo!("PlaySound")
    }
}
impl ::core::clone::Clone for IUserNotification {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IUserNotification {}
impl ::core::cmp::PartialEq for IUserNotification {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IUserNotification {}
impl ::core::fmt::Debug for IUserNotification {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUserNotification").field(&self.0).finish()
    }
}
impl FromIntoMemory for IUserNotification {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IUserNotification {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xba9711ba_5893_4787_a7e1_41277151550b);
}
pub struct IUserNotification2(pub crate::core::IUnknown);
pub trait IUserNotification2_Trait: crate::core::IUnknown_Trait {
    fn SetBalloonInfo(
        &self,
        psz_title: PCWSTR,
        psz_text: PCWSTR,
        dw_info_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SetBalloonInfo")
    }
    fn SetBalloonRetry(
        &self,
        dw_show_time: u32,
        dw_interval: u32,
        c_retry_count: u32,
    ) -> crate::core::HRESULT {
        todo!("SetBalloonRetry")
    }
    fn SetIconInfo(
        &self,
        h_icon: super::WindowsAndMessaging::HICON,
        psz_tool_tip: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SetIconInfo")
    }
    fn Show(
        &self,
        pqc: IQueryContinue,
        dw_continue_poll_interval: u32,
        p_sink: IUserNotificationCallback,
    ) -> crate::core::HRESULT {
        todo!("Show")
    }
    fn PlaySound(&self, psz_sound_name: PCWSTR) -> crate::core::HRESULT {
        todo!("PlaySound")
    }
}
impl ::core::clone::Clone for IUserNotification2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IUserNotification2 {}
impl ::core::cmp::PartialEq for IUserNotification2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IUserNotification2 {}
impl ::core::fmt::Debug for IUserNotification2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUserNotification2").field(&self.0).finish()
    }
}
impl FromIntoMemory for IUserNotification2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IUserNotification2 {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x215913cc_57eb_4fab_ab5a_e5fa7bea2a6c);
}
pub struct IUserNotificationCallback(pub crate::core::IUnknown);
pub trait IUserNotificationCallback_Trait: crate::core::IUnknown_Trait {
    fn OnBalloonUserClick(
        &self,
        pt: ConstPtr<super::super::Foundation::POINT>,
    ) -> crate::core::HRESULT {
        todo!("OnBalloonUserClick")
    }
    fn OnLeftClick(&self, pt: ConstPtr<super::super::Foundation::POINT>) -> crate::core::HRESULT {
        todo!("OnLeftClick")
    }
    fn OnContextMenu(&self, pt: ConstPtr<super::super::Foundation::POINT>) -> crate::core::HRESULT {
        todo!("OnContextMenu")
    }
}
impl ::core::clone::Clone for IUserNotificationCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IUserNotificationCallback {}
impl ::core::cmp::PartialEq for IUserNotificationCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IUserNotificationCallback {}
impl ::core::fmt::Debug for IUserNotificationCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IUserNotificationCallback")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IUserNotificationCallback {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IUserNotificationCallback {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x19108294_0441_4aff_8013_fa0a730b0bea);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IViewStateIdentityItem(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IViewStateIdentityItem_Trait: IRelatedItem_Trait {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IViewStateIdentityItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IViewStateIdentityItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IViewStateIdentityItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IViewStateIdentityItem {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IViewStateIdentityItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IViewStateIdentityItem")
            .field(&self.0)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IViewStateIdentityItem {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IViewStateIdentityItem {
    type Super = IRelatedItem;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x9d264146_a94f_4195_9f9f_3bb12ce0c955);
}
pub struct IVirtualDesktopManager(pub crate::core::IUnknown);
pub trait IVirtualDesktopManager_Trait: crate::core::IUnknown_Trait {
    fn IsWindowOnCurrentVirtualDesktop(
        &self,
        top_level_window: super::super::Foundation::HWND,
        on_current_desktop: MutPtr<super::super::Foundation::BOOL>,
    ) -> crate::core::HRESULT {
        todo!("IsWindowOnCurrentVirtualDesktop")
    }
    fn GetWindowDesktopId(
        &self,
        top_level_window: super::super::Foundation::HWND,
        desktop_id: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("GetWindowDesktopId")
    }
    fn MoveWindowToDesktop(
        &self,
        top_level_window: super::super::Foundation::HWND,
        desktop_id: ConstPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("MoveWindowToDesktop")
    }
}
impl ::core::clone::Clone for IVirtualDesktopManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IVirtualDesktopManager {}
impl ::core::cmp::PartialEq for IVirtualDesktopManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVirtualDesktopManager {}
impl ::core::fmt::Debug for IVirtualDesktopManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVirtualDesktopManager")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for IVirtualDesktopManager {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IVirtualDesktopManager {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xa5cd92ff_29be_454c_8d04_d82879fb3f1b);
}
pub struct IVisualProperties(pub crate::core::IUnknown);
pub trait IVisualProperties_Trait: crate::core::IUnknown_Trait {
    fn SetWatermark(
        &self,
        hbmp: super::super::Graphics::Gdi::HBITMAP,
        vpwf: VPWATERMARKFLAGS,
    ) -> crate::core::HRESULT {
        todo!("SetWatermark")
    }
    fn SetColor(&self, vpcf: VPCOLORFLAGS, cr: u32) -> crate::core::HRESULT {
        todo!("SetColor")
    }
    fn GetColor(&self, vpcf: VPCOLORFLAGS, pcr: MutPtr<u32>) -> crate::core::HRESULT {
        todo!("GetColor")
    }
    fn SetItemHeight(&self, cy_item_in_pixels: i32) -> crate::core::HRESULT {
        todo!("SetItemHeight")
    }
    fn GetItemHeight(&self, cy_item_in_pixels: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("GetItemHeight")
    }
    fn SetFont(
        &self,
        plf: ConstPtr<super::super::Graphics::Gdi::LOGFONTW>,
        b_redraw: super::super::Foundation::BOOL,
    ) -> crate::core::HRESULT {
        todo!("SetFont")
    }
    fn GetFont(&self, plf: MutPtr<super::super::Graphics::Gdi::LOGFONTW>) -> crate::core::HRESULT {
        todo!("GetFont")
    }
    fn SetTheme(&self, psz_sub_app_name: PCWSTR, psz_sub_id_list: PCWSTR) -> crate::core::HRESULT {
        todo!("SetTheme")
    }
}
impl ::core::clone::Clone for IVisualProperties {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
impl ::core::marker::Copy for IVisualProperties {}
impl ::core::cmp::PartialEq for IVisualProperties {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IVisualProperties {}
impl ::core::fmt::Debug for IVisualProperties {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IVisualProperties").field(&self.0).finish()
    }
}
impl FromIntoMemory for IVisualProperties {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
impl crate::core::ComInterface for IVisualProperties {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xe693cf68_d967_4112_8763_99172aee5e5a);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWebBrowser(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWebBrowser_Trait: super::super::System::Com::IDispatch_Trait {
    fn GoBack(&self) -> crate::core::HRESULT {
        todo!("GoBack")
    }
    fn GoForward(&self) -> crate::core::HRESULT {
        todo!("GoForward")
    }
    fn GoHome(&self) -> crate::core::HRESULT {
        todo!("GoHome")
    }
    fn GoSearch(&self) -> crate::core::HRESULT {
        todo!("GoSearch")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Navigate(
        &self,
        url: super::super::Foundation::BSTR,
        flags: ConstPtr<super::super::System::Com::VARIANT>,
        target_frame_name: ConstPtr<super::super::System::Com::VARIANT>,
        post_data: ConstPtr<super::super::System::Com::VARIANT>,
        headers: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("Navigate")
    }
    fn Refresh(&self) -> crate::core::HRESULT {
        todo!("Refresh")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Refresh2(
        &self,
        level: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("Refresh2")
    }
    fn Stop(&self) -> crate::core::HRESULT {
        todo!("Stop")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Application(
        &self,
        pp_disp: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Application")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Parent(
        &self,
        pp_disp: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Parent")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Container(
        &self,
        pp_disp: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Container")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Document(
        &self,
        pp_disp: MutPtr<super::super::System::Com::IDispatch>,
    ) -> crate::core::HRESULT {
        todo!("get_Document")
    }
    fn get_TopLevelContainer(&self, p_bool: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_TopLevelContainer")
    }
    fn get_Type(&self, r#type: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Type")
    }
    fn get_Left(&self, pl: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Left")
    }
    fn put_Left(&self, left: i32) -> crate::core::HRESULT {
        todo!("put_Left")
    }
    fn get_Top(&self, pl: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Top")
    }
    fn put_Top(&self, top: i32) -> crate::core::HRESULT {
        todo!("put_Top")
    }
    fn get_Width(&self, pl: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Width")
    }
    fn put_Width(&self, width: i32) -> crate::core::HRESULT {
        todo!("put_Width")
    }
    fn get_Height(&self, pl: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_Height")
    }
    fn put_Height(&self, height: i32) -> crate::core::HRESULT {
        todo!("put_Height")
    }
    fn get_LocationName(
        &self,
        location_name: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_LocationName")
    }
    fn get_LocationURL(
        &self,
        location_url: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_LocationURL")
    }
    fn get_Busy(&self, p_bool: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_Busy")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWebBrowser {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWebBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWebBrowser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWebBrowser {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWebBrowser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWebBrowser").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWebBrowser {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWebBrowser {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xeab22ac1_30c1_11cf_a7eb_0000c05bae0b);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWebBrowser2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWebBrowser2_Trait: IWebBrowserApp_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn Navigate2(
        &self,
        url: ConstPtr<super::super::System::Com::VARIANT>,
        flags: ConstPtr<super::super::System::Com::VARIANT>,
        target_frame_name: ConstPtr<super::super::System::Com::VARIANT>,
        post_data: ConstPtr<super::super::System::Com::VARIANT>,
        headers: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("Navigate2")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn QueryStatusWB(
        &self,
        cmd_id: super::super::System::Ole::OLECMDID,
        pcmdf: MutPtr<super::super::System::Ole::OLECMDF>,
    ) -> crate::core::HRESULT {
        todo!("QueryStatusWB")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ExecWB(
        &self,
        cmd_id: super::super::System::Ole::OLECMDID,
        cmdexecopt: super::super::System::Ole::OLECMDEXECOPT,
        pva_in: ConstPtr<super::super::System::Com::VARIANT>,
        pva_out: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ExecWB")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn ShowBrowserBar(
        &self,
        pva_clsid: ConstPtr<super::super::System::Com::VARIANT>,
        pvar_show: ConstPtr<super::super::System::Com::VARIANT>,
        pvar_size: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("ShowBrowserBar")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_ReadyState(
        &self,
        pl_ready_state: MutPtr<super::super::System::Ole::READYSTATE>,
    ) -> crate::core::HRESULT {
        todo!("get_ReadyState")
    }
    fn get_Offline(&self, pb_offline: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_Offline")
    }
    fn put_Offline(&self, b_offline: i16) -> crate::core::HRESULT {
        todo!("put_Offline")
    }
    fn get_Silent(&self, pb_silent: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_Silent")
    }
    fn put_Silent(&self, b_silent: i16) -> crate::core::HRESULT {
        todo!("put_Silent")
    }
    fn get_RegisterAsBrowser(&self, pb_register: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_RegisterAsBrowser")
    }
    fn put_RegisterAsBrowser(&self, b_register: i16) -> crate::core::HRESULT {
        todo!("put_RegisterAsBrowser")
    }
    fn get_RegisterAsDropTarget(&self, pb_register: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_RegisterAsDropTarget")
    }
    fn put_RegisterAsDropTarget(&self, b_register: i16) -> crate::core::HRESULT {
        todo!("put_RegisterAsDropTarget")
    }
    fn get_TheaterMode(&self, pb_register: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_TheaterMode")
    }
    fn put_TheaterMode(&self, b_register: i16) -> crate::core::HRESULT {
        todo!("put_TheaterMode")
    }
    fn get_AddressBar(&self, value: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_AddressBar")
    }
    fn put_AddressBar(&self, value: i16) -> crate::core::HRESULT {
        todo!("put_AddressBar")
    }
    fn get_Resizable(&self, value: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_Resizable")
    }
    fn put_Resizable(&self, value: i16) -> crate::core::HRESULT {
        todo!("put_Resizable")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWebBrowser2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWebBrowser2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWebBrowser2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWebBrowser2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWebBrowser2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWebBrowser2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWebBrowser2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWebBrowser2 {
    type Super = IWebBrowserApp;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xd30c1661_cdaf_11d0_8a3e_00c04fc9e26e);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWebBrowserApp(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWebBrowserApp_Trait: IWebBrowser_Trait {
    fn Quit(&self) -> crate::core::HRESULT {
        todo!("Quit")
    }
    fn ClientToWindow(&self, pcx: MutPtr<i32>, pcy: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("ClientToWindow")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn PutProperty(
        &self,
        property: super::super::Foundation::BSTR,
        vt_value: super::super::System::Com::VARIANT,
    ) -> crate::core::HRESULT {
        todo!("PutProperty")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetProperty(
        &self,
        property: super::super::Foundation::BSTR,
        pvt_value: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("GetProperty")
    }
    fn get_Name(&self, name: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Name")
    }
    fn get_HWND(
        &self,
        p_hwnd: MutPtr<super::super::Foundation::SHANDLE_PTR>,
    ) -> crate::core::HRESULT {
        todo!("get_HWND")
    }
    fn get_FullName(
        &self,
        full_name: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_FullName")
    }
    fn get_Path(&self, path: MutPtr<super::super::Foundation::BSTR>) -> crate::core::HRESULT {
        todo!("get_Path")
    }
    fn get_Visible(&self, p_bool: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_Visible")
    }
    fn put_Visible(&self, value: i16) -> crate::core::HRESULT {
        todo!("put_Visible")
    }
    fn get_StatusBar(&self, p_bool: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_StatusBar")
    }
    fn put_StatusBar(&self, value: i16) -> crate::core::HRESULT {
        todo!("put_StatusBar")
    }
    fn get_StatusText(
        &self,
        status_text: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_StatusText")
    }
    fn put_StatusText(&self, status_text: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_StatusText")
    }
    fn get_ToolBar(&self, value: MutPtr<i32>) -> crate::core::HRESULT {
        todo!("get_ToolBar")
    }
    fn put_ToolBar(&self, value: i32) -> crate::core::HRESULT {
        todo!("put_ToolBar")
    }
    fn get_MenuBar(&self, value: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_MenuBar")
    }
    fn put_MenuBar(&self, value: i16) -> crate::core::HRESULT {
        todo!("put_MenuBar")
    }
    fn get_FullScreen(&self, pb_full_screen: MutPtr<i16>) -> crate::core::HRESULT {
        todo!("get_FullScreen")
    }
    fn put_FullScreen(&self, b_full_screen: i16) -> crate::core::HRESULT {
        todo!("put_FullScreen")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWebBrowserApp {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWebBrowserApp {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWebBrowserApp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWebBrowserApp {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWebBrowserApp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWebBrowserApp").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWebBrowserApp {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWebBrowserApp {
    type Super = IWebBrowser;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0002df05_0000_0000_c000_000000000046);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWebWizardExtension(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWebWizardExtension_Trait: IWizardExtension_Trait {
    fn SetInitialURL(&self, psz_url: PCWSTR) -> crate::core::HRESULT {
        todo!("SetInitialURL")
    }
    fn SetErrorURL(&self, psz_error_url: PCWSTR) -> crate::core::HRESULT {
        todo!("SetErrorURL")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWebWizardExtension {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWebWizardExtension {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWebWizardExtension {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWebWizardExtension {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWebWizardExtension {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWebWizardExtension").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWebWizardExtension {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWebWizardExtension {
    type Super = IWizardExtension;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x0e6b3f66_98d1_48c0_a222_fbde74e2fbc5);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWebWizardHost(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWebWizardHost_Trait: super::super::System::Com::IDispatch_Trait {
    fn FinalBack(&self) -> crate::core::HRESULT {
        todo!("FinalBack")
    }
    fn FinalNext(&self) -> crate::core::HRESULT {
        todo!("FinalNext")
    }
    fn Cancel(&self) -> crate::core::HRESULT {
        todo!("Cancel")
    }
    fn put_Caption(&self, bstr_caption: super::super::Foundation::BSTR) -> crate::core::HRESULT {
        todo!("put_Caption")
    }
    fn get_Caption(
        &self,
        pbstr_caption: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("get_Caption")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn put_Property(
        &self,
        bstr_property_name: super::super::Foundation::BSTR,
        pv_property: ConstPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("put_Property")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn get_Property(
        &self,
        bstr_property_name: super::super::Foundation::BSTR,
        pv_property: MutPtr<super::super::System::Com::VARIANT>,
    ) -> crate::core::HRESULT {
        todo!("get_Property")
    }
    fn SetWizardButtons(
        &self,
        vf_enable_back: i16,
        vf_enable_next: i16,
        vf_last_page: i16,
    ) -> crate::core::HRESULT {
        todo!("SetWizardButtons")
    }
    fn SetHeaderText(
        &self,
        bstr_header_title: super::super::Foundation::BSTR,
        bstr_header_subtitle: super::super::Foundation::BSTR,
    ) -> crate::core::HRESULT {
        todo!("SetHeaderText")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWebWizardHost {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWebWizardHost {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWebWizardHost {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWebWizardHost {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWebWizardHost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWebWizardHost").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWebWizardHost {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWebWizardHost {
    type Super = super::super::System::Com::IDispatch;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x18bcc359_4990_4bfb_b951_3c83702be5f9);
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWebWizardHost2(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWebWizardHost2_Trait: IWebWizardHost_Trait {
    fn SignString(
        &self,
        value: super::super::Foundation::BSTR,
        signed_value: MutPtr<super::super::Foundation::BSTR>,
    ) -> crate::core::HRESULT {
        todo!("SignString")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWebWizardHost2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWebWizardHost2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWebWizardHost2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWebWizardHost2 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWebWizardHost2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWebWizardHost2").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWebWizardHost2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWebWizardHost2 {
    type Super = IWebWizardHost;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xf9c013dc_3c23_4041_8e39_cfb402f7ea59);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWizardExtension(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWizardExtension_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn AddPages(
        &self,
        a_pages: MutPtr<super::Controls::HPROPSHEETPAGE>,
        c_pages: u32,
        pn_pages_added: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("AddPages")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetFirstPage(
        &self,
        phpage: MutPtr<super::Controls::HPROPSHEETPAGE>,
    ) -> crate::core::HRESULT {
        todo!("GetFirstPage")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetLastPage(&self, phpage: MutPtr<super::Controls::HPROPSHEETPAGE>) -> crate::core::HRESULT {
        todo!("GetLastPage")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWizardExtension {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWizardExtension {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWizardExtension {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWizardExtension {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWizardExtension {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWizardExtension").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWizardExtension {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWizardExtension {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0xc02ea696_86cc_491e_9b23_74394a0444a8);
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct IWizardSite(pub crate::core::IUnknown);
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub trait IWizardSite_Trait: crate::core::IUnknown_Trait {
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetPreviousPage(
        &self,
        phpage: MutPtr<super::Controls::HPROPSHEETPAGE>,
    ) -> crate::core::HRESULT {
        todo!("GetPreviousPage")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetNextPage(&self, phpage: MutPtr<super::Controls::HPROPSHEETPAGE>) -> crate::core::HRESULT {
        todo!("GetNextPage")
    }
    #[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
    #[cfg(dummy_option_that_does_not_exist)]
    fn GetCancelledPage(
        &self,
        phpage: MutPtr<super::Controls::HPROPSHEETPAGE>,
    ) -> crate::core::HRESULT {
        todo!("GetCancelledPage")
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for IWizardSite {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for IWizardSite {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for IWizardSite {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for IWizardSite {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for IWizardSite {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWizardSite").field(&self.0).finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for IWizardSite {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<crate::core::IUnknown as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        <crate::core::IUnknown as FromIntoMemory>::size()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl crate::core::ComInterface for IWizardSite {
    type Super = crate::core::IUnknown;
    const IID: crate::core::GUID =
        crate::core::GUID::from_u128(0x88960f5b_422f_4e7b_8013_73415381c3c3);
}
pub const Identity_LocalUserProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0xa198529b_730f_4089_b646_a12557f5665e);
pub const ImageProperties: crate::core::GUID =
    crate::core::GUID::from_u128(0x7ab770c7_0e23_4d7a_8aa2_19bfad479829);
pub const ImageRecompress: crate::core::GUID =
    crate::core::GUID::from_u128(0x6e33091c_d2f8_4740_b55e_2e11d1477a2c);
pub const ImageTranscode: crate::core::GUID =
    crate::core::GUID::from_u128(0x17b75166_928f_417d_9685_64aa135565c1);
pub const InputPanelConfiguration: crate::core::GUID =
    crate::core::GUID::from_u128(0x2853add3_f096_4c63_a78f_7fa3ea837fb7);
pub const InternetExplorer: crate::core::GUID =
    crate::core::GUID::from_u128(0x0002df01_0000_0000_c000_000000000046);
pub const InternetExplorerMedium: crate::core::GUID =
    crate::core::GUID::from_u128(0xd5e8041d_920f_45e9_b8fb_b1deb82c6e5e);
pub const InternetPrintOrdering: crate::core::GUID =
    crate::core::GUID::from_u128(0xadd36aa8_751a_4579_a266_d66f5202ccbb);
pub const ItemCount_Property_GUID: crate::core::GUID =
    crate::core::GUID::from_u128(0xabbf5c45_5ccc_47b7_bb4e_87cb87bbd162);
pub const ItemIndex_Property_GUID: crate::core::GUID =
    crate::core::GUID::from_u128(0x92a053da_2969_4021_bf27_514cfc2e4a69);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct KF_CATEGORY(pub i32);
pub const KF_CATEGORY_VIRTUAL: KF_CATEGORY = KF_CATEGORY(1i32);
pub const KF_CATEGORY_FIXED: KF_CATEGORY = KF_CATEGORY(2i32);
pub const KF_CATEGORY_COMMON: KF_CATEGORY = KF_CATEGORY(3i32);
pub const KF_CATEGORY_PERUSER: KF_CATEGORY = KF_CATEGORY(4i32);
impl ::core::marker::Copy for KF_CATEGORY {}
impl ::core::clone::Clone for KF_CATEGORY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for KF_CATEGORY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KF_CATEGORY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KF_CATEGORY").field(&self.0).finish()
    }
}
impl FromIntoMemory for KF_CATEGORY {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct KNOWNDESTCATEGORY(pub i32);
pub const KDC_FREQUENT: KNOWNDESTCATEGORY = KNOWNDESTCATEGORY(1i32);
pub const KDC_RECENT: KNOWNDESTCATEGORY = KNOWNDESTCATEGORY(2i32);
impl ::core::marker::Copy for KNOWNDESTCATEGORY {}
impl ::core::clone::Clone for KNOWNDESTCATEGORY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for KNOWNDESTCATEGORY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KNOWNDESTCATEGORY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KNOWNDESTCATEGORY").field(&self.0).finish()
    }
}
impl FromIntoMemory for KNOWNDESTCATEGORY {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct KNOWNFOLDER_DEFINITION {
    pub category: KF_CATEGORY,
    pub pszName: PWSTR,
    pub pszDescription: PWSTR,
    pub fidParent: crate::core::GUID,
    pub pszRelativePath: PWSTR,
    pub pszParsingName: PWSTR,
    pub pszTooltip: PWSTR,
    pub pszLocalizedName: PWSTR,
    pub pszIcon: PWSTR,
    pub pszSecurity: PWSTR,
    pub dwAttributes: u32,
    pub kfdFlags: u32,
    pub ftidType: crate::core::GUID,
}
impl ::core::marker::Copy for KNOWNFOLDER_DEFINITION {}
impl ::core::clone::Clone for KNOWNFOLDER_DEFINITION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for KNOWNFOLDER_DEFINITION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("KNOWNFOLDER_DEFINITION")
            .field("category", &self.category)
            .field("pszName", &self.pszName)
            .field("pszDescription", &self.pszDescription)
            .field("fidParent", &self.fidParent)
            .field("pszRelativePath", &self.pszRelativePath)
            .field("pszParsingName", &self.pszParsingName)
            .field("pszTooltip", &self.pszTooltip)
            .field("pszLocalizedName", &self.pszLocalizedName)
            .field("pszIcon", &self.pszIcon)
            .field("pszSecurity", &self.pszSecurity)
            .field("dwAttributes", &self.dwAttributes)
            .field("kfdFlags", &self.kfdFlags)
            .field("ftidType", &self.ftidType)
            .finish()
    }
}
impl ::core::cmp::PartialEq for KNOWNFOLDER_DEFINITION {
    fn eq(&self, other: &Self) -> bool {
        self.category == other.category
            && self.pszName == other.pszName
            && self.pszDescription == other.pszDescription
            && self.fidParent == other.fidParent
            && self.pszRelativePath == other.pszRelativePath
            && self.pszParsingName == other.pszParsingName
            && self.pszTooltip == other.pszTooltip
            && self.pszLocalizedName == other.pszLocalizedName
            && self.pszIcon == other.pszIcon
            && self.pszSecurity == other.pszSecurity
            && self.dwAttributes == other.dwAttributes
            && self.kfdFlags == other.kfdFlags
            && self.ftidType == other.ftidType
    }
}
impl ::core::cmp::Eq for KNOWNFOLDER_DEFINITION {}
impl FromIntoMemory for KNOWNFOLDER_DEFINITION {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 76);
        let f_category = <KF_CATEGORY as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszName = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszDescription = <PWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_fidParent = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        let f_pszRelativePath = <PWSTR as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_pszParsingName = <PWSTR as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_pszTooltip = <PWSTR as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_pszLocalizedName = <PWSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_pszIcon = <PWSTR as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_pszSecurity = <PWSTR as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_dwAttributes = <u32 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_kfdFlags = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        let f_ftidType = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[60..60 + 16]);
        Self {
            category: f_category,
            pszName: f_pszName,
            pszDescription: f_pszDescription,
            fidParent: f_fidParent,
            pszRelativePath: f_pszRelativePath,
            pszParsingName: f_pszParsingName,
            pszTooltip: f_pszTooltip,
            pszLocalizedName: f_pszLocalizedName,
            pszIcon: f_pszIcon,
            pszSecurity: f_pszSecurity,
            dwAttributes: f_dwAttributes,
            kfdFlags: f_kfdFlags,
            ftidType: f_ftidType,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 76);
        FromIntoMemory::into_bytes(self.category, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszName, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszDescription, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.fidParent, &mut into[12..12 + 16]);
        FromIntoMemory::into_bytes(self.pszRelativePath, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.pszParsingName, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.pszTooltip, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.pszLocalizedName, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.pszIcon, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.pszSecurity, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.dwAttributes, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.kfdFlags, &mut into[56..56 + 4]);
        FromIntoMemory::into_bytes(self.ftidType, &mut into[60..60 + 16]);
    }
    fn size() -> usize {
        76
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct KNOWN_FOLDER_FLAG(pub i32);
pub const KF_FLAG_DEFAULT: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(0i32);
pub const KF_FLAG_FORCE_APP_DATA_REDIRECTION: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(524288i32);
pub const KF_FLAG_RETURN_FILTER_REDIRECTION_TARGET: KNOWN_FOLDER_FLAG =
    KNOWN_FOLDER_FLAG(262144i32);
pub const KF_FLAG_FORCE_PACKAGE_REDIRECTION: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(131072i32);
pub const KF_FLAG_NO_PACKAGE_REDIRECTION: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(65536i32);
pub const KF_FLAG_FORCE_APPCONTAINER_REDIRECTION: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(131072i32);
pub const KF_FLAG_NO_APPCONTAINER_REDIRECTION: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(65536i32);
pub const KF_FLAG_CREATE: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(32768i32);
pub const KF_FLAG_DONT_VERIFY: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(16384i32);
pub const KF_FLAG_DONT_UNEXPAND: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(8192i32);
pub const KF_FLAG_NO_ALIAS: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(4096i32);
pub const KF_FLAG_INIT: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(2048i32);
pub const KF_FLAG_DEFAULT_PATH: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(1024i32);
pub const KF_FLAG_NOT_PARENT_RELATIVE: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(512i32);
pub const KF_FLAG_SIMPLE_IDLIST: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(256i32);
pub const KF_FLAG_ALIAS_ONLY: KNOWN_FOLDER_FLAG = KNOWN_FOLDER_FLAG(-2147483648i32);
impl ::core::marker::Copy for KNOWN_FOLDER_FLAG {}
impl ::core::clone::Clone for KNOWN_FOLDER_FLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for KNOWN_FOLDER_FLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for KNOWN_FOLDER_FLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KNOWN_FOLDER_FLAG").field(&self.0).finish()
    }
}
impl FromIntoMemory for KNOWN_FOLDER_FLAG {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const KnownFolderManager: crate::core::GUID =
    crate::core::GUID::from_u128(0x4df0c730_df9d_4ae3_9153_aa6b82e9795a);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct LIBRARYFOLDERFILTER(pub i32);
pub const LFF_FORCEFILESYSTEM: LIBRARYFOLDERFILTER = LIBRARYFOLDERFILTER(1i32);
pub const LFF_STORAGEITEMS: LIBRARYFOLDERFILTER = LIBRARYFOLDERFILTER(2i32);
pub const LFF_ALLITEMS: LIBRARYFOLDERFILTER = LIBRARYFOLDERFILTER(3i32);
impl ::core::marker::Copy for LIBRARYFOLDERFILTER {}
impl ::core::clone::Clone for LIBRARYFOLDERFILTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LIBRARYFOLDERFILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for LIBRARYFOLDERFILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LIBRARYFOLDERFILTER").field(&self.0).finish()
    }
}
impl FromIntoMemory for LIBRARYFOLDERFILTER {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct LIBRARYMANAGEDIALOGOPTIONS(pub i32);
pub const LMD_DEFAULT: LIBRARYMANAGEDIALOGOPTIONS = LIBRARYMANAGEDIALOGOPTIONS(0i32);
pub const LMD_ALLOWUNINDEXABLENETWORKLOCATIONS: LIBRARYMANAGEDIALOGOPTIONS =
    LIBRARYMANAGEDIALOGOPTIONS(1i32);
impl ::core::marker::Copy for LIBRARYMANAGEDIALOGOPTIONS {}
impl ::core::clone::Clone for LIBRARYMANAGEDIALOGOPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LIBRARYMANAGEDIALOGOPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for LIBRARYMANAGEDIALOGOPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LIBRARYMANAGEDIALOGOPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for LIBRARYMANAGEDIALOGOPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct LIBRARYOPTIONFLAGS(pub i32);
pub const LOF_DEFAULT: LIBRARYOPTIONFLAGS = LIBRARYOPTIONFLAGS(0i32);
pub const LOF_PINNEDTONAVPANE: LIBRARYOPTIONFLAGS = LIBRARYOPTIONFLAGS(1i32);
pub const LOF_MASK_ALL: LIBRARYOPTIONFLAGS = LIBRARYOPTIONFLAGS(1i32);
impl ::core::marker::Copy for LIBRARYOPTIONFLAGS {}
impl ::core::clone::Clone for LIBRARYOPTIONFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LIBRARYOPTIONFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for LIBRARYOPTIONFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LIBRARYOPTIONFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for LIBRARYOPTIONFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct LIBRARYSAVEFLAGS(pub i32);
pub const LSF_FAILIFTHERE: LIBRARYSAVEFLAGS = LIBRARYSAVEFLAGS(0i32);
pub const LSF_OVERRIDEEXISTING: LIBRARYSAVEFLAGS = LIBRARYSAVEFLAGS(1i32);
pub const LSF_MAKEUNIQUENAME: LIBRARYSAVEFLAGS = LIBRARYSAVEFLAGS(2i32);
impl ::core::marker::Copy for LIBRARYSAVEFLAGS {}
impl ::core::clone::Clone for LIBRARYSAVEFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LIBRARYSAVEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for LIBRARYSAVEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LIBRARYSAVEFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for LIBRARYSAVEFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const LIBRARY_E_NO_ACCESSIBLE_LOCATION: crate::core::HRESULT =
    crate::core::HRESULT(-2144927231i32);
pub const LIBRARY_E_NO_SAVE_LOCATION: crate::core::HRESULT = crate::core::HRESULT(-2144927232i32);
pub const LINK_E_DELETE: crate::core::HRESULT = crate::core::HRESULT(-2144927485i32);
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub type LPFNDFMCALLBACK = StdCallFnPtr<
    (
        IShellFolder,
        super::super::Foundation::HWND,
        super::super::System::Com::IDataObject,
        u32,
        super::super::Foundation::WPARAM,
        super::super::Foundation::LPARAM,
    ),
    crate::core::HRESULT,
>;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub type LPFNVIEWCALLBACK = StdCallFnPtr<
    (
        IShellView,
        IShellFolder,
        super::super::Foundation::HWND,
        u32,
        super::super::Foundation::WPARAM,
        super::super::Foundation::LPARAM,
    ),
    crate::core::HRESULT,
>;
pub const LocalThumbnailCache: crate::core::GUID =
    crate::core::GUID::from_u128(0x50ef4544_ac9f_4a8e_b21b_8a26180db13f);
pub const MAXFILELEN: u32 = 13u32;
pub const MAX_COLUMN_DESC_LEN: u32 = 128u32;
pub const MAX_COLUMN_NAME_LEN: u32 = 80u32;
pub const MAX_SYNCMGRHANDLERNAME: u32 = 32u32;
pub const MAX_SYNCMGRITEMNAME: u32 = 128u32;
pub const MAX_SYNCMGR_ID: u32 = 64u32;
pub const MAX_SYNCMGR_NAME: u32 = 128u32;
pub const MAX_SYNCMGR_PROGRESSTEXT: u32 = 260u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct MENUBANDHANDLERCID(pub i32);
pub const MBHANDCID_PIDLSELECT: MENUBANDHANDLERCID = MENUBANDHANDLERCID(0i32);
impl ::core::marker::Copy for MENUBANDHANDLERCID {}
impl ::core::clone::Clone for MENUBANDHANDLERCID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MENUBANDHANDLERCID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MENUBANDHANDLERCID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MENUBANDHANDLERCID").field(&self.0).finish()
    }
}
impl FromIntoMemory for MENUBANDHANDLERCID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct MENUPOPUPPOPUPFLAGS(pub i32);
pub const MPPF_SETFOCUS: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(1i32);
pub const MPPF_INITIALSELECT: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(2i32);
pub const MPPF_NOANIMATE: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(4i32);
pub const MPPF_KEYBOARD: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(16i32);
pub const MPPF_REPOSITION: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(32i32);
pub const MPPF_FORCEZORDER: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(64i32);
pub const MPPF_FINALSELECT: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(128i32);
pub const MPPF_TOP: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(536870912i32);
pub const MPPF_LEFT: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(1073741824i32);
pub const MPPF_RIGHT: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(1610612736i32);
pub const MPPF_BOTTOM: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(-2147483648i32);
pub const MPPF_POS_MASK: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(-536870912i32);
pub const MPPF_ALIGN_LEFT: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(33554432i32);
pub const MPPF_ALIGN_RIGHT: MENUPOPUPPOPUPFLAGS = MENUPOPUPPOPUPFLAGS(67108864i32);
impl ::core::marker::Copy for MENUPOPUPPOPUPFLAGS {}
impl ::core::clone::Clone for MENUPOPUPPOPUPFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MENUPOPUPPOPUPFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MENUPOPUPPOPUPFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MENUPOPUPPOPUPFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for MENUPOPUPPOPUPFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct MENUPOPUPSELECT(pub i32);
pub const MPOS_EXECUTE: MENUPOPUPSELECT = MENUPOPUPSELECT(0i32);
pub const MPOS_FULLCANCEL: MENUPOPUPSELECT = MENUPOPUPSELECT(1i32);
pub const MPOS_CANCELLEVEL: MENUPOPUPSELECT = MENUPOPUPSELECT(2i32);
pub const MPOS_SELECTLEFT: MENUPOPUPSELECT = MENUPOPUPSELECT(3i32);
pub const MPOS_SELECTRIGHT: MENUPOPUPSELECT = MENUPOPUPSELECT(4i32);
pub const MPOS_CHILDTRACKING: MENUPOPUPSELECT = MENUPOPUPSELECT(5i32);
impl ::core::marker::Copy for MENUPOPUPSELECT {}
impl ::core::clone::Clone for MENUPOPUPSELECT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MENUPOPUPSELECT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MENUPOPUPSELECT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MENUPOPUPSELECT").field(&self.0).finish()
    }
}
impl FromIntoMemory for MENUPOPUPSELECT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct MERGE_UPDATE_STATUS(pub i32);
pub const MUS_COMPLETE: MERGE_UPDATE_STATUS = MERGE_UPDATE_STATUS(0i32);
pub const MUS_USERINPUTNEEDED: MERGE_UPDATE_STATUS = MERGE_UPDATE_STATUS(1i32);
pub const MUS_FAILED: MERGE_UPDATE_STATUS = MERGE_UPDATE_STATUS(2i32);
impl ::core::marker::Copy for MERGE_UPDATE_STATUS {}
impl ::core::clone::Clone for MERGE_UPDATE_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MERGE_UPDATE_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MERGE_UPDATE_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MERGE_UPDATE_STATUS").field(&self.0).finish()
    }
}
impl FromIntoMemory for MERGE_UPDATE_STATUS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct MM_FLAGS(pub u32);
pub const MM_ADDSEPARATOR: MM_FLAGS = MM_FLAGS(1u32);
pub const MM_SUBMENUSHAVEIDS: MM_FLAGS = MM_FLAGS(2u32);
pub const MM_DONTREMOVESEPS: MM_FLAGS = MM_FLAGS(4u32);
impl ::core::marker::Copy for MM_FLAGS {}
impl ::core::clone::Clone for MM_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MM_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MM_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MM_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for MM_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MM_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MM_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MM_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MM_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for MM_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct MONITOR_APP_VISIBILITY(pub i32);
pub const MAV_UNKNOWN: MONITOR_APP_VISIBILITY = MONITOR_APP_VISIBILITY(0i32);
pub const MAV_NO_APP_VISIBLE: MONITOR_APP_VISIBILITY = MONITOR_APP_VISIBILITY(1i32);
pub const MAV_APP_VISIBLE: MONITOR_APP_VISIBILITY = MONITOR_APP_VISIBILITY(2i32);
impl ::core::marker::Copy for MONITOR_APP_VISIBILITY {}
impl ::core::clone::Clone for MONITOR_APP_VISIBILITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MONITOR_APP_VISIBILITY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for MONITOR_APP_VISIBILITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MONITOR_APP_VISIBILITY")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for MONITOR_APP_VISIBILITY {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct MULTIKEYHELPA {
    pub mkSize: u32,
    pub mkKeylist: super::super::Foundation::CHAR,
    pub szKeyphrase: [super::super::Foundation::CHAR; 1],
}
impl ::core::marker::Copy for MULTIKEYHELPA {}
impl ::core::clone::Clone for MULTIKEYHELPA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MULTIKEYHELPA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MULTIKEYHELPA")
            .field("mkSize", &self.mkSize)
            .field("mkKeylist", &self.mkKeylist)
            .field("szKeyphrase", &self.szKeyphrase)
            .finish()
    }
}
impl ::core::cmp::PartialEq for MULTIKEYHELPA {
    fn eq(&self, other: &Self) -> bool {
        self.mkSize == other.mkSize
            && self.mkKeylist == other.mkKeylist
            && self.szKeyphrase == other.szKeyphrase
    }
}
impl ::core::cmp::Eq for MULTIKEYHELPA {}
impl FromIntoMemory for MULTIKEYHELPA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_mkSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_mkKeylist =
            <super::super::Foundation::CHAR as FromIntoMemory>::from_bytes(&from[4..4 + 1]);
        let f_szKeyphrase =
            <[super::super::Foundation::CHAR; 1] as FromIntoMemory>::from_bytes(&from[5..5 + 1]);
        Self {
            mkSize: f_mkSize,
            mkKeylist: f_mkKeylist,
            szKeyphrase: f_szKeyphrase,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.mkSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.mkKeylist, &mut into[4..4 + 1]);
        FromIntoMemory::into_bytes(self.szKeyphrase, &mut into[5..5 + 1]);
    }
    fn size() -> usize {
        8
    }
}
pub struct MULTIKEYHELPW {
    pub mkSize: u32,
    pub mkKeylist: u16,
    pub szKeyphrase: [u16; 1],
}
impl ::core::marker::Copy for MULTIKEYHELPW {}
impl ::core::clone::Clone for MULTIKEYHELPW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MULTIKEYHELPW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MULTIKEYHELPW")
            .field("mkSize", &self.mkSize)
            .field("mkKeylist", &self.mkKeylist)
            .field("szKeyphrase", &self.szKeyphrase)
            .finish()
    }
}
impl ::core::cmp::PartialEq for MULTIKEYHELPW {
    fn eq(&self, other: &Self) -> bool {
        self.mkSize == other.mkSize
            && self.mkKeylist == other.mkKeylist
            && self.szKeyphrase == other.szKeyphrase
    }
}
impl ::core::cmp::Eq for MULTIKEYHELPW {}
impl FromIntoMemory for MULTIKEYHELPW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_mkSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_mkKeylist = <u16 as FromIntoMemory>::from_bytes(&from[4..4 + 1]);
        let f_szKeyphrase = <[u16; 1] as FromIntoMemory>::from_bytes(&from[5..5 + 1]);
        Self {
            mkSize: f_mkSize,
            mkKeylist: f_mkKeylist,
            szKeyphrase: f_szKeyphrase,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.mkSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.mkKeylist, &mut into[4..4 + 1]);
        FromIntoMemory::into_bytes(self.szKeyphrase, &mut into[5..5 + 1]);
    }
    fn size() -> usize {
        8
    }
}
pub const MailRecipient: crate::core::GUID =
    crate::core::GUID::from_u128(0x9e56be60_c50f_11cf_9a2c_00a0c90a90ce);
pub const MergedCategorizer: crate::core::GUID =
    crate::core::GUID::from_u128(0x8e827c11_33e7_4bc1_b242_8cd9a1c2b304);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NAMESPACEWALKFLAG(pub i32);
pub const NSWF_DEFAULT: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(0i32);
pub const NSWF_NONE_IMPLIES_ALL: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(1i32);
pub const NSWF_ONE_IMPLIES_ALL: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(2i32);
pub const NSWF_DONT_TRAVERSE_LINKS: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(4i32);
pub const NSWF_DONT_ACCUMULATE_RESULT: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(8i32);
pub const NSWF_TRAVERSE_STREAM_JUNCTIONS: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(16i32);
pub const NSWF_FILESYSTEM_ONLY: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(32i32);
pub const NSWF_SHOW_PROGRESS: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(64i32);
pub const NSWF_FLAG_VIEWORDER: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(128i32);
pub const NSWF_IGNORE_AUTOPLAY_HIDA: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(256i32);
pub const NSWF_ASYNC: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(512i32);
pub const NSWF_DONT_RESOLVE_LINKS: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(1024i32);
pub const NSWF_ACCUMULATE_FOLDERS: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(2048i32);
pub const NSWF_DONT_SORT: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(4096i32);
pub const NSWF_USE_TRANSFER_MEDIUM: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(8192i32);
pub const NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(16384i32);
pub const NSWF_ANY_IMPLIES_ALL: NAMESPACEWALKFLAG = NAMESPACEWALKFLAG(32768i32);
impl ::core::marker::Copy for NAMESPACEWALKFLAG {}
impl ::core::clone::Clone for NAMESPACEWALKFLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NAMESPACEWALKFLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NAMESPACEWALKFLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NAMESPACEWALKFLAG").field(&self.0).finish()
    }
}
impl FromIntoMemory for NAMESPACEWALKFLAG {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NATIVE_DISPLAY_ORIENTATION(pub i32);
pub const NDO_LANDSCAPE: NATIVE_DISPLAY_ORIENTATION = NATIVE_DISPLAY_ORIENTATION(0i32);
pub const NDO_PORTRAIT: NATIVE_DISPLAY_ORIENTATION = NATIVE_DISPLAY_ORIENTATION(1i32);
impl ::core::marker::Copy for NATIVE_DISPLAY_ORIENTATION {}
impl ::core::clone::Clone for NATIVE_DISPLAY_ORIENTATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NATIVE_DISPLAY_ORIENTATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NATIVE_DISPLAY_ORIENTATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NATIVE_DISPLAY_ORIENTATION")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for NATIVE_DISPLAY_ORIENTATION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const NCM_DISPLAYERRORTIP: u32 = 1028u32;
pub const NCM_GETADDRESS: u32 = 1025u32;
pub const NCM_GETALLOWTYPE: u32 = 1027u32;
pub const NCM_SETALLOWTYPE: u32 = 1026u32;
pub struct NC_ADDRESS {
    pub pAddrInfo: MutPtr<NC_ADDRESS_0>,
    pub PortNumber: u16,
    pub PrefixLength: u8,
}
impl ::core::marker::Copy for NC_ADDRESS {}
impl ::core::clone::Clone for NC_ADDRESS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NC_ADDRESS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NC_ADDRESS")
            .field("pAddrInfo", &self.pAddrInfo)
            .field("PortNumber", &self.PortNumber)
            .field("PrefixLength", &self.PrefixLength)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NC_ADDRESS {
    fn eq(&self, other: &Self) -> bool {
        self.pAddrInfo == other.pAddrInfo
            && self.PortNumber == other.PortNumber
            && self.PrefixLength == other.PrefixLength
    }
}
impl ::core::cmp::Eq for NC_ADDRESS {}
impl FromIntoMemory for NC_ADDRESS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_pAddrInfo = <MutPtr<NC_ADDRESS_0> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_PortNumber = <u16 as FromIntoMemory>::from_bytes(&from[4..4 + 2]);
        let f_PrefixLength = <u8 as FromIntoMemory>::from_bytes(&from[6..6 + 1]);
        Self {
            pAddrInfo: f_pAddrInfo,
            PortNumber: f_PortNumber,
            PrefixLength: f_PrefixLength,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.pAddrInfo, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.PortNumber, &mut into[4..4 + 2]);
        FromIntoMemory::into_bytes(self.PrefixLength, &mut into[6..6 + 1]);
    }
    fn size() -> usize {
        8
    }
}
pub struct NC_ADDRESS_0(pub u8);
pub const NETCACHE_E_NEGATIVE_CACHE: crate::core::HRESULT = crate::core::HRESULT(-2144927488i32);
pub struct NEWCPLINFOA {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwHelpContext: u32,
    pub lData: PtrDiffRepr,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub szName: [super::super::Foundation::CHAR; 32],
    pub szInfo: [super::super::Foundation::CHAR; 64],
    pub szHelpFile: [super::super::Foundation::CHAR; 128],
}
impl ::core::marker::Copy for NEWCPLINFOA {}
impl ::core::clone::Clone for NEWCPLINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NEWCPLINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NEWCPLINFOA")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dwHelpContext", &self.dwHelpContext)
            .field("lData", &self.lData)
            .field("hIcon", &self.hIcon)
            .field("szName", &self.szName)
            .field("szInfo", &self.szInfo)
            .field("szHelpFile", &self.szHelpFile)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NEWCPLINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dwHelpContext == other.dwHelpContext
            && self.lData == other.lData
            && self.hIcon == other.hIcon
            && self.szName == other.szName
            && self.szInfo == other.szInfo
            && self.szHelpFile == other.szHelpFile
    }
}
impl ::core::cmp::Eq for NEWCPLINFOA {}
impl FromIntoMemory for NEWCPLINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 244);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwHelpContext = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lData = <PtrDiffRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_szName = <[super::super::Foundation::CHAR; 32] as FromIntoMemory>::from_bytes(
            &from[20..20 + 32],
        );
        let f_szInfo = <[super::super::Foundation::CHAR; 64] as FromIntoMemory>::from_bytes(
            &from[52..52 + 64],
        );
        let f_szHelpFile = <[super::super::Foundation::CHAR; 128] as FromIntoMemory>::from_bytes(
            &from[116..116 + 128],
        );
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            dwHelpContext: f_dwHelpContext,
            lData: f_lData,
            hIcon: f_hIcon,
            szName: f_szName,
            szInfo: f_szInfo,
            szHelpFile: f_szHelpFile,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 244);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwHelpContext, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lData, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.szName, &mut into[20..20 + 32]);
        FromIntoMemory::into_bytes(self.szInfo, &mut into[52..52 + 64]);
        FromIntoMemory::into_bytes(self.szHelpFile, &mut into[116..116 + 128]);
    }
    fn size() -> usize {
        244
    }
}
pub struct NEWCPLINFOW {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub dwHelpContext: u32,
    pub lData: PtrDiffRepr,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub szName: [u16; 32],
    pub szInfo: [u16; 64],
    pub szHelpFile: [u16; 128],
}
impl ::core::marker::Copy for NEWCPLINFOW {}
impl ::core::clone::Clone for NEWCPLINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NEWCPLINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NEWCPLINFOW")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("dwHelpContext", &self.dwHelpContext)
            .field("lData", &self.lData)
            .field("hIcon", &self.hIcon)
            .field("szName", &self.szName)
            .field("szInfo", &self.szInfo)
            .field("szHelpFile", &self.szHelpFile)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NEWCPLINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.dwHelpContext == other.dwHelpContext
            && self.lData == other.lData
            && self.hIcon == other.hIcon
            && self.szName == other.szName
            && self.szInfo == other.szInfo
            && self.szHelpFile == other.szHelpFile
    }
}
impl ::core::cmp::Eq for NEWCPLINFOW {}
impl FromIntoMemory for NEWCPLINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 244);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwHelpContext = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lData = <PtrDiffRepr as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_szName = <[u16; 32] as FromIntoMemory>::from_bytes(&from[20..20 + 32]);
        let f_szInfo = <[u16; 64] as FromIntoMemory>::from_bytes(&from[52..52 + 64]);
        let f_szHelpFile = <[u16; 128] as FromIntoMemory>::from_bytes(&from[116..116 + 128]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            dwHelpContext: f_dwHelpContext,
            lData: f_lData,
            hIcon: f_hIcon,
            szName: f_szName,
            szInfo: f_szInfo,
            szHelpFile: f_szHelpFile,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 244);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwHelpContext, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lData, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.szName, &mut into[20..20 + 32]);
        FromIntoMemory::into_bytes(self.szInfo, &mut into[52..52 + 64]);
        FromIntoMemory::into_bytes(self.szHelpFile, &mut into[116..116 + 128]);
    }
    fn size() -> usize {
        244
    }
}
pub const NIIF_ERROR: u32 = 3u32;
pub const NIIF_ICON_MASK: u32 = 15u32;
pub const NIIF_INFO: u32 = 1u32;
pub const NIIF_LARGE_ICON: u32 = 32u32;
pub const NIIF_NONE: u32 = 0u32;
pub const NIIF_NOSOUND: u32 = 16u32;
pub const NIIF_RESPECT_QUIET_TIME: u32 = 128u32;
pub const NIIF_USER: u32 = 4u32;
pub const NIIF_WARNING: u32 = 2u32;
pub const NINF_KEY: u32 = 1u32;
pub const NIN_BALLOONHIDE: u32 = 1027u32;
pub const NIN_BALLOONSHOW: u32 = 1026u32;
pub const NIN_BALLOONTIMEOUT: u32 = 1028u32;
pub const NIN_BALLOONUSERCLICK: u32 = 1029u32;
pub const NIN_POPUPCLOSE: u32 = 1031u32;
pub const NIN_POPUPOPEN: u32 = 1030u32;
pub const NIN_SELECT: u32 = 1024u32;
pub const NIS_HIDDEN: u32 = 1u32;
pub const NIS_SHAREDICON: u32 = 2u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct NOTIFYICONDATAA {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uID: u32,
    pub uFlags: NOTIFY_ICON_DATA_FLAGS,
    pub uCallbackMessage: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub szTip: [super::super::Foundation::CHAR; 128],
    pub dwState: u32,
    pub dwStateMask: u32,
    pub szInfo: [super::super::Foundation::CHAR; 256],
    pub Anonymous: NOTIFYICONDATAA_0,
    pub szInfoTitle: [super::super::Foundation::CHAR; 64],
    pub dwInfoFlags: u32,
    pub guidItem: crate::core::GUID,
    pub hBalloonIcon: super::WindowsAndMessaging::HICON,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for NOTIFYICONDATAA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for NOTIFYICONDATAA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for NOTIFYICONDATAA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAA")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uID", &self.uID)
            .field("uFlags", &self.uFlags)
            .field("uCallbackMessage", &self.uCallbackMessage)
            .field("hIcon", &self.hIcon)
            .field("szTip", &self.szTip)
            .field("dwState", &self.dwState)
            .field("dwStateMask", &self.dwStateMask)
            .field("szInfo", &self.szInfo)
            .field("Anonymous", &self.Anonymous)
            .field("szInfoTitle", &self.szInfoTitle)
            .field("dwInfoFlags", &self.dwInfoFlags)
            .field("guidItem", &self.guidItem)
            .field("hBalloonIcon", &self.hBalloonIcon)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for NOTIFYICONDATAA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uID == other.uID
            && self.uFlags == other.uFlags
            && self.uCallbackMessage == other.uCallbackMessage
            && self.hIcon == other.hIcon
            && self.szTip == other.szTip
            && self.dwState == other.dwState
            && self.dwStateMask == other.dwStateMask
            && self.szInfo == other.szInfo
            && self.Anonymous == other.Anonymous
            && self.szInfoTitle == other.szInfoTitle
            && self.dwInfoFlags == other.dwInfoFlags
            && self.guidItem == other.guidItem
            && self.hBalloonIcon == other.hBalloonIcon
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for NOTIFYICONDATAA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for NOTIFYICONDATAA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 508);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uID = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_uFlags = <NOTIFY_ICON_DATA_FLAGS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_uCallbackMessage = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_szTip = <[super::super::Foundation::CHAR; 128] as FromIntoMemory>::from_bytes(
            &from[24..24 + 128],
        );
        let f_dwState = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwStateMask = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_szInfo = <[super::super::Foundation::CHAR; 256] as FromIntoMemory>::from_bytes(
            &from[160..160 + 256],
        );
        let f_Anonymous = <NOTIFYICONDATAA_0 as FromIntoMemory>::from_bytes(&from[416..416 + 4]);
        let f_szInfoTitle = <[super::super::Foundation::CHAR; 64] as FromIntoMemory>::from_bytes(
            &from[420..420 + 64],
        );
        let f_dwInfoFlags = <u32 as FromIntoMemory>::from_bytes(&from[484..484 + 4]);
        let f_guidItem = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[488..488 + 16]);
        let f_hBalloonIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[504..504 + 4]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uID: f_uID,
            uFlags: f_uFlags,
            uCallbackMessage: f_uCallbackMessage,
            hIcon: f_hIcon,
            szTip: f_szTip,
            dwState: f_dwState,
            dwStateMask: f_dwStateMask,
            szInfo: f_szInfo,
            Anonymous: f_Anonymous,
            szInfoTitle: f_szInfoTitle,
            dwInfoFlags: f_dwInfoFlags,
            guidItem: f_guidItem,
            hBalloonIcon: f_hBalloonIcon,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 508);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uID, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.uFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.uCallbackMessage, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.szTip, &mut into[24..24 + 128]);
        FromIntoMemory::into_bytes(self.dwState, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwStateMask, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.szInfo, &mut into[160..160 + 256]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[416..416 + 4]);
        FromIntoMemory::into_bytes(self.szInfoTitle, &mut into[420..420 + 64]);
        FromIntoMemory::into_bytes(self.dwInfoFlags, &mut into[484..484 + 4]);
        FromIntoMemory::into_bytes(self.guidItem, &mut into[488..488 + 16]);
        FromIntoMemory::into_bytes(self.hBalloonIcon, &mut into[504..504 + 4]);
    }
    fn size() -> usize {
        508
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct NOTIFYICONDATAA_0 {
    data: [u8; 4],
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::default::Default for NOTIFYICONDATAA_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for NOTIFYICONDATAA_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for NOTIFYICONDATAA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for NOTIFYICONDATAA_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAA_0")
            .field("data", &self.data)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for NOTIFYICONDATAA_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for NOTIFYICONDATAA_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for NOTIFYICONDATAA_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
pub struct NOTIFYICONDATAA {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uID: u32,
    pub uFlags: NOTIFY_ICON_DATA_FLAGS,
    pub uCallbackMessage: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub szTip: [super::super::Foundation::CHAR; 128],
    pub dwState: u32,
    pub dwStateMask: u32,
    pub szInfo: [super::super::Foundation::CHAR; 256],
    pub Anonymous: NOTIFYICONDATAA_0,
    pub szInfoTitle: [super::super::Foundation::CHAR; 64],
    pub dwInfoFlags: u32,
    pub guidItem: crate::core::GUID,
    pub hBalloonIcon: super::WindowsAndMessaging::HICON,
}
impl ::core::marker::Copy for NOTIFYICONDATAA {}
impl ::core::clone::Clone for NOTIFYICONDATAA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NOTIFYICONDATAA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAA")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uID", &self.uID)
            .field("uFlags", &self.uFlags)
            .field("uCallbackMessage", &self.uCallbackMessage)
            .field("hIcon", &self.hIcon)
            .field("szTip", &self.szTip)
            .field("dwState", &self.dwState)
            .field("dwStateMask", &self.dwStateMask)
            .field("szInfo", &self.szInfo)
            .field("Anonymous", &self.Anonymous)
            .field("szInfoTitle", &self.szInfoTitle)
            .field("dwInfoFlags", &self.dwInfoFlags)
            .field("guidItem", &self.guidItem)
            .field("hBalloonIcon", &self.hBalloonIcon)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NOTIFYICONDATAA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uID == other.uID
            && self.uFlags == other.uFlags
            && self.uCallbackMessage == other.uCallbackMessage
            && self.hIcon == other.hIcon
            && self.szTip == other.szTip
            && self.dwState == other.dwState
            && self.dwStateMask == other.dwStateMask
            && self.szInfo == other.szInfo
            && self.Anonymous == other.Anonymous
            && self.szInfoTitle == other.szInfoTitle
            && self.dwInfoFlags == other.dwInfoFlags
            && self.guidItem == other.guidItem
            && self.hBalloonIcon == other.hBalloonIcon
    }
}
impl ::core::cmp::Eq for NOTIFYICONDATAA {}
impl FromIntoMemory for NOTIFYICONDATAA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 508);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uID = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_uFlags = <NOTIFY_ICON_DATA_FLAGS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_uCallbackMessage = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_szTip = <[super::super::Foundation::CHAR; 128] as FromIntoMemory>::from_bytes(
            &from[24..24 + 128],
        );
        let f_dwState = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwStateMask = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_szInfo = <[super::super::Foundation::CHAR; 256] as FromIntoMemory>::from_bytes(
            &from[160..160 + 256],
        );
        let f_Anonymous = <NOTIFYICONDATAA_0 as FromIntoMemory>::from_bytes(&from[416..416 + 4]);
        let f_szInfoTitle = <[super::super::Foundation::CHAR; 64] as FromIntoMemory>::from_bytes(
            &from[420..420 + 64],
        );
        let f_dwInfoFlags = <u32 as FromIntoMemory>::from_bytes(&from[484..484 + 4]);
        let f_guidItem = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[488..488 + 16]);
        let f_hBalloonIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[504..504 + 4]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uID: f_uID,
            uFlags: f_uFlags,
            uCallbackMessage: f_uCallbackMessage,
            hIcon: f_hIcon,
            szTip: f_szTip,
            dwState: f_dwState,
            dwStateMask: f_dwStateMask,
            szInfo: f_szInfo,
            Anonymous: f_Anonymous,
            szInfoTitle: f_szInfoTitle,
            dwInfoFlags: f_dwInfoFlags,
            guidItem: f_guidItem,
            hBalloonIcon: f_hBalloonIcon,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 508);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uID, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.uFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.uCallbackMessage, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.szTip, &mut into[24..24 + 128]);
        FromIntoMemory::into_bytes(self.dwState, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwStateMask, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.szInfo, &mut into[160..160 + 256]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[416..416 + 4]);
        FromIntoMemory::into_bytes(self.szInfoTitle, &mut into[420..420 + 64]);
        FromIntoMemory::into_bytes(self.dwInfoFlags, &mut into[484..484 + 4]);
        FromIntoMemory::into_bytes(self.guidItem, &mut into[488..488 + 16]);
        FromIntoMemory::into_bytes(self.hBalloonIcon, &mut into[504..504 + 4]);
    }
    fn size() -> usize {
        508
    }
}
pub struct NOTIFYICONDATAA_0 {
    data: [u8; 4],
}
impl ::core::default::Default for NOTIFYICONDATAA_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
impl ::core::marker::Copy for NOTIFYICONDATAA_0 {}
impl ::core::clone::Clone for NOTIFYICONDATAA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NOTIFYICONDATAA_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAA_0")
            .field("data", &self.data)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NOTIFYICONDATAA_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for NOTIFYICONDATAA_0 {}
impl FromIntoMemory for NOTIFYICONDATAA_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct NOTIFYICONDATAW {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uID: u32,
    pub uFlags: NOTIFY_ICON_DATA_FLAGS,
    pub uCallbackMessage: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub szTip: [u16; 128],
    pub dwState: u32,
    pub dwStateMask: u32,
    pub szInfo: [u16; 256],
    pub Anonymous: NOTIFYICONDATAW_0,
    pub szInfoTitle: [u16; 64],
    pub dwInfoFlags: u32,
    pub guidItem: crate::core::GUID,
    pub hBalloonIcon: super::WindowsAndMessaging::HICON,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for NOTIFYICONDATAW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for NOTIFYICONDATAW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for NOTIFYICONDATAW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAW")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uID", &self.uID)
            .field("uFlags", &self.uFlags)
            .field("uCallbackMessage", &self.uCallbackMessage)
            .field("hIcon", &self.hIcon)
            .field("szTip", &self.szTip)
            .field("dwState", &self.dwState)
            .field("dwStateMask", &self.dwStateMask)
            .field("szInfo", &self.szInfo)
            .field("Anonymous", &self.Anonymous)
            .field("szInfoTitle", &self.szInfoTitle)
            .field("dwInfoFlags", &self.dwInfoFlags)
            .field("guidItem", &self.guidItem)
            .field("hBalloonIcon", &self.hBalloonIcon)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for NOTIFYICONDATAW {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uID == other.uID
            && self.uFlags == other.uFlags
            && self.uCallbackMessage == other.uCallbackMessage
            && self.hIcon == other.hIcon
            && self.szTip == other.szTip
            && self.dwState == other.dwState
            && self.dwStateMask == other.dwStateMask
            && self.szInfo == other.szInfo
            && self.Anonymous == other.Anonymous
            && self.szInfoTitle == other.szInfoTitle
            && self.dwInfoFlags == other.dwInfoFlags
            && self.guidItem == other.guidItem
            && self.hBalloonIcon == other.hBalloonIcon
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for NOTIFYICONDATAW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for NOTIFYICONDATAW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 508);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uID = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_uFlags = <NOTIFY_ICON_DATA_FLAGS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_uCallbackMessage = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_szTip = <[u16; 128] as FromIntoMemory>::from_bytes(&from[24..24 + 128]);
        let f_dwState = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwStateMask = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_szInfo = <[u16; 256] as FromIntoMemory>::from_bytes(&from[160..160 + 256]);
        let f_Anonymous = <NOTIFYICONDATAW_0 as FromIntoMemory>::from_bytes(&from[416..416 + 4]);
        let f_szInfoTitle = <[u16; 64] as FromIntoMemory>::from_bytes(&from[420..420 + 64]);
        let f_dwInfoFlags = <u32 as FromIntoMemory>::from_bytes(&from[484..484 + 4]);
        let f_guidItem = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[488..488 + 16]);
        let f_hBalloonIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[504..504 + 4]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uID: f_uID,
            uFlags: f_uFlags,
            uCallbackMessage: f_uCallbackMessage,
            hIcon: f_hIcon,
            szTip: f_szTip,
            dwState: f_dwState,
            dwStateMask: f_dwStateMask,
            szInfo: f_szInfo,
            Anonymous: f_Anonymous,
            szInfoTitle: f_szInfoTitle,
            dwInfoFlags: f_dwInfoFlags,
            guidItem: f_guidItem,
            hBalloonIcon: f_hBalloonIcon,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 508);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uID, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.uFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.uCallbackMessage, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.szTip, &mut into[24..24 + 128]);
        FromIntoMemory::into_bytes(self.dwState, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwStateMask, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.szInfo, &mut into[160..160 + 256]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[416..416 + 4]);
        FromIntoMemory::into_bytes(self.szInfoTitle, &mut into[420..420 + 64]);
        FromIntoMemory::into_bytes(self.dwInfoFlags, &mut into[484..484 + 4]);
        FromIntoMemory::into_bytes(self.guidItem, &mut into[488..488 + 16]);
        FromIntoMemory::into_bytes(self.hBalloonIcon, &mut into[504..504 + 4]);
    }
    fn size() -> usize {
        508
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct NOTIFYICONDATAW_0 {
    data: [u8; 4],
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::default::Default for NOTIFYICONDATAW_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for NOTIFYICONDATAW_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for NOTIFYICONDATAW_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for NOTIFYICONDATAW_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAW_0")
            .field("data", &self.data)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for NOTIFYICONDATAW_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for NOTIFYICONDATAW_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for NOTIFYICONDATAW_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
pub struct NOTIFYICONDATAW {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uID: u32,
    pub uFlags: NOTIFY_ICON_DATA_FLAGS,
    pub uCallbackMessage: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub szTip: [u16; 128],
    pub dwState: u32,
    pub dwStateMask: u32,
    pub szInfo: [u16; 256],
    pub Anonymous: NOTIFYICONDATAW_0,
    pub szInfoTitle: [u16; 64],
    pub dwInfoFlags: u32,
    pub guidItem: crate::core::GUID,
    pub hBalloonIcon: super::WindowsAndMessaging::HICON,
}
impl ::core::marker::Copy for NOTIFYICONDATAW {}
impl ::core::clone::Clone for NOTIFYICONDATAW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NOTIFYICONDATAW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAW")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uID", &self.uID)
            .field("uFlags", &self.uFlags)
            .field("uCallbackMessage", &self.uCallbackMessage)
            .field("hIcon", &self.hIcon)
            .field("szTip", &self.szTip)
            .field("dwState", &self.dwState)
            .field("dwStateMask", &self.dwStateMask)
            .field("szInfo", &self.szInfo)
            .field("Anonymous", &self.Anonymous)
            .field("szInfoTitle", &self.szInfoTitle)
            .field("dwInfoFlags", &self.dwInfoFlags)
            .field("guidItem", &self.guidItem)
            .field("hBalloonIcon", &self.hBalloonIcon)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NOTIFYICONDATAW {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uID == other.uID
            && self.uFlags == other.uFlags
            && self.uCallbackMessage == other.uCallbackMessage
            && self.hIcon == other.hIcon
            && self.szTip == other.szTip
            && self.dwState == other.dwState
            && self.dwStateMask == other.dwStateMask
            && self.szInfo == other.szInfo
            && self.Anonymous == other.Anonymous
            && self.szInfoTitle == other.szInfoTitle
            && self.dwInfoFlags == other.dwInfoFlags
            && self.guidItem == other.guidItem
            && self.hBalloonIcon == other.hBalloonIcon
    }
}
impl ::core::cmp::Eq for NOTIFYICONDATAW {}
impl FromIntoMemory for NOTIFYICONDATAW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 508);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uID = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_uFlags = <NOTIFY_ICON_DATA_FLAGS as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_uCallbackMessage = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_szTip = <[u16; 128] as FromIntoMemory>::from_bytes(&from[24..24 + 128]);
        let f_dwState = <u32 as FromIntoMemory>::from_bytes(&from[152..152 + 4]);
        let f_dwStateMask = <u32 as FromIntoMemory>::from_bytes(&from[156..156 + 4]);
        let f_szInfo = <[u16; 256] as FromIntoMemory>::from_bytes(&from[160..160 + 256]);
        let f_Anonymous = <NOTIFYICONDATAW_0 as FromIntoMemory>::from_bytes(&from[416..416 + 4]);
        let f_szInfoTitle = <[u16; 64] as FromIntoMemory>::from_bytes(&from[420..420 + 64]);
        let f_dwInfoFlags = <u32 as FromIntoMemory>::from_bytes(&from[484..484 + 4]);
        let f_guidItem = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[488..488 + 16]);
        let f_hBalloonIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[504..504 + 4]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uID: f_uID,
            uFlags: f_uFlags,
            uCallbackMessage: f_uCallbackMessage,
            hIcon: f_hIcon,
            szTip: f_szTip,
            dwState: f_dwState,
            dwStateMask: f_dwStateMask,
            szInfo: f_szInfo,
            Anonymous: f_Anonymous,
            szInfoTitle: f_szInfoTitle,
            dwInfoFlags: f_dwInfoFlags,
            guidItem: f_guidItem,
            hBalloonIcon: f_hBalloonIcon,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 508);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uID, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.uFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.uCallbackMessage, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.szTip, &mut into[24..24 + 128]);
        FromIntoMemory::into_bytes(self.dwState, &mut into[152..152 + 4]);
        FromIntoMemory::into_bytes(self.dwStateMask, &mut into[156..156 + 4]);
        FromIntoMemory::into_bytes(self.szInfo, &mut into[160..160 + 256]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[416..416 + 4]);
        FromIntoMemory::into_bytes(self.szInfoTitle, &mut into[420..420 + 64]);
        FromIntoMemory::into_bytes(self.dwInfoFlags, &mut into[484..484 + 4]);
        FromIntoMemory::into_bytes(self.guidItem, &mut into[488..488 + 16]);
        FromIntoMemory::into_bytes(self.hBalloonIcon, &mut into[504..504 + 4]);
    }
    fn size() -> usize {
        508
    }
}
pub struct NOTIFYICONDATAW_0 {
    data: [u8; 4],
}
impl ::core::default::Default for NOTIFYICONDATAW_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
impl ::core::marker::Copy for NOTIFYICONDATAW_0 {}
impl ::core::clone::Clone for NOTIFYICONDATAW_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NOTIFYICONDATAW_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONDATAW_0")
            .field("data", &self.data)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NOTIFYICONDATAW_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for NOTIFYICONDATAW_0 {}
impl FromIntoMemory for NOTIFYICONDATAW_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct NOTIFYICONIDENTIFIER {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uID: u32,
    pub guidItem: crate::core::GUID,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for NOTIFYICONIDENTIFIER {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for NOTIFYICONIDENTIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for NOTIFYICONIDENTIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONIDENTIFIER")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uID", &self.uID)
            .field("guidItem", &self.guidItem)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for NOTIFYICONIDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uID == other.uID
            && self.guidItem == other.guidItem
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for NOTIFYICONIDENTIFIER {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for NOTIFYICONIDENTIFIER {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uID = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_guidItem = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uID: f_uID,
            guidItem: f_guidItem,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uID, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.guidItem, &mut into[12..12 + 16]);
    }
    fn size() -> usize {
        28
    }
}
pub struct NOTIFYICONIDENTIFIER {
    pub cbSize: u32,
    pub hWnd: super::super::Foundation::HWND,
    pub uID: u32,
    pub guidItem: crate::core::GUID,
}
impl ::core::marker::Copy for NOTIFYICONIDENTIFIER {}
impl ::core::clone::Clone for NOTIFYICONIDENTIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NOTIFYICONIDENTIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NOTIFYICONIDENTIFIER")
            .field("cbSize", &self.cbSize)
            .field("hWnd", &self.hWnd)
            .field("uID", &self.uID)
            .field("guidItem", &self.guidItem)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NOTIFYICONIDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hWnd == other.hWnd
            && self.uID == other.uID
            && self.guidItem == other.guidItem
    }
}
impl ::core::cmp::Eq for NOTIFYICONIDENTIFIER {}
impl FromIntoMemory for NOTIFYICONIDENTIFIER {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hWnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uID = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_guidItem = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        Self {
            cbSize: f_cbSize,
            hWnd: f_hWnd,
            uID: f_uID,
            guidItem: f_guidItem,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hWnd, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uID, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.guidItem, &mut into[12..12 + 16]);
    }
    fn size() -> usize {
        28
    }
}
pub const NOTIFYICON_VERSION: u32 = 3u32;
pub const NOTIFYICON_VERSION_4: u32 = 4u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NOTIFY_ICON_DATA_FLAGS(pub u32);
pub const NIF_MESSAGE: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(1u32);
pub const NIF_ICON: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(2u32);
pub const NIF_TIP: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(4u32);
pub const NIF_STATE: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(8u32);
pub const NIF_INFO: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(16u32);
pub const NIF_GUID: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(32u32);
pub const NIF_REALTIME: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(64u32);
pub const NIF_SHOWTIP: NOTIFY_ICON_DATA_FLAGS = NOTIFY_ICON_DATA_FLAGS(128u32);
impl ::core::marker::Copy for NOTIFY_ICON_DATA_FLAGS {}
impl ::core::clone::Clone for NOTIFY_ICON_DATA_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NOTIFY_ICON_DATA_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NOTIFY_ICON_DATA_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NOTIFY_ICON_DATA_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl ::core::ops::BitOr for NOTIFY_ICON_DATA_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for NOTIFY_ICON_DATA_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for NOTIFY_ICON_DATA_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for NOTIFY_ICON_DATA_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for NOTIFY_ICON_DATA_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for NOTIFY_ICON_DATA_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NOTIFY_ICON_MESSAGE(pub u32);
pub const NIM_ADD: NOTIFY_ICON_MESSAGE = NOTIFY_ICON_MESSAGE(0u32);
pub const NIM_MODIFY: NOTIFY_ICON_MESSAGE = NOTIFY_ICON_MESSAGE(1u32);
pub const NIM_DELETE: NOTIFY_ICON_MESSAGE = NOTIFY_ICON_MESSAGE(2u32);
pub const NIM_SETFOCUS: NOTIFY_ICON_MESSAGE = NOTIFY_ICON_MESSAGE(3u32);
pub const NIM_SETVERSION: NOTIFY_ICON_MESSAGE = NOTIFY_ICON_MESSAGE(4u32);
impl ::core::marker::Copy for NOTIFY_ICON_MESSAGE {}
impl ::core::clone::Clone for NOTIFY_ICON_MESSAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NOTIFY_ICON_MESSAGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NOTIFY_ICON_MESSAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NOTIFY_ICON_MESSAGE").field(&self.0).finish()
    }
}
impl FromIntoMemory for NOTIFY_ICON_MESSAGE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const NPCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x3dd6bec0_8193_4ffe_ae25_e08e39ea4063);
#[doc = "*Required namespaces: 'Windows.Win32.NetworkManagement.WNet'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct NRESARRAY {
    pub cItems: u32,
    pub nr: [super::super::NetworkManagement::WNet::NETRESOURCEA; 1],
}
#[doc = "*Required namespaces: 'Windows.Win32.NetworkManagement.WNet'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for NRESARRAY {}
#[doc = "*Required namespaces: 'Windows.Win32.NetworkManagement.WNet'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for NRESARRAY {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.NetworkManagement.WNet'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for NRESARRAY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NRESARRAY")
            .field("cItems", &self.cItems)
            .field("nr", &self.nr)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.NetworkManagement.WNet'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for NRESARRAY {
    fn eq(&self, other: &Self) -> bool {
        self.cItems == other.cItems && self.nr == other.nr
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.NetworkManagement.WNet'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for NRESARRAY {}
#[doc = "*Required namespaces: 'Windows.Win32.NetworkManagement.WNet'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for NRESARRAY {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 36);
        let f_cItems = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_nr = < [ super::super::NetworkManagement::WNet:: NETRESOURCEA ;1 ] as FromIntoMemory > :: from_bytes ( & from [ 4 .. 4 + 32 ] ) ;
        Self {
            cItems: f_cItems,
            nr: f_nr,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 36);
        FromIntoMemory::into_bytes(self.cItems, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.nr, &mut into[4..4 + 32]);
    }
    fn size() -> usize {
        36
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct NSTCCUSTOMDRAW {
    pub psi: IShellItem,
    pub uItemState: u32,
    pub nstcis: u32,
    pub pszText: PCWSTR,
    pub iImage: i32,
    pub himl: super::Controls::HIMAGELIST,
    pub iLevel: i32,
    pub iIndent: i32,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for NSTCCUSTOMDRAW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for NSTCCUSTOMDRAW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for NSTCCUSTOMDRAW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NSTCCUSTOMDRAW")
            .field("psi", &self.psi)
            .field("uItemState", &self.uItemState)
            .field("nstcis", &self.nstcis)
            .field("pszText", &self.pszText)
            .field("iImage", &self.iImage)
            .field("himl", &self.himl)
            .field("iLevel", &self.iLevel)
            .field("iIndent", &self.iIndent)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for NSTCCUSTOMDRAW {
    fn eq(&self, other: &Self) -> bool {
        self.psi == other.psi
            && self.uItemState == other.uItemState
            && self.nstcis == other.nstcis
            && self.pszText == other.pszText
            && self.iImage == other.iImage
            && self.himl == other.himl
            && self.iLevel == other.iLevel
            && self.iIndent == other.iIndent
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for NSTCCUSTOMDRAW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for NSTCCUSTOMDRAW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_psi = <IShellItem as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_uItemState = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_nstcis = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszText = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_iImage = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_himl = <super::Controls::HIMAGELIST as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_iLevel = <i32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_iIndent = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            psi: f_psi,
            uItemState: f_uItemState,
            nstcis: f_nstcis,
            pszText: f_pszText,
            iImage: f_iImage,
            himl: f_himl,
            iLevel: f_iLevel,
            iIndent: f_iIndent,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.psi, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.uItemState, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.nstcis, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszText, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.iImage, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.himl, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.iLevel, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.iIndent, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub const NSTCDHPOS_ONTOP: i32 = -1i32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NSTCFOLDERCAPABILITIES(pub i32);
pub const NSTCFC_NONE: NSTCFOLDERCAPABILITIES = NSTCFOLDERCAPABILITIES(0i32);
pub const NSTCFC_PINNEDITEMFILTERING: NSTCFOLDERCAPABILITIES = NSTCFOLDERCAPABILITIES(1i32);
pub const NSTCFC_DELAY_REGISTER_NOTIFY: NSTCFOLDERCAPABILITIES = NSTCFOLDERCAPABILITIES(2i32);
impl ::core::marker::Copy for NSTCFOLDERCAPABILITIES {}
impl ::core::clone::Clone for NSTCFOLDERCAPABILITIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NSTCFOLDERCAPABILITIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NSTCFOLDERCAPABILITIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NSTCFOLDERCAPABILITIES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for NSTCFOLDERCAPABILITIES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NSTCGNI(pub i32);
pub const NSTCGNI_NEXT: NSTCGNI = NSTCGNI(0i32);
pub const NSTCGNI_NEXTVISIBLE: NSTCGNI = NSTCGNI(1i32);
pub const NSTCGNI_PREV: NSTCGNI = NSTCGNI(2i32);
pub const NSTCGNI_PREVVISIBLE: NSTCGNI = NSTCGNI(3i32);
pub const NSTCGNI_PARENT: NSTCGNI = NSTCGNI(4i32);
pub const NSTCGNI_CHILD: NSTCGNI = NSTCGNI(5i32);
pub const NSTCGNI_FIRSTVISIBLE: NSTCGNI = NSTCGNI(6i32);
pub const NSTCGNI_LASTVISIBLE: NSTCGNI = NSTCGNI(7i32);
impl ::core::marker::Copy for NSTCGNI {}
impl ::core::clone::Clone for NSTCGNI {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NSTCGNI {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NSTCGNI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NSTCGNI").field(&self.0).finish()
    }
}
impl FromIntoMemory for NSTCGNI {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NSTCSTYLE2(pub i32);
pub const NSTCS2_DEFAULT: NSTCSTYLE2 = NSTCSTYLE2(0i32);
pub const NSTCS2_INTERRUPTNOTIFICATIONS: NSTCSTYLE2 = NSTCSTYLE2(1i32);
pub const NSTCS2_SHOWNULLSPACEMENU: NSTCSTYLE2 = NSTCSTYLE2(2i32);
pub const NSTCS2_DISPLAYPADDING: NSTCSTYLE2 = NSTCSTYLE2(4i32);
pub const NSTCS2_DISPLAYPINNEDONLY: NSTCSTYLE2 = NSTCSTYLE2(8i32);
pub const NTSCS2_NOSINGLETONAUTOEXPAND: NSTCSTYLE2 = NSTCSTYLE2(16i32);
pub const NTSCS2_NEVERINSERTNONENUMERATED: NSTCSTYLE2 = NSTCSTYLE2(32i32);
impl ::core::marker::Copy for NSTCSTYLE2 {}
impl ::core::clone::Clone for NSTCSTYLE2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NSTCSTYLE2 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NSTCSTYLE2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NSTCSTYLE2").field(&self.0).finish()
    }
}
impl FromIntoMemory for NSTCSTYLE2 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct NT_CONSOLE_PROPS {
    pub dbh: DATABLOCK_HEADER,
    pub wFillAttribute: u16,
    pub wPopupFillAttribute: u16,
    pub dwScreenBufferSize: super::super::System::Console::COORD,
    pub dwWindowSize: super::super::System::Console::COORD,
    pub dwWindowOrigin: super::super::System::Console::COORD,
    pub nFont: u32,
    pub nInputBufferSize: u32,
    pub dwFontSize: super::super::System::Console::COORD,
    pub uFontFamily: u32,
    pub uFontWeight: u32,
    pub FaceName: [u16; 32],
    pub uCursorSize: u32,
    pub bFullScreen: super::super::Foundation::BOOL,
    pub bQuickEdit: super::super::Foundation::BOOL,
    pub bInsertMode: super::super::Foundation::BOOL,
    pub bAutoPosition: super::super::Foundation::BOOL,
    pub uHistoryBufferSize: u32,
    pub uNumberOfHistoryBuffers: u32,
    pub bHistoryNoDup: super::super::Foundation::BOOL,
    pub ColorTable: [u32; 16],
}
impl ::core::marker::Copy for NT_CONSOLE_PROPS {}
impl ::core::clone::Clone for NT_CONSOLE_PROPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NT_CONSOLE_PROPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NT_CONSOLE_PROPS")
            .field("dbh", &self.dbh)
            .field("wFillAttribute", &self.wFillAttribute)
            .field("wPopupFillAttribute", &self.wPopupFillAttribute)
            .field("dwScreenBufferSize", &self.dwScreenBufferSize)
            .field("dwWindowSize", &self.dwWindowSize)
            .field("dwWindowOrigin", &self.dwWindowOrigin)
            .field("nFont", &self.nFont)
            .field("nInputBufferSize", &self.nInputBufferSize)
            .field("dwFontSize", &self.dwFontSize)
            .field("uFontFamily", &self.uFontFamily)
            .field("uFontWeight", &self.uFontWeight)
            .field("FaceName", &self.FaceName)
            .field("uCursorSize", &self.uCursorSize)
            .field("bFullScreen", &self.bFullScreen)
            .field("bQuickEdit", &self.bQuickEdit)
            .field("bInsertMode", &self.bInsertMode)
            .field("bAutoPosition", &self.bAutoPosition)
            .field("uHistoryBufferSize", &self.uHistoryBufferSize)
            .field("uNumberOfHistoryBuffers", &self.uNumberOfHistoryBuffers)
            .field("bHistoryNoDup", &self.bHistoryNoDup)
            .field("ColorTable", &self.ColorTable)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NT_CONSOLE_PROPS {
    fn eq(&self, other: &Self) -> bool {
        self.dbh == other.dbh
            && self.wFillAttribute == other.wFillAttribute
            && self.wPopupFillAttribute == other.wPopupFillAttribute
            && self.dwScreenBufferSize == other.dwScreenBufferSize
            && self.dwWindowSize == other.dwWindowSize
            && self.dwWindowOrigin == other.dwWindowOrigin
            && self.nFont == other.nFont
            && self.nInputBufferSize == other.nInputBufferSize
            && self.dwFontSize == other.dwFontSize
            && self.uFontFamily == other.uFontFamily
            && self.uFontWeight == other.uFontWeight
            && self.FaceName == other.FaceName
            && self.uCursorSize == other.uCursorSize
            && self.bFullScreen == other.bFullScreen
            && self.bQuickEdit == other.bQuickEdit
            && self.bInsertMode == other.bInsertMode
            && self.bAutoPosition == other.bAutoPosition
            && self.uHistoryBufferSize == other.uHistoryBufferSize
            && self.uNumberOfHistoryBuffers == other.uNumberOfHistoryBuffers
            && self.bHistoryNoDup == other.bHistoryNoDup
            && self.ColorTable == other.ColorTable
    }
}
impl ::core::cmp::Eq for NT_CONSOLE_PROPS {}
impl FromIntoMemory for NT_CONSOLE_PROPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 172);
        let f_dbh = <DATABLOCK_HEADER as FromIntoMemory>::from_bytes(&from[0..0 + 8]);
        let f_wFillAttribute = <u16 as FromIntoMemory>::from_bytes(&from[8..8 + 2]);
        let f_wPopupFillAttribute = <u16 as FromIntoMemory>::from_bytes(&from[10..10 + 2]);
        let f_dwScreenBufferSize =
            <super::super::System::Console::COORD as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_dwWindowSize =
            <super::super::System::Console::COORD as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_dwWindowOrigin =
            <super::super::System::Console::COORD as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_nFont = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_nInputBufferSize = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_dwFontSize =
            <super::super::System::Console::COORD as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_uFontFamily = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_uFontWeight = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_FaceName = <[u16; 32] as FromIntoMemory>::from_bytes(&from[44..44 + 32]);
        let f_uCursorSize = <u32 as FromIntoMemory>::from_bytes(&from[76..76 + 4]);
        let f_bFullScreen =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[80..80 + 4]);
        let f_bQuickEdit =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[84..84 + 4]);
        let f_bInsertMode =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[88..88 + 4]);
        let f_bAutoPosition =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[92..92 + 4]);
        let f_uHistoryBufferSize = <u32 as FromIntoMemory>::from_bytes(&from[96..96 + 4]);
        let f_uNumberOfHistoryBuffers = <u32 as FromIntoMemory>::from_bytes(&from[100..100 + 4]);
        let f_bHistoryNoDup =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[104..104 + 4]);
        let f_ColorTable = <[u32; 16] as FromIntoMemory>::from_bytes(&from[108..108 + 64]);
        Self {
            dbh: f_dbh,
            wFillAttribute: f_wFillAttribute,
            wPopupFillAttribute: f_wPopupFillAttribute,
            dwScreenBufferSize: f_dwScreenBufferSize,
            dwWindowSize: f_dwWindowSize,
            dwWindowOrigin: f_dwWindowOrigin,
            nFont: f_nFont,
            nInputBufferSize: f_nInputBufferSize,
            dwFontSize: f_dwFontSize,
            uFontFamily: f_uFontFamily,
            uFontWeight: f_uFontWeight,
            FaceName: f_FaceName,
            uCursorSize: f_uCursorSize,
            bFullScreen: f_bFullScreen,
            bQuickEdit: f_bQuickEdit,
            bInsertMode: f_bInsertMode,
            bAutoPosition: f_bAutoPosition,
            uHistoryBufferSize: f_uHistoryBufferSize,
            uNumberOfHistoryBuffers: f_uNumberOfHistoryBuffers,
            bHistoryNoDup: f_bHistoryNoDup,
            ColorTable: f_ColorTable,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 172);
        FromIntoMemory::into_bytes(self.dbh, &mut into[0..0 + 8]);
        FromIntoMemory::into_bytes(self.wFillAttribute, &mut into[8..8 + 2]);
        FromIntoMemory::into_bytes(self.wPopupFillAttribute, &mut into[10..10 + 2]);
        FromIntoMemory::into_bytes(self.dwScreenBufferSize, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.dwWindowSize, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.dwWindowOrigin, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.nFont, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.nInputBufferSize, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.dwFontSize, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.uFontFamily, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.uFontWeight, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.FaceName, &mut into[44..44 + 32]);
        FromIntoMemory::into_bytes(self.uCursorSize, &mut into[76..76 + 4]);
        FromIntoMemory::into_bytes(self.bFullScreen, &mut into[80..80 + 4]);
        FromIntoMemory::into_bytes(self.bQuickEdit, &mut into[84..84 + 4]);
        FromIntoMemory::into_bytes(self.bInsertMode, &mut into[88..88 + 4]);
        FromIntoMemory::into_bytes(self.bAutoPosition, &mut into[92..92 + 4]);
        FromIntoMemory::into_bytes(self.uHistoryBufferSize, &mut into[96..96 + 4]);
        FromIntoMemory::into_bytes(self.uNumberOfHistoryBuffers, &mut into[100..100 + 4]);
        FromIntoMemory::into_bytes(self.bHistoryNoDup, &mut into[104..104 + 4]);
        FromIntoMemory::into_bytes(self.ColorTable, &mut into[108..108 + 64]);
    }
    fn size() -> usize {
        172
    }
}
pub const NT_CONSOLE_PROPS_SIG: u32 = 2684354562u32;
pub struct NT_FE_CONSOLE_PROPS {
    pub dbh: DATABLOCK_HEADER,
    pub uCodePage: u32,
}
impl ::core::marker::Copy for NT_FE_CONSOLE_PROPS {}
impl ::core::clone::Clone for NT_FE_CONSOLE_PROPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NT_FE_CONSOLE_PROPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NT_FE_CONSOLE_PROPS")
            .field("dbh", &self.dbh)
            .field("uCodePage", &self.uCodePage)
            .finish()
    }
}
impl ::core::cmp::PartialEq for NT_FE_CONSOLE_PROPS {
    fn eq(&self, other: &Self) -> bool {
        self.dbh == other.dbh && self.uCodePage == other.uCodePage
    }
}
impl ::core::cmp::Eq for NT_FE_CONSOLE_PROPS {}
impl FromIntoMemory for NT_FE_CONSOLE_PROPS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dbh = <DATABLOCK_HEADER as FromIntoMemory>::from_bytes(&from[0..0 + 8]);
        let f_uCodePage = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dbh: f_dbh,
            uCodePage: f_uCodePage,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dbh, &mut into[0..0 + 8]);
        FromIntoMemory::into_bytes(self.uCodePage, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const NT_FE_CONSOLE_PROPS_SIG: u32 = 2684354564u32;
pub const NUM_POINTS: u32 = 3u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NWMF(pub i32);
pub const NWMF_UNLOADING: NWMF = NWMF(1i32);
pub const NWMF_USERINITED: NWMF = NWMF(2i32);
pub const NWMF_FIRST: NWMF = NWMF(4i32);
pub const NWMF_OVERRIDEKEY: NWMF = NWMF(8i32);
pub const NWMF_SHOWHELP: NWMF = NWMF(16i32);
pub const NWMF_HTMLDIALOG: NWMF = NWMF(32i32);
pub const NWMF_FROMDIALOGCHILD: NWMF = NWMF(64i32);
pub const NWMF_USERREQUESTED: NWMF = NWMF(128i32);
pub const NWMF_USERALLOWED: NWMF = NWMF(256i32);
pub const NWMF_FORCEWINDOW: NWMF = NWMF(65536i32);
pub const NWMF_FORCETAB: NWMF = NWMF(131072i32);
pub const NWMF_SUGGESTWINDOW: NWMF = NWMF(262144i32);
pub const NWMF_SUGGESTTAB: NWMF = NWMF(524288i32);
pub const NWMF_INACTIVETAB: NWMF = NWMF(1048576i32);
impl ::core::marker::Copy for NWMF {}
impl ::core::clone::Clone for NWMF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NWMF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NWMF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NWMF").field(&self.0).finish()
    }
}
impl FromIntoMemory for NWMF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const NamespaceTreeControl: crate::core::GUID =
    crate::core::GUID::from_u128(0xae054212_3535_4430_83ed_d501aa6680e6);
pub const NamespaceWalker: crate::core::GUID =
    crate::core::GUID::from_u128(0x72eb61e0_8672_4303_9175_f2e4c68b2e7c);
pub const NetworkConnections: crate::core::GUID =
    crate::core::GUID::from_u128(0x7007acc7_3202_11d1_aad2_00805fc1270e);
pub const NetworkExplorerFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0xf02c1a0d_be21_4350_88b0_7367fc96ef3c);
pub const NetworkPlaces: crate::core::GUID =
    crate::core::GUID::from_u128(0x208d2c60_3aea_1069_a2d7_08002b30309d);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct NewProcessCauseConstants(pub i32);
pub const ProtectedModeRedirect: NewProcessCauseConstants = NewProcessCauseConstants(1i32);
impl ::core::marker::Copy for NewProcessCauseConstants {}
impl ::core::clone::Clone for NewProcessCauseConstants {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NewProcessCauseConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for NewProcessCauseConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NewProcessCauseConstants")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for NewProcessCauseConstants {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const OFASI_EDIT: u32 = 1u32;
pub const OFASI_OPENDESKTOP: u32 = 2u32;
pub const OFFLINE_STATUS_INCOMPLETE: u32 = 4u32;
pub const OFFLINE_STATUS_LOCAL: u32 = 1u32;
pub const OFFLINE_STATUS_REMOTE: u32 = 2u32;
pub const OF_CAP_CANCLOSE: u32 = 2u32;
pub const OF_CAP_CANSWITCHTO: u32 = 1u32;
pub const OI_ASYNC: u32 = 4294962926u32;
pub const OI_DEFAULT: u32 = 0u32;
pub struct OPENASINFO {
    pub pcszFile: PCWSTR,
    pub pcszClass: PCWSTR,
    pub oaifInFlags: OPEN_AS_INFO_FLAGS,
}
impl ::core::marker::Copy for OPENASINFO {}
impl ::core::clone::Clone for OPENASINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPENASINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPENASINFO")
            .field("pcszFile", &self.pcszFile)
            .field("pcszClass", &self.pcszClass)
            .field("oaifInFlags", &self.oaifInFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for OPENASINFO {
    fn eq(&self, other: &Self) -> bool {
        self.pcszFile == other.pcszFile
            && self.pcszClass == other.pcszClass
            && self.oaifInFlags == other.oaifInFlags
    }
}
impl ::core::cmp::Eq for OPENASINFO {}
impl FromIntoMemory for OPENASINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_pcszFile = <PCWSTR as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pcszClass = <PCWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_oaifInFlags = <OPEN_AS_INFO_FLAGS as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            pcszFile: f_pcszFile,
            pcszClass: f_pcszClass,
            oaifInFlags: f_oaifInFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.pcszFile, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pcszClass, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.oaifInFlags, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const OPENPROPS_INHIBITPIF: u32 = 32768u32;
pub const OPENPROPS_NONE: u32 = 0u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct OPEN_AS_INFO_FLAGS(pub u32);
pub const OAIF_ALLOW_REGISTRATION: OPEN_AS_INFO_FLAGS = OPEN_AS_INFO_FLAGS(1u32);
pub const OAIF_REGISTER_EXT: OPEN_AS_INFO_FLAGS = OPEN_AS_INFO_FLAGS(2u32);
pub const OAIF_EXEC: OPEN_AS_INFO_FLAGS = OPEN_AS_INFO_FLAGS(4u32);
pub const OAIF_FORCE_REGISTRATION: OPEN_AS_INFO_FLAGS = OPEN_AS_INFO_FLAGS(8u32);
pub const OAIF_HIDE_REGISTRATION: OPEN_AS_INFO_FLAGS = OPEN_AS_INFO_FLAGS(32u32);
pub const OAIF_URL_PROTOCOL: OPEN_AS_INFO_FLAGS = OPEN_AS_INFO_FLAGS(64u32);
pub const OAIF_FILE_IS_URI: OPEN_AS_INFO_FLAGS = OPEN_AS_INFO_FLAGS(128u32);
impl ::core::marker::Copy for OPEN_AS_INFO_FLAGS {}
impl ::core::clone::Clone for OPEN_AS_INFO_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPEN_AS_INFO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for OPEN_AS_INFO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPEN_AS_INFO_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for OPEN_AS_INFO_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for OPEN_AS_INFO_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for OPEN_AS_INFO_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for OPEN_AS_INFO_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for OPEN_AS_INFO_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for OPEN_AS_INFO_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct OPEN_PRINTER_PROPS_INFOA {
    pub dwSize: u32,
    pub pszSheetName: PSTR,
    pub uSheetIndex: u32,
    pub dwFlags: u32,
    pub bModal: super::super::Foundation::BOOL,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for OPEN_PRINTER_PROPS_INFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for OPEN_PRINTER_PROPS_INFOA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for OPEN_PRINTER_PROPS_INFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPEN_PRINTER_PROPS_INFOA")
            .field("dwSize", &self.dwSize)
            .field("pszSheetName", &self.pszSheetName)
            .field("uSheetIndex", &self.uSheetIndex)
            .field("dwFlags", &self.dwFlags)
            .field("bModal", &self.bModal)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for OPEN_PRINTER_PROPS_INFOA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.pszSheetName == other.pszSheetName
            && self.uSheetIndex == other.uSheetIndex
            && self.dwFlags == other.dwFlags
            && self.bModal == other.bModal
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for OPEN_PRINTER_PROPS_INFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for OPEN_PRINTER_PROPS_INFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszSheetName = <PSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uSheetIndex = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_bModal =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwSize: f_dwSize,
            pszSheetName: f_pszSheetName,
            uSheetIndex: f_uSheetIndex,
            dwFlags: f_dwFlags,
            bModal: f_bModal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszSheetName, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uSheetIndex, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.bModal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct OPEN_PRINTER_PROPS_INFOA {
    pub dwSize: u32,
    pub pszSheetName: PSTR,
    pub uSheetIndex: u32,
    pub dwFlags: u32,
    pub bModal: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for OPEN_PRINTER_PROPS_INFOA {}
impl ::core::clone::Clone for OPEN_PRINTER_PROPS_INFOA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPEN_PRINTER_PROPS_INFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPEN_PRINTER_PROPS_INFOA")
            .field("dwSize", &self.dwSize)
            .field("pszSheetName", &self.pszSheetName)
            .field("uSheetIndex", &self.uSheetIndex)
            .field("dwFlags", &self.dwFlags)
            .field("bModal", &self.bModal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for OPEN_PRINTER_PROPS_INFOA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.pszSheetName == other.pszSheetName
            && self.uSheetIndex == other.uSheetIndex
            && self.dwFlags == other.dwFlags
            && self.bModal == other.bModal
    }
}
impl ::core::cmp::Eq for OPEN_PRINTER_PROPS_INFOA {}
impl FromIntoMemory for OPEN_PRINTER_PROPS_INFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszSheetName = <PSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uSheetIndex = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_bModal =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwSize: f_dwSize,
            pszSheetName: f_pszSheetName,
            uSheetIndex: f_uSheetIndex,
            dwFlags: f_dwFlags,
            bModal: f_bModal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszSheetName, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uSheetIndex, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.bModal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct OPEN_PRINTER_PROPS_INFOW {
    pub dwSize: u32,
    pub pszSheetName: PWSTR,
    pub uSheetIndex: u32,
    pub dwFlags: u32,
    pub bModal: super::super::Foundation::BOOL,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for OPEN_PRINTER_PROPS_INFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for OPEN_PRINTER_PROPS_INFOW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for OPEN_PRINTER_PROPS_INFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPEN_PRINTER_PROPS_INFOW")
            .field("dwSize", &self.dwSize)
            .field("pszSheetName", &self.pszSheetName)
            .field("uSheetIndex", &self.uSheetIndex)
            .field("dwFlags", &self.dwFlags)
            .field("bModal", &self.bModal)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for OPEN_PRINTER_PROPS_INFOW {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.pszSheetName == other.pszSheetName
            && self.uSheetIndex == other.uSheetIndex
            && self.dwFlags == other.dwFlags
            && self.bModal == other.bModal
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for OPEN_PRINTER_PROPS_INFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for OPEN_PRINTER_PROPS_INFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszSheetName = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uSheetIndex = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_bModal =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwSize: f_dwSize,
            pszSheetName: f_pszSheetName,
            uSheetIndex: f_uSheetIndex,
            dwFlags: f_dwFlags,
            bModal: f_bModal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszSheetName, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uSheetIndex, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.bModal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct OPEN_PRINTER_PROPS_INFOW {
    pub dwSize: u32,
    pub pszSheetName: PWSTR,
    pub uSheetIndex: u32,
    pub dwFlags: u32,
    pub bModal: super::super::Foundation::BOOL,
}
impl ::core::marker::Copy for OPEN_PRINTER_PROPS_INFOW {}
impl ::core::clone::Clone for OPEN_PRINTER_PROPS_INFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPEN_PRINTER_PROPS_INFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPEN_PRINTER_PROPS_INFOW")
            .field("dwSize", &self.dwSize)
            .field("pszSheetName", &self.pszSheetName)
            .field("uSheetIndex", &self.uSheetIndex)
            .field("dwFlags", &self.dwFlags)
            .field("bModal", &self.bModal)
            .finish()
    }
}
impl ::core::cmp::PartialEq for OPEN_PRINTER_PROPS_INFOW {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.pszSheetName == other.pszSheetName
            && self.uSheetIndex == other.uSheetIndex
            && self.dwFlags == other.dwFlags
            && self.bModal == other.bModal
    }
}
impl ::core::cmp::Eq for OPEN_PRINTER_PROPS_INFOW {}
impl FromIntoMemory for OPEN_PRINTER_PROPS_INFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszSheetName = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uSheetIndex = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_bModal =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            dwSize: f_dwSize,
            pszSheetName: f_pszSheetName,
            uSheetIndex: f_uSheetIndex,
            dwFlags: f_dwFlags,
            bModal: f_bModal,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszSheetName, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uSheetIndex, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.bModal, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct OS(pub u32);
pub const OS_WINDOWS: OS = OS(0u32);
pub const OS_NT: OS = OS(1u32);
pub const OS_WIN95ORGREATER: OS = OS(2u32);
pub const OS_NT4ORGREATER: OS = OS(3u32);
pub const OS_WIN98ORGREATER: OS = OS(5u32);
pub const OS_WIN98_GOLD: OS = OS(6u32);
pub const OS_WIN2000ORGREATER: OS = OS(7u32);
pub const OS_WIN2000PRO: OS = OS(8u32);
pub const OS_WIN2000SERVER: OS = OS(9u32);
pub const OS_WIN2000ADVSERVER: OS = OS(10u32);
pub const OS_WIN2000DATACENTER: OS = OS(11u32);
pub const OS_WIN2000TERMINAL: OS = OS(12u32);
pub const OS_EMBEDDED: OS = OS(13u32);
pub const OS_TERMINALCLIENT: OS = OS(14u32);
pub const OS_TERMINALREMOTEADMIN: OS = OS(15u32);
pub const OS_WIN95_GOLD: OS = OS(16u32);
pub const OS_MEORGREATER: OS = OS(17u32);
pub const OS_XPORGREATER: OS = OS(18u32);
pub const OS_HOME: OS = OS(19u32);
pub const OS_PROFESSIONAL: OS = OS(20u32);
pub const OS_DATACENTER: OS = OS(21u32);
pub const OS_ADVSERVER: OS = OS(22u32);
pub const OS_SERVER: OS = OS(23u32);
pub const OS_TERMINALSERVER: OS = OS(24u32);
pub const OS_PERSONALTERMINALSERVER: OS = OS(25u32);
pub const OS_FASTUSERSWITCHING: OS = OS(26u32);
pub const OS_WELCOMELOGONUI: OS = OS(27u32);
pub const OS_DOMAINMEMBER: OS = OS(28u32);
pub const OS_ANYSERVER: OS = OS(29u32);
pub const OS_WOW6432: OS = OS(30u32);
pub const OS_WEBSERVER: OS = OS(31u32);
pub const OS_SMALLBUSINESSSERVER: OS = OS(32u32);
pub const OS_TABLETPC: OS = OS(33u32);
pub const OS_SERVERADMINUI: OS = OS(34u32);
pub const OS_MEDIACENTER: OS = OS(35u32);
pub const OS_APPLIANCE: OS = OS(36u32);
impl ::core::marker::Copy for OS {}
impl ::core::clone::Clone for OS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for OS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OS").field(&self.0).finish()
    }
}
impl FromIntoMemory for OS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct OfflineFolderStatus(pub i32);
pub const OFS_INACTIVE: OfflineFolderStatus = OfflineFolderStatus(-1i32);
pub const OFS_ONLINE: OfflineFolderStatus = OfflineFolderStatus(0i32);
pub const OFS_OFFLINE: OfflineFolderStatus = OfflineFolderStatus(1i32);
pub const OFS_SERVERBACK: OfflineFolderStatus = OfflineFolderStatus(2i32);
pub const OFS_DIRTYCACHE: OfflineFolderStatus = OfflineFolderStatus(3i32);
impl ::core::marker::Copy for OfflineFolderStatus {}
impl ::core::clone::Clone for OfflineFolderStatus {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OfflineFolderStatus {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for OfflineFolderStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OfflineFolderStatus").field(&self.0).finish()
    }
}
impl FromIntoMemory for OfflineFolderStatus {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const OnexCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x07aa0886_cc8d_4e19_a410_1c75af686e62);
pub const OnexPlapSmartcardCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x33c86cd6_705f_4ba1_9adb_67070b837775);
pub const OpenControlPanel: crate::core::GUID =
    crate::core::GUID::from_u128(0x06622d85_6856_4460_8de1_a81921b41c4b);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PACKAGE_EXECUTION_STATE(pub i32);
pub const PES_UNKNOWN: PACKAGE_EXECUTION_STATE = PACKAGE_EXECUTION_STATE(0i32);
pub const PES_RUNNING: PACKAGE_EXECUTION_STATE = PACKAGE_EXECUTION_STATE(1i32);
pub const PES_SUSPENDING: PACKAGE_EXECUTION_STATE = PACKAGE_EXECUTION_STATE(2i32);
pub const PES_SUSPENDED: PACKAGE_EXECUTION_STATE = PACKAGE_EXECUTION_STATE(3i32);
pub const PES_TERMINATED: PACKAGE_EXECUTION_STATE = PACKAGE_EXECUTION_STATE(4i32);
impl ::core::marker::Copy for PACKAGE_EXECUTION_STATE {}
impl ::core::clone::Clone for PACKAGE_EXECUTION_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PACKAGE_EXECUTION_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PACKAGE_EXECUTION_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PACKAGE_EXECUTION_STATE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for PACKAGE_EXECUTION_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const PANE_NAVIGATION: u32 = 5u32;
pub const PANE_NONE: u32 = 4294967295u32;
pub const PANE_OFFLINE: u32 = 2u32;
pub const PANE_PRINTER: u32 = 3u32;
pub const PANE_PRIVACY: u32 = 7u32;
pub const PANE_PROGRESS: u32 = 6u32;
pub const PANE_SSL: u32 = 4u32;
pub const PANE_ZONE: u32 = 1u32;
pub type PAPPCONSTRAIN_CHANGE_ROUTINE = StdCallFnPtr<
    (
        super::super::Foundation::BOOLEAN,
        ConstPtr<::core::ffi::c_void>,
    ),
    (),
>;
pub type PAPPSTATE_CHANGE_ROUTINE = StdCallFnPtr<
    (
        super::super::Foundation::BOOLEAN,
        ConstPtr<::core::ffi::c_void>,
    ),
    (),
>;
pub struct PARSEDURLA {
    pub cbSize: u32,
    pub pszProtocol: PCSTR,
    pub cchProtocol: u32,
    pub pszSuffix: PCSTR,
    pub cchSuffix: u32,
    pub nScheme: u32,
}
impl ::core::marker::Copy for PARSEDURLA {}
impl ::core::clone::Clone for PARSEDURLA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PARSEDURLA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PARSEDURLA")
            .field("cbSize", &self.cbSize)
            .field("pszProtocol", &self.pszProtocol)
            .field("cchProtocol", &self.cchProtocol)
            .field("pszSuffix", &self.pszSuffix)
            .field("cchSuffix", &self.cchSuffix)
            .field("nScheme", &self.nScheme)
            .finish()
    }
}
impl ::core::cmp::PartialEq for PARSEDURLA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.pszProtocol == other.pszProtocol
            && self.cchProtocol == other.cchProtocol
            && self.pszSuffix == other.pszSuffix
            && self.cchSuffix == other.cchSuffix
            && self.nScheme == other.nScheme
    }
}
impl ::core::cmp::Eq for PARSEDURLA {}
impl FromIntoMemory for PARSEDURLA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszProtocol = <PCSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cchProtocol = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszSuffix = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_cchSuffix = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_nScheme = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            cbSize: f_cbSize,
            pszProtocol: f_pszProtocol,
            cchProtocol: f_cchProtocol,
            pszSuffix: f_pszSuffix,
            cchSuffix: f_cchSuffix,
            nScheme: f_nScheme,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszProtocol, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cchProtocol, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszSuffix, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.cchSuffix, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.nScheme, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub struct PARSEDURLW {
    pub cbSize: u32,
    pub pszProtocol: PCWSTR,
    pub cchProtocol: u32,
    pub pszSuffix: PCWSTR,
    pub cchSuffix: u32,
    pub nScheme: u32,
}
impl ::core::marker::Copy for PARSEDURLW {}
impl ::core::clone::Clone for PARSEDURLW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PARSEDURLW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PARSEDURLW")
            .field("cbSize", &self.cbSize)
            .field("pszProtocol", &self.pszProtocol)
            .field("cchProtocol", &self.cchProtocol)
            .field("pszSuffix", &self.pszSuffix)
            .field("cchSuffix", &self.cchSuffix)
            .field("nScheme", &self.nScheme)
            .finish()
    }
}
impl ::core::cmp::PartialEq for PARSEDURLW {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.pszProtocol == other.pszProtocol
            && self.cchProtocol == other.cchProtocol
            && self.pszSuffix == other.pszSuffix
            && self.cchSuffix == other.cchSuffix
            && self.nScheme == other.nScheme
    }
}
impl ::core::cmp::Eq for PARSEDURLW {}
impl FromIntoMemory for PARSEDURLW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszProtocol = <PCWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cchProtocol = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszSuffix = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_cchSuffix = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_nScheme = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            cbSize: f_cbSize,
            pszProtocol: f_pszProtocol,
            cchProtocol: f_cchProtocol,
            pszSuffix: f_pszSuffix,
            cchSuffix: f_cchSuffix,
            nScheme: f_nScheme,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszProtocol, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cchProtocol, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszSuffix, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.cchSuffix, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.nScheme, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub const PATHCCH_MAX_CCH: u32 = 32768u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PATHCCH_OPTIONS(pub i32);
pub const PATHCCH_NONE: PATHCCH_OPTIONS = PATHCCH_OPTIONS(0i32);
pub const PATHCCH_ALLOW_LONG_PATHS: PATHCCH_OPTIONS = PATHCCH_OPTIONS(1i32);
pub const PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS: PATHCCH_OPTIONS = PATHCCH_OPTIONS(2i32);
pub const PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS: PATHCCH_OPTIONS = PATHCCH_OPTIONS(4i32);
pub const PATHCCH_DO_NOT_NORMALIZE_SEGMENTS: PATHCCH_OPTIONS = PATHCCH_OPTIONS(8i32);
pub const PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH: PATHCCH_OPTIONS = PATHCCH_OPTIONS(16i32);
pub const PATHCCH_ENSURE_TRAILING_SLASH: PATHCCH_OPTIONS = PATHCCH_OPTIONS(32i32);
pub const PATHCCH_CANONICALIZE_SLASHES: PATHCCH_OPTIONS = PATHCCH_OPTIONS(64i32);
impl ::core::marker::Copy for PATHCCH_OPTIONS {}
impl ::core::clone::Clone for PATHCCH_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PATHCCH_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PATHCCH_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PATHCCH_OPTIONS").field(&self.0).finish()
    }
}
impl FromIntoMemory for PATHCCH_OPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PCS_RET(pub u32);
pub const PCS_FATAL: PCS_RET = PCS_RET(2147483648u32);
pub const PCS_REPLACEDCHAR: PCS_RET = PCS_RET(1u32);
pub const PCS_REMOVEDCHAR: PCS_RET = PCS_RET(2u32);
pub const PCS_TRUNCATED: PCS_RET = PCS_RET(4u32);
pub const PCS_PATHTOOLONG: PCS_RET = PCS_RET(8u32);
impl ::core::marker::Copy for PCS_RET {}
impl ::core::clone::Clone for PCS_RET {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PCS_RET {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PCS_RET {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PCS_RET").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for PCS_RET {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for PCS_RET {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for PCS_RET {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for PCS_RET {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for PCS_RET {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for PCS_RET {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const PDTIMER_PAUSE: u32 = 2u32;
pub const PDTIMER_RESET: u32 = 1u32;
pub const PDTIMER_RESUME: u32 = 3u32;
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct PERSIST_FOLDER_TARGET_INFO {
    pub pidlTargetFolder: MutPtr<Common::ITEMIDLIST>,
    pub szTargetParsingName: [u16; 260],
    pub szNetworkProvider: [u16; 260],
    pub dwAttributes: u32,
    pub csidl: i32,
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for PERSIST_FOLDER_TARGET_INFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for PERSIST_FOLDER_TARGET_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for PERSIST_FOLDER_TARGET_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PERSIST_FOLDER_TARGET_INFO")
            .field("pidlTargetFolder", &self.pidlTargetFolder)
            .field("szTargetParsingName", &self.szTargetParsingName)
            .field("szNetworkProvider", &self.szNetworkProvider)
            .field("dwAttributes", &self.dwAttributes)
            .field("csidl", &self.csidl)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for PERSIST_FOLDER_TARGET_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.pidlTargetFolder == other.pidlTargetFolder
            && self.szTargetParsingName == other.szTargetParsingName
            && self.szNetworkProvider == other.szNetworkProvider
            && self.dwAttributes == other.dwAttributes
            && self.csidl == other.csidl
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for PERSIST_FOLDER_TARGET_INFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for PERSIST_FOLDER_TARGET_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 532);
        let f_pidlTargetFolder =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_szTargetParsingName = <[u16; 260] as FromIntoMemory>::from_bytes(&from[4..4 + 260]);
        let f_szNetworkProvider = <[u16; 260] as FromIntoMemory>::from_bytes(&from[264..264 + 260]);
        let f_dwAttributes = <u32 as FromIntoMemory>::from_bytes(&from[524..524 + 4]);
        let f_csidl = <i32 as FromIntoMemory>::from_bytes(&from[528..528 + 4]);
        Self {
            pidlTargetFolder: f_pidlTargetFolder,
            szTargetParsingName: f_szTargetParsingName,
            szNetworkProvider: f_szNetworkProvider,
            dwAttributes: f_dwAttributes,
            csidl: f_csidl,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 532);
        FromIntoMemory::into_bytes(self.pidlTargetFolder, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.szTargetParsingName, &mut into[4..4 + 260]);
        FromIntoMemory::into_bytes(self.szNetworkProvider, &mut into[264..264 + 260]);
        FromIntoMemory::into_bytes(self.dwAttributes, &mut into[524..524 + 4]);
        FromIntoMemory::into_bytes(self.csidl, &mut into[528..528 + 4]);
    }
    fn size() -> usize {
        532
    }
}
pub type PFNCANSHAREFOLDERW = StdCallFnPtr<(PCWSTR,), crate::core::HRESULT>;
pub type PFNSHOWSHAREFOLDERUIW =
    StdCallFnPtr<(super::super::Foundation::HWND, PCWSTR), crate::core::HRESULT>;
pub const PIDASI_AVG_DATA_RATE: u32 = 4u32;
pub const PIDASI_CHANNEL_COUNT: u32 = 7u32;
pub const PIDASI_COMPRESSION: u32 = 10u32;
pub const PIDASI_FORMAT: u32 = 2u32;
pub const PIDASI_SAMPLE_RATE: u32 = 5u32;
pub const PIDASI_SAMPLE_SIZE: u32 = 6u32;
pub const PIDASI_STREAM_NAME: u32 = 9u32;
pub const PIDASI_STREAM_NUMBER: u32 = 8u32;
pub const PIDASI_TIMELENGTH: u32 = 3u32;
pub const PIDDRSI_DESCRIPTION: u32 = 3u32;
pub const PIDDRSI_PLAYCOUNT: u32 = 4u32;
pub const PIDDRSI_PLAYEXPIRES: u32 = 6u32;
pub const PIDDRSI_PLAYSTARTS: u32 = 5u32;
pub const PIDDRSI_PROTECTED: u32 = 2u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PIDISF_FLAGS(pub i32);
pub const PIDISF_RECENTLYCHANGED: PIDISF_FLAGS = PIDISF_FLAGS(1i32);
pub const PIDISF_CACHEDSTICKY: PIDISF_FLAGS = PIDISF_FLAGS(2i32);
pub const PIDISF_CACHEIMAGES: PIDISF_FLAGS = PIDISF_FLAGS(16i32);
pub const PIDISF_FOLLOWALLLINKS: PIDISF_FLAGS = PIDISF_FLAGS(32i32);
impl ::core::marker::Copy for PIDISF_FLAGS {}
impl ::core::clone::Clone for PIDISF_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PIDISF_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PIDISF_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PIDISF_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for PIDISF_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for PIDISF_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for PIDISF_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for PIDISF_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for PIDISF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for PIDISF_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PIDISM_OPTIONS(pub i32);
pub const PIDISM_GLOBAL: PIDISM_OPTIONS = PIDISM_OPTIONS(0i32);
pub const PIDISM_WATCH: PIDISM_OPTIONS = PIDISM_OPTIONS(1i32);
pub const PIDISM_DONTWATCH: PIDISM_OPTIONS = PIDISM_OPTIONS(2i32);
impl ::core::marker::Copy for PIDISM_OPTIONS {}
impl ::core::clone::Clone for PIDISM_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PIDISM_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PIDISM_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PIDISM_OPTIONS").field(&self.0).finish()
    }
}
impl FromIntoMemory for PIDISM_OPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PIDISR_INFO(pub i32);
pub const PIDISR_UP_TO_DATE: PIDISR_INFO = PIDISR_INFO(0i32);
pub const PIDISR_NEEDS_ADD: PIDISR_INFO = PIDISR_INFO(1i32);
pub const PIDISR_NEEDS_UPDATE: PIDISR_INFO = PIDISR_INFO(2i32);
pub const PIDISR_NEEDS_DELETE: PIDISR_INFO = PIDISR_INFO(3i32);
impl ::core::marker::Copy for PIDISR_INFO {}
impl ::core::clone::Clone for PIDISR_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PIDISR_INFO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PIDISR_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PIDISR_INFO").field(&self.0).finish()
    }
}
impl FromIntoMemory for PIDISR_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const PIDSI_ALBUM: u32 = 4u32;
pub const PIDSI_ARTIST: u32 = 2u32;
pub const PIDSI_COMMENT: u32 = 6u32;
pub const PIDSI_GENRE: u32 = 11u32;
pub const PIDSI_LYRICS: u32 = 12u32;
pub const PIDSI_SONGTITLE: u32 = 3u32;
pub const PIDSI_TRACK: u32 = 7u32;
pub const PIDSI_YEAR: u32 = 5u32;
pub const PIDVSI_COMPRESSION: u32 = 10u32;
pub const PIDVSI_DATA_RATE: u32 = 8u32;
pub const PIDVSI_FRAME_COUNT: u32 = 5u32;
pub const PIDVSI_FRAME_HEIGHT: u32 = 4u32;
pub const PIDVSI_FRAME_RATE: u32 = 6u32;
pub const PIDVSI_FRAME_WIDTH: u32 = 3u32;
pub const PIDVSI_SAMPLE_SIZE: u32 = 9u32;
pub const PIDVSI_STREAM_NAME: u32 = 2u32;
pub const PIDVSI_STREAM_NUMBER: u32 = 11u32;
pub const PIDVSI_TIMELENGTH: u32 = 7u32;
pub const PID_COMPUTERNAME: u32 = 5u32;
pub const PID_CONTROLPANEL_CATEGORY: u32 = 2u32;
pub const PID_DESCRIPTIONID: u32 = 2u32;
pub const PID_DISPLACED_DATE: u32 = 3u32;
pub const PID_DISPLACED_FROM: u32 = 2u32;
pub const PID_DISPLAY_PROPERTIES: u32 = 0u32;
pub const PID_FINDDATA: u32 = 0u32;
pub const PID_HTMLINFOTIPFILE: u32 = 5u32;
pub const PID_INTROTEXT: u32 = 1u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PID_INTSITE(pub i32);
pub const PID_INTSITE_WHATSNEW: PID_INTSITE = PID_INTSITE(2i32);
pub const PID_INTSITE_AUTHOR: PID_INTSITE = PID_INTSITE(3i32);
pub const PID_INTSITE_LASTVISIT: PID_INTSITE = PID_INTSITE(4i32);
pub const PID_INTSITE_LASTMOD: PID_INTSITE = PID_INTSITE(5i32);
pub const PID_INTSITE_VISITCOUNT: PID_INTSITE = PID_INTSITE(6i32);
pub const PID_INTSITE_DESCRIPTION: PID_INTSITE = PID_INTSITE(7i32);
pub const PID_INTSITE_COMMENT: PID_INTSITE = PID_INTSITE(8i32);
pub const PID_INTSITE_FLAGS: PID_INTSITE = PID_INTSITE(9i32);
pub const PID_INTSITE_CONTENTLEN: PID_INTSITE = PID_INTSITE(10i32);
pub const PID_INTSITE_CONTENTCODE: PID_INTSITE = PID_INTSITE(11i32);
pub const PID_INTSITE_RECURSE: PID_INTSITE = PID_INTSITE(12i32);
pub const PID_INTSITE_WATCH: PID_INTSITE = PID_INTSITE(13i32);
pub const PID_INTSITE_SUBSCRIPTION: PID_INTSITE = PID_INTSITE(14i32);
pub const PID_INTSITE_URL: PID_INTSITE = PID_INTSITE(15i32);
pub const PID_INTSITE_TITLE: PID_INTSITE = PID_INTSITE(16i32);
pub const PID_INTSITE_CODEPAGE: PID_INTSITE = PID_INTSITE(18i32);
pub const PID_INTSITE_TRACKING: PID_INTSITE = PID_INTSITE(19i32);
pub const PID_INTSITE_ICONINDEX: PID_INTSITE = PID_INTSITE(20i32);
pub const PID_INTSITE_ICONFILE: PID_INTSITE = PID_INTSITE(21i32);
pub const PID_INTSITE_ROAMED: PID_INTSITE = PID_INTSITE(34i32);
impl ::core::marker::Copy for PID_INTSITE {}
impl ::core::clone::Clone for PID_INTSITE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PID_INTSITE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PID_INTSITE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PID_INTSITE").field(&self.0).finish()
    }
}
impl FromIntoMemory for PID_INTSITE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PID_IS(pub i32);
pub const PID_IS_URL: PID_IS = PID_IS(2i32);
pub const PID_IS_NAME: PID_IS = PID_IS(4i32);
pub const PID_IS_WORKINGDIR: PID_IS = PID_IS(5i32);
pub const PID_IS_HOTKEY: PID_IS = PID_IS(6i32);
pub const PID_IS_SHOWCMD: PID_IS = PID_IS(7i32);
pub const PID_IS_ICONINDEX: PID_IS = PID_IS(8i32);
pub const PID_IS_ICONFILE: PID_IS = PID_IS(9i32);
pub const PID_IS_WHATSNEW: PID_IS = PID_IS(10i32);
pub const PID_IS_AUTHOR: PID_IS = PID_IS(11i32);
pub const PID_IS_DESCRIPTION: PID_IS = PID_IS(12i32);
pub const PID_IS_COMMENT: PID_IS = PID_IS(13i32);
pub const PID_IS_ROAMED: PID_IS = PID_IS(15i32);
impl ::core::marker::Copy for PID_IS {}
impl ::core::clone::Clone for PID_IS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PID_IS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PID_IS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PID_IS").field(&self.0).finish()
    }
}
impl FromIntoMemory for PID_IS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const PID_LINK_TARGET: u32 = 2u32;
pub const PID_LINK_TARGET_TYPE: u32 = 3u32;
pub const PID_MISC_ACCESSCOUNT: u32 = 3u32;
pub const PID_MISC_OWNER: u32 = 4u32;
pub const PID_MISC_PICS: u32 = 6u32;
pub const PID_MISC_STATUS: u32 = 2u32;
pub const PID_NETRESOURCE: u32 = 1u32;
pub const PID_NETWORKLOCATION: u32 = 4u32;
pub const PID_QUERY_RANK: u32 = 2u32;
pub const PID_SHARE_CSC_STATUS: u32 = 2u32;
pub const PID_SYNC_COPY_IN: u32 = 2u32;
pub const PID_VOLUME_CAPACITY: u32 = 3u32;
pub const PID_VOLUME_FILESYSTEM: u32 = 4u32;
pub const PID_VOLUME_FREE: u32 = 2u32;
pub const PID_WHICHFOLDER: u32 = 3u32;
pub const PIFDEFFILESIZE: u32 = 80u32;
pub const PIFDEFPATHSIZE: u32 = 64u32;
pub const PIFMAXFILEPATH: u32 = 260u32;
pub const PIFNAMESIZE: u32 = 30u32;
pub const PIFPARAMSSIZE: u32 = 64u32;
pub const PIFSHDATASIZE: u32 = 64u32;
pub const PIFSHPROGSIZE: u32 = 64u32;
pub const PIFSTARTLOCSIZE: u32 = 63u32;
pub const PINLogonCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0xcb82ea12_9f71_446d_89e1_8d0924e1256e);
pub const PLATFORM_BROWSERONLY: u32 = 1u32;
pub const PLATFORM_IE3: u32 = 1u32;
pub const PLATFORM_INTEGRATED: u32 = 2u32;
pub const PLATFORM_UNKNOWN: u32 = 0u32;
pub const PMSF_DONT_STRIP_SPACES: u32 = 65536u32;
pub const PMSF_MULTIPLE: u32 = 1u32;
pub const PMSF_NORMAL: u32 = 0u32;
pub const PO_DELETE: u32 = 19u32;
pub const PO_PORTCHANGE: u32 = 32u32;
pub const PO_RENAME: u32 = 20u32;
pub const PO_REN_PORT: u32 = 52u32;
pub const PPCF_ADDARGUMENTS: u32 = 3u32;
pub const PPCF_ADDQUOTES: u32 = 1u32;
pub const PPCF_FORCEQUALIFY: u32 = 64u32;
pub const PPCF_LONGESTPOSSIBLE: u32 = 128u32;
pub const PPCF_NODIRECTORIES: u32 = 16u32;
pub struct PREVIEWHANDLERFRAMEINFO {
    pub haccel: super::WindowsAndMessaging::HACCEL,
    pub cAccelEntries: u32,
}
impl ::core::marker::Copy for PREVIEWHANDLERFRAMEINFO {}
impl ::core::clone::Clone for PREVIEWHANDLERFRAMEINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PREVIEWHANDLERFRAMEINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PREVIEWHANDLERFRAMEINFO")
            .field("haccel", &self.haccel)
            .field("cAccelEntries", &self.cAccelEntries)
            .finish()
    }
}
impl ::core::cmp::PartialEq for PREVIEWHANDLERFRAMEINFO {
    fn eq(&self, other: &Self) -> bool {
        self.haccel == other.haccel && self.cAccelEntries == other.cAccelEntries
    }
}
impl ::core::cmp::Eq for PREVIEWHANDLERFRAMEINFO {}
impl FromIntoMemory for PREVIEWHANDLERFRAMEINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_haccel =
            <super::WindowsAndMessaging::HACCEL as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_cAccelEntries = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            haccel: f_haccel,
            cAccelEntries: f_cAccelEntries,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.haccel, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.cAccelEntries, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PRF_FLAGS(pub i32);
pub const PRF_VERIFYEXISTS: PRF_FLAGS = PRF_FLAGS(1i32);
pub const PRF_TRYPROGRAMEXTENSIONS: PRF_FLAGS = PRF_FLAGS(3i32);
pub const PRF_FIRSTDIRDEF: PRF_FLAGS = PRF_FLAGS(4i32);
pub const PRF_DONTFINDLNK: PRF_FLAGS = PRF_FLAGS(8i32);
pub const PRF_REQUIREABSOLUTE: PRF_FLAGS = PRF_FLAGS(16i32);
impl ::core::marker::Copy for PRF_FLAGS {}
impl ::core::clone::Clone for PRF_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PRF_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PRF_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PRF_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for PRF_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for PRF_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for PRF_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for PRF_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for PRF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for PRF_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const PRINTACTION_DOCUMENTDEFAULTS: u32 = 6u32;
pub const PRINTACTION_NETINSTALL: u32 = 2u32;
pub const PRINTACTION_NETINSTALLLINK: u32 = 3u32;
pub const PRINTACTION_OPEN: u32 = 0u32;
pub const PRINTACTION_OPENNETPRN: u32 = 5u32;
pub const PRINTACTION_PROPERTIES: u32 = 1u32;
pub const PRINTACTION_SERVERPROPERTIES: u32 = 7u32;
pub const PRINTACTION_TESTPAGE: u32 = 4u32;
pub const PRINT_PROP_FORCE_NAME: u32 = 1u32;
pub struct PROFILEINFOA {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub lpUserName: PSTR,
    pub lpProfilePath: PSTR,
    pub lpDefaultPath: PSTR,
    pub lpServerName: PSTR,
    pub lpPolicyPath: PSTR,
    pub hProfile: super::super::Foundation::HANDLE,
}
impl ::core::marker::Copy for PROFILEINFOA {}
impl ::core::clone::Clone for PROFILEINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PROFILEINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PROFILEINFOA")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("lpUserName", &self.lpUserName)
            .field("lpProfilePath", &self.lpProfilePath)
            .field("lpDefaultPath", &self.lpDefaultPath)
            .field("lpServerName", &self.lpServerName)
            .field("lpPolicyPath", &self.lpPolicyPath)
            .field("hProfile", &self.hProfile)
            .finish()
    }
}
impl ::core::cmp::PartialEq for PROFILEINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.lpUserName == other.lpUserName
            && self.lpProfilePath == other.lpProfilePath
            && self.lpDefaultPath == other.lpDefaultPath
            && self.lpServerName == other.lpServerName
            && self.lpPolicyPath == other.lpPolicyPath
            && self.hProfile == other.hProfile
    }
}
impl ::core::cmp::Eq for PROFILEINFOA {}
impl FromIntoMemory for PROFILEINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpUserName = <PSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpProfilePath = <PSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpDefaultPath = <PSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpServerName = <PSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpPolicyPath = <PSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_hProfile =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            lpUserName: f_lpUserName,
            lpProfilePath: f_lpProfilePath,
            lpDefaultPath: f_lpDefaultPath,
            lpServerName: f_lpServerName,
            lpPolicyPath: f_lpPolicyPath,
            hProfile: f_hProfile,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpUserName, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpProfilePath, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpDefaultPath, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpServerName, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpPolicyPath, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.hProfile, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct PROFILEINFOW {
    pub dwSize: u32,
    pub dwFlags: u32,
    pub lpUserName: PWSTR,
    pub lpProfilePath: PWSTR,
    pub lpDefaultPath: PWSTR,
    pub lpServerName: PWSTR,
    pub lpPolicyPath: PWSTR,
    pub hProfile: super::super::Foundation::HANDLE,
}
impl ::core::marker::Copy for PROFILEINFOW {}
impl ::core::clone::Clone for PROFILEINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PROFILEINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PROFILEINFOW")
            .field("dwSize", &self.dwSize)
            .field("dwFlags", &self.dwFlags)
            .field("lpUserName", &self.lpUserName)
            .field("lpProfilePath", &self.lpProfilePath)
            .field("lpDefaultPath", &self.lpDefaultPath)
            .field("lpServerName", &self.lpServerName)
            .field("lpPolicyPath", &self.lpPolicyPath)
            .field("hProfile", &self.hProfile)
            .finish()
    }
}
impl ::core::cmp::PartialEq for PROFILEINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwFlags == other.dwFlags
            && self.lpUserName == other.lpUserName
            && self.lpProfilePath == other.lpProfilePath
            && self.lpDefaultPath == other.lpDefaultPath
            && self.lpServerName == other.lpServerName
            && self.lpPolicyPath == other.lpPolicyPath
            && self.hProfile == other.hProfile
    }
}
impl ::core::cmp::Eq for PROFILEINFOW {}
impl FromIntoMemory for PROFILEINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpUserName = <PWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpProfilePath = <PWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpDefaultPath = <PWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpServerName = <PWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpPolicyPath = <PWSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_hProfile =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            dwSize: f_dwSize,
            dwFlags: f_dwFlags,
            lpUserName: f_lpUserName,
            lpProfilePath: f_lpProfilePath,
            lpDefaultPath: f_lpDefaultPath,
            lpServerName: f_lpServerName,
            lpPolicyPath: f_lpPolicyPath,
            hProfile: f_hProfile,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpUserName, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpProfilePath, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpDefaultPath, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpServerName, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpPolicyPath, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.hProfile, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub const PROGDLG_AUTOTIME: u32 = 2u32;
pub const PROGDLG_MARQUEEPROGRESS: u32 = 32u32;
pub const PROGDLG_MODAL: u32 = 1u32;
pub const PROGDLG_NOCANCEL: u32 = 64u32;
pub const PROGDLG_NOMINIMIZE: u32 = 8u32;
pub const PROGDLG_NOPROGRESSBAR: u32 = 16u32;
pub const PROGDLG_NORMAL: u32 = 0u32;
pub const PROGDLG_NOTIME: u32 = 4u32;
pub const PROPSTR_EXTENSIONCOMPLETIONSTATE: &'static str = "ExtensionCompletionState";
pub const PROP_CONTRACT_DELEGATE: &'static str = "ContractDelegate";
pub struct PUBAPPINFO {
    pub cbSize: u32,
    pub dwMask: u32,
    pub pszSource: PWSTR,
    pub stAssigned: super::super::Foundation::SYSTEMTIME,
    pub stPublished: super::super::Foundation::SYSTEMTIME,
    pub stScheduled: super::super::Foundation::SYSTEMTIME,
    pub stExpire: super::super::Foundation::SYSTEMTIME,
}
impl ::core::marker::Copy for PUBAPPINFO {}
impl ::core::clone::Clone for PUBAPPINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PUBAPPINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PUBAPPINFO")
            .field("cbSize", &self.cbSize)
            .field("dwMask", &self.dwMask)
            .field("pszSource", &self.pszSource)
            .field("stAssigned", &self.stAssigned)
            .field("stPublished", &self.stPublished)
            .field("stScheduled", &self.stScheduled)
            .field("stExpire", &self.stExpire)
            .finish()
    }
}
impl ::core::cmp::PartialEq for PUBAPPINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwMask == other.dwMask
            && self.pszSource == other.pszSource
            && self.stAssigned == other.stAssigned
            && self.stPublished == other.stPublished
            && self.stScheduled == other.stScheduled
            && self.stExpire == other.stExpire
    }
}
impl ::core::cmp::Eq for PUBAPPINFO {}
impl FromIntoMemory for PUBAPPINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 76);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pszSource = <PWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_stAssigned = <super::super::Foundation::SYSTEMTIME as FromIntoMemory>::from_bytes(
            &from[12..12 + 16],
        );
        let f_stPublished = <super::super::Foundation::SYSTEMTIME as FromIntoMemory>::from_bytes(
            &from[28..28 + 16],
        );
        let f_stScheduled = <super::super::Foundation::SYSTEMTIME as FromIntoMemory>::from_bytes(
            &from[44..44 + 16],
        );
        let f_stExpire = <super::super::Foundation::SYSTEMTIME as FromIntoMemory>::from_bytes(
            &from[60..60 + 16],
        );
        Self {
            cbSize: f_cbSize,
            dwMask: f_dwMask,
            pszSource: f_pszSource,
            stAssigned: f_stAssigned,
            stPublished: f_stPublished,
            stScheduled: f_stScheduled,
            stExpire: f_stExpire,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 76);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pszSource, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.stAssigned, &mut into[12..12 + 16]);
        FromIntoMemory::into_bytes(self.stPublished, &mut into[28..28 + 16]);
        FromIntoMemory::into_bytes(self.stScheduled, &mut into[44..44 + 16]);
        FromIntoMemory::into_bytes(self.stExpire, &mut into[60..60 + 16]);
    }
    fn size() -> usize {
        76
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct PUBAPPINFOFLAGS(pub i32);
pub const PAI_SOURCE: PUBAPPINFOFLAGS = PUBAPPINFOFLAGS(1i32);
pub const PAI_ASSIGNEDTIME: PUBAPPINFOFLAGS = PUBAPPINFOFLAGS(2i32);
pub const PAI_PUBLISHEDTIME: PUBAPPINFOFLAGS = PUBAPPINFOFLAGS(4i32);
pub const PAI_SCHEDULEDTIME: PUBAPPINFOFLAGS = PUBAPPINFOFLAGS(8i32);
pub const PAI_EXPIRETIME: PUBAPPINFOFLAGS = PUBAPPINFOFLAGS(16i32);
impl ::core::marker::Copy for PUBAPPINFOFLAGS {}
impl ::core::clone::Clone for PUBAPPINFOFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PUBAPPINFOFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for PUBAPPINFOFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PUBAPPINFOFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for PUBAPPINFOFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const PackageDebugSettings: crate::core::GUID =
    crate::core::GUID::from_u128(0xb1aec16f_2383_4852_b0e9_8f0b1dc66b4d);
pub const PasswordCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x60b78e88_ead8_445c_9cfd_0b87f74ea6cd);
pub const PreviousVersions: crate::core::GUID =
    crate::core::GUID::from_u128(0x596ab062_b4d2_4215_9f74_e9109b0a8153);
pub const PropertiesUI: crate::core::GUID =
    crate::core::GUID::from_u128(0xd912f8cf_0396_4915_884e_fb425d32943b);
pub const PublishDropTarget: crate::core::GUID =
    crate::core::GUID::from_u128(0xcc6eeffb_43f6_46c5_9619_51d571967f7d);
pub const PublishingWizard: crate::core::GUID =
    crate::core::GUID::from_u128(0x6b33163c_76a5_4b6c_bf21_45de9cd503a1);
pub struct QCMINFO {
    pub hmenu: super::WindowsAndMessaging::HMENU,
    pub indexMenu: u32,
    pub idCmdFirst: u32,
    pub idCmdLast: u32,
    pub pIdMap: ConstPtr<QCMINFO_IDMAP>,
}
impl ::core::marker::Copy for QCMINFO {}
impl ::core::clone::Clone for QCMINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QCMINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QCMINFO")
            .field("hmenu", &self.hmenu)
            .field("indexMenu", &self.indexMenu)
            .field("idCmdFirst", &self.idCmdFirst)
            .field("idCmdLast", &self.idCmdLast)
            .field("pIdMap", &self.pIdMap)
            .finish()
    }
}
impl ::core::cmp::PartialEq for QCMINFO {
    fn eq(&self, other: &Self) -> bool {
        self.hmenu == other.hmenu
            && self.indexMenu == other.indexMenu
            && self.idCmdFirst == other.idCmdFirst
            && self.idCmdLast == other.idCmdLast
            && self.pIdMap == other.pIdMap
    }
}
impl ::core::cmp::Eq for QCMINFO {}
impl FromIntoMemory for QCMINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_hmenu =
            <super::WindowsAndMessaging::HMENU as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_indexMenu = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_idCmdFirst = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_idCmdLast = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pIdMap = <ConstPtr<QCMINFO_IDMAP> as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        Self {
            hmenu: f_hmenu,
            indexMenu: f_indexMenu,
            idCmdFirst: f_idCmdFirst,
            idCmdLast: f_idCmdLast,
            pIdMap: f_pIdMap,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.hmenu, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.indexMenu, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.idCmdFirst, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.idCmdLast, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pIdMap, &mut into[16..16 + 4]);
    }
    fn size() -> usize {
        20
    }
}
pub struct QCMINFO_IDMAP {
    pub nMaxIds: u32,
    pub pIdList: [QCMINFO_IDMAP_PLACEMENT; 1],
}
impl ::core::marker::Copy for QCMINFO_IDMAP {}
impl ::core::clone::Clone for QCMINFO_IDMAP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QCMINFO_IDMAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QCMINFO_IDMAP")
            .field("nMaxIds", &self.nMaxIds)
            .field("pIdList", &self.pIdList)
            .finish()
    }
}
impl ::core::cmp::PartialEq for QCMINFO_IDMAP {
    fn eq(&self, other: &Self) -> bool {
        self.nMaxIds == other.nMaxIds && self.pIdList == other.pIdList
    }
}
impl ::core::cmp::Eq for QCMINFO_IDMAP {}
impl FromIntoMemory for QCMINFO_IDMAP {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_nMaxIds = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pIdList =
            <[QCMINFO_IDMAP_PLACEMENT; 1] as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        Self {
            nMaxIds: f_nMaxIds,
            pIdList: f_pIdList,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.nMaxIds, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pIdList, &mut into[4..4 + 8]);
    }
    fn size() -> usize {
        12
    }
}
pub struct QCMINFO_IDMAP_PLACEMENT {
    pub id: u32,
    pub fFlags: u32,
}
impl ::core::marker::Copy for QCMINFO_IDMAP_PLACEMENT {}
impl ::core::clone::Clone for QCMINFO_IDMAP_PLACEMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QCMINFO_IDMAP_PLACEMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QCMINFO_IDMAP_PLACEMENT")
            .field("id", &self.id)
            .field("fFlags", &self.fFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for QCMINFO_IDMAP_PLACEMENT {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id && self.fFlags == other.fFlags
    }
}
impl ::core::cmp::Eq for QCMINFO_IDMAP_PLACEMENT {}
impl FromIntoMemory for QCMINFO_IDMAP_PLACEMENT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_id = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            id: f_id,
            fFlags: f_fFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.id, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fFlags, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub const QCMINFO_PLACE_AFTER: u32 = 1u32;
pub const QCMINFO_PLACE_BEFORE: u32 = 0u32;
pub struct QITAB {
    pub piid: ConstPtr<crate::core::GUID>,
    pub dwOffset: u32,
}
impl ::core::marker::Copy for QITAB {}
impl ::core::clone::Clone for QITAB {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QITAB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QITAB")
            .field("piid", &self.piid)
            .field("dwOffset", &self.dwOffset)
            .finish()
    }
}
impl ::core::cmp::PartialEq for QITAB {
    fn eq(&self, other: &Self) -> bool {
        self.piid == other.piid && self.dwOffset == other.dwOffset
    }
}
impl ::core::cmp::Eq for QITAB {}
impl FromIntoMemory for QITAB {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_piid = <ConstPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwOffset = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            piid: f_piid,
            dwOffset: f_dwOffset,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.piid, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwOffset, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct QITIPF_FLAGS(pub i32);
pub const QITIPF_DEFAULT: QITIPF_FLAGS = QITIPF_FLAGS(0i32);
pub const QITIPF_USENAME: QITIPF_FLAGS = QITIPF_FLAGS(1i32);
pub const QITIPF_LINKNOTARGET: QITIPF_FLAGS = QITIPF_FLAGS(2i32);
pub const QITIPF_LINKUSETARGET: QITIPF_FLAGS = QITIPF_FLAGS(4i32);
pub const QITIPF_USESLOWTIP: QITIPF_FLAGS = QITIPF_FLAGS(8i32);
pub const QITIPF_SINGLELINE: QITIPF_FLAGS = QITIPF_FLAGS(16i32);
pub const QIF_CACHED: QITIPF_FLAGS = QITIPF_FLAGS(1i32);
pub const QIF_DONTEXPANDFOLDER: QITIPF_FLAGS = QITIPF_FLAGS(2i32);
impl ::core::marker::Copy for QITIPF_FLAGS {}
impl ::core::clone::Clone for QITIPF_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for QITIPF_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for QITIPF_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("QITIPF_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for QITIPF_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for QITIPF_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for QITIPF_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for QITIPF_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for QITIPF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for QITIPF_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct QUERY_USER_NOTIFICATION_STATE(pub i32);
pub const QUNS_NOT_PRESENT: QUERY_USER_NOTIFICATION_STATE = QUERY_USER_NOTIFICATION_STATE(1i32);
pub const QUNS_BUSY: QUERY_USER_NOTIFICATION_STATE = QUERY_USER_NOTIFICATION_STATE(2i32);
pub const QUNS_RUNNING_D3D_FULL_SCREEN: QUERY_USER_NOTIFICATION_STATE =
    QUERY_USER_NOTIFICATION_STATE(3i32);
pub const QUNS_PRESENTATION_MODE: QUERY_USER_NOTIFICATION_STATE =
    QUERY_USER_NOTIFICATION_STATE(4i32);
pub const QUNS_ACCEPTS_NOTIFICATIONS: QUERY_USER_NOTIFICATION_STATE =
    QUERY_USER_NOTIFICATION_STATE(5i32);
pub const QUNS_QUIET_TIME: QUERY_USER_NOTIFICATION_STATE = QUERY_USER_NOTIFICATION_STATE(6i32);
pub const QUNS_APP: QUERY_USER_NOTIFICATION_STATE = QUERY_USER_NOTIFICATION_STATE(7i32);
impl ::core::marker::Copy for QUERY_USER_NOTIFICATION_STATE {}
impl ::core::clone::Clone for QUERY_USER_NOTIFICATION_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for QUERY_USER_NOTIFICATION_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for QUERY_USER_NOTIFICATION_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("QUERY_USER_NOTIFICATION_STATE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for QUERY_USER_NOTIFICATION_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const QueryCancelAutoPlay: crate::core::GUID =
    crate::core::GUID::from_u128(0x331f1768_05a9_4ddd_b86e_dae34ddc998a);
pub const RASProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x5537e283_b1e7_4ef8_9c6e_7ab0afe5056d);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct RESTRICTIONS(pub i32);
pub const REST_NONE: RESTRICTIONS = RESTRICTIONS(0i32);
pub const REST_NORUN: RESTRICTIONS = RESTRICTIONS(1i32);
pub const REST_NOCLOSE: RESTRICTIONS = RESTRICTIONS(2i32);
pub const REST_NOSAVESET: RESTRICTIONS = RESTRICTIONS(4i32);
pub const REST_NOFILEMENU: RESTRICTIONS = RESTRICTIONS(8i32);
pub const REST_NOSETFOLDERS: RESTRICTIONS = RESTRICTIONS(16i32);
pub const REST_NOSETTASKBAR: RESTRICTIONS = RESTRICTIONS(32i32);
pub const REST_NODESKTOP: RESTRICTIONS = RESTRICTIONS(64i32);
pub const REST_NOFIND: RESTRICTIONS = RESTRICTIONS(128i32);
pub const REST_NODRIVES: RESTRICTIONS = RESTRICTIONS(256i32);
pub const REST_NODRIVEAUTORUN: RESTRICTIONS = RESTRICTIONS(512i32);
pub const REST_NODRIVETYPEAUTORUN: RESTRICTIONS = RESTRICTIONS(1024i32);
pub const REST_NONETHOOD: RESTRICTIONS = RESTRICTIONS(2048i32);
pub const REST_STARTBANNER: RESTRICTIONS = RESTRICTIONS(4096i32);
pub const REST_RESTRICTRUN: RESTRICTIONS = RESTRICTIONS(8192i32);
pub const REST_NOPRINTERTABS: RESTRICTIONS = RESTRICTIONS(16384i32);
pub const REST_NOPRINTERDELETE: RESTRICTIONS = RESTRICTIONS(32768i32);
pub const REST_NOPRINTERADD: RESTRICTIONS = RESTRICTIONS(65536i32);
pub const REST_NOSTARTMENUSUBFOLDERS: RESTRICTIONS = RESTRICTIONS(131072i32);
pub const REST_MYDOCSONNET: RESTRICTIONS = RESTRICTIONS(262144i32);
pub const REST_NOEXITTODOS: RESTRICTIONS = RESTRICTIONS(524288i32);
pub const REST_ENFORCESHELLEXTSECURITY: RESTRICTIONS = RESTRICTIONS(1048576i32);
pub const REST_LINKRESOLVEIGNORELINKINFO: RESTRICTIONS = RESTRICTIONS(2097152i32);
pub const REST_NOCOMMONGROUPS: RESTRICTIONS = RESTRICTIONS(4194304i32);
pub const REST_SEPARATEDESKTOPPROCESS: RESTRICTIONS = RESTRICTIONS(8388608i32);
pub const REST_NOWEB: RESTRICTIONS = RESTRICTIONS(16777216i32);
pub const REST_NOTRAYCONTEXTMENU: RESTRICTIONS = RESTRICTIONS(33554432i32);
pub const REST_NOVIEWCONTEXTMENU: RESTRICTIONS = RESTRICTIONS(67108864i32);
pub const REST_NONETCONNECTDISCONNECT: RESTRICTIONS = RESTRICTIONS(134217728i32);
pub const REST_STARTMENULOGOFF: RESTRICTIONS = RESTRICTIONS(268435456i32);
pub const REST_NOSETTINGSASSIST: RESTRICTIONS = RESTRICTIONS(536870912i32);
pub const REST_NOINTERNETICON: RESTRICTIONS = RESTRICTIONS(1073741825i32);
pub const REST_NORECENTDOCSHISTORY: RESTRICTIONS = RESTRICTIONS(1073741826i32);
pub const REST_NORECENTDOCSMENU: RESTRICTIONS = RESTRICTIONS(1073741827i32);
pub const REST_NOACTIVEDESKTOP: RESTRICTIONS = RESTRICTIONS(1073741828i32);
pub const REST_NOACTIVEDESKTOPCHANGES: RESTRICTIONS = RESTRICTIONS(1073741829i32);
pub const REST_NOFAVORITESMENU: RESTRICTIONS = RESTRICTIONS(1073741830i32);
pub const REST_CLEARRECENTDOCSONEXIT: RESTRICTIONS = RESTRICTIONS(1073741831i32);
pub const REST_CLASSICSHELL: RESTRICTIONS = RESTRICTIONS(1073741832i32);
pub const REST_NOCUSTOMIZEWEBVIEW: RESTRICTIONS = RESTRICTIONS(1073741833i32);
pub const REST_NOHTMLWALLPAPER: RESTRICTIONS = RESTRICTIONS(1073741840i32);
pub const REST_NOCHANGINGWALLPAPER: RESTRICTIONS = RESTRICTIONS(1073741841i32);
pub const REST_NODESKCOMP: RESTRICTIONS = RESTRICTIONS(1073741842i32);
pub const REST_NOADDDESKCOMP: RESTRICTIONS = RESTRICTIONS(1073741843i32);
pub const REST_NODELDESKCOMP: RESTRICTIONS = RESTRICTIONS(1073741844i32);
pub const REST_NOCLOSEDESKCOMP: RESTRICTIONS = RESTRICTIONS(1073741845i32);
pub const REST_NOCLOSE_DRAGDROPBAND: RESTRICTIONS = RESTRICTIONS(1073741846i32);
pub const REST_NOMOVINGBAND: RESTRICTIONS = RESTRICTIONS(1073741847i32);
pub const REST_NOEDITDESKCOMP: RESTRICTIONS = RESTRICTIONS(1073741848i32);
pub const REST_NORESOLVESEARCH: RESTRICTIONS = RESTRICTIONS(1073741849i32);
pub const REST_NORESOLVETRACK: RESTRICTIONS = RESTRICTIONS(1073741850i32);
pub const REST_FORCECOPYACLWITHFILE: RESTRICTIONS = RESTRICTIONS(1073741851i32);
pub const REST_NOFORGETSOFTWAREUPDATE: RESTRICTIONS = RESTRICTIONS(1073741853i32);
pub const REST_NOSETACTIVEDESKTOP: RESTRICTIONS = RESTRICTIONS(1073741854i32);
pub const REST_NOUPDATEWINDOWS: RESTRICTIONS = RESTRICTIONS(1073741855i32);
pub const REST_NOCHANGESTARMENU: RESTRICTIONS = RESTRICTIONS(1073741856i32);
pub const REST_NOFOLDEROPTIONS: RESTRICTIONS = RESTRICTIONS(1073741857i32);
pub const REST_HASFINDCOMPUTERS: RESTRICTIONS = RESTRICTIONS(1073741858i32);
pub const REST_INTELLIMENUS: RESTRICTIONS = RESTRICTIONS(1073741859i32);
pub const REST_RUNDLGMEMCHECKBOX: RESTRICTIONS = RESTRICTIONS(1073741860i32);
pub const REST_ARP_ShowPostSetup: RESTRICTIONS = RESTRICTIONS(1073741861i32);
pub const REST_NOCSC: RESTRICTIONS = RESTRICTIONS(1073741862i32);
pub const REST_NOCONTROLPANEL: RESTRICTIONS = RESTRICTIONS(1073741863i32);
pub const REST_ENUMWORKGROUP: RESTRICTIONS = RESTRICTIONS(1073741864i32);
pub const REST_ARP_NOARP: RESTRICTIONS = RESTRICTIONS(1073741865i32);
pub const REST_ARP_NOREMOVEPAGE: RESTRICTIONS = RESTRICTIONS(1073741866i32);
pub const REST_ARP_NOADDPAGE: RESTRICTIONS = RESTRICTIONS(1073741867i32);
pub const REST_ARP_NOWINSETUPPAGE: RESTRICTIONS = RESTRICTIONS(1073741868i32);
pub const REST_GREYMSIADS: RESTRICTIONS = RESTRICTIONS(1073741869i32);
pub const REST_NOCHANGEMAPPEDDRIVELABEL: RESTRICTIONS = RESTRICTIONS(1073741870i32);
pub const REST_NOCHANGEMAPPEDDRIVECOMMENT: RESTRICTIONS = RESTRICTIONS(1073741871i32);
pub const REST_MaxRecentDocs: RESTRICTIONS = RESTRICTIONS(1073741872i32);
pub const REST_NONETWORKCONNECTIONS: RESTRICTIONS = RESTRICTIONS(1073741873i32);
pub const REST_FORCESTARTMENULOGOFF: RESTRICTIONS = RESTRICTIONS(1073741874i32);
pub const REST_NOWEBVIEW: RESTRICTIONS = RESTRICTIONS(1073741875i32);
pub const REST_NOCUSTOMIZETHISFOLDER: RESTRICTIONS = RESTRICTIONS(1073741876i32);
pub const REST_NOENCRYPTION: RESTRICTIONS = RESTRICTIONS(1073741877i32);
pub const REST_DONTSHOWSUPERHIDDEN: RESTRICTIONS = RESTRICTIONS(1073741879i32);
pub const REST_NOSHELLSEARCHBUTTON: RESTRICTIONS = RESTRICTIONS(1073741880i32);
pub const REST_NOHARDWARETAB: RESTRICTIONS = RESTRICTIONS(1073741881i32);
pub const REST_NORUNASINSTALLPROMPT: RESTRICTIONS = RESTRICTIONS(1073741882i32);
pub const REST_PROMPTRUNASINSTALLNETPATH: RESTRICTIONS = RESTRICTIONS(1073741883i32);
pub const REST_NOMANAGEMYCOMPUTERVERB: RESTRICTIONS = RESTRICTIONS(1073741884i32);
pub const REST_DISALLOWRUN: RESTRICTIONS = RESTRICTIONS(1073741886i32);
pub const REST_NOWELCOMESCREEN: RESTRICTIONS = RESTRICTIONS(1073741887i32);
pub const REST_RESTRICTCPL: RESTRICTIONS = RESTRICTIONS(1073741888i32);
pub const REST_DISALLOWCPL: RESTRICTIONS = RESTRICTIONS(1073741889i32);
pub const REST_NOSMBALLOONTIP: RESTRICTIONS = RESTRICTIONS(1073741890i32);
pub const REST_NOSMHELP: RESTRICTIONS = RESTRICTIONS(1073741891i32);
pub const REST_NOWINKEYS: RESTRICTIONS = RESTRICTIONS(1073741892i32);
pub const REST_NOENCRYPTONMOVE: RESTRICTIONS = RESTRICTIONS(1073741893i32);
pub const REST_NOLOCALMACHINERUN: RESTRICTIONS = RESTRICTIONS(1073741894i32);
pub const REST_NOCURRENTUSERRUN: RESTRICTIONS = RESTRICTIONS(1073741895i32);
pub const REST_NOLOCALMACHINERUNONCE: RESTRICTIONS = RESTRICTIONS(1073741896i32);
pub const REST_NOCURRENTUSERRUNONCE: RESTRICTIONS = RESTRICTIONS(1073741897i32);
pub const REST_FORCEACTIVEDESKTOPON: RESTRICTIONS = RESTRICTIONS(1073741898i32);
pub const REST_NOVIEWONDRIVE: RESTRICTIONS = RESTRICTIONS(1073741900i32);
pub const REST_NONETCRAWL: RESTRICTIONS = RESTRICTIONS(1073741901i32);
pub const REST_NOSHAREDDOCUMENTS: RESTRICTIONS = RESTRICTIONS(1073741902i32);
pub const REST_NOSMMYDOCS: RESTRICTIONS = RESTRICTIONS(1073741903i32);
pub const REST_NOSMMYPICS: RESTRICTIONS = RESTRICTIONS(1073741904i32);
pub const REST_ALLOWBITBUCKDRIVES: RESTRICTIONS = RESTRICTIONS(1073741905i32);
pub const REST_NONLEGACYSHELLMODE: RESTRICTIONS = RESTRICTIONS(1073741906i32);
pub const REST_NOCONTROLPANELBARRICADE: RESTRICTIONS = RESTRICTIONS(1073741907i32);
pub const REST_NOSTARTPAGE: RESTRICTIONS = RESTRICTIONS(1073741908i32);
pub const REST_NOAUTOTRAYNOTIFY: RESTRICTIONS = RESTRICTIONS(1073741909i32);
pub const REST_NOTASKGROUPING: RESTRICTIONS = RESTRICTIONS(1073741910i32);
pub const REST_NOCDBURNING: RESTRICTIONS = RESTRICTIONS(1073741911i32);
pub const REST_MYCOMPNOPROP: RESTRICTIONS = RESTRICTIONS(1073741912i32);
pub const REST_MYDOCSNOPROP: RESTRICTIONS = RESTRICTIONS(1073741913i32);
pub const REST_NOSTARTPANEL: RESTRICTIONS = RESTRICTIONS(1073741914i32);
pub const REST_NODISPLAYAPPEARANCEPAGE: RESTRICTIONS = RESTRICTIONS(1073741915i32);
pub const REST_NOTHEMESTAB: RESTRICTIONS = RESTRICTIONS(1073741916i32);
pub const REST_NOVISUALSTYLECHOICE: RESTRICTIONS = RESTRICTIONS(1073741917i32);
pub const REST_NOSIZECHOICE: RESTRICTIONS = RESTRICTIONS(1073741918i32);
pub const REST_NOCOLORCHOICE: RESTRICTIONS = RESTRICTIONS(1073741919i32);
pub const REST_SETVISUALSTYLE: RESTRICTIONS = RESTRICTIONS(1073741920i32);
pub const REST_STARTRUNNOHOMEPATH: RESTRICTIONS = RESTRICTIONS(1073741921i32);
pub const REST_NOUSERNAMEINSTARTPANEL: RESTRICTIONS = RESTRICTIONS(1073741922i32);
pub const REST_NOMYCOMPUTERICON: RESTRICTIONS = RESTRICTIONS(1073741923i32);
pub const REST_NOSMNETWORKPLACES: RESTRICTIONS = RESTRICTIONS(1073741924i32);
pub const REST_NOSMPINNEDLIST: RESTRICTIONS = RESTRICTIONS(1073741925i32);
pub const REST_NOSMMYMUSIC: RESTRICTIONS = RESTRICTIONS(1073741926i32);
pub const REST_NOSMEJECTPC: RESTRICTIONS = RESTRICTIONS(1073741927i32);
pub const REST_NOSMMOREPROGRAMS: RESTRICTIONS = RESTRICTIONS(1073741928i32);
pub const REST_NOSMMFUPROGRAMS: RESTRICTIONS = RESTRICTIONS(1073741929i32);
pub const REST_NOTRAYITEMSDISPLAY: RESTRICTIONS = RESTRICTIONS(1073741930i32);
pub const REST_NOTOOLBARSONTASKBAR: RESTRICTIONS = RESTRICTIONS(1073741931i32);
pub const REST_NOSMCONFIGUREPROGRAMS: RESTRICTIONS = RESTRICTIONS(1073741935i32);
pub const REST_HIDECLOCK: RESTRICTIONS = RESTRICTIONS(1073741936i32);
pub const REST_NOLOWDISKSPACECHECKS: RESTRICTIONS = RESTRICTIONS(1073741937i32);
pub const REST_NOENTIRENETWORK: RESTRICTIONS = RESTRICTIONS(1073741938i32);
pub const REST_NODESKTOPCLEANUP: RESTRICTIONS = RESTRICTIONS(1073741939i32);
pub const REST_BITBUCKNUKEONDELETE: RESTRICTIONS = RESTRICTIONS(1073741940i32);
pub const REST_BITBUCKCONFIRMDELETE: RESTRICTIONS = RESTRICTIONS(1073741941i32);
pub const REST_BITBUCKNOPROP: RESTRICTIONS = RESTRICTIONS(1073741942i32);
pub const REST_NODISPBACKGROUND: RESTRICTIONS = RESTRICTIONS(1073741943i32);
pub const REST_NODISPSCREENSAVEPG: RESTRICTIONS = RESTRICTIONS(1073741944i32);
pub const REST_NODISPSETTINGSPG: RESTRICTIONS = RESTRICTIONS(1073741945i32);
pub const REST_NODISPSCREENSAVEPREVIEW: RESTRICTIONS = RESTRICTIONS(1073741946i32);
pub const REST_NODISPLAYCPL: RESTRICTIONS = RESTRICTIONS(1073741947i32);
pub const REST_HIDERUNASVERB: RESTRICTIONS = RESTRICTIONS(1073741948i32);
pub const REST_NOTHUMBNAILCACHE: RESTRICTIONS = RESTRICTIONS(1073741949i32);
pub const REST_NOSTRCMPLOGICAL: RESTRICTIONS = RESTRICTIONS(1073741950i32);
pub const REST_NOPUBLISHWIZARD: RESTRICTIONS = RESTRICTIONS(1073741951i32);
pub const REST_NOONLINEPRINTSWIZARD: RESTRICTIONS = RESTRICTIONS(1073741952i32);
pub const REST_NOWEBSERVICES: RESTRICTIONS = RESTRICTIONS(1073741953i32);
pub const REST_ALLOWUNHASHEDWEBVIEW: RESTRICTIONS = RESTRICTIONS(1073741954i32);
pub const REST_ALLOWLEGACYWEBVIEW: RESTRICTIONS = RESTRICTIONS(1073741955i32);
pub const REST_REVERTWEBVIEWSECURITY: RESTRICTIONS = RESTRICTIONS(1073741956i32);
pub const REST_INHERITCONSOLEHANDLES: RESTRICTIONS = RESTRICTIONS(1073741958i32);
pub const REST_NOREMOTERECURSIVEEVENTS: RESTRICTIONS = RESTRICTIONS(1073741961i32);
pub const REST_NOREMOTECHANGENOTIFY: RESTRICTIONS = RESTRICTIONS(1073741969i32);
pub const REST_NOENUMENTIRENETWORK: RESTRICTIONS = RESTRICTIONS(1073741971i32);
pub const REST_NOINTERNETOPENWITH: RESTRICTIONS = RESTRICTIONS(1073741973i32);
pub const REST_DONTRETRYBADNETNAME: RESTRICTIONS = RESTRICTIONS(1073741979i32);
pub const REST_ALLOWFILECLSIDJUNCTIONS: RESTRICTIONS = RESTRICTIONS(1073741980i32);
pub const REST_NOUPNPINSTALL: RESTRICTIONS = RESTRICTIONS(1073741981i32);
pub const REST_ARP_DONTGROUPPATCHES: RESTRICTIONS = RESTRICTIONS(1073741996i32);
pub const REST_ARP_NOCHOOSEPROGRAMSPAGE: RESTRICTIONS = RESTRICTIONS(1073741997i32);
pub const REST_NODISCONNECT: RESTRICTIONS = RESTRICTIONS(1090519041i32);
pub const REST_NOSECURITY: RESTRICTIONS = RESTRICTIONS(1090519042i32);
pub const REST_NOFILEASSOCIATE: RESTRICTIONS = RESTRICTIONS(1090519043i32);
pub const REST_ALLOWCOMMENTTOGGLE: RESTRICTIONS = RESTRICTIONS(1090519044i32);
impl ::core::marker::Copy for RESTRICTIONS {}
impl ::core::clone::Clone for RESTRICTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for RESTRICTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for RESTRICTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("RESTRICTIONS").field(&self.0).finish()
    }
}
impl FromIntoMemory for RESTRICTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct RefreshConstants(pub i32);
pub const REFRESH_NORMAL: RefreshConstants = RefreshConstants(0i32);
pub const REFRESH_IFEXPIRED: RefreshConstants = RefreshConstants(1i32);
pub const REFRESH_COMPLETELY: RefreshConstants = RefreshConstants(3i32);
impl ::core::marker::Copy for RefreshConstants {}
impl ::core::clone::Clone for RefreshConstants {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for RefreshConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for RefreshConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("RefreshConstants").field(&self.0).finish()
    }
}
impl FromIntoMemory for RefreshConstants {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SBSP_ABSOLUTE: u32 = 0u32;
pub const SBSP_ACTIVATE_NOFOCUS: u32 = 524288u32;
pub const SBSP_ALLOW_AUTONAVIGATE: u32 = 65536u32;
pub const SBSP_CALLERUNTRUSTED: u32 = 8388608u32;
pub const SBSP_CREATENOHISTORY: u32 = 1048576u32;
pub const SBSP_DEFBROWSER: u32 = 0u32;
pub const SBSP_DEFMODE: u32 = 0u32;
pub const SBSP_EXPLOREMODE: u32 = 32u32;
pub const SBSP_FEEDNAVIGATION: u32 = 536870912u32;
pub const SBSP_HELPMODE: u32 = 64u32;
pub const SBSP_INITIATEDBYHLINKFRAME: u32 = 2147483648u32;
pub const SBSP_KEEPSAMETEMPLATE: u32 = 131072u32;
pub const SBSP_KEEPWORDWHEELTEXT: u32 = 262144u32;
pub const SBSP_NAVIGATEBACK: u32 = 16384u32;
pub const SBSP_NAVIGATEFORWARD: u32 = 32768u32;
pub const SBSP_NEWBROWSER: u32 = 2u32;
pub const SBSP_NOAUTOSELECT: u32 = 67108864u32;
pub const SBSP_NOTRANSFERHIST: u32 = 128u32;
pub const SBSP_OPENMODE: u32 = 16u32;
pub const SBSP_PARENT: u32 = 8192u32;
pub const SBSP_PLAYNOSOUND: u32 = 2097152u32;
pub const SBSP_REDIRECT: u32 = 1073741824u32;
pub const SBSP_RELATIVE: u32 = 4096u32;
pub const SBSP_SAMEBROWSER: u32 = 1u32;
pub const SBSP_TRUSTEDFORACTIVEX: u32 = 268435456u32;
pub const SBSP_TRUSTFIRSTDOWNLOAD: u32 = 16777216u32;
pub const SBSP_UNTRUSTEDFORDOWNLOAD: u32 = 33554432u32;
pub const SBSP_WRITENOHISTORY: u32 = 134217728u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SCALE_CHANGE_FLAGS(pub u32);
pub const SCF_VALUE_NONE: SCALE_CHANGE_FLAGS = SCALE_CHANGE_FLAGS(0u32);
pub const SCF_SCALE: SCALE_CHANGE_FLAGS = SCALE_CHANGE_FLAGS(1u32);
pub const SCF_PHYSICAL: SCALE_CHANGE_FLAGS = SCALE_CHANGE_FLAGS(2u32);
impl ::core::marker::Copy for SCALE_CHANGE_FLAGS {}
impl ::core::clone::Clone for SCALE_CHANGE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SCALE_CHANGE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SCALE_CHANGE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SCALE_CHANGE_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SCALE_CHANGE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SCALE_CHANGE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SCALE_CHANGE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SCALE_CHANGE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SCALE_CHANGE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SCALE_CHANGE_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SCHEME_CREATE: u32 = 128u32;
pub const SCHEME_DISPLAY: u32 = 1u32;
pub const SCHEME_DONOTUSE: u32 = 64u32;
pub const SCHEME_EDIT: u32 = 2u32;
pub const SCHEME_GLOBAL: u32 = 8u32;
pub const SCHEME_LOCAL: u32 = 4u32;
pub const SCHEME_REFRESH: u32 = 16u32;
pub const SCHEME_UPDATE: u32 = 32u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SCNRT_STATUS(pub i32);
pub const SCNRT_ENABLE: SCNRT_STATUS = SCNRT_STATUS(0i32);
pub const SCNRT_DISABLE: SCNRT_STATUS = SCNRT_STATUS(1i32);
impl ::core::marker::Copy for SCNRT_STATUS {}
impl ::core::clone::Clone for SCNRT_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SCNRT_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SCNRT_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SCNRT_STATUS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SCNRT_STATUS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SCRM_VERIFYPW: u32 = 32768u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SECURELOCKCODE(pub i32);
pub const SECURELOCK_NOCHANGE: SECURELOCKCODE = SECURELOCKCODE(-1i32);
pub const SECURELOCK_SET_UNSECURE: SECURELOCKCODE = SECURELOCKCODE(0i32);
pub const SECURELOCK_SET_MIXED: SECURELOCKCODE = SECURELOCKCODE(1i32);
pub const SECURELOCK_SET_SECUREUNKNOWNBIT: SECURELOCKCODE = SECURELOCKCODE(2i32);
pub const SECURELOCK_SET_SECURE40BIT: SECURELOCKCODE = SECURELOCKCODE(3i32);
pub const SECURELOCK_SET_SECURE56BIT: SECURELOCKCODE = SECURELOCKCODE(4i32);
pub const SECURELOCK_SET_FORTEZZA: SECURELOCKCODE = SECURELOCKCODE(5i32);
pub const SECURELOCK_SET_SECURE128BIT: SECURELOCKCODE = SECURELOCKCODE(6i32);
pub const SECURELOCK_FIRSTSUGGEST: SECURELOCKCODE = SECURELOCKCODE(7i32);
pub const SECURELOCK_SUGGEST_UNSECURE: SECURELOCKCODE = SECURELOCKCODE(7i32);
pub const SECURELOCK_SUGGEST_MIXED: SECURELOCKCODE = SECURELOCKCODE(8i32);
pub const SECURELOCK_SUGGEST_SECUREUNKNOWNBIT: SECURELOCKCODE = SECURELOCKCODE(9i32);
pub const SECURELOCK_SUGGEST_SECURE40BIT: SECURELOCKCODE = SECURELOCKCODE(10i32);
pub const SECURELOCK_SUGGEST_SECURE56BIT: SECURELOCKCODE = SECURELOCKCODE(11i32);
pub const SECURELOCK_SUGGEST_FORTEZZA: SECURELOCKCODE = SECURELOCKCODE(12i32);
pub const SECURELOCK_SUGGEST_SECURE128BIT: SECURELOCKCODE = SECURELOCKCODE(13i32);
impl ::core::marker::Copy for SECURELOCKCODE {}
impl ::core::clone::Clone for SECURELOCKCODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SECURELOCKCODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SECURELOCKCODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SECURELOCKCODE").field(&self.0).finish()
    }
}
impl FromIntoMemory for SECURELOCKCODE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SEE_MASK_ASYNCOK: u32 = 1048576u32;
pub const SEE_MASK_CLASSKEY: u32 = 3u32;
pub const SEE_MASK_CLASSNAME: u32 = 1u32;
pub const SEE_MASK_CONNECTNETDRV: u32 = 128u32;
pub const SEE_MASK_DEFAULT: u32 = 0u32;
pub const SEE_MASK_DOENVSUBST: u32 = 512u32;
pub const SEE_MASK_FLAG_DDEWAIT: u32 = 256u32;
pub const SEE_MASK_FLAG_HINST_IS_SITE: u32 = 134217728u32;
pub const SEE_MASK_FLAG_LOG_USAGE: u32 = 67108864u32;
pub const SEE_MASK_FLAG_NO_UI: u32 = 1024u32;
pub const SEE_MASK_HMONITOR: u32 = 2097152u32;
pub const SEE_MASK_HOTKEY: u32 = 32u32;
pub const SEE_MASK_ICON: u32 = 16u32;
pub const SEE_MASK_IDLIST: u32 = 4u32;
pub const SEE_MASK_INVOKEIDLIST: u32 = 12u32;
pub const SEE_MASK_NOASYNC: u32 = 256u32;
pub const SEE_MASK_NOCLOSEPROCESS: u32 = 64u32;
pub const SEE_MASK_NOQUERYCLASSSTORE: u32 = 16777216u32;
pub const SEE_MASK_NOZONECHECKS: u32 = 8388608u32;
pub const SEE_MASK_NO_CONSOLE: u32 = 32768u32;
pub const SEE_MASK_UNICODE: u32 = 16384u32;
pub const SEE_MASK_WAITFORINPUTIDLE: u32 = 33554432u32;
pub const SETPROPS_NONE: u32 = 0u32;
pub const SE_ERR_ACCESSDENIED: u32 = 5u32;
pub const SE_ERR_ASSOCINCOMPLETE: u32 = 27u32;
pub const SE_ERR_DDEBUSY: u32 = 30u32;
pub const SE_ERR_DDEFAIL: u32 = 29u32;
pub const SE_ERR_DDETIMEOUT: u32 = 28u32;
pub const SE_ERR_DLLNOTFOUND: u32 = 32u32;
pub const SE_ERR_FNF: u32 = 2u32;
pub const SE_ERR_NOASSOC: u32 = 31u32;
pub const SE_ERR_OOM: u32 = 8u32;
pub const SE_ERR_PNF: u32 = 3u32;
pub const SE_ERR_SHARE: u32 = 26u32;
pub const SFBID_PIDLCHANGED: i32 = 0i32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SFBS_FLAGS(pub i32);
pub const SFBS_FLAGS_ROUND_TO_NEAREST_DISPLAYED_DIGIT: SFBS_FLAGS = SFBS_FLAGS(1i32);
pub const SFBS_FLAGS_TRUNCATE_UNDISPLAYED_DECIMAL_DIGITS: SFBS_FLAGS = SFBS_FLAGS(2i32);
impl ::core::marker::Copy for SFBS_FLAGS {}
impl ::core::clone::Clone for SFBS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SFBS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SFBS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SFBS_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SFBS_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SFGAO_BROWSABLE: i32 = 134217728i32;
pub const SFGAO_CANCOPY: u32 = 1u32;
pub const SFGAO_CANDELETE: i32 = 32i32;
pub const SFGAO_CANLINK: u32 = 4u32;
pub const SFGAO_CANMONIKER: i32 = 4194304i32;
pub const SFGAO_CANMOVE: u32 = 2u32;
pub const SFGAO_CANRENAME: i32 = 16i32;
pub const SFGAO_CAPABILITYMASK: i32 = 375i32;
pub const SFGAO_COMPRESSED: i32 = 67108864i32;
pub const SFGAO_CONTENTSMASK: i32 = -2147483648i32;
pub const SFGAO_DISPLAYATTRMASK: i32 = 1032192i32;
pub const SFGAO_DROPTARGET: i32 = 256i32;
pub const SFGAO_ENCRYPTED: i32 = 8192i32;
pub const SFGAO_FILESYSANCESTOR: i32 = 268435456i32;
pub const SFGAO_FILESYSTEM: i32 = 1073741824i32;
pub const SFGAO_FOLDER: i32 = 536870912i32;
pub const SFGAO_GHOSTED: i32 = 32768i32;
pub const SFGAO_HASPROPSHEET: i32 = 64i32;
pub const SFGAO_HASSTORAGE: i32 = 4194304i32;
pub const SFGAO_HASSUBFOLDER: i32 = -2147483648i32;
pub const SFGAO_HIDDEN: i32 = 524288i32;
pub const SFGAO_ISSLOW: i32 = 16384i32;
pub const SFGAO_LINK: i32 = 65536i32;
pub const SFGAO_NEWCONTENT: i32 = 2097152i32;
pub const SFGAO_NONENUMERATED: i32 = 1048576i32;
pub const SFGAO_PKEYSFGAOMASK: i32 = -2130427904i32;
pub const SFGAO_PLACEHOLDER: i32 = 2048i32;
pub const SFGAO_READONLY: i32 = 262144i32;
pub const SFGAO_REMOVABLE: i32 = 33554432i32;
pub const SFGAO_SHARE: i32 = 131072i32;
pub const SFGAO_STORAGE: i32 = 8i32;
pub const SFGAO_STORAGEANCESTOR: i32 = 8388608i32;
pub const SFGAO_STORAGECAPMASK: i32 = 1891958792i32;
pub const SFGAO_STREAM: i32 = 4194304i32;
pub const SFGAO_SYSTEM: i32 = 4096i32;
pub const SFGAO_VALIDATE: i32 = 16777216i32;
pub const SFVM_ADDOBJECT: u32 = 3u32;
pub const SFVM_GETSELECTEDOBJECTS: u32 = 9u32;
pub struct SFVM_HELPTOPIC_DATA {
    pub wszHelpFile: [u16; 260],
    pub wszHelpTopic: [u16; 260],
}
impl ::core::marker::Copy for SFVM_HELPTOPIC_DATA {}
impl ::core::clone::Clone for SFVM_HELPTOPIC_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SFVM_HELPTOPIC_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SFVM_HELPTOPIC_DATA")
            .field("wszHelpFile", &self.wszHelpFile)
            .field("wszHelpTopic", &self.wszHelpTopic)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SFVM_HELPTOPIC_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.wszHelpFile == other.wszHelpFile && self.wszHelpTopic == other.wszHelpTopic
    }
}
impl ::core::cmp::Eq for SFVM_HELPTOPIC_DATA {}
impl FromIntoMemory for SFVM_HELPTOPIC_DATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 520);
        let f_wszHelpFile = <[u16; 260] as FromIntoMemory>::from_bytes(&from[0..0 + 260]);
        let f_wszHelpTopic = <[u16; 260] as FromIntoMemory>::from_bytes(&from[260..260 + 260]);
        Self {
            wszHelpFile: f_wszHelpFile,
            wszHelpTopic: f_wszHelpTopic,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 520);
        FromIntoMemory::into_bytes(self.wszHelpFile, &mut into[0..0 + 260]);
        FromIntoMemory::into_bytes(self.wszHelpTopic, &mut into[260..260 + 260]);
    }
    fn size() -> usize {
        520
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SFVM_MESSAGE_ID(pub i32);
pub const SFVM_MERGEMENU: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(1i32);
pub const SFVM_INVOKECOMMAND: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(2i32);
pub const SFVM_GETHELPTEXT: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(3i32);
pub const SFVM_GETTOOLTIPTEXT: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(4i32);
pub const SFVM_GETBUTTONINFO: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(5i32);
pub const SFVM_GETBUTTONS: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(6i32);
pub const SFVM_INITMENUPOPUP: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(7i32);
pub const SFVM_FSNOTIFY: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(14i32);
pub const SFVM_WINDOWCREATED: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(15i32);
pub const SFVM_GETDETAILSOF: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(23i32);
pub const SFVM_COLUMNCLICK: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(24i32);
pub const SFVM_QUERYFSNOTIFY: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(25i32);
pub const SFVM_DEFITEMCOUNT: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(26i32);
pub const SFVM_DEFVIEWMODE: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(27i32);
pub const SFVM_UNMERGEMENU: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(28i32);
pub const SFVM_UPDATESTATUSBAR: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(31i32);
pub const SFVM_BACKGROUNDENUM: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(32i32);
pub const SFVM_DIDDRAGDROP: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(36i32);
pub const SFVM_SETISFV: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(39i32);
pub const SFVM_THISIDLIST: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(41i32);
pub const SFVM_ADDPROPERTYPAGES: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(47i32);
pub const SFVM_BACKGROUNDENUMDONE: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(48i32);
pub const SFVM_GETNOTIFY: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(49i32);
pub const SFVM_GETSORTDEFAULTS: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(53i32);
pub const SFVM_SIZE: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(57i32);
pub const SFVM_GETZONE: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(58i32);
pub const SFVM_GETPANE: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(59i32);
pub const SFVM_GETHELPTOPIC: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(63i32);
pub const SFVM_GETANIMATION: SFVM_MESSAGE_ID = SFVM_MESSAGE_ID(68i32);
impl ::core::marker::Copy for SFVM_MESSAGE_ID {}
impl ::core::clone::Clone for SFVM_MESSAGE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SFVM_MESSAGE_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SFVM_MESSAGE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SFVM_MESSAGE_ID").field(&self.0).finish()
    }
}
impl FromIntoMemory for SFVM_MESSAGE_ID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SFVM_PROPPAGE_DATA {
    pub dwReserved: u32,
    pub pfn: super::Controls::LPFNSVADDPROPSHEETPAGE,
    pub lParam: super::super::Foundation::LPARAM,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SFVM_PROPPAGE_DATA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SFVM_PROPPAGE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SFVM_PROPPAGE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SFVM_PROPPAGE_DATA")
            .field("dwReserved", &self.dwReserved)
            .field("pfn", &self.pfn)
            .field("lParam", &self.lParam)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SFVM_PROPPAGE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwReserved == other.dwReserved && self.pfn == other.pfn && self.lParam == other.lParam
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SFVM_PROPPAGE_DATA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Controls'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SFVM_PROPPAGE_DATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pfn = <super::Controls::LPFNSVADDPROPSHEETPAGE as FromIntoMemory>::from_bytes(
            &from[4..4 + 4],
        );
        let f_lParam =
            <super::super::Foundation::LPARAM as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            dwReserved: f_dwReserved,
            pfn: f_pfn,
            lParam: f_lParam,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pfn, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lParam, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const SFVM_REARRANGE: u32 = 1u32;
pub const SFVM_REMOVEOBJECT: u32 = 6u32;
pub const SFVM_SETCLIPBOARD: u32 = 16u32;
pub const SFVM_SETITEMPOS: u32 = 14u32;
pub const SFVM_SETPOINTS: u32 = 23u32;
pub const SFVM_UPDATEOBJECT: u32 = 7u32;
pub const SFVSOC_INVALIDATE_ALL: u32 = 1u32;
pub const SFVSOC_NOSCROLL: u32 = 2u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SFVS_SELECT(pub i32);
pub const SFVS_SELECT_NONE: SFVS_SELECT = SFVS_SELECT(0i32);
pub const SFVS_SELECT_ALLITEMS: SFVS_SELECT = SFVS_SELECT(1i32);
pub const SFVS_SELECT_INVERT: SFVS_SELECT = SFVS_SELECT(2i32);
impl ::core::marker::Copy for SFVS_SELECT {}
impl ::core::clone::Clone for SFVS_SELECT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SFVS_SELECT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SFVS_SELECT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SFVS_SELECT").field(&self.0).finish()
    }
}
impl FromIntoMemory for SFVS_SELECT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SFV_CREATE {
    pub cbSize: u32,
    pub pshf: IShellFolder,
    pub psvOuter: IShellView,
    pub psfvcb: IShellFolderViewCB,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SFV_CREATE {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SFV_CREATE {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SFV_CREATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SFV_CREATE")
            .field("cbSize", &self.cbSize)
            .field("pshf", &self.pshf)
            .field("psvOuter", &self.psvOuter)
            .field("psfvcb", &self.psfvcb)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SFV_CREATE {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.pshf == other.pshf
            && self.psvOuter == other.psvOuter
            && self.psfvcb == other.psfvcb
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SFV_CREATE {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SFV_CREATE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pshf = <IShellFolder as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_psvOuter = <IShellView as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_psfvcb = <IShellFolderViewCB as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            cbSize: f_cbSize,
            pshf: f_pshf,
            psvOuter: f_psvOuter,
            psfvcb: f_psfvcb,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pshf, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.psvOuter, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.psfvcb, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SFV_SETITEMPOS {
    pub pidl: MutPtr<Common::ITEMIDLIST>,
    pub pt: super::super::Foundation::POINT,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SFV_SETITEMPOS {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SFV_SETITEMPOS {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SFV_SETITEMPOS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SFV_SETITEMPOS")
            .field("pidl", &self.pidl)
            .field("pt", &self.pt)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SFV_SETITEMPOS {
    fn eq(&self, other: &Self) -> bool {
        self.pidl == other.pidl && self.pt == other.pt
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SFV_SETITEMPOS {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SFV_SETITEMPOS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_pidl = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pt = <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        Self {
            pidl: f_pidl,
            pt: f_pt,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.pidl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pt, &mut into[4..4 + 8]);
    }
    fn size() -> usize {
        12
    }
}
pub const SHACF_AUTOAPPEND_FORCE_OFF: u32 = 2147483648u32;
pub const SHACF_AUTOAPPEND_FORCE_ON: u32 = 1073741824u32;
pub const SHACF_AUTOSUGGEST_FORCE_OFF: u32 = 536870912u32;
pub const SHACF_AUTOSUGGEST_FORCE_ON: u32 = 268435456u32;
pub const SHACF_DEFAULT: u32 = 0u32;
pub const SHACF_FILESYSTEM: u32 = 1u32;
pub const SHACF_FILESYS_DIRS: u32 = 32u32;
pub const SHACF_FILESYS_ONLY: u32 = 16u32;
pub const SHACF_URLHISTORY: u32 = 2u32;
pub const SHACF_URLMRU: u32 = 4u32;
pub const SHACF_USETAB: u32 = 8u32;
pub const SHACF_VIRTUAL_NAMESPACE: u32 = 64u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHARD(pub i32);
pub const SHARD_PIDL: SHARD = SHARD(1i32);
pub const SHARD_PATHA: SHARD = SHARD(2i32);
pub const SHARD_PATHW: SHARD = SHARD(3i32);
pub const SHARD_APPIDINFO: SHARD = SHARD(4i32);
pub const SHARD_APPIDINFOIDLIST: SHARD = SHARD(5i32);
pub const SHARD_LINK: SHARD = SHARD(6i32);
pub const SHARD_APPIDINFOLINK: SHARD = SHARD(7i32);
pub const SHARD_SHELLITEM: SHARD = SHARD(8i32);
impl ::core::marker::Copy for SHARD {}
impl ::core::clone::Clone for SHARD {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHARD {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHARD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHARD").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHARD {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHARDAPPIDINFO {
    pub psi: IShellItem,
    pub pszAppID: PCWSTR,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHARDAPPIDINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHARDAPPIDINFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHARDAPPIDINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHARDAPPIDINFO")
            .field("psi", &self.psi)
            .field("pszAppID", &self.pszAppID)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHARDAPPIDINFO {
    fn eq(&self, other: &Self) -> bool {
        self.psi == other.psi && self.pszAppID == other.pszAppID
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHARDAPPIDINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHARDAPPIDINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_psi = <IShellItem as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszAppID = <PCWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            psi: f_psi,
            pszAppID: f_pszAppID,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.psi, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszAppID, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHARDAPPIDINFOIDLIST {
    pub pidl: MutPtr<Common::ITEMIDLIST>,
    pub pszAppID: PCWSTR,
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHARDAPPIDINFOIDLIST {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHARDAPPIDINFOIDLIST {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHARDAPPIDINFOIDLIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHARDAPPIDINFOIDLIST")
            .field("pidl", &self.pidl)
            .field("pszAppID", &self.pszAppID)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHARDAPPIDINFOIDLIST {
    fn eq(&self, other: &Self) -> bool {
        self.pidl == other.pidl && self.pszAppID == other.pszAppID
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHARDAPPIDINFOIDLIST {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHARDAPPIDINFOIDLIST {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_pidl = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszAppID = <PCWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            pidl: f_pidl,
            pszAppID: f_pszAppID,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.pidl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszAppID, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHARDAPPIDINFOLINK {
    pub psl: IShellLinkA,
    pub pszAppID: PCWSTR,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHARDAPPIDINFOLINK {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHARDAPPIDINFOLINK {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHARDAPPIDINFOLINK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHARDAPPIDINFOLINK")
            .field("psl", &self.psl)
            .field("pszAppID", &self.pszAppID)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHARDAPPIDINFOLINK {
    fn eq(&self, other: &Self) -> bool {
        self.psl == other.psl && self.pszAppID == other.pszAppID
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHARDAPPIDINFOLINK {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Storage.FileSystem', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHARDAPPIDINFOLINK {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_psl = <IShellLinkA as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszAppID = <PCWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            psl: f_psl,
            pszAppID: f_pszAppID,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.psl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszAppID, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHARE_ROLE(pub i32);
pub const SHARE_ROLE_INVALID: SHARE_ROLE = SHARE_ROLE(-1i32);
pub const SHARE_ROLE_READER: SHARE_ROLE = SHARE_ROLE(0i32);
pub const SHARE_ROLE_CONTRIBUTOR: SHARE_ROLE = SHARE_ROLE(1i32);
pub const SHARE_ROLE_CO_OWNER: SHARE_ROLE = SHARE_ROLE(2i32);
pub const SHARE_ROLE_OWNER: SHARE_ROLE = SHARE_ROLE(3i32);
pub const SHARE_ROLE_CUSTOM: SHARE_ROLE = SHARE_ROLE(4i32);
pub const SHARE_ROLE_MIXED: SHARE_ROLE = SHARE_ROLE(5i32);
impl ::core::marker::Copy for SHARE_ROLE {}
impl ::core::clone::Clone for SHARE_ROLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHARE_ROLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHARE_ROLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHARE_ROLE").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHARE_ROLE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SHCDF_UPDATEITEM: u32 = 1u32;
pub const SHCIDS_ALLFIELDS: i32 = -2147483648i32;
pub const SHCIDS_BITMASK: i32 = -65536i32;
pub const SHCIDS_CANONICALONLY: i32 = 268435456i32;
pub const SHCIDS_COLUMNMASK: i32 = 65535i32;
pub const SHCNEE_MSI_CHANGE: i32 = 4i32;
pub const SHCNEE_MSI_UNINSTALL: i32 = 5i32;
pub const SHCNEE_ORDERCHANGED: i32 = 2i32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHCNE_ID(pub u32);
pub const SHCNE_RENAMEITEM: SHCNE_ID = SHCNE_ID(1u32);
pub const SHCNE_CREATE: SHCNE_ID = SHCNE_ID(2u32);
pub const SHCNE_DELETE: SHCNE_ID = SHCNE_ID(4u32);
pub const SHCNE_MKDIR: SHCNE_ID = SHCNE_ID(8u32);
pub const SHCNE_RMDIR: SHCNE_ID = SHCNE_ID(16u32);
pub const SHCNE_MEDIAINSERTED: SHCNE_ID = SHCNE_ID(32u32);
pub const SHCNE_MEDIAREMOVED: SHCNE_ID = SHCNE_ID(64u32);
pub const SHCNE_DRIVEREMOVED: SHCNE_ID = SHCNE_ID(128u32);
pub const SHCNE_DRIVEADD: SHCNE_ID = SHCNE_ID(256u32);
pub const SHCNE_NETSHARE: SHCNE_ID = SHCNE_ID(512u32);
pub const SHCNE_NETUNSHARE: SHCNE_ID = SHCNE_ID(1024u32);
pub const SHCNE_ATTRIBUTES: SHCNE_ID = SHCNE_ID(2048u32);
pub const SHCNE_UPDATEDIR: SHCNE_ID = SHCNE_ID(4096u32);
pub const SHCNE_UPDATEITEM: SHCNE_ID = SHCNE_ID(8192u32);
pub const SHCNE_SERVERDISCONNECT: SHCNE_ID = SHCNE_ID(16384u32);
pub const SHCNE_UPDATEIMAGE: SHCNE_ID = SHCNE_ID(32768u32);
pub const SHCNE_DRIVEADDGUI: SHCNE_ID = SHCNE_ID(65536u32);
pub const SHCNE_RENAMEFOLDER: SHCNE_ID = SHCNE_ID(131072u32);
pub const SHCNE_FREESPACE: SHCNE_ID = SHCNE_ID(262144u32);
pub const SHCNE_EXTENDED_EVENT: SHCNE_ID = SHCNE_ID(67108864u32);
pub const SHCNE_ASSOCCHANGED: SHCNE_ID = SHCNE_ID(134217728u32);
pub const SHCNE_DISKEVENTS: SHCNE_ID = SHCNE_ID(145439u32);
pub const SHCNE_GLOBALEVENTS: SHCNE_ID = SHCNE_ID(201687520u32);
pub const SHCNE_ALLEVENTS: SHCNE_ID = SHCNE_ID(2147483647u32);
pub const SHCNE_INTERRUPT: SHCNE_ID = SHCNE_ID(2147483648u32);
impl ::core::marker::Copy for SHCNE_ID {}
impl ::core::clone::Clone for SHCNE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHCNE_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHCNE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHCNE_ID").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SHCNE_ID {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SHCNE_ID {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SHCNE_ID {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SHCNE_ID {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SHCNE_ID {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SHCNE_ID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHCNF_FLAGS(pub u32);
pub const SHCNF_IDLIST: SHCNF_FLAGS = SHCNF_FLAGS(0u32);
pub const SHCNF_PATHA: SHCNF_FLAGS = SHCNF_FLAGS(1u32);
pub const SHCNF_PRINTERA: SHCNF_FLAGS = SHCNF_FLAGS(2u32);
pub const SHCNF_DWORD: SHCNF_FLAGS = SHCNF_FLAGS(3u32);
pub const SHCNF_PATHW: SHCNF_FLAGS = SHCNF_FLAGS(5u32);
pub const SHCNF_PRINTERW: SHCNF_FLAGS = SHCNF_FLAGS(6u32);
pub const SHCNF_TYPE: SHCNF_FLAGS = SHCNF_FLAGS(255u32);
pub const SHCNF_FLUSH: SHCNF_FLAGS = SHCNF_FLAGS(4096u32);
pub const SHCNF_FLUSHNOWAIT: SHCNF_FLAGS = SHCNF_FLAGS(12288u32);
pub const SHCNF_NOTIFYRECURSIVE: SHCNF_FLAGS = SHCNF_FLAGS(65536u32);
pub const SHCNF_PATH: SHCNF_FLAGS = SHCNF_FLAGS(5u32);
pub const SHCNF_PRINTER: SHCNF_FLAGS = SHCNF_FLAGS(6u32);
impl ::core::marker::Copy for SHCNF_FLAGS {}
impl ::core::clone::Clone for SHCNF_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHCNF_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHCNF_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHCNF_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SHCNF_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SHCNF_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SHCNF_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SHCNF_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SHCNF_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SHCNF_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHCNRF_SOURCE(pub i32);
pub const SHCNRF_InterruptLevel: SHCNRF_SOURCE = SHCNRF_SOURCE(1i32);
pub const SHCNRF_ShellLevel: SHCNRF_SOURCE = SHCNRF_SOURCE(2i32);
pub const SHCNRF_RecursiveInterrupt: SHCNRF_SOURCE = SHCNRF_SOURCE(4096i32);
pub const SHCNRF_NewDelivery: SHCNRF_SOURCE = SHCNRF_SOURCE(32768i32);
impl ::core::marker::Copy for SHCNRF_SOURCE {}
impl ::core::clone::Clone for SHCNRF_SOURCE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHCNRF_SOURCE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHCNRF_SOURCE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHCNRF_SOURCE").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SHCNRF_SOURCE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SHCNRF_SOURCE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SHCNRF_SOURCE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SHCNRF_SOURCE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SHCNRF_SOURCE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SHCNRF_SOURCE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct SHCOLUMNDATA {
    pub dwFlags: u32,
    pub dwFileAttributes: u32,
    pub dwReserved: u32,
    pub pwszExt: PWSTR,
    pub wszFile: [u16; 260],
}
impl ::core::marker::Copy for SHCOLUMNDATA {}
impl ::core::clone::Clone for SHCOLUMNDATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHCOLUMNDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHCOLUMNDATA")
            .field("dwFlags", &self.dwFlags)
            .field("dwFileAttributes", &self.dwFileAttributes)
            .field("dwReserved", &self.dwReserved)
            .field("pwszExt", &self.pwszExt)
            .field("wszFile", &self.wszFile)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHCOLUMNDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.dwFileAttributes == other.dwFileAttributes
            && self.dwReserved == other.dwReserved
            && self.pwszExt == other.pwszExt
            && self.wszFile == other.wszFile
    }
}
impl ::core::cmp::Eq for SHCOLUMNDATA {}
impl FromIntoMemory for SHCOLUMNDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 276);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFileAttributes = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pwszExt = <PWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_wszFile = <[u16; 260] as FromIntoMemory>::from_bytes(&from[16..16 + 260]);
        Self {
            dwFlags: f_dwFlags,
            dwFileAttributes: f_dwFileAttributes,
            dwReserved: f_dwReserved,
            pwszExt: f_pwszExt,
            wszFile: f_wszFile,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 276);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFileAttributes, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pwszExt, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.wszFile, &mut into[16..16 + 260]);
    }
    fn size() -> usize {
        276
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHCOLUMNINFO {
    pub scid: PropertiesSystem::PROPERTYKEY,
    pub vt: u16,
    pub fmt: u32,
    pub cChars: u32,
    pub csFlags: u32,
    pub wszTitle: [u16; 80],
    pub wszDescription: [u16; 128],
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHCOLUMNINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHCOLUMNINFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHCOLUMNINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHCOLUMNINFO")
            .field("scid", &self.scid)
            .field("vt", &self.vt)
            .field("fmt", &self.fmt)
            .field("cChars", &self.cChars)
            .field("csFlags", &self.csFlags)
            .field("wszTitle", &self.wszTitle)
            .field("wszDescription", &self.wszDescription)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHCOLUMNINFO {
    fn eq(&self, other: &Self) -> bool {
        self.scid == other.scid
            && self.vt == other.vt
            && self.fmt == other.fmt
            && self.cChars == other.cChars
            && self.csFlags == other.csFlags
            && self.wszTitle == other.wszTitle
            && self.wszDescription == other.wszDescription
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHCOLUMNINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHCOLUMNINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 242);
        let f_scid =
            <PropertiesSystem::PROPERTYKEY as FromIntoMemory>::from_bytes(&from[0..0 + 20]);
        let f_vt = <u16 as FromIntoMemory>::from_bytes(&from[20..20 + 2]);
        let f_fmt = <u32 as FromIntoMemory>::from_bytes(&from[22..22 + 4]);
        let f_cChars = <u32 as FromIntoMemory>::from_bytes(&from[26..26 + 4]);
        let f_csFlags = <u32 as FromIntoMemory>::from_bytes(&from[30..30 + 4]);
        let f_wszTitle = <[u16; 80] as FromIntoMemory>::from_bytes(&from[34..34 + 80]);
        let f_wszDescription = <[u16; 128] as FromIntoMemory>::from_bytes(&from[114..114 + 128]);
        Self {
            scid: f_scid,
            vt: f_vt,
            fmt: f_fmt,
            cChars: f_cChars,
            csFlags: f_csFlags,
            wszTitle: f_wszTitle,
            wszDescription: f_wszDescription,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 242);
        FromIntoMemory::into_bytes(self.scid, &mut into[0..0 + 20]);
        FromIntoMemory::into_bytes(self.vt, &mut into[20..20 + 2]);
        FromIntoMemory::into_bytes(self.fmt, &mut into[22..22 + 4]);
        FromIntoMemory::into_bytes(self.cChars, &mut into[26..26 + 4]);
        FromIntoMemory::into_bytes(self.csFlags, &mut into[30..30 + 4]);
        FromIntoMemory::into_bytes(self.wszTitle, &mut into[34..34 + 80]);
        FromIntoMemory::into_bytes(self.wszDescription, &mut into[114..114 + 128]);
    }
    fn size() -> usize {
        242
    }
}
pub struct SHCOLUMNINIT {
    pub dwFlags: u32,
    pub dwReserved: u32,
    pub wszFolder: [u16; 260],
}
impl ::core::marker::Copy for SHCOLUMNINIT {}
impl ::core::clone::Clone for SHCOLUMNINIT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHCOLUMNINIT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHCOLUMNINIT")
            .field("dwFlags", &self.dwFlags)
            .field("dwReserved", &self.dwReserved)
            .field("wszFolder", &self.wszFolder)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHCOLUMNINIT {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags
            && self.dwReserved == other.dwReserved
            && self.wszFolder == other.wszFolder
    }
}
impl ::core::cmp::Eq for SHCOLUMNINIT {}
impl FromIntoMemory for SHCOLUMNINIT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 268);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwReserved = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_wszFolder = <[u16; 260] as FromIntoMemory>::from_bytes(&from[8..8 + 260]);
        Self {
            dwFlags: f_dwFlags,
            dwReserved: f_dwReserved,
            wszFolder: f_wszFolder,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 268);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwReserved, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.wszFolder, &mut into[8..8 + 260]);
    }
    fn size() -> usize {
        268
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Security', 'Windows.Win32.System.Threading'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHCREATEPROCESSINFOW {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub pszFile: PCWSTR,
    pub pszParameters: PCWSTR,
    pub pszCurrentDirectory: PCWSTR,
    pub hUserToken: super::super::Foundation::HANDLE,
    pub lpProcessAttributes: MutPtr<super::super::Security::SECURITY_ATTRIBUTES>,
    pub lpThreadAttributes: MutPtr<super::super::Security::SECURITY_ATTRIBUTES>,
    pub bInheritHandles: super::super::Foundation::BOOL,
    pub dwCreationFlags: u32,
    pub lpStartupInfo: MutPtr<super::super::System::Threading::STARTUPINFOW>,
    pub lpProcessInformation: MutPtr<super::super::System::Threading::PROCESS_INFORMATION>,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Security', 'Windows.Win32.System.Threading'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHCREATEPROCESSINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Security', 'Windows.Win32.System.Threading'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHCREATEPROCESSINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Security', 'Windows.Win32.System.Threading'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHCREATEPROCESSINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHCREATEPROCESSINFOW")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("pszFile", &self.pszFile)
            .field("pszParameters", &self.pszParameters)
            .field("pszCurrentDirectory", &self.pszCurrentDirectory)
            .field("hUserToken", &self.hUserToken)
            .field("lpProcessAttributes", &self.lpProcessAttributes)
            .field("lpThreadAttributes", &self.lpThreadAttributes)
            .field("bInheritHandles", &self.bInheritHandles)
            .field("dwCreationFlags", &self.dwCreationFlags)
            .field("lpStartupInfo", &self.lpStartupInfo)
            .field("lpProcessInformation", &self.lpProcessInformation)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Security', 'Windows.Win32.System.Threading'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHCREATEPROCESSINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.pszFile == other.pszFile
            && self.pszParameters == other.pszParameters
            && self.pszCurrentDirectory == other.pszCurrentDirectory
            && self.hUserToken == other.hUserToken
            && self.lpProcessAttributes == other.lpProcessAttributes
            && self.lpThreadAttributes == other.lpThreadAttributes
            && self.bInheritHandles == other.bInheritHandles
            && self.dwCreationFlags == other.dwCreationFlags
            && self.lpStartupInfo == other.lpStartupInfo
            && self.lpProcessInformation == other.lpProcessInformation
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Security', 'Windows.Win32.System.Threading'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHCREATEPROCESSINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Security', 'Windows.Win32.System.Threading'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHCREATEPROCESSINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 52);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszFile = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pszParameters = <PCWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pszCurrentDirectory = <PCWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_hUserToken =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpProcessAttributes =
            <MutPtr<super::super::Security::SECURITY_ATTRIBUTES> as FromIntoMemory>::from_bytes(
                &from[28..28 + 4],
            );
        let f_lpThreadAttributes =
            <MutPtr<super::super::Security::SECURITY_ATTRIBUTES> as FromIntoMemory>::from_bytes(
                &from[32..32 + 4],
            );
        let f_bInheritHandles =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwCreationFlags = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpStartupInfo =
            <MutPtr<super::super::System::Threading::STARTUPINFOW> as FromIntoMemory>::from_bytes(
                &from[44..44 + 4],
            );
        let f_lpProcessInformation = < MutPtr < super::super::System::Threading:: PROCESS_INFORMATION > as FromIntoMemory > :: from_bytes ( & from [ 48 .. 48 + 4 ] ) ;
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            pszFile: f_pszFile,
            pszParameters: f_pszParameters,
            pszCurrentDirectory: f_pszCurrentDirectory,
            hUserToken: f_hUserToken,
            lpProcessAttributes: f_lpProcessAttributes,
            lpThreadAttributes: f_lpThreadAttributes,
            bInheritHandles: f_bInheritHandles,
            dwCreationFlags: f_dwCreationFlags,
            lpStartupInfo: f_lpStartupInfo,
            lpProcessInformation: f_lpProcessInformation,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 52);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszFile, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pszParameters, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pszCurrentDirectory, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.hUserToken, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpProcessAttributes, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpThreadAttributes, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.bInheritHandles, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwCreationFlags, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpStartupInfo, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.lpProcessInformation, &mut into[48..48 + 4]);
    }
    fn size() -> usize {
        52
    }
}
pub struct SHCREATEPROCESSINFOW {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub pszFile: PCWSTR,
    pub pszParameters: PCWSTR,
    pub pszCurrentDirectory: PCWSTR,
    pub hUserToken: super::super::Foundation::HANDLE,
    pub lpProcessAttributes: MutPtr<super::super::Security::SECURITY_ATTRIBUTES>,
    pub lpThreadAttributes: MutPtr<super::super::Security::SECURITY_ATTRIBUTES>,
    pub bInheritHandles: super::super::Foundation::BOOL,
    pub dwCreationFlags: u32,
    pub lpStartupInfo: MutPtr<super::super::System::Threading::STARTUPINFOW>,
    pub lpProcessInformation: MutPtr<super::super::System::Threading::PROCESS_INFORMATION>,
}
impl ::core::marker::Copy for SHCREATEPROCESSINFOW {}
impl ::core::clone::Clone for SHCREATEPROCESSINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHCREATEPROCESSINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHCREATEPROCESSINFOW")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("pszFile", &self.pszFile)
            .field("pszParameters", &self.pszParameters)
            .field("pszCurrentDirectory", &self.pszCurrentDirectory)
            .field("hUserToken", &self.hUserToken)
            .field("lpProcessAttributes", &self.lpProcessAttributes)
            .field("lpThreadAttributes", &self.lpThreadAttributes)
            .field("bInheritHandles", &self.bInheritHandles)
            .field("dwCreationFlags", &self.dwCreationFlags)
            .field("lpStartupInfo", &self.lpStartupInfo)
            .field("lpProcessInformation", &self.lpProcessInformation)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHCREATEPROCESSINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.pszFile == other.pszFile
            && self.pszParameters == other.pszParameters
            && self.pszCurrentDirectory == other.pszCurrentDirectory
            && self.hUserToken == other.hUserToken
            && self.lpProcessAttributes == other.lpProcessAttributes
            && self.lpThreadAttributes == other.lpThreadAttributes
            && self.bInheritHandles == other.bInheritHandles
            && self.dwCreationFlags == other.dwCreationFlags
            && self.lpStartupInfo == other.lpStartupInfo
            && self.lpProcessInformation == other.lpProcessInformation
    }
}
impl ::core::cmp::Eq for SHCREATEPROCESSINFOW {}
impl FromIntoMemory for SHCREATEPROCESSINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 52);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszFile = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_pszParameters = <PCWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pszCurrentDirectory = <PCWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_hUserToken =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpProcessAttributes =
            <MutPtr<super::super::Security::SECURITY_ATTRIBUTES> as FromIntoMemory>::from_bytes(
                &from[28..28 + 4],
            );
        let f_lpThreadAttributes =
            <MutPtr<super::super::Security::SECURITY_ATTRIBUTES> as FromIntoMemory>::from_bytes(
                &from[32..32 + 4],
            );
        let f_bInheritHandles =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_dwCreationFlags = <u32 as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_lpStartupInfo =
            <MutPtr<super::super::System::Threading::STARTUPINFOW> as FromIntoMemory>::from_bytes(
                &from[44..44 + 4],
            );
        let f_lpProcessInformation = < MutPtr < super::super::System::Threading:: PROCESS_INFORMATION > as FromIntoMemory > :: from_bytes ( & from [ 48 .. 48 + 4 ] ) ;
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            pszFile: f_pszFile,
            pszParameters: f_pszParameters,
            pszCurrentDirectory: f_pszCurrentDirectory,
            hUserToken: f_hUserToken,
            lpProcessAttributes: f_lpProcessAttributes,
            lpThreadAttributes: f_lpThreadAttributes,
            bInheritHandles: f_bInheritHandles,
            dwCreationFlags: f_dwCreationFlags,
            lpStartupInfo: f_lpStartupInfo,
            lpProcessInformation: f_lpProcessInformation,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 52);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszFile, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.pszParameters, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pszCurrentDirectory, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.hUserToken, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpProcessAttributes, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.lpThreadAttributes, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.bInheritHandles, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.dwCreationFlags, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.lpStartupInfo, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.lpProcessInformation, &mut into[48..48 + 4]);
    }
    fn size() -> usize {
        52
    }
}
pub const SHC_E_SHELL_COMPONENT_STARTUP_FAILURE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927180i32);
pub struct SHChangeDWORDAsIDList {
    pub cb: u16,
    pub dwItem1: u32,
    pub dwItem2: u32,
    pub cbZero: u16,
}
impl ::core::marker::Copy for SHChangeDWORDAsIDList {}
impl ::core::clone::Clone for SHChangeDWORDAsIDList {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHChangeDWORDAsIDList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHChangeDWORDAsIDList")
            .field("cb", &self.cb)
            .field("dwItem1", &self.dwItem1)
            .field("dwItem2", &self.dwItem2)
            .field("cbZero", &self.cbZero)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHChangeDWORDAsIDList {
    fn eq(&self, other: &Self) -> bool {
        self.cb == other.cb
            && self.dwItem1 == other.dwItem1
            && self.dwItem2 == other.dwItem2
            && self.cbZero == other.cbZero
    }
}
impl ::core::cmp::Eq for SHChangeDWORDAsIDList {}
impl FromIntoMemory for SHChangeDWORDAsIDList {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_cb = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_dwItem1 = <u32 as FromIntoMemory>::from_bytes(&from[2..2 + 4]);
        let f_dwItem2 = <u32 as FromIntoMemory>::from_bytes(&from[6..6 + 4]);
        let f_cbZero = <u16 as FromIntoMemory>::from_bytes(&from[10..10 + 2]);
        Self {
            cb: f_cb,
            dwItem1: f_dwItem1,
            dwItem2: f_dwItem2,
            cbZero: f_cbZero,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.cb, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.dwItem1, &mut into[2..2 + 4]);
        FromIntoMemory::into_bytes(self.dwItem2, &mut into[6..6 + 4]);
        FromIntoMemory::into_bytes(self.cbZero, &mut into[10..10 + 2]);
    }
    fn size() -> usize {
        12
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHChangeNotifyEntry {
    pub pidl: MutPtr<Common::ITEMIDLIST>,
    pub fRecursive: super::super::Foundation::BOOL,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHChangeNotifyEntry {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHChangeNotifyEntry {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHChangeNotifyEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHChangeNotifyEntry")
            .field("pidl", &self.pidl)
            .field("fRecursive", &self.fRecursive)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHChangeNotifyEntry {
    fn eq(&self, other: &Self) -> bool {
        self.pidl == other.pidl && self.fRecursive == other.fRecursive
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHChangeNotifyEntry {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHChangeNotifyEntry {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_pidl = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fRecursive =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            pidl: f_pidl,
            fRecursive: f_fRecursive,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.pidl, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fRecursive, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
pub struct SHChangeProductKeyAsIDList {
    pub cb: u16,
    pub wszProductKey: [u16; 39],
    pub cbZero: u16,
}
impl ::core::marker::Copy for SHChangeProductKeyAsIDList {}
impl ::core::clone::Clone for SHChangeProductKeyAsIDList {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHChangeProductKeyAsIDList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHChangeProductKeyAsIDList")
            .field("cb", &self.cb)
            .field("wszProductKey", &self.wszProductKey)
            .field("cbZero", &self.cbZero)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHChangeProductKeyAsIDList {
    fn eq(&self, other: &Self) -> bool {
        self.cb == other.cb
            && self.wszProductKey == other.wszProductKey
            && self.cbZero == other.cbZero
    }
}
impl ::core::cmp::Eq for SHChangeProductKeyAsIDList {}
impl FromIntoMemory for SHChangeProductKeyAsIDList {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 43);
        let f_cb = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_wszProductKey = <[u16; 39] as FromIntoMemory>::from_bytes(&from[2..2 + 39]);
        let f_cbZero = <u16 as FromIntoMemory>::from_bytes(&from[41..41 + 2]);
        Self {
            cb: f_cb,
            wszProductKey: f_wszProductKey,
            cbZero: f_cbZero,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 43);
        FromIntoMemory::into_bytes(self.cb, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.wszProductKey, &mut into[2..2 + 39]);
        FromIntoMemory::into_bytes(self.cbZero, &mut into[41..41 + 2]);
    }
    fn size() -> usize {
        43
    }
}
pub struct SHChangeUpdateImageIDList {
    pub cb: u16,
    pub iIconIndex: i32,
    pub iCurIndex: i32,
    pub uFlags: u32,
    pub dwProcessID: u32,
    pub szName: [u16; 260],
    pub cbZero: u16,
}
impl ::core::marker::Copy for SHChangeUpdateImageIDList {}
impl ::core::clone::Clone for SHChangeUpdateImageIDList {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHChangeUpdateImageIDList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHChangeUpdateImageIDList")
            .field("cb", &self.cb)
            .field("iIconIndex", &self.iIconIndex)
            .field("iCurIndex", &self.iCurIndex)
            .field("uFlags", &self.uFlags)
            .field("dwProcessID", &self.dwProcessID)
            .field("szName", &self.szName)
            .field("cbZero", &self.cbZero)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHChangeUpdateImageIDList {
    fn eq(&self, other: &Self) -> bool {
        self.cb == other.cb
            && self.iIconIndex == other.iIconIndex
            && self.iCurIndex == other.iCurIndex
            && self.uFlags == other.uFlags
            && self.dwProcessID == other.dwProcessID
            && self.szName == other.szName
            && self.cbZero == other.cbZero
    }
}
impl ::core::cmp::Eq for SHChangeUpdateImageIDList {}
impl FromIntoMemory for SHChangeUpdateImageIDList {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 280);
        let f_cb = <u16 as FromIntoMemory>::from_bytes(&from[0..0 + 2]);
        let f_iIconIndex = <i32 as FromIntoMemory>::from_bytes(&from[2..2 + 4]);
        let f_iCurIndex = <i32 as FromIntoMemory>::from_bytes(&from[6..6 + 4]);
        let f_uFlags = <u32 as FromIntoMemory>::from_bytes(&from[10..10 + 4]);
        let f_dwProcessID = <u32 as FromIntoMemory>::from_bytes(&from[14..14 + 4]);
        let f_szName = <[u16; 260] as FromIntoMemory>::from_bytes(&from[18..18 + 260]);
        let f_cbZero = <u16 as FromIntoMemory>::from_bytes(&from[278..278 + 2]);
        Self {
            cb: f_cb,
            iIconIndex: f_iIconIndex,
            iCurIndex: f_iCurIndex,
            uFlags: f_uFlags,
            dwProcessID: f_dwProcessID,
            szName: f_szName,
            cbZero: f_cbZero,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 280);
        FromIntoMemory::into_bytes(self.cb, &mut into[0..0 + 2]);
        FromIntoMemory::into_bytes(self.iIconIndex, &mut into[2..2 + 4]);
        FromIntoMemory::into_bytes(self.iCurIndex, &mut into[6..6 + 4]);
        FromIntoMemory::into_bytes(self.uFlags, &mut into[10..10 + 4]);
        FromIntoMemory::into_bytes(self.dwProcessID, &mut into[14..14 + 4]);
        FromIntoMemory::into_bytes(self.szName, &mut into[18..18 + 260]);
        FromIntoMemory::into_bytes(self.cbZero, &mut into[278..278 + 2]);
    }
    fn size() -> usize {
        280
    }
}
pub struct SHDESCRIPTIONID {
    pub dwDescriptionId: SHDID_ID,
    pub clsid: crate::core::GUID,
}
impl ::core::marker::Copy for SHDESCRIPTIONID {}
impl ::core::clone::Clone for SHDESCRIPTIONID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHDESCRIPTIONID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHDESCRIPTIONID")
            .field("dwDescriptionId", &self.dwDescriptionId)
            .field("clsid", &self.clsid)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHDESCRIPTIONID {
    fn eq(&self, other: &Self) -> bool {
        self.dwDescriptionId == other.dwDescriptionId && self.clsid == other.clsid
    }
}
impl ::core::cmp::Eq for SHDESCRIPTIONID {}
impl FromIntoMemory for SHDESCRIPTIONID {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_dwDescriptionId = <SHDID_ID as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_clsid = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        Self {
            dwDescriptionId: f_dwDescriptionId,
            clsid: f_clsid,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.dwDescriptionId, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.clsid, &mut into[4..4 + 16]);
    }
    fn size() -> usize {
        20
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHDID_ID(pub i32);
pub const SHDID_ROOT_REGITEM: SHDID_ID = SHDID_ID(1i32);
pub const SHDID_FS_FILE: SHDID_ID = SHDID_ID(2i32);
pub const SHDID_FS_DIRECTORY: SHDID_ID = SHDID_ID(3i32);
pub const SHDID_FS_OTHER: SHDID_ID = SHDID_ID(4i32);
pub const SHDID_COMPUTER_DRIVE35: SHDID_ID = SHDID_ID(5i32);
pub const SHDID_COMPUTER_DRIVE525: SHDID_ID = SHDID_ID(6i32);
pub const SHDID_COMPUTER_REMOVABLE: SHDID_ID = SHDID_ID(7i32);
pub const SHDID_COMPUTER_FIXED: SHDID_ID = SHDID_ID(8i32);
pub const SHDID_COMPUTER_NETDRIVE: SHDID_ID = SHDID_ID(9i32);
pub const SHDID_COMPUTER_CDROM: SHDID_ID = SHDID_ID(10i32);
pub const SHDID_COMPUTER_RAMDISK: SHDID_ID = SHDID_ID(11i32);
pub const SHDID_COMPUTER_OTHER: SHDID_ID = SHDID_ID(12i32);
pub const SHDID_NET_DOMAIN: SHDID_ID = SHDID_ID(13i32);
pub const SHDID_NET_SERVER: SHDID_ID = SHDID_ID(14i32);
pub const SHDID_NET_SHARE: SHDID_ID = SHDID_ID(15i32);
pub const SHDID_NET_RESTOFNET: SHDID_ID = SHDID_ID(16i32);
pub const SHDID_NET_OTHER: SHDID_ID = SHDID_ID(17i32);
pub const SHDID_COMPUTER_IMAGING: SHDID_ID = SHDID_ID(18i32);
pub const SHDID_COMPUTER_AUDIO: SHDID_ID = SHDID_ID(19i32);
pub const SHDID_COMPUTER_SHAREDDOCS: SHDID_ID = SHDID_ID(20i32);
pub const SHDID_MOBILE_DEVICE: SHDID_ID = SHDID_ID(21i32);
pub const SHDID_REMOTE_DESKTOP_DRIVE: SHDID_ID = SHDID_ID(22i32);
impl ::core::marker::Copy for SHDID_ID {}
impl ::core::clone::Clone for SHDID_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHDID_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHDID_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHDID_ID").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHDID_ID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct SHDRAGIMAGE {
    pub sizeDragImage: super::super::Foundation::SIZE,
    pub ptOffset: super::super::Foundation::POINT,
    pub hbmpDragImage: super::super::Graphics::Gdi::HBITMAP,
    pub crColorKey: u32,
}
impl ::core::marker::Copy for SHDRAGIMAGE {}
impl ::core::clone::Clone for SHDRAGIMAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHDRAGIMAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHDRAGIMAGE")
            .field("sizeDragImage", &self.sizeDragImage)
            .field("ptOffset", &self.ptOffset)
            .field("hbmpDragImage", &self.hbmpDragImage)
            .field("crColorKey", &self.crColorKey)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHDRAGIMAGE {
    fn eq(&self, other: &Self) -> bool {
        self.sizeDragImage == other.sizeDragImage
            && self.ptOffset == other.ptOffset
            && self.hbmpDragImage == other.hbmpDragImage
            && self.crColorKey == other.crColorKey
    }
}
impl ::core::cmp::Eq for SHDRAGIMAGE {}
impl FromIntoMemory for SHDRAGIMAGE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_sizeDragImage =
            <super::super::Foundation::SIZE as FromIntoMemory>::from_bytes(&from[0..0 + 8]);
        let f_ptOffset =
            <super::super::Foundation::POINT as FromIntoMemory>::from_bytes(&from[8..8 + 8]);
        let f_hbmpDragImage =
            <super::super::Graphics::Gdi::HBITMAP as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_crColorKey = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            sizeDragImage: f_sizeDragImage,
            ptOffset: f_ptOffset,
            hbmpDragImage: f_hbmpDragImage,
            crColorKey: f_crColorKey,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.sizeDragImage, &mut into[0..0 + 8]);
        FromIntoMemory::into_bytes(self.ptOffset, &mut into[8..8 + 8]);
        FromIntoMemory::into_bytes(self.hbmpDragImage, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.crColorKey, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHELLBROWSERSHOWCONTROL(pub i32);
pub const SBSC_HIDE: SHELLBROWSERSHOWCONTROL = SHELLBROWSERSHOWCONTROL(0i32);
pub const SBSC_SHOW: SHELLBROWSERSHOWCONTROL = SHELLBROWSERSHOWCONTROL(1i32);
pub const SBSC_TOGGLE: SHELLBROWSERSHOWCONTROL = SHELLBROWSERSHOWCONTROL(2i32);
pub const SBSC_QUERY: SHELLBROWSERSHOWCONTROL = SHELLBROWSERSHOWCONTROL(3i32);
impl ::core::marker::Copy for SHELLBROWSERSHOWCONTROL {}
impl ::core::clone::Clone for SHELLBROWSERSHOWCONTROL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHELLBROWSERSHOWCONTROL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHELLBROWSERSHOWCONTROL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHELLBROWSERSHOWCONTROL")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SHELLBROWSERSHOWCONTROL {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHELLEXECUTEINFOA {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub lpVerb: PCSTR,
    pub lpFile: PCSTR,
    pub lpParameters: PCSTR,
    pub lpDirectory: PCSTR,
    pub nShow: i32,
    pub hInstApp: super::super::Foundation::HINSTANCE,
    pub lpIDList: MutPtr<::core::ffi::c_void>,
    pub lpClass: PCSTR,
    pub hkeyClass: super::super::System::Registry::HKEY,
    pub dwHotKey: u32,
    pub Anonymous: SHELLEXECUTEINFOA_0,
    pub hProcess: super::super::Foundation::HANDLE,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHELLEXECUTEINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHELLEXECUTEINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHELLEXECUTEINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOA")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("lpVerb", &self.lpVerb)
            .field("lpFile", &self.lpFile)
            .field("lpParameters", &self.lpParameters)
            .field("lpDirectory", &self.lpDirectory)
            .field("nShow", &self.nShow)
            .field("hInstApp", &self.hInstApp)
            .field("lpIDList", &self.lpIDList)
            .field("lpClass", &self.lpClass)
            .field("hkeyClass", &self.hkeyClass)
            .field("dwHotKey", &self.dwHotKey)
            .field("Anonymous", &self.Anonymous)
            .field("hProcess", &self.hProcess)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.lpVerb == other.lpVerb
            && self.lpFile == other.lpFile
            && self.lpParameters == other.lpParameters
            && self.lpDirectory == other.lpDirectory
            && self.nShow == other.nShow
            && self.hInstApp == other.hInstApp
            && self.lpIDList == other.lpIDList
            && self.lpClass == other.lpClass
            && self.hkeyClass == other.hkeyClass
            && self.dwHotKey == other.dwHotKey
            && self.Anonymous == other.Anonymous
            && self.hProcess == other.hProcess
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHELLEXECUTEINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHELLEXECUTEINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVerb = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFile = <PCSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpParameters = <PCSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpDirectory = <PCSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_nShow = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_hInstApp =
            <super::super::Foundation::HINSTANCE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpIDList =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpClass = <PCSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_hkeyClass =
            <super::super::System::Registry::HKEY as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwHotKey = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_Anonymous = <SHELLEXECUTEINFOA_0 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_hProcess =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            lpVerb: f_lpVerb,
            lpFile: f_lpFile,
            lpParameters: f_lpParameters,
            lpDirectory: f_lpDirectory,
            nShow: f_nShow,
            hInstApp: f_hInstApp,
            lpIDList: f_lpIDList,
            lpClass: f_lpClass,
            hkeyClass: f_hkeyClass,
            dwHotKey: f_dwHotKey,
            Anonymous: f_Anonymous,
            hProcess: f_hProcess,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVerb, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFile, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpParameters, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectory, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.nShow, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.hInstApp, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpIDList, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpClass, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.hkeyClass, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwHotKey, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.hProcess, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHELLEXECUTEINFOA_0 {
    data: [u8; 4],
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::default::Default for SHELLEXECUTEINFOA_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHELLEXECUTEINFOA_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHELLEXECUTEINFOA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHELLEXECUTEINFOA_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOA_0")
            .field("data", &self.data)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOA_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHELLEXECUTEINFOA_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHELLEXECUTEINFOA_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
pub struct SHELLEXECUTEINFOA {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub lpVerb: PCSTR,
    pub lpFile: PCSTR,
    pub lpParameters: PCSTR,
    pub lpDirectory: PCSTR,
    pub nShow: i32,
    pub hInstApp: super::super::Foundation::HINSTANCE,
    pub lpIDList: MutPtr<::core::ffi::c_void>,
    pub lpClass: PCSTR,
    pub hkeyClass: super::super::System::Registry::HKEY,
    pub dwHotKey: u32,
    pub Anonymous: SHELLEXECUTEINFOA_0,
    pub hProcess: super::super::Foundation::HANDLE,
}
impl ::core::marker::Copy for SHELLEXECUTEINFOA {}
impl ::core::clone::Clone for SHELLEXECUTEINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELLEXECUTEINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOA")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("lpVerb", &self.lpVerb)
            .field("lpFile", &self.lpFile)
            .field("lpParameters", &self.lpParameters)
            .field("lpDirectory", &self.lpDirectory)
            .field("nShow", &self.nShow)
            .field("hInstApp", &self.hInstApp)
            .field("lpIDList", &self.lpIDList)
            .field("lpClass", &self.lpClass)
            .field("hkeyClass", &self.hkeyClass)
            .field("dwHotKey", &self.dwHotKey)
            .field("Anonymous", &self.Anonymous)
            .field("hProcess", &self.hProcess)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.lpVerb == other.lpVerb
            && self.lpFile == other.lpFile
            && self.lpParameters == other.lpParameters
            && self.lpDirectory == other.lpDirectory
            && self.nShow == other.nShow
            && self.hInstApp == other.hInstApp
            && self.lpIDList == other.lpIDList
            && self.lpClass == other.lpClass
            && self.hkeyClass == other.hkeyClass
            && self.dwHotKey == other.dwHotKey
            && self.Anonymous == other.Anonymous
            && self.hProcess == other.hProcess
    }
}
impl ::core::cmp::Eq for SHELLEXECUTEINFOA {}
impl FromIntoMemory for SHELLEXECUTEINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVerb = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFile = <PCSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpParameters = <PCSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpDirectory = <PCSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_nShow = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_hInstApp =
            <super::super::Foundation::HINSTANCE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpIDList =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpClass = <PCSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_hkeyClass =
            <super::super::System::Registry::HKEY as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwHotKey = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_Anonymous = <SHELLEXECUTEINFOA_0 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_hProcess =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            lpVerb: f_lpVerb,
            lpFile: f_lpFile,
            lpParameters: f_lpParameters,
            lpDirectory: f_lpDirectory,
            nShow: f_nShow,
            hInstApp: f_hInstApp,
            lpIDList: f_lpIDList,
            lpClass: f_lpClass,
            hkeyClass: f_hkeyClass,
            dwHotKey: f_dwHotKey,
            Anonymous: f_Anonymous,
            hProcess: f_hProcess,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVerb, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFile, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpParameters, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectory, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.nShow, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.hInstApp, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpIDList, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpClass, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.hkeyClass, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwHotKey, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.hProcess, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
pub struct SHELLEXECUTEINFOA_0 {
    data: [u8; 4],
}
impl ::core::default::Default for SHELLEXECUTEINFOA_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
impl ::core::marker::Copy for SHELLEXECUTEINFOA_0 {}
impl ::core::clone::Clone for SHELLEXECUTEINFOA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELLEXECUTEINFOA_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOA_0")
            .field("data", &self.data)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOA_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for SHELLEXECUTEINFOA_0 {}
impl FromIntoMemory for SHELLEXECUTEINFOA_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHELLEXECUTEINFOW {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub lpVerb: PCWSTR,
    pub lpFile: PCWSTR,
    pub lpParameters: PCWSTR,
    pub lpDirectory: PCWSTR,
    pub nShow: i32,
    pub hInstApp: super::super::Foundation::HINSTANCE,
    pub lpIDList: MutPtr<::core::ffi::c_void>,
    pub lpClass: PCWSTR,
    pub hkeyClass: super::super::System::Registry::HKEY,
    pub dwHotKey: u32,
    pub Anonymous: SHELLEXECUTEINFOW_0,
    pub hProcess: super::super::Foundation::HANDLE,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHELLEXECUTEINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHELLEXECUTEINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHELLEXECUTEINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOW")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("lpVerb", &self.lpVerb)
            .field("lpFile", &self.lpFile)
            .field("lpParameters", &self.lpParameters)
            .field("lpDirectory", &self.lpDirectory)
            .field("nShow", &self.nShow)
            .field("hInstApp", &self.hInstApp)
            .field("lpIDList", &self.lpIDList)
            .field("lpClass", &self.lpClass)
            .field("hkeyClass", &self.hkeyClass)
            .field("dwHotKey", &self.dwHotKey)
            .field("Anonymous", &self.Anonymous)
            .field("hProcess", &self.hProcess)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.lpVerb == other.lpVerb
            && self.lpFile == other.lpFile
            && self.lpParameters == other.lpParameters
            && self.lpDirectory == other.lpDirectory
            && self.nShow == other.nShow
            && self.hInstApp == other.hInstApp
            && self.lpIDList == other.lpIDList
            && self.lpClass == other.lpClass
            && self.hkeyClass == other.hkeyClass
            && self.dwHotKey == other.dwHotKey
            && self.Anonymous == other.Anonymous
            && self.hProcess == other.hProcess
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHELLEXECUTEINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHELLEXECUTEINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVerb = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFile = <PCWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpParameters = <PCWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpDirectory = <PCWSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_nShow = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_hInstApp =
            <super::super::Foundation::HINSTANCE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpIDList =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpClass = <PCWSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_hkeyClass =
            <super::super::System::Registry::HKEY as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwHotKey = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_Anonymous = <SHELLEXECUTEINFOW_0 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_hProcess =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            lpVerb: f_lpVerb,
            lpFile: f_lpFile,
            lpParameters: f_lpParameters,
            lpDirectory: f_lpDirectory,
            nShow: f_nShow,
            hInstApp: f_hInstApp,
            lpIDList: f_lpIDList,
            lpClass: f_lpClass,
            hkeyClass: f_hkeyClass,
            dwHotKey: f_dwHotKey,
            Anonymous: f_Anonymous,
            hProcess: f_hProcess,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVerb, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFile, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpParameters, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectory, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.nShow, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.hInstApp, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpIDList, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpClass, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.hkeyClass, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwHotKey, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.hProcess, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHELLEXECUTEINFOW_0 {
    data: [u8; 4],
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::default::Default for SHELLEXECUTEINFOW_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHELLEXECUTEINFOW_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHELLEXECUTEINFOW_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHELLEXECUTEINFOW_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOW_0")
            .field("data", &self.data)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOW_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHELLEXECUTEINFOW_0 {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Registry'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHELLEXECUTEINFOW_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
pub struct SHELLEXECUTEINFOW {
    pub cbSize: u32,
    pub fMask: u32,
    pub hwnd: super::super::Foundation::HWND,
    pub lpVerb: PCWSTR,
    pub lpFile: PCWSTR,
    pub lpParameters: PCWSTR,
    pub lpDirectory: PCWSTR,
    pub nShow: i32,
    pub hInstApp: super::super::Foundation::HINSTANCE,
    pub lpIDList: MutPtr<::core::ffi::c_void>,
    pub lpClass: PCWSTR,
    pub hkeyClass: super::super::System::Registry::HKEY,
    pub dwHotKey: u32,
    pub Anonymous: SHELLEXECUTEINFOW_0,
    pub hProcess: super::super::Foundation::HANDLE,
}
impl ::core::marker::Copy for SHELLEXECUTEINFOW {}
impl ::core::clone::Clone for SHELLEXECUTEINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELLEXECUTEINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOW")
            .field("cbSize", &self.cbSize)
            .field("fMask", &self.fMask)
            .field("hwnd", &self.hwnd)
            .field("lpVerb", &self.lpVerb)
            .field("lpFile", &self.lpFile)
            .field("lpParameters", &self.lpParameters)
            .field("lpDirectory", &self.lpDirectory)
            .field("nShow", &self.nShow)
            .field("hInstApp", &self.hInstApp)
            .field("lpIDList", &self.lpIDList)
            .field("lpClass", &self.lpClass)
            .field("hkeyClass", &self.hkeyClass)
            .field("dwHotKey", &self.dwHotKey)
            .field("Anonymous", &self.Anonymous)
            .field("hProcess", &self.hProcess)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.fMask == other.fMask
            && self.hwnd == other.hwnd
            && self.lpVerb == other.lpVerb
            && self.lpFile == other.lpFile
            && self.lpParameters == other.lpParameters
            && self.lpDirectory == other.lpDirectory
            && self.nShow == other.nShow
            && self.hInstApp == other.hInstApp
            && self.lpIDList == other.lpIDList
            && self.lpClass == other.lpClass
            && self.hkeyClass == other.hkeyClass
            && self.dwHotKey == other.dwHotKey
            && self.Anonymous == other.Anonymous
            && self.hProcess == other.hProcess
    }
}
impl ::core::cmp::Eq for SHELLEXECUTEINFOW {}
impl FromIntoMemory for SHELLEXECUTEINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_fMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpVerb = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpFile = <PCWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpParameters = <PCWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_lpDirectory = <PCWSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_nShow = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_hInstApp =
            <super::super::Foundation::HINSTANCE as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_lpIDList =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_lpClass = <PCWSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_hkeyClass =
            <super::super::System::Registry::HKEY as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_dwHotKey = <u32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_Anonymous = <SHELLEXECUTEINFOW_0 as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_hProcess =
            <super::super::Foundation::HANDLE as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            cbSize: f_cbSize,
            fMask: f_fMask,
            hwnd: f_hwnd,
            lpVerb: f_lpVerb,
            lpFile: f_lpFile,
            lpParameters: f_lpParameters,
            lpDirectory: f_lpDirectory,
            nShow: f_nShow,
            hInstApp: f_hInstApp,
            lpIDList: f_lpIDList,
            lpClass: f_lpClass,
            hkeyClass: f_hkeyClass,
            dwHotKey: f_dwHotKey,
            Anonymous: f_Anonymous,
            hProcess: f_hProcess,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.fMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpVerb, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpFile, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpParameters, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.lpDirectory, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.nShow, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.hInstApp, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.lpIDList, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.lpClass, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.hkeyClass, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.dwHotKey, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.Anonymous, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.hProcess, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
pub struct SHELLEXECUTEINFOW_0 {
    data: [u8; 4],
}
impl ::core::default::Default for SHELLEXECUTEINFOW_0 {
    fn default() -> Self {
        Self { data: [0u8; 4] }
    }
}
impl ::core::marker::Copy for SHELLEXECUTEINFOW_0 {}
impl ::core::clone::Clone for SHELLEXECUTEINFOW_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELLEXECUTEINFOW_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLEXECUTEINFOW_0")
            .field("data", &self.data)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELLEXECUTEINFOW_0 {
    fn eq(&self, other: &Self) -> bool {
        self.data == other.data
    }
}
impl ::core::cmp::Eq for SHELLEXECUTEINFOW_0 {}
impl FromIntoMemory for SHELLEXECUTEINFOW_0 {
    fn from_bytes(from: &[u8]) -> Self {
        let mut data = [0u8; 4];
        <_ as AsMut<[u8]>>::as_mut(&mut data).clone_from_slice(from);
        Self { data }
    }
    fn into_bytes(self, into: &mut [u8]) {
        into.clone_from_slice(<_ as AsRef<[u8]>>::as_ref(&self.data));
    }
    fn size() -> usize {
        4
    }
}
pub struct SHELLFLAGSTATE {
    pub _bitfield: i32,
}
impl ::core::marker::Copy for SHELLFLAGSTATE {}
impl ::core::clone::Clone for SHELLFLAGSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELLFLAGSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLFLAGSTATE")
            .field("_bitfield", &self._bitfield)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELLFLAGSTATE {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for SHELLFLAGSTATE {}
impl FromIntoMemory for SHELLFLAGSTATE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 4);
        let f__bitfield = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        Self {
            _bitfield: f__bitfield,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 4);
        FromIntoMemory::into_bytes(self._bitfield, &mut into[0..0 + 4]);
    }
    fn size() -> usize {
        4
    }
}
pub struct SHELLSTATEA {
    pub _bitfield1: i32,
    pub dwWin95Unused: u32,
    pub uWin95Unused: u32,
    pub lParamSort: i32,
    pub iSortDirection: i32,
    pub version: u32,
    pub uNotUsed: u32,
    pub _bitfield2: i32,
}
impl ::core::marker::Copy for SHELLSTATEA {}
impl ::core::clone::Clone for SHELLSTATEA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELLSTATEA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLSTATEA")
            .field("_bitfield1", &self._bitfield1)
            .field("dwWin95Unused", &self.dwWin95Unused)
            .field("uWin95Unused", &self.uWin95Unused)
            .field("lParamSort", &self.lParamSort)
            .field("iSortDirection", &self.iSortDirection)
            .field("version", &self.version)
            .field("uNotUsed", &self.uNotUsed)
            .field("_bitfield2", &self._bitfield2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELLSTATEA {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield1 == other._bitfield1
            && self.dwWin95Unused == other.dwWin95Unused
            && self.uWin95Unused == other.uWin95Unused
            && self.lParamSort == other.lParamSort
            && self.iSortDirection == other.iSortDirection
            && self.version == other.version
            && self.uNotUsed == other.uNotUsed
            && self._bitfield2 == other._bitfield2
    }
}
impl ::core::cmp::Eq for SHELLSTATEA {}
impl FromIntoMemory for SHELLSTATEA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f__bitfield1 = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwWin95Unused = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uWin95Unused = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lParamSort = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_iSortDirection = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_version = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_uNotUsed = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f__bitfield2 = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            _bitfield1: f__bitfield1,
            dwWin95Unused: f_dwWin95Unused,
            uWin95Unused: f_uWin95Unused,
            lParamSort: f_lParamSort,
            iSortDirection: f_iSortDirection,
            version: f_version,
            uNotUsed: f_uNotUsed,
            _bitfield2: f__bitfield2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self._bitfield1, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwWin95Unused, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uWin95Unused, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lParamSort, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.iSortDirection, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.version, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.uNotUsed, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self._bitfield2, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub const SHELLSTATEVERSION_IE4: u32 = 9u32;
pub const SHELLSTATEVERSION_WIN2K: u32 = 10u32;
pub struct SHELLSTATEW {
    pub _bitfield1: i32,
    pub dwWin95Unused: u32,
    pub uWin95Unused: u32,
    pub lParamSort: i32,
    pub iSortDirection: i32,
    pub version: u32,
    pub uNotUsed: u32,
    pub _bitfield2: i32,
}
impl ::core::marker::Copy for SHELLSTATEW {}
impl ::core::clone::Clone for SHELLSTATEW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELLSTATEW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELLSTATEW")
            .field("_bitfield1", &self._bitfield1)
            .field("dwWin95Unused", &self.dwWin95Unused)
            .field("uWin95Unused", &self.uWin95Unused)
            .field("lParamSort", &self.lParamSort)
            .field("iSortDirection", &self.iSortDirection)
            .field("version", &self.version)
            .field("uNotUsed", &self.uNotUsed)
            .field("_bitfield2", &self._bitfield2)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELLSTATEW {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield1 == other._bitfield1
            && self.dwWin95Unused == other.dwWin95Unused
            && self.uWin95Unused == other.uWin95Unused
            && self.lParamSort == other.lParamSort
            && self.iSortDirection == other.iSortDirection
            && self.version == other.version
            && self.uNotUsed == other.uNotUsed
            && self._bitfield2 == other._bitfield2
    }
}
impl ::core::cmp::Eq for SHELLSTATEW {}
impl FromIntoMemory for SHELLSTATEW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f__bitfield1 = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwWin95Unused = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_uWin95Unused = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lParamSort = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_iSortDirection = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_version = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_uNotUsed = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f__bitfield2 = <i32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            _bitfield1: f__bitfield1,
            dwWin95Unused: f_dwWin95Unused,
            uWin95Unused: f_uWin95Unused,
            lParamSort: f_lParamSort,
            iSortDirection: f_iSortDirection,
            version: f_version,
            uNotUsed: f_uNotUsed,
            _bitfield2: f__bitfield2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self._bitfield1, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwWin95Unused, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.uWin95Unused, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lParamSort, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.iSortDirection, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.version, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.uNotUsed, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self._bitfield2, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub const SHELL_E_WRONG_BITDEPTH: crate::core::HRESULT = crate::core::HRESULT(-2144927486i32);
pub struct SHELL_ITEM_RESOURCE {
    pub guidType: crate::core::GUID,
    pub szName: [u16; 260],
}
impl ::core::marker::Copy for SHELL_ITEM_RESOURCE {}
impl ::core::clone::Clone for SHELL_ITEM_RESOURCE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHELL_ITEM_RESOURCE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHELL_ITEM_RESOURCE")
            .field("guidType", &self.guidType)
            .field("szName", &self.szName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHELL_ITEM_RESOURCE {
    fn eq(&self, other: &Self) -> bool {
        self.guidType == other.guidType && self.szName == other.szName
    }
}
impl ::core::cmp::Eq for SHELL_ITEM_RESOURCE {}
impl FromIntoMemory for SHELL_ITEM_RESOURCE {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 276);
        let f_guidType = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[0..0 + 16]);
        let f_szName = <[u16; 260] as FromIntoMemory>::from_bytes(&from[16..16 + 260]);
        Self {
            guidType: f_guidType,
            szName: f_szName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 276);
        FromIntoMemory::into_bytes(self.guidType, &mut into[0..0 + 16]);
        FromIntoMemory::into_bytes(self.szName, &mut into[16..16 + 260]);
    }
    fn size() -> usize {
        276
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHELL_LINK_DATA_FLAGS(pub i32);
pub const SLDF_DEFAULT: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(0i32);
pub const SLDF_HAS_ID_LIST: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(1i32);
pub const SLDF_HAS_LINK_INFO: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(2i32);
pub const SLDF_HAS_NAME: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(4i32);
pub const SLDF_HAS_RELPATH: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(8i32);
pub const SLDF_HAS_WORKINGDIR: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(16i32);
pub const SLDF_HAS_ARGS: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(32i32);
pub const SLDF_HAS_ICONLOCATION: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(64i32);
pub const SLDF_UNICODE: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(128i32);
pub const SLDF_FORCE_NO_LINKINFO: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(256i32);
pub const SLDF_HAS_EXP_SZ: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(512i32);
pub const SLDF_RUN_IN_SEPARATE: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(1024i32);
pub const SLDF_HAS_DARWINID: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(4096i32);
pub const SLDF_RUNAS_USER: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(8192i32);
pub const SLDF_HAS_EXP_ICON_SZ: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(16384i32);
pub const SLDF_NO_PIDL_ALIAS: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(32768i32);
pub const SLDF_FORCE_UNCNAME: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(65536i32);
pub const SLDF_RUN_WITH_SHIMLAYER: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(131072i32);
pub const SLDF_FORCE_NO_LINKTRACK: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(262144i32);
pub const SLDF_ENABLE_TARGET_METADATA: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(524288i32);
pub const SLDF_DISABLE_LINK_PATH_TRACKING: SHELL_LINK_DATA_FLAGS =
    SHELL_LINK_DATA_FLAGS(1048576i32);
pub const SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING: SHELL_LINK_DATA_FLAGS =
    SHELL_LINK_DATA_FLAGS(2097152i32);
pub const SLDF_NO_KF_ALIAS: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(4194304i32);
pub const SLDF_ALLOW_LINK_TO_LINK: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(8388608i32);
pub const SLDF_UNALIAS_ON_SAVE: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(16777216i32);
pub const SLDF_PREFER_ENVIRONMENT_PATH: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(33554432i32);
pub const SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET: SHELL_LINK_DATA_FLAGS =
    SHELL_LINK_DATA_FLAGS(67108864i32);
pub const SLDF_PERSIST_VOLUME_ID_RELATIVE: SHELL_LINK_DATA_FLAGS =
    SHELL_LINK_DATA_FLAGS(134217728i32);
pub const SLDF_VALID: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(268433407i32);
pub const SLDF_RESERVED: SHELL_LINK_DATA_FLAGS = SHELL_LINK_DATA_FLAGS(-2147483648i32);
impl ::core::marker::Copy for SHELL_LINK_DATA_FLAGS {}
impl ::core::clone::Clone for SHELL_LINK_DATA_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHELL_LINK_DATA_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHELL_LINK_DATA_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHELL_LINK_DATA_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SHELL_LINK_DATA_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHELL_UI_COMPONENT(pub i32);
pub const SHELL_UI_COMPONENT_TASKBARS: SHELL_UI_COMPONENT = SHELL_UI_COMPONENT(0i32);
pub const SHELL_UI_COMPONENT_NOTIFICATIONAREA: SHELL_UI_COMPONENT = SHELL_UI_COMPONENT(1i32);
pub const SHELL_UI_COMPONENT_DESKBAND: SHELL_UI_COMPONENT = SHELL_UI_COMPONENT(2i32);
impl ::core::marker::Copy for SHELL_UI_COMPONENT {}
impl ::core::clone::Clone for SHELL_UI_COMPONENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHELL_UI_COMPONENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHELL_UI_COMPONENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHELL_UI_COMPONENT").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHELL_UI_COMPONENT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SHERB_NOCONFIRMATION: u32 = 1u32;
pub const SHERB_NOPROGRESSUI: u32 = 2u32;
pub const SHERB_NOSOUND: u32 = 4u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHFILEINFOA {
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub iIcon: i32,
    pub dwAttributes: u32,
    pub szDisplayName: [super::super::Foundation::CHAR; 260],
    pub szTypeName: [super::super::Foundation::CHAR; 80],
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHFILEINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHFILEINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHFILEINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEINFOA")
            .field("hIcon", &self.hIcon)
            .field("iIcon", &self.iIcon)
            .field("dwAttributes", &self.dwAttributes)
            .field("szDisplayName", &self.szDisplayName)
            .field("szTypeName", &self.szTypeName)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHFILEINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.hIcon == other.hIcon
            && self.iIcon == other.iIcon
            && self.dwAttributes == other.dwAttributes
            && self.szDisplayName == other.szDisplayName
            && self.szTypeName == other.szTypeName
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHFILEINFOA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHFILEINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 352);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iIcon = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwAttributes = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_szDisplayName = <[super::super::Foundation::CHAR; 260] as FromIntoMemory>::from_bytes(
            &from[12..12 + 260],
        );
        let f_szTypeName = <[super::super::Foundation::CHAR; 80] as FromIntoMemory>::from_bytes(
            &from[272..272 + 80],
        );
        Self {
            hIcon: f_hIcon,
            iIcon: f_iIcon,
            dwAttributes: f_dwAttributes,
            szDisplayName: f_szDisplayName,
            szTypeName: f_szTypeName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 352);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iIcon, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwAttributes, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.szDisplayName, &mut into[12..12 + 260]);
        FromIntoMemory::into_bytes(self.szTypeName, &mut into[272..272 + 80]);
    }
    fn size() -> usize {
        352
    }
}
pub struct SHFILEINFOA {
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub iIcon: i32,
    pub dwAttributes: u32,
    pub szDisplayName: [super::super::Foundation::CHAR; 260],
    pub szTypeName: [super::super::Foundation::CHAR; 80],
}
impl ::core::marker::Copy for SHFILEINFOA {}
impl ::core::clone::Clone for SHFILEINFOA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHFILEINFOA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEINFOA")
            .field("hIcon", &self.hIcon)
            .field("iIcon", &self.iIcon)
            .field("dwAttributes", &self.dwAttributes)
            .field("szDisplayName", &self.szDisplayName)
            .field("szTypeName", &self.szTypeName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHFILEINFOA {
    fn eq(&self, other: &Self) -> bool {
        self.hIcon == other.hIcon
            && self.iIcon == other.iIcon
            && self.dwAttributes == other.dwAttributes
            && self.szDisplayName == other.szDisplayName
            && self.szTypeName == other.szTypeName
    }
}
impl ::core::cmp::Eq for SHFILEINFOA {}
impl FromIntoMemory for SHFILEINFOA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 352);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iIcon = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwAttributes = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_szDisplayName = <[super::super::Foundation::CHAR; 260] as FromIntoMemory>::from_bytes(
            &from[12..12 + 260],
        );
        let f_szTypeName = <[super::super::Foundation::CHAR; 80] as FromIntoMemory>::from_bytes(
            &from[272..272 + 80],
        );
        Self {
            hIcon: f_hIcon,
            iIcon: f_iIcon,
            dwAttributes: f_dwAttributes,
            szDisplayName: f_szDisplayName,
            szTypeName: f_szTypeName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 352);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iIcon, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwAttributes, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.szDisplayName, &mut into[12..12 + 260]);
        FromIntoMemory::into_bytes(self.szTypeName, &mut into[272..272 + 80]);
    }
    fn size() -> usize {
        352
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHFILEINFOW {
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub iIcon: i32,
    pub dwAttributes: u32,
    pub szDisplayName: [u16; 260],
    pub szTypeName: [u16; 80],
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHFILEINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHFILEINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHFILEINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEINFOW")
            .field("hIcon", &self.hIcon)
            .field("iIcon", &self.iIcon)
            .field("dwAttributes", &self.dwAttributes)
            .field("szDisplayName", &self.szDisplayName)
            .field("szTypeName", &self.szTypeName)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHFILEINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.hIcon == other.hIcon
            && self.iIcon == other.iIcon
            && self.dwAttributes == other.dwAttributes
            && self.szDisplayName == other.szDisplayName
            && self.szTypeName == other.szTypeName
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHFILEINFOW {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHFILEINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 352);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iIcon = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwAttributes = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_szDisplayName = <[u16; 260] as FromIntoMemory>::from_bytes(&from[12..12 + 260]);
        let f_szTypeName = <[u16; 80] as FromIntoMemory>::from_bytes(&from[272..272 + 80]);
        Self {
            hIcon: f_hIcon,
            iIcon: f_iIcon,
            dwAttributes: f_dwAttributes,
            szDisplayName: f_szDisplayName,
            szTypeName: f_szTypeName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 352);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iIcon, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwAttributes, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.szDisplayName, &mut into[12..12 + 260]);
        FromIntoMemory::into_bytes(self.szTypeName, &mut into[272..272 + 80]);
    }
    fn size() -> usize {
        352
    }
}
pub struct SHFILEINFOW {
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub iIcon: i32,
    pub dwAttributes: u32,
    pub szDisplayName: [u16; 260],
    pub szTypeName: [u16; 80],
}
impl ::core::marker::Copy for SHFILEINFOW {}
impl ::core::clone::Clone for SHFILEINFOW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHFILEINFOW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEINFOW")
            .field("hIcon", &self.hIcon)
            .field("iIcon", &self.iIcon)
            .field("dwAttributes", &self.dwAttributes)
            .field("szDisplayName", &self.szDisplayName)
            .field("szTypeName", &self.szTypeName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHFILEINFOW {
    fn eq(&self, other: &Self) -> bool {
        self.hIcon == other.hIcon
            && self.iIcon == other.iIcon
            && self.dwAttributes == other.dwAttributes
            && self.szDisplayName == other.szDisplayName
            && self.szTypeName == other.szTypeName
    }
}
impl ::core::cmp::Eq for SHFILEINFOW {}
impl FromIntoMemory for SHFILEINFOW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 352);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iIcon = <i32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwAttributes = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_szDisplayName = <[u16; 260] as FromIntoMemory>::from_bytes(&from[12..12 + 260]);
        let f_szTypeName = <[u16; 80] as FromIntoMemory>::from_bytes(&from[272..272 + 80]);
        Self {
            hIcon: f_hIcon,
            iIcon: f_iIcon,
            dwAttributes: f_dwAttributes,
            szDisplayName: f_szDisplayName,
            szTypeName: f_szTypeName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 352);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iIcon, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwAttributes, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.szDisplayName, &mut into[12..12 + 260]);
        FromIntoMemory::into_bytes(self.szTypeName, &mut into[272..272 + 80]);
    }
    fn size() -> usize {
        352
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHFILEOPSTRUCTA {
    pub hwnd: super::super::Foundation::HWND,
    pub wFunc: u32,
    pub pFrom: MutPtr<i8>,
    pub pTo: MutPtr<i8>,
    pub fFlags: u16,
    pub fAnyOperationsAborted: super::super::Foundation::BOOL,
    pub hNameMappings: MutPtr<::core::ffi::c_void>,
    pub lpszProgressTitle: PCSTR,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHFILEOPSTRUCTA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHFILEOPSTRUCTA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHFILEOPSTRUCTA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEOPSTRUCTA")
            .field("hwnd", &self.hwnd)
            .field("wFunc", &self.wFunc)
            .field("pFrom", &self.pFrom)
            .field("pTo", &self.pTo)
            .field("fFlags", &self.fFlags)
            .field("fAnyOperationsAborted", &self.fAnyOperationsAborted)
            .field("hNameMappings", &self.hNameMappings)
            .field("lpszProgressTitle", &self.lpszProgressTitle)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHFILEOPSTRUCTA {
    fn eq(&self, other: &Self) -> bool {
        self.hwnd == other.hwnd
            && self.wFunc == other.wFunc
            && self.pFrom == other.pFrom
            && self.pTo == other.pTo
            && self.fFlags == other.fFlags
            && self.fAnyOperationsAborted == other.fAnyOperationsAborted
            && self.hNameMappings == other.hNameMappings
            && self.lpszProgressTitle == other.lpszProgressTitle
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHFILEOPSTRUCTA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHFILEOPSTRUCTA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_wFunc = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pFrom = <MutPtr<i8> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pTo = <MutPtr<i8> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_fFlags = <u16 as FromIntoMemory>::from_bytes(&from[16..16 + 2]);
        let f_fAnyOperationsAborted =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_hNameMappings =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpszProgressTitle = <PCSTR as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            hwnd: f_hwnd,
            wFunc: f_wFunc,
            pFrom: f_pFrom,
            pTo: f_pTo,
            fFlags: f_fFlags,
            fAnyOperationsAborted: f_fAnyOperationsAborted,
            hNameMappings: f_hNameMappings,
            lpszProgressTitle: f_lpszProgressTitle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.wFunc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pFrom, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pTo, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.fFlags, &mut into[16..16 + 2]);
        FromIntoMemory::into_bytes(self.fAnyOperationsAborted, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.hNameMappings, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpszProgressTitle, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct SHFILEOPSTRUCTA {
    pub hwnd: super::super::Foundation::HWND,
    pub wFunc: u32,
    pub pFrom: MutPtr<i8>,
    pub pTo: MutPtr<i8>,
    pub fFlags: u16,
    pub fAnyOperationsAborted: super::super::Foundation::BOOL,
    pub hNameMappings: MutPtr<::core::ffi::c_void>,
    pub lpszProgressTitle: PCSTR,
}
impl ::core::marker::Copy for SHFILEOPSTRUCTA {}
impl ::core::clone::Clone for SHFILEOPSTRUCTA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHFILEOPSTRUCTA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEOPSTRUCTA")
            .field("hwnd", &self.hwnd)
            .field("wFunc", &self.wFunc)
            .field("pFrom", &self.pFrom)
            .field("pTo", &self.pTo)
            .field("fFlags", &self.fFlags)
            .field("fAnyOperationsAborted", &self.fAnyOperationsAborted)
            .field("hNameMappings", &self.hNameMappings)
            .field("lpszProgressTitle", &self.lpszProgressTitle)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHFILEOPSTRUCTA {
    fn eq(&self, other: &Self) -> bool {
        self.hwnd == other.hwnd
            && self.wFunc == other.wFunc
            && self.pFrom == other.pFrom
            && self.pTo == other.pTo
            && self.fFlags == other.fFlags
            && self.fAnyOperationsAborted == other.fAnyOperationsAborted
            && self.hNameMappings == other.hNameMappings
            && self.lpszProgressTitle == other.lpszProgressTitle
    }
}
impl ::core::cmp::Eq for SHFILEOPSTRUCTA {}
impl FromIntoMemory for SHFILEOPSTRUCTA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 30);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_wFunc = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pFrom = <MutPtr<i8> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pTo = <MutPtr<i8> as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_fFlags = <u16 as FromIntoMemory>::from_bytes(&from[16..16 + 2]);
        let f_fAnyOperationsAborted =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[18..18 + 4]);
        let f_hNameMappings =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[22..22 + 4]);
        let f_lpszProgressTitle = <PCSTR as FromIntoMemory>::from_bytes(&from[26..26 + 4]);
        Self {
            hwnd: f_hwnd,
            wFunc: f_wFunc,
            pFrom: f_pFrom,
            pTo: f_pTo,
            fFlags: f_fFlags,
            fAnyOperationsAborted: f_fAnyOperationsAborted,
            hNameMappings: f_hNameMappings,
            lpszProgressTitle: f_lpszProgressTitle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 30);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.wFunc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pFrom, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pTo, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.fFlags, &mut into[16..16 + 2]);
        FromIntoMemory::into_bytes(self.fAnyOperationsAborted, &mut into[18..18 + 4]);
        FromIntoMemory::into_bytes(self.hNameMappings, &mut into[22..22 + 4]);
        FromIntoMemory::into_bytes(self.lpszProgressTitle, &mut into[26..26 + 4]);
    }
    fn size() -> usize {
        30
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHFILEOPSTRUCTW {
    pub hwnd: super::super::Foundation::HWND,
    pub wFunc: u32,
    pub pFrom: PCWSTR,
    pub pTo: PCWSTR,
    pub fFlags: u16,
    pub fAnyOperationsAborted: super::super::Foundation::BOOL,
    pub hNameMappings: MutPtr<::core::ffi::c_void>,
    pub lpszProgressTitle: PCWSTR,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHFILEOPSTRUCTW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHFILEOPSTRUCTW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHFILEOPSTRUCTW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEOPSTRUCTW")
            .field("hwnd", &self.hwnd)
            .field("wFunc", &self.wFunc)
            .field("pFrom", &self.pFrom)
            .field("pTo", &self.pTo)
            .field("fFlags", &self.fFlags)
            .field("fAnyOperationsAborted", &self.fAnyOperationsAborted)
            .field("hNameMappings", &self.hNameMappings)
            .field("lpszProgressTitle", &self.lpszProgressTitle)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHFILEOPSTRUCTW {
    fn eq(&self, other: &Self) -> bool {
        self.hwnd == other.hwnd
            && self.wFunc == other.wFunc
            && self.pFrom == other.pFrom
            && self.pTo == other.pTo
            && self.fFlags == other.fFlags
            && self.fAnyOperationsAborted == other.fAnyOperationsAborted
            && self.hNameMappings == other.hNameMappings
            && self.lpszProgressTitle == other.lpszProgressTitle
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHFILEOPSTRUCTW {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHFILEOPSTRUCTW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_wFunc = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pFrom = <PCWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pTo = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_fFlags = <u16 as FromIntoMemory>::from_bytes(&from[16..16 + 2]);
        let f_fAnyOperationsAborted =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_hNameMappings =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_lpszProgressTitle = <PCWSTR as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        Self {
            hwnd: f_hwnd,
            wFunc: f_wFunc,
            pFrom: f_pFrom,
            pTo: f_pTo,
            fFlags: f_fFlags,
            fAnyOperationsAborted: f_fAnyOperationsAborted,
            hNameMappings: f_hNameMappings,
            lpszProgressTitle: f_lpszProgressTitle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.wFunc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pFrom, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pTo, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.fFlags, &mut into[16..16 + 2]);
        FromIntoMemory::into_bytes(self.fAnyOperationsAborted, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.hNameMappings, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.lpszProgressTitle, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub struct SHFILEOPSTRUCTW {
    pub hwnd: super::super::Foundation::HWND,
    pub wFunc: u32,
    pub pFrom: PCWSTR,
    pub pTo: PCWSTR,
    pub fFlags: u16,
    pub fAnyOperationsAborted: super::super::Foundation::BOOL,
    pub hNameMappings: MutPtr<::core::ffi::c_void>,
    pub lpszProgressTitle: PCWSTR,
}
impl ::core::marker::Copy for SHFILEOPSTRUCTW {}
impl ::core::clone::Clone for SHFILEOPSTRUCTW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHFILEOPSTRUCTW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFILEOPSTRUCTW")
            .field("hwnd", &self.hwnd)
            .field("wFunc", &self.wFunc)
            .field("pFrom", &self.pFrom)
            .field("pTo", &self.pTo)
            .field("fFlags", &self.fFlags)
            .field("fAnyOperationsAborted", &self.fAnyOperationsAborted)
            .field("hNameMappings", &self.hNameMappings)
            .field("lpszProgressTitle", &self.lpszProgressTitle)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHFILEOPSTRUCTW {
    fn eq(&self, other: &Self) -> bool {
        self.hwnd == other.hwnd
            && self.wFunc == other.wFunc
            && self.pFrom == other.pFrom
            && self.pTo == other.pTo
            && self.fFlags == other.fFlags
            && self.fAnyOperationsAborted == other.fAnyOperationsAborted
            && self.hNameMappings == other.hNameMappings
            && self.lpszProgressTitle == other.lpszProgressTitle
    }
}
impl ::core::cmp::Eq for SHFILEOPSTRUCTW {}
impl FromIntoMemory for SHFILEOPSTRUCTW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 30);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_wFunc = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pFrom = <PCWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pTo = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_fFlags = <u16 as FromIntoMemory>::from_bytes(&from[16..16 + 2]);
        let f_fAnyOperationsAborted =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[18..18 + 4]);
        let f_hNameMappings =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[22..22 + 4]);
        let f_lpszProgressTitle = <PCWSTR as FromIntoMemory>::from_bytes(&from[26..26 + 4]);
        Self {
            hwnd: f_hwnd,
            wFunc: f_wFunc,
            pFrom: f_pFrom,
            pTo: f_pTo,
            fFlags: f_fFlags,
            fAnyOperationsAborted: f_fAnyOperationsAborted,
            hNameMappings: f_hNameMappings,
            lpszProgressTitle: f_lpszProgressTitle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 30);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.wFunc, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pFrom, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pTo, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.fFlags, &mut into[16..16 + 2]);
        FromIntoMemory::into_bytes(self.fAnyOperationsAborted, &mut into[18..18 + 4]);
        FromIntoMemory::into_bytes(self.hNameMappings, &mut into[22..22 + 4]);
        FromIntoMemory::into_bytes(self.lpszProgressTitle, &mut into[26..26 + 4]);
    }
    fn size() -> usize {
        30
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHFMT_ID(pub u32);
pub const SHFMT_ID_DEFAULT: SHFMT_ID = SHFMT_ID(65535u32);
impl ::core::marker::Copy for SHFMT_ID {}
impl ::core::clone::Clone for SHFMT_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHFMT_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHFMT_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHFMT_ID").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHFMT_ID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHFMT_OPT(pub i32);
pub const SHFMT_OPT_NONE: SHFMT_OPT = SHFMT_OPT(0i32);
pub const SHFMT_OPT_FULL: SHFMT_OPT = SHFMT_OPT(1i32);
pub const SHFMT_OPT_SYSONLY: SHFMT_OPT = SHFMT_OPT(2i32);
impl ::core::marker::Copy for SHFMT_OPT {}
impl ::core::clone::Clone for SHFMT_OPT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHFMT_OPT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHFMT_OPT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHFMT_OPT").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SHFMT_OPT {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SHFMT_OPT {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SHFMT_OPT {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SHFMT_OPT {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SHFMT_OPT {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SHFMT_OPT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHFMT_RET(pub u32);
pub const SHFMT_ERROR: SHFMT_RET = SHFMT_RET(4294967295u32);
pub const SHFMT_CANCEL: SHFMT_RET = SHFMT_RET(4294967294u32);
pub const SHFMT_NOFORMAT: SHFMT_RET = SHFMT_RET(4294967293u32);
impl ::core::marker::Copy for SHFMT_RET {}
impl ::core::clone::Clone for SHFMT_RET {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHFMT_RET {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHFMT_RET {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHFMT_RET").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHFMT_RET {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct SHFOLDERCUSTOMSETTINGS {
    pub dwSize: u32,
    pub dwMask: u32,
    pub pvid: MutPtr<crate::core::GUID>,
    pub pszWebViewTemplate: PWSTR,
    pub cchWebViewTemplate: u32,
    pub pszWebViewTemplateVersion: PWSTR,
    pub pszInfoTip: PWSTR,
    pub cchInfoTip: u32,
    pub pclsid: MutPtr<crate::core::GUID>,
    pub dwFlags: u32,
    pub pszIconFile: PWSTR,
    pub cchIconFile: u32,
    pub iIconIndex: i32,
    pub pszLogo: PWSTR,
    pub cchLogo: u32,
}
impl ::core::marker::Copy for SHFOLDERCUSTOMSETTINGS {}
impl ::core::clone::Clone for SHFOLDERCUSTOMSETTINGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHFOLDERCUSTOMSETTINGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHFOLDERCUSTOMSETTINGS")
            .field("dwSize", &self.dwSize)
            .field("dwMask", &self.dwMask)
            .field("pvid", &self.pvid)
            .field("pszWebViewTemplate", &self.pszWebViewTemplate)
            .field("cchWebViewTemplate", &self.cchWebViewTemplate)
            .field("pszWebViewTemplateVersion", &self.pszWebViewTemplateVersion)
            .field("pszInfoTip", &self.pszInfoTip)
            .field("cchInfoTip", &self.cchInfoTip)
            .field("pclsid", &self.pclsid)
            .field("dwFlags", &self.dwFlags)
            .field("pszIconFile", &self.pszIconFile)
            .field("cchIconFile", &self.cchIconFile)
            .field("iIconIndex", &self.iIconIndex)
            .field("pszLogo", &self.pszLogo)
            .field("cchLogo", &self.cchLogo)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHFOLDERCUSTOMSETTINGS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize
            && self.dwMask == other.dwMask
            && self.pvid == other.pvid
            && self.pszWebViewTemplate == other.pszWebViewTemplate
            && self.cchWebViewTemplate == other.cchWebViewTemplate
            && self.pszWebViewTemplateVersion == other.pszWebViewTemplateVersion
            && self.pszInfoTip == other.pszInfoTip
            && self.cchInfoTip == other.cchInfoTip
            && self.pclsid == other.pclsid
            && self.dwFlags == other.dwFlags
            && self.pszIconFile == other.pszIconFile
            && self.cchIconFile == other.cchIconFile
            && self.iIconIndex == other.iIconIndex
            && self.pszLogo == other.pszLogo
            && self.cchLogo == other.cchLogo
    }
}
impl ::core::cmp::Eq for SHFOLDERCUSTOMSETTINGS {}
impl FromIntoMemory for SHFOLDERCUSTOMSETTINGS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 60);
        let f_dwSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pvid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pszWebViewTemplate = <PWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_cchWebViewTemplate = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pszWebViewTemplateVersion = <PWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_pszInfoTip = <PWSTR as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_cchInfoTip = <u32 as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_pclsid = <MutPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_pszIconFile = <PWSTR as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_cchIconFile = <u32 as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        let f_iIconIndex = <i32 as FromIntoMemory>::from_bytes(&from[48..48 + 4]);
        let f_pszLogo = <PWSTR as FromIntoMemory>::from_bytes(&from[52..52 + 4]);
        let f_cchLogo = <u32 as FromIntoMemory>::from_bytes(&from[56..56 + 4]);
        Self {
            dwSize: f_dwSize,
            dwMask: f_dwMask,
            pvid: f_pvid,
            pszWebViewTemplate: f_pszWebViewTemplate,
            cchWebViewTemplate: f_cchWebViewTemplate,
            pszWebViewTemplateVersion: f_pszWebViewTemplateVersion,
            pszInfoTip: f_pszInfoTip,
            cchInfoTip: f_cchInfoTip,
            pclsid: f_pclsid,
            dwFlags: f_dwFlags,
            pszIconFile: f_pszIconFile,
            cchIconFile: f_cchIconFile,
            iIconIndex: f_iIconIndex,
            pszLogo: f_pszLogo,
            cchLogo: f_cchLogo,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 60);
        FromIntoMemory::into_bytes(self.dwSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pvid, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pszWebViewTemplate, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.cchWebViewTemplate, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pszWebViewTemplateVersion, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.pszInfoTip, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.cchInfoTip, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.pclsid, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.pszIconFile, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.cchIconFile, &mut into[44..44 + 4]);
        FromIntoMemory::into_bytes(self.iIconIndex, &mut into[48..48 + 4]);
        FromIntoMemory::into_bytes(self.pszLogo, &mut into[52..52 + 4]);
        FromIntoMemory::into_bytes(self.cchLogo, &mut into[56..56 + 4]);
    }
    fn size() -> usize {
        60
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHGDFIL_FORMAT(pub i32);
pub const SHGDFIL_FINDDATA: SHGDFIL_FORMAT = SHGDFIL_FORMAT(1i32);
pub const SHGDFIL_NETRESOURCE: SHGDFIL_FORMAT = SHGDFIL_FORMAT(2i32);
pub const SHGDFIL_DESCRIPTIONID: SHGDFIL_FORMAT = SHGDFIL_FORMAT(3i32);
impl ::core::marker::Copy for SHGDFIL_FORMAT {}
impl ::core::clone::Clone for SHGDFIL_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHGDFIL_FORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHGDFIL_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHGDFIL_FORMAT").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHGDFIL_FORMAT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHGFI_FLAGS(pub i32);
pub const SHGFI_ADDOVERLAYS: SHGFI_FLAGS = SHGFI_FLAGS(32i32);
pub const SHGFI_ATTR_SPECIFIED: SHGFI_FLAGS = SHGFI_FLAGS(131072i32);
pub const SHGFI_ATTRIBUTES: SHGFI_FLAGS = SHGFI_FLAGS(2048i32);
pub const SHGFI_DISPLAYNAME: SHGFI_FLAGS = SHGFI_FLAGS(512i32);
pub const SHGFI_EXETYPE: SHGFI_FLAGS = SHGFI_FLAGS(8192i32);
pub const SHGFI_ICON: SHGFI_FLAGS = SHGFI_FLAGS(256i32);
pub const SHGFI_ICONLOCATION: SHGFI_FLAGS = SHGFI_FLAGS(4096i32);
pub const SHGFI_LARGEICON: SHGFI_FLAGS = SHGFI_FLAGS(0i32);
pub const SHGFI_LINKOVERLAY: SHGFI_FLAGS = SHGFI_FLAGS(32768i32);
pub const SHGFI_OPENICON: SHGFI_FLAGS = SHGFI_FLAGS(2i32);
pub const SHGFI_OVERLAYINDEX: SHGFI_FLAGS = SHGFI_FLAGS(64i32);
pub const SHGFI_PIDL: SHGFI_FLAGS = SHGFI_FLAGS(8i32);
pub const SHGFI_SELECTED: SHGFI_FLAGS = SHGFI_FLAGS(65536i32);
pub const SHGFI_SHELLICONSIZE: SHGFI_FLAGS = SHGFI_FLAGS(4i32);
pub const SHGFI_SMALLICON: SHGFI_FLAGS = SHGFI_FLAGS(1i32);
pub const SHGFI_SYSICONINDEX: SHGFI_FLAGS = SHGFI_FLAGS(16384i32);
pub const SHGFI_TYPENAME: SHGFI_FLAGS = SHGFI_FLAGS(1024i32);
pub const SHGFI_USEFILEATTRIBUTES: SHGFI_FLAGS = SHGFI_FLAGS(16i32);
impl ::core::marker::Copy for SHGFI_FLAGS {}
impl ::core::clone::Clone for SHGFI_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHGFI_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHGFI_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHGFI_FLAGS").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SHGFI_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SHGFI_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SHGFI_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SHGFI_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SHGFI_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SHGFI_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHGFP_TYPE(pub i32);
pub const SHGFP_TYPE_CURRENT: SHGFP_TYPE = SHGFP_TYPE(0i32);
pub const SHGFP_TYPE_DEFAULT: SHGFP_TYPE = SHGFP_TYPE(1i32);
impl ::core::marker::Copy for SHGFP_TYPE {}
impl ::core::clone::Clone for SHGFP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHGFP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHGFP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHGFP_TYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHGFP_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHGLOBALCOUNTER(pub i32);
pub const GLOBALCOUNTER_SEARCHMANAGER: SHGLOBALCOUNTER = SHGLOBALCOUNTER(0i32);
pub const GLOBALCOUNTER_SEARCHOPTIONS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(1i32);
pub const GLOBALCOUNTER_FOLDERSETTINGSCHANGE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(2i32);
pub const GLOBALCOUNTER_RATINGS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(3i32);
pub const GLOBALCOUNTER_APPROVEDSITES: SHGLOBALCOUNTER = SHGLOBALCOUNTER(4i32);
pub const GLOBALCOUNTER_RESTRICTIONS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(5i32);
pub const GLOBALCOUNTER_SHELLSETTINGSCHANGED: SHGLOBALCOUNTER = SHGLOBALCOUNTER(6i32);
pub const GLOBALCOUNTER_SYSTEMPIDLCHANGE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(7i32);
pub const GLOBALCOUNTER_OVERLAYMANAGER: SHGLOBALCOUNTER = SHGLOBALCOUNTER(8i32);
pub const GLOBALCOUNTER_QUERYASSOCIATIONS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(9i32);
pub const GLOBALCOUNTER_IESESSIONS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(10i32);
pub const GLOBALCOUNTER_IEONLY_SESSIONS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(11i32);
pub const GLOBALCOUNTER_APPLICATION_DESTINATIONS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(12i32);
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_CSCSYNCINPROGRESS: SHGLOBALCOUNTER =
    SHGLOBALCOUNTER(13i32);
pub const GLOBALCOUNTER_BITBUCKETNUMDELETERS: SHGLOBALCOUNTER = SHGLOBALCOUNTER(14i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SHARES: SHGLOBALCOUNTER = SHGLOBALCOUNTER(15i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_A: SHGLOBALCOUNTER = SHGLOBALCOUNTER(16i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_B: SHGLOBALCOUNTER = SHGLOBALCOUNTER(17i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_C: SHGLOBALCOUNTER = SHGLOBALCOUNTER(18i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_D: SHGLOBALCOUNTER = SHGLOBALCOUNTER(19i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_E: SHGLOBALCOUNTER = SHGLOBALCOUNTER(20i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_F: SHGLOBALCOUNTER = SHGLOBALCOUNTER(21i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_G: SHGLOBALCOUNTER = SHGLOBALCOUNTER(22i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_H: SHGLOBALCOUNTER = SHGLOBALCOUNTER(23i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_I: SHGLOBALCOUNTER = SHGLOBALCOUNTER(24i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_J: SHGLOBALCOUNTER = SHGLOBALCOUNTER(25i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_K: SHGLOBALCOUNTER = SHGLOBALCOUNTER(26i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_L: SHGLOBALCOUNTER = SHGLOBALCOUNTER(27i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_M: SHGLOBALCOUNTER = SHGLOBALCOUNTER(28i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_N: SHGLOBALCOUNTER = SHGLOBALCOUNTER(29i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_O: SHGLOBALCOUNTER = SHGLOBALCOUNTER(30i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_P: SHGLOBALCOUNTER = SHGLOBALCOUNTER(31i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Q: SHGLOBALCOUNTER = SHGLOBALCOUNTER(32i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_R: SHGLOBALCOUNTER = SHGLOBALCOUNTER(33i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_S: SHGLOBALCOUNTER = SHGLOBALCOUNTER(34i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_T: SHGLOBALCOUNTER = SHGLOBALCOUNTER(35i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_U: SHGLOBALCOUNTER = SHGLOBALCOUNTER(36i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_V: SHGLOBALCOUNTER = SHGLOBALCOUNTER(37i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_W: SHGLOBALCOUNTER = SHGLOBALCOUNTER(38i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_X: SHGLOBALCOUNTER = SHGLOBALCOUNTER(39i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Y: SHGLOBALCOUNTER = SHGLOBALCOUNTER(40i32);
pub const GLOBALCOUNTER_RECYCLEDIRTYCOUNT_DRIVE_Z: SHGLOBALCOUNTER = SHGLOBALCOUNTER(41i32);
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEDIRTYCOUNT_SERVERDRIVE: SHGLOBALCOUNTER =
    SHGLOBALCOUNTER(42i32);
pub const __UNUSED_RECYCLE_WAS_GLOBALCOUNTER_RECYCLEGLOBALDIRTYCOUNT: SHGLOBALCOUNTER =
    SHGLOBALCOUNTER(43i32);
pub const GLOBALCOUNTER_RECYCLEBINENUM: SHGLOBALCOUNTER = SHGLOBALCOUNTER(44i32);
pub const GLOBALCOUNTER_RECYCLEBINCORRUPTED: SHGLOBALCOUNTER = SHGLOBALCOUNTER(45i32);
pub const GLOBALCOUNTER_RATINGS_STATECOUNTER: SHGLOBALCOUNTER = SHGLOBALCOUNTER(46i32);
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(47i32);
pub const GLOBALCOUNTER_INTERNETTOOLBAR_LAYOUT: SHGLOBALCOUNTER = SHGLOBALCOUNTER(48i32);
pub const GLOBALCOUNTER_FOLDERDEFINITION_CACHE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(49i32);
pub const GLOBALCOUNTER_COMMONPLACES_LIST_CACHE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(50i32);
pub const GLOBALCOUNTER_PRIVATE_PROFILE_CACHE_MACHINEWIDE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(51i32);
pub const GLOBALCOUNTER_ASSOCCHANGED: SHGLOBALCOUNTER = SHGLOBALCOUNTER(52i32);
pub const GLOBALCOUNTER_APP_ITEMS_STATE_STORE_CACHE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(53i32);
pub const GLOBALCOUNTER_SETTINGSYNC_ENABLED: SHGLOBALCOUNTER = SHGLOBALCOUNTER(54i32);
pub const GLOBALCOUNTER_APPSFOLDER_FILETYPEASSOCIATION_COUNTER: SHGLOBALCOUNTER =
    SHGLOBALCOUNTER(55i32);
pub const GLOBALCOUNTER_USERINFOCHANGED: SHGLOBALCOUNTER = SHGLOBALCOUNTER(56i32);
pub const GLOBALCOUNTER_SYNC_ENGINE_INFORMATION_CACHE_MACHINEWIDE: SHGLOBALCOUNTER =
    SHGLOBALCOUNTER(57i32);
pub const GLOBALCOUNTER_BANNERS_DATAMODEL_CACHE_MACHINEWIDE: SHGLOBALCOUNTER =
    SHGLOBALCOUNTER(58i32);
pub const GLOBALCOUNTER_MAXIMUMVALUE: SHGLOBALCOUNTER = SHGLOBALCOUNTER(59i32);
impl ::core::marker::Copy for SHGLOBALCOUNTER {}
impl ::core::clone::Clone for SHGLOBALCOUNTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHGLOBALCOUNTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHGLOBALCOUNTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHGLOBALCOUNTER").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHGLOBALCOUNTER {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SHGNLI_NOLNK: u64 = 8u64;
pub const SHGNLI_NOLOCNAME: u64 = 16u64;
pub const SHGNLI_NOUNIQUE: u64 = 4u64;
pub const SHGNLI_PIDL: u64 = 1u64;
pub const SHGNLI_PREFIXNAME: u64 = 2u64;
pub const SHGNLI_USEURLEXT: u64 = 32u64;
pub const SHGSI_ICONLOCATION: u32 = 0u32;
pub const SHGVSPB_ALLFOLDERS: u32 = 8u32;
pub const SHGVSPB_ALLUSERS: u32 = 2u32;
pub const SHGVSPB_INHERIT: u32 = 16u32;
pub const SHGVSPB_NOAUTODEFAULTS: u32 = 2147483648u32;
pub const SHGVSPB_PERFOLDER: u32 = 4u32;
pub const SHGVSPB_PERUSER: u32 = 1u32;
pub const SHGVSPB_ROAM: u32 = 32u32;
pub const SHHLNF_NOAUTOSELECT: u32 = 67108864u32;
pub const SHHLNF_WRITENOHISTORY: u32 = 134217728u32;
pub const SHIL_EXTRALARGE: u32 = 2u32;
pub const SHIL_JUMBO: u32 = 4u32;
pub const SHIL_LARGE: u32 = 0u32;
pub const SHIL_LAST: u32 = 4u32;
pub const SHIL_SMALL: u32 = 1u32;
pub const SHIL_SYSSMALL: u32 = 3u32;
pub const SHIMGDEC_DEFAULT: u32 = 0u32;
pub const SHIMGDEC_LOADFULL: u32 = 2u32;
pub const SHIMGDEC_THUMBNAIL: u32 = 1u32;
pub const SHIMGKEY_QUALITY: &'static str = "Compression";
pub const SHIMGKEY_RAWFORMAT: &'static str = "RawDataFormat";
pub const SHIMSTCAPFLAG_LOCKABLE: u32 = 1u32;
pub const SHIMSTCAPFLAG_PURGEABLE: u32 = 2u32;
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHNAMEMAPPINGA {
    pub pszOldPath: PSTR,
    pub pszNewPath: PSTR,
    pub cchOldPath: i32,
    pub cchNewPath: i32,
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHNAMEMAPPINGA {}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHNAMEMAPPINGA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHNAMEMAPPINGA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHNAMEMAPPINGA")
            .field("pszOldPath", &self.pszOldPath)
            .field("pszNewPath", &self.pszNewPath)
            .field("cchOldPath", &self.cchOldPath)
            .field("cchNewPath", &self.cchNewPath)
            .finish()
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHNAMEMAPPINGA {
    fn eq(&self, other: &Self) -> bool {
        self.pszOldPath == other.pszOldPath
            && self.pszNewPath == other.pszNewPath
            && self.cchOldPath == other.cchOldPath
            && self.cchNewPath == other.cchNewPath
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHNAMEMAPPINGA {}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHNAMEMAPPINGA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_pszOldPath = <PSTR as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszNewPath = <PSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cchOldPath = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_cchNewPath = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            pszOldPath: f_pszOldPath,
            pszNewPath: f_pszNewPath,
            cchOldPath: f_cchOldPath,
            cchNewPath: f_cchNewPath,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.pszOldPath, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszNewPath, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cchOldPath, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.cchNewPath, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct SHNAMEMAPPINGA {
    pub pszOldPath: PSTR,
    pub pszNewPath: PSTR,
    pub cchOldPath: i32,
    pub cchNewPath: i32,
}
impl ::core::marker::Copy for SHNAMEMAPPINGA {}
impl ::core::clone::Clone for SHNAMEMAPPINGA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHNAMEMAPPINGA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHNAMEMAPPINGA")
            .field("pszOldPath", &self.pszOldPath)
            .field("pszNewPath", &self.pszNewPath)
            .field("cchOldPath", &self.cchOldPath)
            .field("cchNewPath", &self.cchNewPath)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHNAMEMAPPINGA {
    fn eq(&self, other: &Self) -> bool {
        self.pszOldPath == other.pszOldPath
            && self.pszNewPath == other.pszNewPath
            && self.cchOldPath == other.cchOldPath
            && self.cchNewPath == other.cchNewPath
    }
}
impl ::core::cmp::Eq for SHNAMEMAPPINGA {}
impl FromIntoMemory for SHNAMEMAPPINGA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_pszOldPath = <PSTR as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszNewPath = <PSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cchOldPath = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_cchNewPath = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            pszOldPath: f_pszOldPath,
            pszNewPath: f_pszNewPath,
            cchOldPath: f_cchOldPath,
            cchNewPath: f_cchNewPath,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.pszOldPath, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszNewPath, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cchOldPath, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.cchNewPath, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHNAMEMAPPINGW {
    pub pszOldPath: PWSTR,
    pub pszNewPath: PWSTR,
    pub cchOldPath: i32,
    pub cchNewPath: i32,
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHNAMEMAPPINGW {}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHNAMEMAPPINGW {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHNAMEMAPPINGW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHNAMEMAPPINGW")
            .field("pszOldPath", &self.pszOldPath)
            .field("pszNewPath", &self.pszNewPath)
            .field("cchOldPath", &self.cchOldPath)
            .field("cchNewPath", &self.cchNewPath)
            .finish()
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHNAMEMAPPINGW {
    fn eq(&self, other: &Self) -> bool {
        self.pszOldPath == other.pszOldPath
            && self.pszNewPath == other.pszNewPath
            && self.cchOldPath == other.cchOldPath
            && self.cchNewPath == other.cchNewPath
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHNAMEMAPPINGW {}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHNAMEMAPPINGW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_pszOldPath = <PWSTR as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszNewPath = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cchOldPath = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_cchNewPath = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            pszOldPath: f_pszOldPath,
            pszNewPath: f_pszNewPath,
            cchOldPath: f_cchOldPath,
            cchNewPath: f_cchNewPath,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.pszOldPath, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszNewPath, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cchOldPath, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.cchNewPath, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct SHNAMEMAPPINGW {
    pub pszOldPath: PWSTR,
    pub pszNewPath: PWSTR,
    pub cchOldPath: i32,
    pub cchNewPath: i32,
}
impl ::core::marker::Copy for SHNAMEMAPPINGW {}
impl ::core::clone::Clone for SHNAMEMAPPINGW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHNAMEMAPPINGW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHNAMEMAPPINGW")
            .field("pszOldPath", &self.pszOldPath)
            .field("pszNewPath", &self.pszNewPath)
            .field("cchOldPath", &self.cchOldPath)
            .field("cchNewPath", &self.cchNewPath)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHNAMEMAPPINGW {
    fn eq(&self, other: &Self) -> bool {
        self.pszOldPath == other.pszOldPath
            && self.pszNewPath == other.pszNewPath
            && self.cchOldPath == other.cchOldPath
            && self.cchNewPath == other.cchNewPath
    }
}
impl ::core::cmp::Eq for SHNAMEMAPPINGW {}
impl FromIntoMemory for SHNAMEMAPPINGW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_pszOldPath = <PWSTR as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pszNewPath = <PWSTR as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_cchOldPath = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_cchNewPath = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            pszOldPath: f_pszOldPath,
            pszNewPath: f_pszNewPath,
            cchOldPath: f_cchOldPath,
            cchNewPath: f_cchNewPath,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.pszOldPath, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pszNewPath, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.cchOldPath, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.cchNewPath, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHOP_TYPE(pub i32);
pub const SHOP_PRINTERNAME: SHOP_TYPE = SHOP_TYPE(1i32);
pub const SHOP_FILEPATH: SHOP_TYPE = SHOP_TYPE(2i32);
pub const SHOP_VOLUMEGUID: SHOP_TYPE = SHOP_TYPE(4i32);
impl ::core::marker::Copy for SHOP_TYPE {}
impl ::core::clone::Clone for SHOP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHOP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHOP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHOP_TYPE").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SHOP_TYPE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SHOP_TYPE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SHOP_TYPE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SHOP_TYPE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SHOP_TYPE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SHOP_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SHPPFW_ASKDIRCREATE: u32 = 2u32;
pub const SHPPFW_DIRCREATE: u32 = 1u32;
pub const SHPPFW_IGNOREFILENAME: u32 = 4u32;
pub const SHPPFW_MEDIACHECKONLY: u32 = 16u32;
pub const SHPPFW_NONE: u32 = 0u32;
pub const SHPPFW_NOWRITECHECK: u32 = 8u32;
pub const SHPWHF_ANYLOCATION: u32 = 256u32;
pub const SHPWHF_NOFILESELECTOR: u32 = 4u32;
pub const SHPWHF_NONETPLACECREATE: u32 = 2u32;
pub const SHPWHF_NORECOMPRESS: u32 = 1u32;
pub const SHPWHF_USEMRU: u32 = 8u32;
pub const SHPWHF_VALIDATEVIAWEBFOLDERS: u32 = 65536u32;
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHQUERYRBINFO {
    pub cbSize: u32,
    pub i64Size: i64,
    pub i64NumItems: i64,
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHQUERYRBINFO {}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHQUERYRBINFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHQUERYRBINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHQUERYRBINFO")
            .field("cbSize", &self.cbSize)
            .field("i64Size", &self.i64Size)
            .field("i64NumItems", &self.i64NumItems)
            .finish()
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHQUERYRBINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.i64Size == other.i64Size
            && self.i64NumItems == other.i64NumItems
    }
}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHQUERYRBINFO {}
#[doc = "*Required namespaces: *"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHQUERYRBINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_i64Size = <i64 as FromIntoMemory>::from_bytes(&from[8..8 + 8]);
        let f_i64NumItems = <i64 as FromIntoMemory>::from_bytes(&from[16..16 + 8]);
        Self {
            cbSize: f_cbSize,
            i64Size: f_i64Size,
            i64NumItems: f_i64NumItems,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.i64Size, &mut into[8..8 + 8]);
        FromIntoMemory::into_bytes(self.i64NumItems, &mut into[16..16 + 8]);
    }
    fn size() -> usize {
        24
    }
}
pub struct SHQUERYRBINFO {
    pub cbSize: u32,
    pub i64Size: i64,
    pub i64NumItems: i64,
}
impl ::core::marker::Copy for SHQUERYRBINFO {}
impl ::core::clone::Clone for SHQUERYRBINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHQUERYRBINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHQUERYRBINFO")
            .field("cbSize", &self.cbSize)
            .field("i64Size", &self.i64Size)
            .field("i64NumItems", &self.i64NumItems)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHQUERYRBINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.i64Size == other.i64Size
            && self.i64NumItems == other.i64NumItems
    }
}
impl ::core::cmp::Eq for SHQUERYRBINFO {}
impl FromIntoMemory for SHQUERYRBINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 20);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_i64Size = <i64 as FromIntoMemory>::from_bytes(&from[4..4 + 8]);
        let f_i64NumItems = <i64 as FromIntoMemory>::from_bytes(&from[12..12 + 8]);
        Self {
            cbSize: f_cbSize,
            i64Size: f_i64Size,
            i64NumItems: f_i64NumItems,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 20);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.i64Size, &mut into[4..4 + 8]);
        FromIntoMemory::into_bytes(self.i64NumItems, &mut into[12..12 + 8]);
    }
    fn size() -> usize {
        20
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHREGDEL_FLAGS(pub i32);
pub const SHREGDEL_DEFAULT: SHREGDEL_FLAGS = SHREGDEL_FLAGS(0i32);
pub const SHREGDEL_HKCU: SHREGDEL_FLAGS = SHREGDEL_FLAGS(1i32);
pub const SHREGDEL_HKLM: SHREGDEL_FLAGS = SHREGDEL_FLAGS(16i32);
pub const SHREGDEL_BOTH: SHREGDEL_FLAGS = SHREGDEL_FLAGS(17i32);
impl ::core::marker::Copy for SHREGDEL_FLAGS {}
impl ::core::clone::Clone for SHREGDEL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHREGDEL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHREGDEL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHREGDEL_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHREGDEL_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHREGENUM_FLAGS(pub i32);
pub const SHREGENUM_DEFAULT: SHREGENUM_FLAGS = SHREGENUM_FLAGS(0i32);
pub const SHREGENUM_HKCU: SHREGENUM_FLAGS = SHREGENUM_FLAGS(1i32);
pub const SHREGENUM_HKLM: SHREGENUM_FLAGS = SHREGENUM_FLAGS(16i32);
pub const SHREGENUM_BOTH: SHREGENUM_FLAGS = SHREGENUM_FLAGS(17i32);
impl ::core::marker::Copy for SHREGENUM_FLAGS {}
impl ::core::clone::Clone for SHREGENUM_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHREGENUM_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHREGENUM_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHREGENUM_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHREGENUM_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SHREGSET_FORCE_HKCU: u32 = 2u32;
pub const SHREGSET_FORCE_HKLM: u32 = 8u32;
pub const SHREGSET_HKCU: u32 = 1u32;
pub const SHREGSET_HKLM: u32 = 4u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SHSTOCKICONID(pub i32);
pub const SIID_DOCNOASSOC: SHSTOCKICONID = SHSTOCKICONID(0i32);
pub const SIID_DOCASSOC: SHSTOCKICONID = SHSTOCKICONID(1i32);
pub const SIID_APPLICATION: SHSTOCKICONID = SHSTOCKICONID(2i32);
pub const SIID_FOLDER: SHSTOCKICONID = SHSTOCKICONID(3i32);
pub const SIID_FOLDEROPEN: SHSTOCKICONID = SHSTOCKICONID(4i32);
pub const SIID_DRIVE525: SHSTOCKICONID = SHSTOCKICONID(5i32);
pub const SIID_DRIVE35: SHSTOCKICONID = SHSTOCKICONID(6i32);
pub const SIID_DRIVEREMOVE: SHSTOCKICONID = SHSTOCKICONID(7i32);
pub const SIID_DRIVEFIXED: SHSTOCKICONID = SHSTOCKICONID(8i32);
pub const SIID_DRIVENET: SHSTOCKICONID = SHSTOCKICONID(9i32);
pub const SIID_DRIVENETDISABLED: SHSTOCKICONID = SHSTOCKICONID(10i32);
pub const SIID_DRIVECD: SHSTOCKICONID = SHSTOCKICONID(11i32);
pub const SIID_DRIVERAM: SHSTOCKICONID = SHSTOCKICONID(12i32);
pub const SIID_WORLD: SHSTOCKICONID = SHSTOCKICONID(13i32);
pub const SIID_SERVER: SHSTOCKICONID = SHSTOCKICONID(15i32);
pub const SIID_PRINTER: SHSTOCKICONID = SHSTOCKICONID(16i32);
pub const SIID_MYNETWORK: SHSTOCKICONID = SHSTOCKICONID(17i32);
pub const SIID_FIND: SHSTOCKICONID = SHSTOCKICONID(22i32);
pub const SIID_HELP: SHSTOCKICONID = SHSTOCKICONID(23i32);
pub const SIID_SHARE: SHSTOCKICONID = SHSTOCKICONID(28i32);
pub const SIID_LINK: SHSTOCKICONID = SHSTOCKICONID(29i32);
pub const SIID_SLOWFILE: SHSTOCKICONID = SHSTOCKICONID(30i32);
pub const SIID_RECYCLER: SHSTOCKICONID = SHSTOCKICONID(31i32);
pub const SIID_RECYCLERFULL: SHSTOCKICONID = SHSTOCKICONID(32i32);
pub const SIID_MEDIACDAUDIO: SHSTOCKICONID = SHSTOCKICONID(40i32);
pub const SIID_LOCK: SHSTOCKICONID = SHSTOCKICONID(47i32);
pub const SIID_AUTOLIST: SHSTOCKICONID = SHSTOCKICONID(49i32);
pub const SIID_PRINTERNET: SHSTOCKICONID = SHSTOCKICONID(50i32);
pub const SIID_SERVERSHARE: SHSTOCKICONID = SHSTOCKICONID(51i32);
pub const SIID_PRINTERFAX: SHSTOCKICONID = SHSTOCKICONID(52i32);
pub const SIID_PRINTERFAXNET: SHSTOCKICONID = SHSTOCKICONID(53i32);
pub const SIID_PRINTERFILE: SHSTOCKICONID = SHSTOCKICONID(54i32);
pub const SIID_STACK: SHSTOCKICONID = SHSTOCKICONID(55i32);
pub const SIID_MEDIASVCD: SHSTOCKICONID = SHSTOCKICONID(56i32);
pub const SIID_STUFFEDFOLDER: SHSTOCKICONID = SHSTOCKICONID(57i32);
pub const SIID_DRIVEUNKNOWN: SHSTOCKICONID = SHSTOCKICONID(58i32);
pub const SIID_DRIVEDVD: SHSTOCKICONID = SHSTOCKICONID(59i32);
pub const SIID_MEDIADVD: SHSTOCKICONID = SHSTOCKICONID(60i32);
pub const SIID_MEDIADVDRAM: SHSTOCKICONID = SHSTOCKICONID(61i32);
pub const SIID_MEDIADVDRW: SHSTOCKICONID = SHSTOCKICONID(62i32);
pub const SIID_MEDIADVDR: SHSTOCKICONID = SHSTOCKICONID(63i32);
pub const SIID_MEDIADVDROM: SHSTOCKICONID = SHSTOCKICONID(64i32);
pub const SIID_MEDIACDAUDIOPLUS: SHSTOCKICONID = SHSTOCKICONID(65i32);
pub const SIID_MEDIACDRW: SHSTOCKICONID = SHSTOCKICONID(66i32);
pub const SIID_MEDIACDR: SHSTOCKICONID = SHSTOCKICONID(67i32);
pub const SIID_MEDIACDBURN: SHSTOCKICONID = SHSTOCKICONID(68i32);
pub const SIID_MEDIABLANKCD: SHSTOCKICONID = SHSTOCKICONID(69i32);
pub const SIID_MEDIACDROM: SHSTOCKICONID = SHSTOCKICONID(70i32);
pub const SIID_AUDIOFILES: SHSTOCKICONID = SHSTOCKICONID(71i32);
pub const SIID_IMAGEFILES: SHSTOCKICONID = SHSTOCKICONID(72i32);
pub const SIID_VIDEOFILES: SHSTOCKICONID = SHSTOCKICONID(73i32);
pub const SIID_MIXEDFILES: SHSTOCKICONID = SHSTOCKICONID(74i32);
pub const SIID_FOLDERBACK: SHSTOCKICONID = SHSTOCKICONID(75i32);
pub const SIID_FOLDERFRONT: SHSTOCKICONID = SHSTOCKICONID(76i32);
pub const SIID_SHIELD: SHSTOCKICONID = SHSTOCKICONID(77i32);
pub const SIID_WARNING: SHSTOCKICONID = SHSTOCKICONID(78i32);
pub const SIID_INFO: SHSTOCKICONID = SHSTOCKICONID(79i32);
pub const SIID_ERROR: SHSTOCKICONID = SHSTOCKICONID(80i32);
pub const SIID_KEY: SHSTOCKICONID = SHSTOCKICONID(81i32);
pub const SIID_SOFTWARE: SHSTOCKICONID = SHSTOCKICONID(82i32);
pub const SIID_RENAME: SHSTOCKICONID = SHSTOCKICONID(83i32);
pub const SIID_DELETE: SHSTOCKICONID = SHSTOCKICONID(84i32);
pub const SIID_MEDIAAUDIODVD: SHSTOCKICONID = SHSTOCKICONID(85i32);
pub const SIID_MEDIAMOVIEDVD: SHSTOCKICONID = SHSTOCKICONID(86i32);
pub const SIID_MEDIAENHANCEDCD: SHSTOCKICONID = SHSTOCKICONID(87i32);
pub const SIID_MEDIAENHANCEDDVD: SHSTOCKICONID = SHSTOCKICONID(88i32);
pub const SIID_MEDIAHDDVD: SHSTOCKICONID = SHSTOCKICONID(89i32);
pub const SIID_MEDIABLURAY: SHSTOCKICONID = SHSTOCKICONID(90i32);
pub const SIID_MEDIAVCD: SHSTOCKICONID = SHSTOCKICONID(91i32);
pub const SIID_MEDIADVDPLUSR: SHSTOCKICONID = SHSTOCKICONID(92i32);
pub const SIID_MEDIADVDPLUSRW: SHSTOCKICONID = SHSTOCKICONID(93i32);
pub const SIID_DESKTOPPC: SHSTOCKICONID = SHSTOCKICONID(94i32);
pub const SIID_MOBILEPC: SHSTOCKICONID = SHSTOCKICONID(95i32);
pub const SIID_USERS: SHSTOCKICONID = SHSTOCKICONID(96i32);
pub const SIID_MEDIASMARTMEDIA: SHSTOCKICONID = SHSTOCKICONID(97i32);
pub const SIID_MEDIACOMPACTFLASH: SHSTOCKICONID = SHSTOCKICONID(98i32);
pub const SIID_DEVICECELLPHONE: SHSTOCKICONID = SHSTOCKICONID(99i32);
pub const SIID_DEVICECAMERA: SHSTOCKICONID = SHSTOCKICONID(100i32);
pub const SIID_DEVICEVIDEOCAMERA: SHSTOCKICONID = SHSTOCKICONID(101i32);
pub const SIID_DEVICEAUDIOPLAYER: SHSTOCKICONID = SHSTOCKICONID(102i32);
pub const SIID_NETWORKCONNECT: SHSTOCKICONID = SHSTOCKICONID(103i32);
pub const SIID_INTERNET: SHSTOCKICONID = SHSTOCKICONID(104i32);
pub const SIID_ZIPFILE: SHSTOCKICONID = SHSTOCKICONID(105i32);
pub const SIID_SETTINGS: SHSTOCKICONID = SHSTOCKICONID(106i32);
pub const SIID_DRIVEHDDVD: SHSTOCKICONID = SHSTOCKICONID(132i32);
pub const SIID_DRIVEBD: SHSTOCKICONID = SHSTOCKICONID(133i32);
pub const SIID_MEDIAHDDVDROM: SHSTOCKICONID = SHSTOCKICONID(134i32);
pub const SIID_MEDIAHDDVDR: SHSTOCKICONID = SHSTOCKICONID(135i32);
pub const SIID_MEDIAHDDVDRAM: SHSTOCKICONID = SHSTOCKICONID(136i32);
pub const SIID_MEDIABDROM: SHSTOCKICONID = SHSTOCKICONID(137i32);
pub const SIID_MEDIABDR: SHSTOCKICONID = SHSTOCKICONID(138i32);
pub const SIID_MEDIABDRE: SHSTOCKICONID = SHSTOCKICONID(139i32);
pub const SIID_CLUSTEREDDRIVE: SHSTOCKICONID = SHSTOCKICONID(140i32);
pub const SIID_MAX_ICONS: SHSTOCKICONID = SHSTOCKICONID(181i32);
impl ::core::marker::Copy for SHSTOCKICONID {}
impl ::core::clone::Clone for SHSTOCKICONID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHSTOCKICONID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SHSTOCKICONID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHSTOCKICONID").field(&self.0).finish()
    }
}
impl FromIntoMemory for SHSTOCKICONID {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SHSTOCKICONINFO {
    pub cbSize: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub iSysImageIndex: i32,
    pub iIcon: i32,
    pub szPath: [u16; 260],
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SHSTOCKICONINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SHSTOCKICONINFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SHSTOCKICONINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHSTOCKICONINFO")
            .field("cbSize", &self.cbSize)
            .field("hIcon", &self.hIcon)
            .field("iSysImageIndex", &self.iSysImageIndex)
            .field("iIcon", &self.iIcon)
            .field("szPath", &self.szPath)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SHSTOCKICONINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hIcon == other.hIcon
            && self.iSysImageIndex == other.iSysImageIndex
            && self.iIcon == other.iIcon
            && self.szPath == other.szPath
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SHSTOCKICONINFO {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SHSTOCKICONINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 276);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_iSysImageIndex = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_iIcon = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_szPath = <[u16; 260] as FromIntoMemory>::from_bytes(&from[16..16 + 260]);
        Self {
            cbSize: f_cbSize,
            hIcon: f_hIcon,
            iSysImageIndex: f_iSysImageIndex,
            iIcon: f_iIcon,
            szPath: f_szPath,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 276);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.iSysImageIndex, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.iIcon, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.szPath, &mut into[16..16 + 260]);
    }
    fn size() -> usize {
        276
    }
}
pub struct SHSTOCKICONINFO {
    pub cbSize: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub iSysImageIndex: i32,
    pub iIcon: i32,
    pub szPath: [u16; 260],
}
impl ::core::marker::Copy for SHSTOCKICONINFO {}
impl ::core::clone::Clone for SHSTOCKICONINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHSTOCKICONINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHSTOCKICONINFO")
            .field("cbSize", &self.cbSize)
            .field("hIcon", &self.hIcon)
            .field("iSysImageIndex", &self.iSysImageIndex)
            .field("iIcon", &self.iIcon)
            .field("szPath", &self.szPath)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SHSTOCKICONINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hIcon == other.hIcon
            && self.iSysImageIndex == other.iSysImageIndex
            && self.iIcon == other.iIcon
            && self.szPath == other.szPath
    }
}
impl ::core::cmp::Eq for SHSTOCKICONINFO {}
impl FromIntoMemory for SHSTOCKICONINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 276);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_iSysImageIndex = <i32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_iIcon = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_szPath = <[u16; 260] as FromIntoMemory>::from_bytes(&from[16..16 + 260]);
        Self {
            cbSize: f_cbSize,
            hIcon: f_hIcon,
            iSysImageIndex: f_iSysImageIndex,
            iIcon: f_iIcon,
            szPath: f_szPath,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 276);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.iSysImageIndex, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.iIcon, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.szPath, &mut into[16..16 + 260]);
    }
    fn size() -> usize {
        276
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SIATTRIBFLAGS(pub i32);
pub const SIATTRIBFLAGS_AND: SIATTRIBFLAGS = SIATTRIBFLAGS(1i32);
pub const SIATTRIBFLAGS_OR: SIATTRIBFLAGS = SIATTRIBFLAGS(2i32);
pub const SIATTRIBFLAGS_APPCOMPAT: SIATTRIBFLAGS = SIATTRIBFLAGS(3i32);
pub const SIATTRIBFLAGS_MASK: SIATTRIBFLAGS = SIATTRIBFLAGS(3i32);
pub const SIATTRIBFLAGS_ALLITEMS: SIATTRIBFLAGS = SIATTRIBFLAGS(16384i32);
impl ::core::marker::Copy for SIATTRIBFLAGS {}
impl ::core::clone::Clone for SIATTRIBFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SIATTRIBFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SIATTRIBFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SIATTRIBFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SIATTRIBFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SID_CommandsPropertyBag: crate::core::GUID =
    crate::core::GUID::from_u128(0x6e043250_4416_485c_b143_e62a760d9fe5);
pub const SID_CtxQueryAssociations: crate::core::GUID =
    crate::core::GUID::from_u128(0xfaadfc40_b777_4b69_aa81_77035ef0e6e8);
pub const SID_DefView: crate::core::GUID =
    crate::core::GUID::from_u128(0x6d12fe80_7911_11cf_9534_0000c05bae0b);
pub const SID_LaunchSourceAppUserModelId: crate::core::GUID =
    crate::core::GUID::from_u128(0x2ce78010_74db_48bc_9c6a_10f372495723);
pub const SID_LaunchSourceViewSizePreference: crate::core::GUID =
    crate::core::GUID::from_u128(0x80605492_67d9_414f_af89_a1cdf1242bc1);
pub const SID_LaunchTargetViewSizePreference: crate::core::GUID =
    crate::core::GUID::from_u128(0x26db2472_b7b7_406b_9702_730a4e20d3bf);
pub const SID_MenuShellFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0xa6c17eb4_2d65_11d2_838f_00c04fd918d0);
pub const SID_SCommDlgBrowser: crate::core::GUID =
    crate::core::GUID::from_u128(0x80f30233_b7df_11d2_a33b_006097df5bd4);
pub const SID_SCommandBarState: crate::core::GUID =
    crate::core::GUID::from_u128(0xb99eaa5c_3850_4400_bc33_2ce534048bf8);
pub const SID_SGetViewFromViewDual: crate::core::GUID =
    crate::core::GUID::from_u128(0x889a935d_971e_4b12_b90c_24dfc9e1e5e8);
pub const SID_SInPlaceBrowser: crate::core::GUID =
    crate::core::GUID::from_u128(0x1d2ae02b_3655_46cc_b63a_285988153bca);
pub const SID_SMenuBandBKContextMenu: crate::core::GUID =
    crate::core::GUID::from_u128(0x164bbd86_1d0d_4de0_9a3b_d9729647c2b8);
pub const SID_SMenuBandBottom: crate::core::GUID =
    crate::core::GUID::from_u128(0x743ca664_0deb_11d1_9825_00c04fd91972);
pub const SID_SMenuBandBottomSelected: crate::core::GUID =
    crate::core::GUID::from_u128(0x165ebaf4_6d51_11d2_83ad_00c04fd918d0);
pub const SID_SMenuBandChild: crate::core::GUID =
    crate::core::GUID::from_u128(0xed9cc020_08b9_11d1_9823_00c04fd91972);
pub const SID_SMenuBandContextMenuModifier: crate::core::GUID =
    crate::core::GUID::from_u128(0x39545874_7162_465e_b783_2aa1874fef81);
pub const SID_SMenuBandParent: crate::core::GUID =
    crate::core::GUID::from_u128(0x8c278eec_3eab_11d1_8cb0_00c04fd918d0);
pub const SID_SMenuBandTop: crate::core::GUID =
    crate::core::GUID::from_u128(0x9493a810_ec38_11d0_bc46_00aa006ce2f5);
pub const SID_SMenuPopup: crate::core::GUID =
    crate::core::GUID::from_u128(0xd1e7afeb_6a2e_11d0_8c78_00c04fd918b4);
pub const SID_SSearchBoxInfo: crate::core::GUID =
    crate::core::GUID::from_u128(0x142daa61_516b_4713_b49c_fb985ef82998);
pub const SID_STopLevelBrowser: crate::core::GUID =
    crate::core::GUID::from_u128(0x4c96be40_915c_11cf_99d3_00aa004ae837);
pub const SID_STopWindow: crate::core::GUID =
    crate::core::GUID::from_u128(0x49e1b500_4636_11d3_97f7_00c04f45d0b3);
pub const SID_ShellExecuteNamedPropertyStore: crate::core::GUID =
    crate::core::GUID::from_u128(0xeb84ada2_00ff_4992_8324_ed5ce061cb29);
pub const SID_URLExecutionContext: crate::core::GUID =
    crate::core::GUID::from_u128(0xfb5f8ebc_bbb6_4d10_a461_777291a09030);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SIGDN(pub i32);
pub const SIGDN_NORMALDISPLAY: SIGDN = SIGDN(0i32);
pub const SIGDN_PARENTRELATIVEPARSING: SIGDN = SIGDN(-2147385343i32);
pub const SIGDN_DESKTOPABSOLUTEPARSING: SIGDN = SIGDN(-2147319808i32);
pub const SIGDN_PARENTRELATIVEEDITING: SIGDN = SIGDN(-2147282943i32);
pub const SIGDN_DESKTOPABSOLUTEEDITING: SIGDN = SIGDN(-2147172352i32);
pub const SIGDN_FILESYSPATH: SIGDN = SIGDN(-2147123200i32);
pub const SIGDN_URL: SIGDN = SIGDN(-2147057664i32);
pub const SIGDN_PARENTRELATIVEFORADDRESSBAR: SIGDN = SIGDN(-2146975743i32);
pub const SIGDN_PARENTRELATIVE: SIGDN = SIGDN(-2146959359i32);
pub const SIGDN_PARENTRELATIVEFORUI: SIGDN = SIGDN(-2146877439i32);
impl ::core::marker::Copy for SIGDN {}
impl ::core::clone::Clone for SIGDN {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SIGDN {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SIGDN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SIGDN").field(&self.0).finish()
    }
}
impl FromIntoMemory for SIGDN {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SIIGBF(pub i32);
pub const SIIGBF_RESIZETOFIT: SIIGBF = SIIGBF(0i32);
pub const SIIGBF_BIGGERSIZEOK: SIIGBF = SIIGBF(1i32);
pub const SIIGBF_MEMORYONLY: SIIGBF = SIIGBF(2i32);
pub const SIIGBF_ICONONLY: SIIGBF = SIIGBF(4i32);
pub const SIIGBF_THUMBNAILONLY: SIIGBF = SIIGBF(8i32);
pub const SIIGBF_INCACHEONLY: SIIGBF = SIIGBF(16i32);
pub const SIIGBF_CROPTOSQUARE: SIIGBF = SIIGBF(32i32);
pub const SIIGBF_WIDETHUMBNAILS: SIIGBF = SIIGBF(64i32);
pub const SIIGBF_ICONBACKGROUND: SIIGBF = SIIGBF(128i32);
pub const SIIGBF_SCALEUP: SIIGBF = SIIGBF(256i32);
impl ::core::marker::Copy for SIIGBF {}
impl ::core::clone::Clone for SIIGBF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SIIGBF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SIIGBF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SIIGBF").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SIIGBF {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SIIGBF {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SIIGBF {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SIIGBF {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SIIGBF {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SIIGBF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SIOM_ICONINDEX: u32 = 2u32;
pub const SIOM_OVERLAYINDEX: u32 = 1u32;
pub const SIOM_RESERVED_DEFAULT: u32 = 3u32;
pub const SIOM_RESERVED_LINK: u32 = 1u32;
pub const SIOM_RESERVED_SHARED: u32 = 0u32;
pub const SIOM_RESERVED_SLOWFILE: u32 = 2u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SLGP_FLAGS(pub i32);
pub const SLGP_SHORTPATH: SLGP_FLAGS = SLGP_FLAGS(1i32);
pub const SLGP_UNCPRIORITY: SLGP_FLAGS = SLGP_FLAGS(2i32);
pub const SLGP_RAWPATH: SLGP_FLAGS = SLGP_FLAGS(4i32);
pub const SLGP_RELATIVEPRIORITY: SLGP_FLAGS = SLGP_FLAGS(8i32);
impl ::core::marker::Copy for SLGP_FLAGS {}
impl ::core::clone::Clone for SLGP_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SLGP_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SLGP_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SLGP_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SLGP_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct SLOWAPPINFO {
    pub ullSize: u64,
    pub ftLastUsed: super::super::Foundation::FILETIME,
    pub iTimesUsed: i32,
    pub pszImage: PWSTR,
}
impl ::core::marker::Copy for SLOWAPPINFO {}
impl ::core::clone::Clone for SLOWAPPINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SLOWAPPINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SLOWAPPINFO")
            .field("ullSize", &self.ullSize)
            .field("ftLastUsed", &self.ftLastUsed)
            .field("iTimesUsed", &self.iTimesUsed)
            .field("pszImage", &self.pszImage)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SLOWAPPINFO {
    fn eq(&self, other: &Self) -> bool {
        self.ullSize == other.ullSize
            && self.ftLastUsed == other.ftLastUsed
            && self.iTimesUsed == other.iTimesUsed
            && self.pszImage == other.pszImage
    }
}
impl ::core::cmp::Eq for SLOWAPPINFO {}
impl FromIntoMemory for SLOWAPPINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_ullSize = <u64 as FromIntoMemory>::from_bytes(&from[0..0 + 8]);
        let f_ftLastUsed =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[8..8 + 8]);
        let f_iTimesUsed = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_pszImage = <PWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            ullSize: f_ullSize,
            ftLastUsed: f_ftLastUsed,
            iTimesUsed: f_iTimesUsed,
            pszImage: f_pszImage,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.ullSize, &mut into[0..0 + 8]);
        FromIntoMemory::into_bytes(self.ftLastUsed, &mut into[8..8 + 8]);
        FromIntoMemory::into_bytes(self.iTimesUsed, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pszImage, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SLR_FLAGS(pub i32);
pub const SLR_NONE: SLR_FLAGS = SLR_FLAGS(0i32);
pub const SLR_NO_UI: SLR_FLAGS = SLR_FLAGS(1i32);
pub const SLR_ANY_MATCH: SLR_FLAGS = SLR_FLAGS(2i32);
pub const SLR_UPDATE: SLR_FLAGS = SLR_FLAGS(4i32);
pub const SLR_NOUPDATE: SLR_FLAGS = SLR_FLAGS(8i32);
pub const SLR_NOSEARCH: SLR_FLAGS = SLR_FLAGS(16i32);
pub const SLR_NOTRACK: SLR_FLAGS = SLR_FLAGS(32i32);
pub const SLR_NOLINKINFO: SLR_FLAGS = SLR_FLAGS(64i32);
pub const SLR_INVOKE_MSI: SLR_FLAGS = SLR_FLAGS(128i32);
pub const SLR_NO_UI_WITH_MSG_PUMP: SLR_FLAGS = SLR_FLAGS(257i32);
pub const SLR_OFFER_DELETE_WITHOUT_FILE: SLR_FLAGS = SLR_FLAGS(512i32);
pub const SLR_KNOWNFOLDER: SLR_FLAGS = SLR_FLAGS(1024i32);
pub const SLR_MACHINE_IN_LOCAL_TARGET: SLR_FLAGS = SLR_FLAGS(2048i32);
pub const SLR_UPDATE_MACHINE_AND_SID: SLR_FLAGS = SLR_FLAGS(4096i32);
pub const SLR_NO_OBJECT_ID: SLR_FLAGS = SLR_FLAGS(8192i32);
impl ::core::marker::Copy for SLR_FLAGS {}
impl ::core::clone::Clone for SLR_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SLR_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SLR_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SLR_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SLR_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SMAE_CONTRACTED: u32 = 2u32;
pub const SMAE_EXPANDED: u32 = 1u32;
pub const SMAE_USER: u32 = 4u32;
pub const SMAE_VALID: u32 = 7u32;
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SMCSHCHANGENOTIFYSTRUCT {
    pub lEvent: i32,
    pub pidl1: MutPtr<Common::ITEMIDLIST>,
    pub pidl2: MutPtr<Common::ITEMIDLIST>,
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SMCSHCHANGENOTIFYSTRUCT {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SMCSHCHANGENOTIFYSTRUCT {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SMCSHCHANGENOTIFYSTRUCT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SMCSHCHANGENOTIFYSTRUCT")
            .field("lEvent", &self.lEvent)
            .field("pidl1", &self.pidl1)
            .field("pidl2", &self.pidl2)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SMCSHCHANGENOTIFYSTRUCT {
    fn eq(&self, other: &Self) -> bool {
        self.lEvent == other.lEvent && self.pidl1 == other.pidl1 && self.pidl2 == other.pidl2
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SMCSHCHANGENOTIFYSTRUCT {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SMCSHCHANGENOTIFYSTRUCT {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 12);
        let f_lEvent = <i32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_pidl1 = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pidl2 = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        Self {
            lEvent: f_lEvent,
            pidl1: f_pidl1,
            pidl2: f_pidl2,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 12);
        FromIntoMemory::into_bytes(self.lEvent, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pidl1, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pidl2, &mut into[8..8 + 4]);
    }
    fn size() -> usize {
        12
    }
}
pub const SMC_AUTOEXPANDCHANGE: u32 = 66u32;
pub const SMC_CHEVRONEXPAND: u32 = 25u32;
pub const SMC_CHEVRONGETTIP: u32 = 47u32;
pub const SMC_CREATE: u32 = 2u32;
pub const SMC_DEFAULTICON: u32 = 22u32;
pub const SMC_DEMOTE: u32 = 17u32;
pub const SMC_DISPLAYCHEVRONTIP: u32 = 42u32;
pub const SMC_EXITMENU: u32 = 3u32;
pub const SMC_GETAUTOEXPANDSTATE: u32 = 65u32;
pub const SMC_GETBKCONTEXTMENU: u32 = 68u32;
pub const SMC_GETCONTEXTMENUMODIFIER: u32 = 67u32;
pub const SMC_GETINFO: u32 = 5u32;
pub const SMC_GETOBJECT: u32 = 7u32;
pub const SMC_GETSFINFO: u32 = 6u32;
pub const SMC_GETSFOBJECT: u32 = 8u32;
pub const SMC_INITMENU: u32 = 1u32;
pub const SMC_NEWITEM: u32 = 23u32;
pub const SMC_OPEN: u32 = 69u32;
pub const SMC_PROMOTE: u32 = 18u32;
pub const SMC_REFRESH: u32 = 16u32;
pub const SMC_SETSFOBJECT: u32 = 45u32;
pub const SMC_SFDDRESTRICTED: u32 = 48u32;
pub const SMC_SFEXEC: u32 = 9u32;
pub const SMC_SFEXEC_MIDDLE: u32 = 49u32;
pub const SMC_SFSELECTITEM: u32 = 10u32;
pub const SMC_SHCHANGENOTIFY: u32 = 46u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SMDATA {
    pub dwMask: u32,
    pub dwFlags: u32,
    pub hmenu: super::WindowsAndMessaging::HMENU,
    pub hwnd: super::super::Foundation::HWND,
    pub uId: u32,
    pub uIdParent: u32,
    pub uIdAncestor: u32,
    pub punk: crate::core::IUnknown,
    pub pidlFolder: MutPtr<Common::ITEMIDLIST>,
    pub pidlItem: MutPtr<Common::ITEMIDLIST>,
    pub psf: IShellFolder,
    pub pvUserData: MutPtr<::core::ffi::c_void>,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SMDATA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SMDATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SMDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SMDATA")
            .field("dwMask", &self.dwMask)
            .field("dwFlags", &self.dwFlags)
            .field("hmenu", &self.hmenu)
            .field("hwnd", &self.hwnd)
            .field("uId", &self.uId)
            .field("uIdParent", &self.uIdParent)
            .field("uIdAncestor", &self.uIdAncestor)
            .field("punk", &self.punk)
            .field("pidlFolder", &self.pidlFolder)
            .field("pidlItem", &self.pidlItem)
            .field("psf", &self.psf)
            .field("pvUserData", &self.pvUserData)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SMDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwMask == other.dwMask
            && self.dwFlags == other.dwFlags
            && self.hmenu == other.hmenu
            && self.hwnd == other.hwnd
            && self.uId == other.uId
            && self.uIdParent == other.uIdParent
            && self.uIdAncestor == other.uIdAncestor
            && self.punk == other.punk
            && self.pidlFolder == other.pidlFolder
            && self.pidlItem == other.pidlItem
            && self.psf == other.psf
            && self.pvUserData == other.pvUserData
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SMDATA {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SMDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 48);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hmenu =
            <super::WindowsAndMessaging::HMENU as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_hwnd =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_uId = <u32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_uIdParent = <u32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_uIdAncestor = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_punk = <crate::core::IUnknown as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_pidlFolder =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[32..32 + 4]);
        let f_pidlItem =
            <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[36..36 + 4]);
        let f_psf = <IShellFolder as FromIntoMemory>::from_bytes(&from[40..40 + 4]);
        let f_pvUserData =
            <MutPtr<::core::ffi::c_void> as FromIntoMemory>::from_bytes(&from[44..44 + 4]);
        Self {
            dwMask: f_dwMask,
            dwFlags: f_dwFlags,
            hmenu: f_hmenu,
            hwnd: f_hwnd,
            uId: f_uId,
            uIdParent: f_uIdParent,
            uIdAncestor: f_uIdAncestor,
            punk: f_punk,
            pidlFolder: f_pidlFolder,
            pidlItem: f_pidlItem,
            psf: f_psf,
            pvUserData: f_pvUserData,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 48);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hmenu, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.hwnd, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.uId, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.uIdParent, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.uIdAncestor, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.punk, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.pidlFolder, &mut into[32..32 + 4]);
        FromIntoMemory::into_bytes(self.pidlItem, &mut into[36..36 + 4]);
        FromIntoMemory::into_bytes(self.psf, &mut into[40..40 + 4]);
        FromIntoMemory::into_bytes(self.pvUserData, &mut into[44..44 + 4]);
    }
    fn size() -> usize {
        48
    }
}
pub const SMDM_HMENU: u32 = 2u32;
pub const SMDM_SHELLFOLDER: u32 = 1u32;
pub const SMDM_TOOLBAR: u32 = 4u32;
pub struct SMINFO {
    pub dwMask: u32,
    pub dwType: u32,
    pub dwFlags: u32,
    pub iIcon: i32,
}
impl ::core::marker::Copy for SMINFO {}
impl ::core::clone::Clone for SMINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SMINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SMINFO")
            .field("dwMask", &self.dwMask)
            .field("dwType", &self.dwType)
            .field("dwFlags", &self.dwFlags)
            .field("iIcon", &self.iIcon)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SMINFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwMask == other.dwMask
            && self.dwType == other.dwType
            && self.dwFlags == other.dwFlags
            && self.iIcon == other.iIcon
    }
}
impl ::core::cmp::Eq for SMINFO {}
impl FromIntoMemory for SMINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwMask = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwType = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_iIcon = <i32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwMask: f_dwMask,
            dwType: f_dwType,
            dwFlags: f_dwFlags,
            iIcon: f_iIcon,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwType, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.iIcon, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SMINFOFLAGS(pub i32);
pub const SMIF_ICON: SMINFOFLAGS = SMINFOFLAGS(1i32);
pub const SMIF_ACCELERATOR: SMINFOFLAGS = SMINFOFLAGS(2i32);
pub const SMIF_DROPTARGET: SMINFOFLAGS = SMINFOFLAGS(4i32);
pub const SMIF_SUBMENU: SMINFOFLAGS = SMINFOFLAGS(8i32);
pub const SMIF_CHECKED: SMINFOFLAGS = SMINFOFLAGS(32i32);
pub const SMIF_DROPCASCADE: SMINFOFLAGS = SMINFOFLAGS(64i32);
pub const SMIF_HIDDEN: SMINFOFLAGS = SMINFOFLAGS(128i32);
pub const SMIF_DISABLED: SMINFOFLAGS = SMINFOFLAGS(256i32);
pub const SMIF_TRACKPOPUP: SMINFOFLAGS = SMINFOFLAGS(512i32);
pub const SMIF_DEMOTED: SMINFOFLAGS = SMINFOFLAGS(1024i32);
pub const SMIF_ALTSTATE: SMINFOFLAGS = SMINFOFLAGS(2048i32);
pub const SMIF_DRAGNDROP: SMINFOFLAGS = SMINFOFLAGS(4096i32);
pub const SMIF_NEW: SMINFOFLAGS = SMINFOFLAGS(8192i32);
impl ::core::marker::Copy for SMINFOFLAGS {}
impl ::core::clone::Clone for SMINFOFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SMINFOFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SMINFOFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SMINFOFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SMINFOFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SMINFOMASK(pub i32);
pub const SMIM_TYPE: SMINFOMASK = SMINFOMASK(1i32);
pub const SMIM_FLAGS: SMINFOMASK = SMINFOMASK(2i32);
pub const SMIM_ICON: SMINFOMASK = SMINFOMASK(4i32);
impl ::core::marker::Copy for SMINFOMASK {}
impl ::core::clone::Clone for SMINFOMASK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SMINFOMASK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SMINFOMASK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SMINFOMASK").field(&self.0).finish()
    }
}
impl FromIntoMemory for SMINFOMASK {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SMINFOTYPE(pub i32);
pub const SMIT_SEPARATOR: SMINFOTYPE = SMINFOTYPE(1i32);
pub const SMIT_STRING: SMINFOTYPE = SMINFOTYPE(2i32);
impl ::core::marker::Copy for SMINFOTYPE {}
impl ::core::clone::Clone for SMINFOTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SMINFOTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SMINFOTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SMINFOTYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for SMINFOTYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SMINIT_AUTOEXPAND: u32 = 256u32;
pub const SMINIT_AUTOTOOLTIP: u32 = 512u32;
pub const SMINIT_CACHED: u32 = 16u32;
pub const SMINIT_DEFAULT: u32 = 0u32;
pub const SMINIT_DROPONCONTAINER: u32 = 1024u32;
pub const SMINIT_HORIZONTAL: u32 = 536870912u32;
pub const SMINIT_RESTRICT_DRAGDROP: u32 = 2u32;
pub const SMINIT_TOPLEVEL: u32 = 4u32;
pub const SMINIT_VERTICAL: u32 = 268435456u32;
pub const SMINV_ID: u32 = 8u32;
pub const SMINV_REFRESH: u32 = 1u32;
pub const SMSET_BOTTOM: u32 = 536870912u32;
pub const SMSET_DONTOWN: u32 = 1u32;
pub const SMSET_TOP: u32 = 268435456u32;
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SORTCOLUMN {
    pub propkey: PropertiesSystem::PROPERTYKEY,
    pub direction: SORTDIRECTION,
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SORTCOLUMN {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SORTCOLUMN {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SORTCOLUMN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SORTCOLUMN")
            .field("propkey", &self.propkey)
            .field("direction", &self.direction)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SORTCOLUMN {
    fn eq(&self, other: &Self) -> bool {
        self.propkey == other.propkey && self.direction == other.direction
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SORTCOLUMN {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.PropertiesSystem'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SORTCOLUMN {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_propkey =
            <PropertiesSystem::PROPERTYKEY as FromIntoMemory>::from_bytes(&from[0..0 + 20]);
        let f_direction = <SORTDIRECTION as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            propkey: f_propkey,
            direction: f_direction,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.propkey, &mut into[0..0 + 20]);
        FromIntoMemory::into_bytes(self.direction, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SORTDIRECTION(pub i32);
pub const SORT_DESCENDING: SORTDIRECTION = SORTDIRECTION(-1i32);
pub const SORT_ASCENDING: SORTDIRECTION = SORTDIRECTION(1i32);
impl ::core::marker::Copy for SORTDIRECTION {}
impl ::core::clone::Clone for SORTDIRECTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SORTDIRECTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SORTDIRECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SORTDIRECTION").field(&self.0).finish()
    }
}
impl FromIntoMemory for SORTDIRECTION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SORT_ORDER_TYPE(pub i32);
pub const SOT_DEFAULT: SORT_ORDER_TYPE = SORT_ORDER_TYPE(0i32);
pub const SOT_IGNORE_FOLDERNESS: SORT_ORDER_TYPE = SORT_ORDER_TYPE(1i32);
impl ::core::marker::Copy for SORT_ORDER_TYPE {}
impl ::core::clone::Clone for SORT_ORDER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SORT_ORDER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SORT_ORDER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SORT_ORDER_TYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for SORT_ORDER_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SPACTION(pub i32);
pub const SPACTION_NONE: SPACTION = SPACTION(0i32);
pub const SPACTION_MOVING: SPACTION = SPACTION(1i32);
pub const SPACTION_COPYING: SPACTION = SPACTION(2i32);
pub const SPACTION_RECYCLING: SPACTION = SPACTION(3i32);
pub const SPACTION_APPLYINGATTRIBS: SPACTION = SPACTION(4i32);
pub const SPACTION_DOWNLOADING: SPACTION = SPACTION(5i32);
pub const SPACTION_SEARCHING_INTERNET: SPACTION = SPACTION(6i32);
pub const SPACTION_CALCULATING: SPACTION = SPACTION(7i32);
pub const SPACTION_UPLOADING: SPACTION = SPACTION(8i32);
pub const SPACTION_SEARCHING_FILES: SPACTION = SPACTION(9i32);
pub const SPACTION_DELETING: SPACTION = SPACTION(10i32);
pub const SPACTION_RENAMING: SPACTION = SPACTION(11i32);
pub const SPACTION_FORMATTING: SPACTION = SPACTION(12i32);
pub const SPACTION_COPY_MOVING: SPACTION = SPACTION(13i32);
impl ::core::marker::Copy for SPACTION {}
impl ::core::clone::Clone for SPACTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SPACTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SPACTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SPACTION").field(&self.0).finish()
    }
}
impl FromIntoMemory for SPACTION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SPMODE_BROWSER: u32 = 8u32;
pub const SPMODE_DBMON: u32 = 8192u32;
pub const SPMODE_DEBUGBREAK: u32 = 512u32;
pub const SPMODE_DEBUGOUT: u32 = 2u32;
pub const SPMODE_EVENT: u32 = 32u32;
pub const SPMODE_EVENTTRACE: u32 = 32768u32;
pub const SPMODE_FLUSH: u32 = 16u32;
pub const SPMODE_FORMATTEXT: u32 = 128u32;
pub const SPMODE_MEMWATCH: u32 = 4096u32;
pub const SPMODE_MSGTRACE: u32 = 1024u32;
pub const SPMODE_MSVM: u32 = 64u32;
pub const SPMODE_MULTISTOP: u32 = 16384u32;
pub const SPMODE_PERFTAGS: u32 = 2048u32;
pub const SPMODE_PROFILE: u32 = 256u32;
pub const SPMODE_SHELL: u32 = 1u32;
pub const SPMODE_TEST: u32 = 4u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SPTEXT(pub i32);
pub const SPTEXT_ACTIONDESCRIPTION: SPTEXT = SPTEXT(1i32);
pub const SPTEXT_ACTIONDETAIL: SPTEXT = SPTEXT(2i32);
impl ::core::marker::Copy for SPTEXT {}
impl ::core::clone::Clone for SPTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SPTEXT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SPTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SPTEXT").field(&self.0).finish()
    }
}
impl FromIntoMemory for SPTEXT {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SRRF_NOEXPAND: u32 = 268435456u32;
pub const SRRF_NOVIRT: u32 = 1073741824u32;
pub const SRRF_RM_ANY: u32 = 0u32;
pub const SRRF_RM_NORMAL: u32 = 65536u32;
pub const SRRF_RM_SAFE: u32 = 131072u32;
pub const SRRF_RM_SAFENETWORK: u32 = 262144u32;
pub const SRRF_RT_ANY: u32 = 65535u32;
pub const SRRF_RT_REG_BINARY: u32 = 8u32;
pub const SRRF_RT_REG_DWORD: u32 = 16u32;
pub const SRRF_RT_REG_EXPAND_SZ: u32 = 4u32;
pub const SRRF_RT_REG_MULTI_SZ: u32 = 32u32;
pub const SRRF_RT_REG_NONE: u32 = 1u32;
pub const SRRF_RT_REG_QWORD: u32 = 64u32;
pub const SRRF_RT_REG_SZ: u32 = 2u32;
pub const SRRF_ZEROONFAILURE: u32 = 536870912u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SSF_MASK(pub u32);
pub const SSF_SHOWALLOBJECTS: SSF_MASK = SSF_MASK(1u32);
pub const SSF_SHOWEXTENSIONS: SSF_MASK = SSF_MASK(2u32);
pub const SSF_HIDDENFILEEXTS: SSF_MASK = SSF_MASK(4u32);
pub const SSF_SERVERADMINUI: SSF_MASK = SSF_MASK(4u32);
pub const SSF_SHOWCOMPCOLOR: SSF_MASK = SSF_MASK(8u32);
pub const SSF_SORTCOLUMNS: SSF_MASK = SSF_MASK(16u32);
pub const SSF_SHOWSYSFILES: SSF_MASK = SSF_MASK(32u32);
pub const SSF_DOUBLECLICKINWEBVIEW: SSF_MASK = SSF_MASK(128u32);
pub const SSF_SHOWATTRIBCOL: SSF_MASK = SSF_MASK(256u32);
pub const SSF_DESKTOPHTML: SSF_MASK = SSF_MASK(512u32);
pub const SSF_WIN95CLASSIC: SSF_MASK = SSF_MASK(1024u32);
pub const SSF_DONTPRETTYPATH: SSF_MASK = SSF_MASK(2048u32);
pub const SSF_SHOWINFOTIP: SSF_MASK = SSF_MASK(8192u32);
pub const SSF_MAPNETDRVBUTTON: SSF_MASK = SSF_MASK(4096u32);
pub const SSF_NOCONFIRMRECYCLE: SSF_MASK = SSF_MASK(32768u32);
pub const SSF_HIDEICONS: SSF_MASK = SSF_MASK(16384u32);
pub const SSF_FILTER: SSF_MASK = SSF_MASK(65536u32);
pub const SSF_WEBVIEW: SSF_MASK = SSF_MASK(131072u32);
pub const SSF_SHOWSUPERHIDDEN: SSF_MASK = SSF_MASK(262144u32);
pub const SSF_SEPPROCESS: SSF_MASK = SSF_MASK(524288u32);
pub const SSF_NONETCRAWLING: SSF_MASK = SSF_MASK(1048576u32);
pub const SSF_STARTPANELON: SSF_MASK = SSF_MASK(2097152u32);
pub const SSF_SHOWSTARTPAGE: SSF_MASK = SSF_MASK(4194304u32);
pub const SSF_AUTOCHECKSELECT: SSF_MASK = SSF_MASK(8388608u32);
pub const SSF_ICONSONLY: SSF_MASK = SSF_MASK(16777216u32);
pub const SSF_SHOWTYPEOVERLAY: SSF_MASK = SSF_MASK(33554432u32);
pub const SSF_SHOWSTATUSBAR: SSF_MASK = SSF_MASK(67108864u32);
impl ::core::marker::Copy for SSF_MASK {}
impl ::core::clone::Clone for SSF_MASK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SSF_MASK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SSF_MASK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SSF_MASK").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for SSF_MASK {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for SSF_MASK {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for SSF_MASK {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for SSF_MASK {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for SSF_MASK {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for SSF_MASK {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<u32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SSM_CLEAR: u32 = 0u32;
pub const SSM_REFRESH: u32 = 2u32;
pub const SSM_SET: u32 = 1u32;
pub const SSM_UPDATE: u32 = 4u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct STGOP(pub i32);
pub const STGOP_MOVE: STGOP = STGOP(1i32);
pub const STGOP_COPY: STGOP = STGOP(2i32);
pub const STGOP_SYNC: STGOP = STGOP(3i32);
pub const STGOP_REMOVE: STGOP = STGOP(5i32);
pub const STGOP_RENAME: STGOP = STGOP(6i32);
pub const STGOP_APPLYPROPERTIES: STGOP = STGOP(8i32);
pub const STGOP_NEW: STGOP = STGOP(10i32);
impl ::core::marker::Copy for STGOP {}
impl ::core::clone::Clone for STGOP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STGOP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for STGOP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STGOP").field(&self.0).finish()
    }
}
impl FromIntoMemory for STGOP {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const STIF_DEFAULT: i32 = 0i32;
pub const STIF_SUPPORT_HEX: i32 = 1i32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct STORAGE_PROVIDER_FILE_FLAGS(pub i32);
pub const SPFF_NONE: STORAGE_PROVIDER_FILE_FLAGS = STORAGE_PROVIDER_FILE_FLAGS(0i32);
pub const SPFF_DOWNLOAD_BY_DEFAULT: STORAGE_PROVIDER_FILE_FLAGS = STORAGE_PROVIDER_FILE_FLAGS(1i32);
pub const SPFF_CREATED_ON_THIS_DEVICE: STORAGE_PROVIDER_FILE_FLAGS =
    STORAGE_PROVIDER_FILE_FLAGS(2i32);
impl ::core::marker::Copy for STORAGE_PROVIDER_FILE_FLAGS {}
impl ::core::clone::Clone for STORAGE_PROVIDER_FILE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STORAGE_PROVIDER_FILE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for STORAGE_PROVIDER_FILE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STORAGE_PROVIDER_FILE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for STORAGE_PROVIDER_FILE_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const STORE_E_NEWER_VERSION_AVAILABLE: crate::core::HRESULT =
    crate::core::HRESULT(-2144927484i32);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct STPFLAG(pub i32);
pub const STPF_NONE: STPFLAG = STPFLAG(0i32);
pub const STPF_USEAPPTHUMBNAILALWAYS: STPFLAG = STPFLAG(1i32);
pub const STPF_USEAPPTHUMBNAILWHENACTIVE: STPFLAG = STPFLAG(2i32);
pub const STPF_USEAPPPEEKALWAYS: STPFLAG = STPFLAG(4i32);
pub const STPF_USEAPPPEEKWHENACTIVE: STPFLAG = STPFLAG(8i32);
impl ::core::marker::Copy for STPFLAG {}
impl ::core::clone::Clone for STPFLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STPFLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for STPFLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STPFLAG").field(&self.0).finish()
    }
}
impl FromIntoMemory for STPFLAG {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const STR_AVOID_DRIVE_RESTRICTION_POLICY: &'static str = "Avoid Drive Restriction Policy";
pub const STR_BIND_DELEGATE_CREATE_OBJECT: &'static str = "Delegate Object Creation";
pub const STR_BIND_FOLDERS_READ_ONLY: &'static str = "Folders As Read Only";
pub const STR_BIND_FOLDER_ENUM_MODE: &'static str = "Folder Enum Mode";
pub const STR_BIND_FORCE_FOLDER_SHORTCUT_RESOLVE: &'static str = "Force Folder Shortcut Resolve";
pub const STR_DONT_PARSE_RELATIVE: &'static str = "Don\'t Parse Relative";
pub const STR_DONT_RESOLVE_LINK: &'static str = "Don\'t Resolve Link";
pub const STR_ENUM_ITEMS_FLAGS: &'static str = "SHCONTF";
pub const STR_FILE_SYS_BIND_DATA: &'static str = "File System Bind Data";
pub const STR_FILE_SYS_BIND_DATA_WIN7_FORMAT: &'static str = "Win7FileSystemIdList";
pub const STR_GET_ASYNC_HANDLER: &'static str = "GetAsyncHandler";
pub const STR_GPS_BESTEFFORT: &'static str = "GPS_BESTEFFORT";
pub const STR_GPS_DELAYCREATION: &'static str = "GPS_DELAYCREATION";
pub const STR_GPS_FASTPROPERTIESONLY: &'static str = "GPS_FASTPROPERTIESONLY";
pub const STR_GPS_HANDLERPROPERTIESONLY: &'static str = "GPS_HANDLERPROPERTIESONLY";
pub const STR_GPS_NO_OPLOCK: &'static str = "GPS_NO_OPLOCK";
pub const STR_GPS_OPENSLOWITEM: &'static str = "GPS_OPENSLOWITEM";
pub const STR_INTERNAL_NAVIGATE: &'static str = "Internal Navigation";
pub const STR_INTERNETFOLDER_PARSE_ONLY_URLMON_BINDABLE: &'static str = "Validate URL";
pub const STR_ITEM_CACHE_CONTEXT: &'static str = "ItemCacheContext";
pub const STR_MYDOCS_CLSID: &'static str = "{450D8FBA-AD25-11D0-98A8-0800361B1103}";
pub const STR_NO_VALIDATE_FILENAME_CHARS: &'static str = "NoValidateFilenameChars";
pub const STR_PARSE_ALLOW_INTERNET_SHELL_FOLDERS: &'static str =
    "Allow binding to Internet shell folder handlers and negate STR_PARSE_PREFER_WEB_BROWSING";
pub const STR_PARSE_AND_CREATE_ITEM: &'static str = "ParseAndCreateItem";
pub const STR_PARSE_DONT_REQUIRE_VALIDATED_URLS: &'static str = "Do not require validated URLs";
pub const STR_PARSE_EXPLICIT_ASSOCIATION_SUCCESSFUL: &'static str = "ExplicitAssociationSuccessful";
pub const STR_PARSE_PARTIAL_IDLIST: &'static str = "ParseOriginalItem";
pub const STR_PARSE_PREFER_FOLDER_BROWSING: &'static str = "Parse Prefer Folder Browsing";
pub const STR_PARSE_PREFER_WEB_BROWSING: &'static str =
    "Do not bind to Internet shell folder handlers";
pub const STR_PARSE_PROPERTYSTORE: &'static str = "DelegateNamedProperties";
pub const STR_PARSE_SHELL_PROTOCOL_TO_FILE_OBJECTS: &'static str =
    "Parse Shell Protocol To File Objects";
pub const STR_PARSE_SHOW_NET_DIAGNOSTICS_UI: &'static str = "Show network diagnostics UI";
pub const STR_PARSE_SKIP_NET_CACHE: &'static str = "Skip Net Resource Cache";
pub const STR_PARSE_TRANSLATE_ALIASES: &'static str = "Parse Translate Aliases";
pub const STR_PARSE_WITH_EXPLICIT_ASSOCAPP: &'static str = "ExplicitAssociationApp";
pub const STR_PARSE_WITH_EXPLICIT_PROGID: &'static str = "ExplicitProgid";
pub const STR_PARSE_WITH_PROPERTIES: &'static str = "ParseWithProperties";
pub const STR_PROPERTYBAG_PARAM: &'static str = "SHBindCtxPropertyBag";
pub const STR_REFERRER_IDENTIFIER: &'static str = "Referrer Identifier";
pub const STR_SKIP_BINDING_CLSID: &'static str = "Skip Binding CLSID";
pub const STR_STORAGEITEM_CREATION_FLAGS: &'static str = "SHGETSTORAGEITEM";
pub const STR_TAB_REUSE_IDENTIFIER: &'static str = "Tab Reuse Identifier";
pub const STR_TRACK_CLSID: &'static str = "Track the CLSID";
pub type SUBCLASSPROC = StdCallFnPtr<
    (
        super::super::Foundation::HWND,
        u32,
        super::super::Foundation::WPARAM,
        super::super::Foundation::LPARAM,
        PtrRepr,
        PtrRepr,
    ),
    super::super::Foundation::LRESULT,
>;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct SV2CVW2_PARAMS {
    pub cbSize: u32,
    pub psvPrev: IShellView,
    pub pfs: MutPtr<FOLDERSETTINGS>,
    pub psbOwner: IShellBrowser,
    pub prcView: MutPtr<super::super::Foundation::RECT>,
    pub pvid: ConstPtr<crate::core::GUID>,
    pub hwndView: super::super::Foundation::HWND,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for SV2CVW2_PARAMS {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for SV2CVW2_PARAMS {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for SV2CVW2_PARAMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SV2CVW2_PARAMS")
            .field("cbSize", &self.cbSize)
            .field("psvPrev", &self.psvPrev)
            .field("pfs", &self.pfs)
            .field("psbOwner", &self.psbOwner)
            .field("prcView", &self.prcView)
            .field("pvid", &self.pvid)
            .field("hwndView", &self.hwndView)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for SV2CVW2_PARAMS {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.psvPrev == other.psvPrev
            && self.pfs == other.pfs
            && self.psbOwner == other.psbOwner
            && self.prcView == other.prcView
            && self.pvid == other.pvid
            && self.hwndView == other.hwndView
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for SV2CVW2_PARAMS {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.System.Com.StructuredStorage', 'Windows.Win32.System.Ole', 'Windows.Win32.UI.Controls', 'Windows.Win32.UI.Shell.Common', 'Windows.Win32.UI.WindowsAndMessaging'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for SV2CVW2_PARAMS {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 28);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_psvPrev = <IShellView as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pfs = <MutPtr<FOLDERSETTINGS> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_psbOwner = <IShellBrowser as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_prcView = <MutPtr<super::super::Foundation::RECT> as FromIntoMemory>::from_bytes(
            &from[16..16 + 4],
        );
        let f_pvid = <ConstPtr<crate::core::GUID> as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_hwndView =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        Self {
            cbSize: f_cbSize,
            psvPrev: f_psvPrev,
            pfs: f_pfs,
            psbOwner: f_psbOwner,
            prcView: f_prcView,
            pvid: f_pvid,
            hwndView: f_hwndView,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 28);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.psvPrev, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pfs, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.psbOwner, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.prcView, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.pvid, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.hwndView, &mut into[24..24 + 4]);
    }
    fn size() -> usize {
        28
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SVUIA_STATUS(pub i32);
pub const SVUIA_DEACTIVATE: SVUIA_STATUS = SVUIA_STATUS(0i32);
pub const SVUIA_ACTIVATE_NOFOCUS: SVUIA_STATUS = SVUIA_STATUS(1i32);
pub const SVUIA_ACTIVATE_FOCUS: SVUIA_STATUS = SVUIA_STATUS(2i32);
pub const SVUIA_INPLACEACTIVATE: SVUIA_STATUS = SVUIA_STATUS(3i32);
impl ::core::marker::Copy for SVUIA_STATUS {}
impl ::core::clone::Clone for SVUIA_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SVUIA_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SVUIA_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SVUIA_STATUS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SVUIA_STATUS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRERRORFLAGS(pub i32);
pub const SYNCMGRERRORFLAG_ENABLEJUMPTEXT: SYNCMGRERRORFLAGS = SYNCMGRERRORFLAGS(1i32);
impl ::core::marker::Copy for SYNCMGRERRORFLAGS {}
impl ::core::clone::Clone for SYNCMGRERRORFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRERRORFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRERRORFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRERRORFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRERRORFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRFLAG(pub i32);
pub const SYNCMGRFLAG_CONNECT: SYNCMGRFLAG = SYNCMGRFLAG(1i32);
pub const SYNCMGRFLAG_PENDINGDISCONNECT: SYNCMGRFLAG = SYNCMGRFLAG(2i32);
pub const SYNCMGRFLAG_MANUAL: SYNCMGRFLAG = SYNCMGRFLAG(3i32);
pub const SYNCMGRFLAG_IDLE: SYNCMGRFLAG = SYNCMGRFLAG(4i32);
pub const SYNCMGRFLAG_INVOKE: SYNCMGRFLAG = SYNCMGRFLAG(5i32);
pub const SYNCMGRFLAG_SCHEDULED: SYNCMGRFLAG = SYNCMGRFLAG(6i32);
pub const SYNCMGRFLAG_EVENTMASK: SYNCMGRFLAG = SYNCMGRFLAG(255i32);
pub const SYNCMGRFLAG_SETTINGS: SYNCMGRFLAG = SYNCMGRFLAG(256i32);
pub const SYNCMGRFLAG_MAYBOTHERUSER: SYNCMGRFLAG = SYNCMGRFLAG(512i32);
impl ::core::marker::Copy for SYNCMGRFLAG {}
impl ::core::clone::Clone for SYNCMGRFLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRFLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRFLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRFLAG").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRFLAG {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRHANDLERFLAGS(pub i32);
pub const SYNCMGRHANDLER_HASPROPERTIES: SYNCMGRHANDLERFLAGS = SYNCMGRHANDLERFLAGS(1i32);
pub const SYNCMGRHANDLER_MAYESTABLISHCONNECTION: SYNCMGRHANDLERFLAGS = SYNCMGRHANDLERFLAGS(2i32);
pub const SYNCMGRHANDLER_ALWAYSLISTHANDLER: SYNCMGRHANDLERFLAGS = SYNCMGRHANDLERFLAGS(4i32);
pub const SYNCMGRHANDLER_HIDDEN: SYNCMGRHANDLERFLAGS = SYNCMGRHANDLERFLAGS(8i32);
impl ::core::marker::Copy for SYNCMGRHANDLERFLAGS {}
impl ::core::clone::Clone for SYNCMGRHANDLERFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRHANDLERFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRHANDLERFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRHANDLERFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRHANDLERFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SYNCMGRHANDLERFLAG_MASK: u32 = 15u32;
pub struct SYNCMGRHANDLERINFO {
    pub cbSize: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub SyncMgrHandlerFlags: u32,
    pub wszHandlerName: [u16; 32],
}
impl ::core::marker::Copy for SYNCMGRHANDLERINFO {}
impl ::core::clone::Clone for SYNCMGRHANDLERINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYNCMGRHANDLERINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYNCMGRHANDLERINFO")
            .field("cbSize", &self.cbSize)
            .field("hIcon", &self.hIcon)
            .field("SyncMgrHandlerFlags", &self.SyncMgrHandlerFlags)
            .field("wszHandlerName", &self.wszHandlerName)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SYNCMGRHANDLERINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.hIcon == other.hIcon
            && self.SyncMgrHandlerFlags == other.SyncMgrHandlerFlags
            && self.wszHandlerName == other.wszHandlerName
    }
}
impl ::core::cmp::Eq for SYNCMGRHANDLERINFO {}
impl FromIntoMemory for SYNCMGRHANDLERINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_SyncMgrHandlerFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_wszHandlerName = <[u16; 32] as FromIntoMemory>::from_bytes(&from[12..12 + 32]);
        Self {
            cbSize: f_cbSize,
            hIcon: f_hIcon,
            SyncMgrHandlerFlags: f_SyncMgrHandlerFlags,
            wszHandlerName: f_wszHandlerName,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.SyncMgrHandlerFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.wszHandlerName, &mut into[12..12 + 32]);
    }
    fn size() -> usize {
        44
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRINVOKEFLAGS(pub i32);
pub const SYNCMGRINVOKE_STARTSYNC: SYNCMGRINVOKEFLAGS = SYNCMGRINVOKEFLAGS(2i32);
pub const SYNCMGRINVOKE_MINIMIZED: SYNCMGRINVOKEFLAGS = SYNCMGRINVOKEFLAGS(4i32);
impl ::core::marker::Copy for SYNCMGRINVOKEFLAGS {}
impl ::core::clone::Clone for SYNCMGRINVOKEFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRINVOKEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRINVOKEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRINVOKEFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRINVOKEFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct SYNCMGRITEM {
    pub cbSize: u32,
    pub dwFlags: u32,
    pub ItemID: crate::core::GUID,
    pub dwItemState: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub wszItemName: [u16; 128],
    pub ftLastUpdate: super::super::Foundation::FILETIME,
}
impl ::core::marker::Copy for SYNCMGRITEM {}
impl ::core::clone::Clone for SYNCMGRITEM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYNCMGRITEM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYNCMGRITEM")
            .field("cbSize", &self.cbSize)
            .field("dwFlags", &self.dwFlags)
            .field("ItemID", &self.ItemID)
            .field("dwItemState", &self.dwItemState)
            .field("hIcon", &self.hIcon)
            .field("wszItemName", &self.wszItemName)
            .field("ftLastUpdate", &self.ftLastUpdate)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SYNCMGRITEM {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.dwFlags == other.dwFlags
            && self.ItemID == other.ItemID
            && self.dwItemState == other.dwItemState
            && self.hIcon == other.hIcon
            && self.wszItemName == other.wszItemName
            && self.ftLastUpdate == other.ftLastUpdate
    }
}
impl ::core::cmp::Eq for SYNCMGRITEM {}
impl FromIntoMemory for SYNCMGRITEM {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 168);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_ItemID = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[8..8 + 16]);
        let f_dwItemState = <u32 as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[28..28 + 4]);
        let f_wszItemName = <[u16; 128] as FromIntoMemory>::from_bytes(&from[32..32 + 128]);
        let f_ftLastUpdate =
            <super::super::Foundation::FILETIME as FromIntoMemory>::from_bytes(&from[160..160 + 8]);
        Self {
            cbSize: f_cbSize,
            dwFlags: f_dwFlags,
            ItemID: f_ItemID,
            dwItemState: f_dwItemState,
            hIcon: f_hIcon,
            wszItemName: f_wszItemName,
            ftLastUpdate: f_ftLastUpdate,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 168);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.ItemID, &mut into[8..8 + 16]);
        FromIntoMemory::into_bytes(self.dwItemState, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[28..28 + 4]);
        FromIntoMemory::into_bytes(self.wszItemName, &mut into[32..32 + 128]);
        FromIntoMemory::into_bytes(self.ftLastUpdate, &mut into[160..160 + 8]);
    }
    fn size() -> usize {
        168
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRITEMFLAGS(pub i32);
pub const SYNCMGRITEM_HASPROPERTIES: SYNCMGRITEMFLAGS = SYNCMGRITEMFLAGS(1i32);
pub const SYNCMGRITEM_TEMPORARY: SYNCMGRITEMFLAGS = SYNCMGRITEMFLAGS(2i32);
pub const SYNCMGRITEM_ROAMINGUSER: SYNCMGRITEMFLAGS = SYNCMGRITEMFLAGS(4i32);
pub const SYNCMGRITEM_LASTUPDATETIME: SYNCMGRITEMFLAGS = SYNCMGRITEMFLAGS(8i32);
pub const SYNCMGRITEM_MAYDELETEITEM: SYNCMGRITEMFLAGS = SYNCMGRITEMFLAGS(16i32);
pub const SYNCMGRITEM_HIDDEN: SYNCMGRITEMFLAGS = SYNCMGRITEMFLAGS(32i32);
impl ::core::marker::Copy for SYNCMGRITEMFLAGS {}
impl ::core::clone::Clone for SYNCMGRITEMFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRITEMFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRITEMFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRITEMFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRITEMFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRITEMSTATE(pub i32);
pub const SYNCMGRITEMSTATE_UNCHECKED: SYNCMGRITEMSTATE = SYNCMGRITEMSTATE(0i32);
pub const SYNCMGRITEMSTATE_CHECKED: SYNCMGRITEMSTATE = SYNCMGRITEMSTATE(1i32);
impl ::core::marker::Copy for SYNCMGRITEMSTATE {}
impl ::core::clone::Clone for SYNCMGRITEMSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRITEMSTATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRITEMSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRITEMSTATE").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRITEMSTATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SYNCMGRITEM_ITEMFLAGMASK: u32 = 127u32;
pub struct SYNCMGRLOGERRORINFO {
    pub cbSize: u32,
    pub mask: u32,
    pub dwSyncMgrErrorFlags: u32,
    pub ErrorID: crate::core::GUID,
    pub ItemID: crate::core::GUID,
}
impl ::core::marker::Copy for SYNCMGRLOGERRORINFO {}
impl ::core::clone::Clone for SYNCMGRLOGERRORINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYNCMGRLOGERRORINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYNCMGRLOGERRORINFO")
            .field("cbSize", &self.cbSize)
            .field("mask", &self.mask)
            .field("dwSyncMgrErrorFlags", &self.dwSyncMgrErrorFlags)
            .field("ErrorID", &self.ErrorID)
            .field("ItemID", &self.ItemID)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SYNCMGRLOGERRORINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.mask == other.mask
            && self.dwSyncMgrErrorFlags == other.dwSyncMgrErrorFlags
            && self.ErrorID == other.ErrorID
            && self.ItemID == other.ItemID
    }
}
impl ::core::cmp::Eq for SYNCMGRLOGERRORINFO {}
impl FromIntoMemory for SYNCMGRLOGERRORINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 44);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_mask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_dwSyncMgrErrorFlags = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_ErrorID = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[12..12 + 16]);
        let f_ItemID = <crate::core::GUID as FromIntoMemory>::from_bytes(&from[28..28 + 16]);
        Self {
            cbSize: f_cbSize,
            mask: f_mask,
            dwSyncMgrErrorFlags: f_dwSyncMgrErrorFlags,
            ErrorID: f_ErrorID,
            ItemID: f_ItemID,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 44);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.mask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.dwSyncMgrErrorFlags, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.ErrorID, &mut into[12..12 + 16]);
        FromIntoMemory::into_bytes(self.ItemID, &mut into[28..28 + 16]);
    }
    fn size() -> usize {
        44
    }
}
pub const SYNCMGRLOGERROR_ERRORFLAGS: u32 = 1u32;
pub const SYNCMGRLOGERROR_ERRORID: u32 = 2u32;
pub const SYNCMGRLOGERROR_ITEMID: u32 = 4u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRLOGLEVEL(pub i32);
pub const SYNCMGRLOGLEVEL_INFORMATION: SYNCMGRLOGLEVEL = SYNCMGRLOGLEVEL(1i32);
pub const SYNCMGRLOGLEVEL_WARNING: SYNCMGRLOGLEVEL = SYNCMGRLOGLEVEL(2i32);
pub const SYNCMGRLOGLEVEL_ERROR: SYNCMGRLOGLEVEL = SYNCMGRLOGLEVEL(3i32);
pub const SYNCMGRLOGLEVEL_LOGLEVELMAX: SYNCMGRLOGLEVEL = SYNCMGRLOGLEVEL(3i32);
impl ::core::marker::Copy for SYNCMGRLOGLEVEL {}
impl ::core::clone::Clone for SYNCMGRLOGLEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRLOGLEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRLOGLEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRLOGLEVEL").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRLOGLEVEL {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct SYNCMGRPROGRESSITEM {
    pub cbSize: u32,
    pub mask: u32,
    pub lpcStatusText: PCWSTR,
    pub dwStatusType: u32,
    pub iProgValue: i32,
    pub iMaxValue: i32,
}
impl ::core::marker::Copy for SYNCMGRPROGRESSITEM {}
impl ::core::clone::Clone for SYNCMGRPROGRESSITEM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYNCMGRPROGRESSITEM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYNCMGRPROGRESSITEM")
            .field("cbSize", &self.cbSize)
            .field("mask", &self.mask)
            .field("lpcStatusText", &self.lpcStatusText)
            .field("dwStatusType", &self.dwStatusType)
            .field("iProgValue", &self.iProgValue)
            .field("iMaxValue", &self.iMaxValue)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SYNCMGRPROGRESSITEM {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize
            && self.mask == other.mask
            && self.lpcStatusText == other.lpcStatusText
            && self.dwStatusType == other.dwStatusType
            && self.iProgValue == other.iProgValue
            && self.iMaxValue == other.iMaxValue
    }
}
impl ::core::cmp::Eq for SYNCMGRPROGRESSITEM {}
impl FromIntoMemory for SYNCMGRPROGRESSITEM {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_cbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_mask = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_lpcStatusText = <PCWSTR as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_dwStatusType = <u32 as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_iProgValue = <i32 as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_iMaxValue = <i32 as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            cbSize: f_cbSize,
            mask: f_mask,
            lpcStatusText: f_lpcStatusText,
            dwStatusType: f_dwStatusType,
            iProgValue: f_iProgValue,
            iMaxValue: f_iMaxValue,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.cbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.mask, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.lpcStatusText, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.dwStatusType, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.iProgValue, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.iMaxValue, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub const SYNCMGRPROGRESSITEM_MAXVALUE: u32 = 8u32;
pub const SYNCMGRPROGRESSITEM_PROGVALUE: u32 = 4u32;
pub const SYNCMGRPROGRESSITEM_STATUSTEXT: u32 = 1u32;
pub const SYNCMGRPROGRESSITEM_STATUSTYPE: u32 = 2u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRREGISTERFLAGS(pub i32);
pub const SYNCMGRREGISTERFLAG_CONNECT: SYNCMGRREGISTERFLAGS = SYNCMGRREGISTERFLAGS(1i32);
pub const SYNCMGRREGISTERFLAG_PENDINGDISCONNECT: SYNCMGRREGISTERFLAGS = SYNCMGRREGISTERFLAGS(2i32);
pub const SYNCMGRREGISTERFLAG_IDLE: SYNCMGRREGISTERFLAGS = SYNCMGRREGISTERFLAGS(4i32);
impl ::core::marker::Copy for SYNCMGRREGISTERFLAGS {}
impl ::core::clone::Clone for SYNCMGRREGISTERFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRREGISTERFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRREGISTERFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRREGISTERFLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGRREGISTERFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SYNCMGRREGISTERFLAGS_MASK: u32 = 7u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGRSTATUS(pub i32);
pub const SYNCMGRSTATUS_STOPPED: SYNCMGRSTATUS = SYNCMGRSTATUS(0i32);
pub const SYNCMGRSTATUS_SKIPPED: SYNCMGRSTATUS = SYNCMGRSTATUS(1i32);
pub const SYNCMGRSTATUS_PENDING: SYNCMGRSTATUS = SYNCMGRSTATUS(2i32);
pub const SYNCMGRSTATUS_UPDATING: SYNCMGRSTATUS = SYNCMGRSTATUS(3i32);
pub const SYNCMGRSTATUS_SUCCEEDED: SYNCMGRSTATUS = SYNCMGRSTATUS(4i32);
pub const SYNCMGRSTATUS_FAILED: SYNCMGRSTATUS = SYNCMGRSTATUS(5i32);
pub const SYNCMGRSTATUS_PAUSED: SYNCMGRSTATUS = SYNCMGRSTATUS(6i32);
pub const SYNCMGRSTATUS_RESUMING: SYNCMGRSTATUS = SYNCMGRSTATUS(7i32);
pub const SYNCMGRSTATUS_UPDATING_INDETERMINATE: SYNCMGRSTATUS = SYNCMGRSTATUS(8i32);
pub const SYNCMGRSTATUS_DELETED: SYNCMGRSTATUS = SYNCMGRSTATUS(256i32);
impl ::core::marker::Copy for SYNCMGRSTATUS {}
impl ::core::clone::Clone for SYNCMGRSTATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGRSTATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGRSTATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGRSTATUS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGRSTATUS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_CANCEL_REQUEST(pub i32);
pub const SYNCMGR_CR_NONE: SYNCMGR_CANCEL_REQUEST = SYNCMGR_CANCEL_REQUEST(0i32);
pub const SYNCMGR_CR_CANCEL_ITEM: SYNCMGR_CANCEL_REQUEST = SYNCMGR_CANCEL_REQUEST(1i32);
pub const SYNCMGR_CR_CANCEL_ALL: SYNCMGR_CANCEL_REQUEST = SYNCMGR_CANCEL_REQUEST(2i32);
pub const SYNCMGR_CR_MAX: SYNCMGR_CANCEL_REQUEST = SYNCMGR_CANCEL_REQUEST(2i32);
impl ::core::marker::Copy for SYNCMGR_CANCEL_REQUEST {}
impl ::core::clone::Clone for SYNCMGR_CANCEL_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_CANCEL_REQUEST {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_CANCEL_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_CANCEL_REQUEST")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_CANCEL_REQUEST {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct SYNCMGR_CONFLICT_ID_INFO {
    pub pblobID: MutPtr<super::super::System::Com::BYTE_BLOB>,
    pub pblobExtra: MutPtr<super::super::System::Com::BYTE_BLOB>,
}
impl ::core::marker::Copy for SYNCMGR_CONFLICT_ID_INFO {}
impl ::core::clone::Clone for SYNCMGR_CONFLICT_ID_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYNCMGR_CONFLICT_ID_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYNCMGR_CONFLICT_ID_INFO")
            .field("pblobID", &self.pblobID)
            .field("pblobExtra", &self.pblobExtra)
            .finish()
    }
}
impl ::core::cmp::PartialEq for SYNCMGR_CONFLICT_ID_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.pblobID == other.pblobID && self.pblobExtra == other.pblobExtra
    }
}
impl ::core::cmp::Eq for SYNCMGR_CONFLICT_ID_INFO {}
impl FromIntoMemory for SYNCMGR_CONFLICT_ID_INFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_pblobID =
            <MutPtr<super::super::System::Com::BYTE_BLOB> as FromIntoMemory>::from_bytes(
                &from[0..0 + 4],
            );
        let f_pblobExtra =
            <MutPtr<super::super::System::Com::BYTE_BLOB> as FromIntoMemory>::from_bytes(
                &from[4..4 + 4],
            );
        Self {
            pblobID: f_pblobID,
            pblobExtra: f_pblobExtra,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.pblobID, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.pblobExtra, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_CONFLICT_ITEM_TYPE(pub i32);
pub const SYNCMGR_CIT_UPDATED: SYNCMGR_CONFLICT_ITEM_TYPE = SYNCMGR_CONFLICT_ITEM_TYPE(1i32);
pub const SYNCMGR_CIT_DELETED: SYNCMGR_CONFLICT_ITEM_TYPE = SYNCMGR_CONFLICT_ITEM_TYPE(2i32);
impl ::core::marker::Copy for SYNCMGR_CONFLICT_ITEM_TYPE {}
impl ::core::clone::Clone for SYNCMGR_CONFLICT_ITEM_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_CONFLICT_ITEM_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_CONFLICT_ITEM_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_CONFLICT_ITEM_TYPE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_CONFLICT_ITEM_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_CONTROL_FLAGS(pub i32);
pub const SYNCMGR_CF_NONE: SYNCMGR_CONTROL_FLAGS = SYNCMGR_CONTROL_FLAGS(0i32);
pub const SYNCMGR_CF_NOWAIT: SYNCMGR_CONTROL_FLAGS = SYNCMGR_CONTROL_FLAGS(0i32);
pub const SYNCMGR_CF_WAIT: SYNCMGR_CONTROL_FLAGS = SYNCMGR_CONTROL_FLAGS(1i32);
pub const SYNCMGR_CF_NOUI: SYNCMGR_CONTROL_FLAGS = SYNCMGR_CONTROL_FLAGS(2i32);
pub const SYNCMGR_CF_VALID: SYNCMGR_CONTROL_FLAGS = SYNCMGR_CONTROL_FLAGS(3i32);
impl ::core::marker::Copy for SYNCMGR_CONTROL_FLAGS {}
impl ::core::clone::Clone for SYNCMGR_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_CONTROL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_CONTROL_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_EVENT_FLAGS(pub i32);
pub const SYNCMGR_EF_NONE: SYNCMGR_EVENT_FLAGS = SYNCMGR_EVENT_FLAGS(0i32);
pub const SYNCMGR_EF_VALID: SYNCMGR_EVENT_FLAGS = SYNCMGR_EVENT_FLAGS(0i32);
impl ::core::marker::Copy for SYNCMGR_EVENT_FLAGS {}
impl ::core::clone::Clone for SYNCMGR_EVENT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_EVENT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_EVENT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_EVENT_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGR_EVENT_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_EVENT_LEVEL(pub i32);
pub const SYNCMGR_EL_INFORMATION: SYNCMGR_EVENT_LEVEL = SYNCMGR_EVENT_LEVEL(1i32);
pub const SYNCMGR_EL_WARNING: SYNCMGR_EVENT_LEVEL = SYNCMGR_EVENT_LEVEL(2i32);
pub const SYNCMGR_EL_ERROR: SYNCMGR_EVENT_LEVEL = SYNCMGR_EVENT_LEVEL(3i32);
pub const SYNCMGR_EL_MAX: SYNCMGR_EVENT_LEVEL = SYNCMGR_EVENT_LEVEL(3i32);
impl ::core::marker::Copy for SYNCMGR_EVENT_LEVEL {}
impl ::core::clone::Clone for SYNCMGR_EVENT_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_EVENT_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_EVENT_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_EVENT_LEVEL").field(&self.0).finish()
    }
}
impl FromIntoMemory for SYNCMGR_EVENT_LEVEL {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_HANDLER_CAPABILITIES(pub i32);
pub const SYNCMGR_HCM_NONE: SYNCMGR_HANDLER_CAPABILITIES = SYNCMGR_HANDLER_CAPABILITIES(0i32);
pub const SYNCMGR_HCM_PROVIDES_ICON: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(1i32);
pub const SYNCMGR_HCM_EVENT_STORE: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(2i32);
pub const SYNCMGR_HCM_CONFLICT_STORE: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(4i32);
pub const SYNCMGR_HCM_SUPPORTS_CONCURRENT_SESSIONS: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(16i32);
pub const SYNCMGR_HCM_CAN_BROWSE_CONTENT: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(65536i32);
pub const SYNCMGR_HCM_CAN_SHOW_SCHEDULE: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(131072i32);
pub const SYNCMGR_HCM_QUERY_BEFORE_ACTIVATE: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(1048576i32);
pub const SYNCMGR_HCM_QUERY_BEFORE_DEACTIVATE: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(2097152i32);
pub const SYNCMGR_HCM_QUERY_BEFORE_ENABLE: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(4194304i32);
pub const SYNCMGR_HCM_QUERY_BEFORE_DISABLE: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(8388608i32);
pub const SYNCMGR_HCM_VALID_MASK: SYNCMGR_HANDLER_CAPABILITIES =
    SYNCMGR_HANDLER_CAPABILITIES(15925271i32);
impl ::core::marker::Copy for SYNCMGR_HANDLER_CAPABILITIES {}
impl ::core::clone::Clone for SYNCMGR_HANDLER_CAPABILITIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_HANDLER_CAPABILITIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_HANDLER_CAPABILITIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_HANDLER_CAPABILITIES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_HANDLER_CAPABILITIES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_HANDLER_POLICIES(pub i32);
pub const SYNCMGR_HPM_NONE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(0i32);
pub const SYNCMGR_HPM_PREVENT_ACTIVATE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(1i32);
pub const SYNCMGR_HPM_PREVENT_DEACTIVATE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(2i32);
pub const SYNCMGR_HPM_PREVENT_ENABLE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(4i32);
pub const SYNCMGR_HPM_PREVENT_DISABLE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(8i32);
pub const SYNCMGR_HPM_PREVENT_START_SYNC: SYNCMGR_HANDLER_POLICIES =
    SYNCMGR_HANDLER_POLICIES(16i32);
pub const SYNCMGR_HPM_PREVENT_STOP_SYNC: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(32i32);
pub const SYNCMGR_HPM_DISABLE_ENABLE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(256i32);
pub const SYNCMGR_HPM_DISABLE_DISABLE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(512i32);
pub const SYNCMGR_HPM_DISABLE_START_SYNC: SYNCMGR_HANDLER_POLICIES =
    SYNCMGR_HANDLER_POLICIES(1024i32);
pub const SYNCMGR_HPM_DISABLE_STOP_SYNC: SYNCMGR_HANDLER_POLICIES =
    SYNCMGR_HANDLER_POLICIES(2048i32);
pub const SYNCMGR_HPM_DISABLE_BROWSE: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(4096i32);
pub const SYNCMGR_HPM_DISABLE_SCHEDULE: SYNCMGR_HANDLER_POLICIES =
    SYNCMGR_HANDLER_POLICIES(8192i32);
pub const SYNCMGR_HPM_HIDDEN_BY_DEFAULT: SYNCMGR_HANDLER_POLICIES =
    SYNCMGR_HANDLER_POLICIES(65536i32);
pub const SYNCMGR_HPM_BACKGROUND_SYNC_ONLY: SYNCMGR_HANDLER_POLICIES =
    SYNCMGR_HANDLER_POLICIES(48i32);
pub const SYNCMGR_HPM_VALID_MASK: SYNCMGR_HANDLER_POLICIES = SYNCMGR_HANDLER_POLICIES(77631i32);
impl ::core::marker::Copy for SYNCMGR_HANDLER_POLICIES {}
impl ::core::clone::Clone for SYNCMGR_HANDLER_POLICIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_HANDLER_POLICIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_HANDLER_POLICIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_HANDLER_POLICIES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_HANDLER_POLICIES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_HANDLER_TYPE(pub i32);
pub const SYNCMGR_HT_UNSPECIFIED: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(0i32);
pub const SYNCMGR_HT_APPLICATION: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(1i32);
pub const SYNCMGR_HT_DEVICE: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(2i32);
pub const SYNCMGR_HT_FOLDER: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(3i32);
pub const SYNCMGR_HT_SERVICE: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(4i32);
pub const SYNCMGR_HT_COMPUTER: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(5i32);
pub const SYNCMGR_HT_MIN: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(0i32);
pub const SYNCMGR_HT_MAX: SYNCMGR_HANDLER_TYPE = SYNCMGR_HANDLER_TYPE(5i32);
impl ::core::marker::Copy for SYNCMGR_HANDLER_TYPE {}
impl ::core::clone::Clone for SYNCMGR_HANDLER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_HANDLER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_HANDLER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_HANDLER_TYPE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_HANDLER_TYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_ITEM_CAPABILITIES(pub i32);
pub const SYNCMGR_ICM_NONE: SYNCMGR_ITEM_CAPABILITIES = SYNCMGR_ITEM_CAPABILITIES(0i32);
pub const SYNCMGR_ICM_PROVIDES_ICON: SYNCMGR_ITEM_CAPABILITIES = SYNCMGR_ITEM_CAPABILITIES(1i32);
pub const SYNCMGR_ICM_EVENT_STORE: SYNCMGR_ITEM_CAPABILITIES = SYNCMGR_ITEM_CAPABILITIES(2i32);
pub const SYNCMGR_ICM_CONFLICT_STORE: SYNCMGR_ITEM_CAPABILITIES = SYNCMGR_ITEM_CAPABILITIES(4i32);
pub const SYNCMGR_ICM_CAN_DELETE: SYNCMGR_ITEM_CAPABILITIES = SYNCMGR_ITEM_CAPABILITIES(16i32);
pub const SYNCMGR_ICM_CAN_BROWSE_CONTENT: SYNCMGR_ITEM_CAPABILITIES =
    SYNCMGR_ITEM_CAPABILITIES(65536i32);
pub const SYNCMGR_ICM_QUERY_BEFORE_ENABLE: SYNCMGR_ITEM_CAPABILITIES =
    SYNCMGR_ITEM_CAPABILITIES(1048576i32);
pub const SYNCMGR_ICM_QUERY_BEFORE_DISABLE: SYNCMGR_ITEM_CAPABILITIES =
    SYNCMGR_ITEM_CAPABILITIES(2097152i32);
pub const SYNCMGR_ICM_QUERY_BEFORE_DELETE: SYNCMGR_ITEM_CAPABILITIES =
    SYNCMGR_ITEM_CAPABILITIES(4194304i32);
pub const SYNCMGR_ICM_VALID_MASK: SYNCMGR_ITEM_CAPABILITIES = SYNCMGR_ITEM_CAPABILITIES(7405591i32);
impl ::core::marker::Copy for SYNCMGR_ITEM_CAPABILITIES {}
impl ::core::clone::Clone for SYNCMGR_ITEM_CAPABILITIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_ITEM_CAPABILITIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_ITEM_CAPABILITIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_ITEM_CAPABILITIES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_ITEM_CAPABILITIES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_ITEM_POLICIES(pub i32);
pub const SYNCMGR_IPM_NONE: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(0i32);
pub const SYNCMGR_IPM_PREVENT_ENABLE: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(1i32);
pub const SYNCMGR_IPM_PREVENT_DISABLE: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(2i32);
pub const SYNCMGR_IPM_PREVENT_START_SYNC: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(4i32);
pub const SYNCMGR_IPM_PREVENT_STOP_SYNC: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(8i32);
pub const SYNCMGR_IPM_DISABLE_ENABLE: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(16i32);
pub const SYNCMGR_IPM_DISABLE_DISABLE: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(32i32);
pub const SYNCMGR_IPM_DISABLE_START_SYNC: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(64i32);
pub const SYNCMGR_IPM_DISABLE_STOP_SYNC: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(128i32);
pub const SYNCMGR_IPM_DISABLE_BROWSE: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(256i32);
pub const SYNCMGR_IPM_DISABLE_DELETE: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(512i32);
pub const SYNCMGR_IPM_HIDDEN_BY_DEFAULT: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(65536i32);
pub const SYNCMGR_IPM_VALID_MASK: SYNCMGR_ITEM_POLICIES = SYNCMGR_ITEM_POLICIES(66303i32);
impl ::core::marker::Copy for SYNCMGR_ITEM_POLICIES {}
impl ::core::clone::Clone for SYNCMGR_ITEM_POLICIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_ITEM_POLICIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_ITEM_POLICIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_ITEM_POLICIES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_ITEM_POLICIES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SYNCMGR_OBJECTID_BrowseContent: crate::core::GUID =
    crate::core::GUID::from_u128(0x57cbb584_e9b4_47ae_a120_c4df3335dee2);
pub const SYNCMGR_OBJECTID_ConflictStore: crate::core::GUID =
    crate::core::GUID::from_u128(0xd78181f4_2389_47e4_a960_60bcc2ed930b);
pub const SYNCMGR_OBJECTID_EventLinkClick: crate::core::GUID =
    crate::core::GUID::from_u128(0x2203bdc1_1af1_4082_8c30_28399f41384c);
pub const SYNCMGR_OBJECTID_EventStore: crate::core::GUID =
    crate::core::GUID::from_u128(0x4bef34b9_a786_4075_ba88_0c2b9d89a98f);
pub const SYNCMGR_OBJECTID_Icon: crate::core::GUID =
    crate::core::GUID::from_u128(0x6dbc85c3_5d07_4c72_a777_7fec78072c06);
pub const SYNCMGR_OBJECTID_QueryBeforeActivate: crate::core::GUID =
    crate::core::GUID::from_u128(0xd882d80b_e7aa_49ed_86b7_e6e1f714cdfe);
pub const SYNCMGR_OBJECTID_QueryBeforeDeactivate: crate::core::GUID =
    crate::core::GUID::from_u128(0xa0efc282_60e0_460e_9374_ea88513cfc80);
pub const SYNCMGR_OBJECTID_QueryBeforeDelete: crate::core::GUID =
    crate::core::GUID::from_u128(0xf76c3397_afb3_45d7_a59f_5a49e905437e);
pub const SYNCMGR_OBJECTID_QueryBeforeDisable: crate::core::GUID =
    crate::core::GUID::from_u128(0xbb5f64aa_f004_4eb5_8e4d_26751966344c);
pub const SYNCMGR_OBJECTID_QueryBeforeEnable: crate::core::GUID =
    crate::core::GUID::from_u128(0x04cbf7f0_5beb_4de1_bc90_908345c480f6);
pub const SYNCMGR_OBJECTID_ShowSchedule: crate::core::GUID =
    crate::core::GUID::from_u128(0xedc6f3e3_8441_4109_adf3_6c1ca0b7de47);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_PRESENTER_CHOICE(pub i32);
pub const SYNCMGR_PC_NO_CHOICE: SYNCMGR_PRESENTER_CHOICE = SYNCMGR_PRESENTER_CHOICE(0i32);
pub const SYNCMGR_PC_KEEP_ONE: SYNCMGR_PRESENTER_CHOICE = SYNCMGR_PRESENTER_CHOICE(1i32);
pub const SYNCMGR_PC_KEEP_MULTIPLE: SYNCMGR_PRESENTER_CHOICE = SYNCMGR_PRESENTER_CHOICE(2i32);
pub const SYNCMGR_PC_KEEP_RECENT: SYNCMGR_PRESENTER_CHOICE = SYNCMGR_PRESENTER_CHOICE(3i32);
pub const SYNCMGR_PC_REMOVE_FROM_SYNC_SET: SYNCMGR_PRESENTER_CHOICE =
    SYNCMGR_PRESENTER_CHOICE(4i32);
pub const SYNCMGR_PC_SKIP: SYNCMGR_PRESENTER_CHOICE = SYNCMGR_PRESENTER_CHOICE(5i32);
impl ::core::marker::Copy for SYNCMGR_PRESENTER_CHOICE {}
impl ::core::clone::Clone for SYNCMGR_PRESENTER_CHOICE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_PRESENTER_CHOICE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_PRESENTER_CHOICE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_PRESENTER_CHOICE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_PRESENTER_CHOICE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_PRESENTER_NEXT_STEP(pub i32);
pub const SYNCMGR_PNS_CONTINUE: SYNCMGR_PRESENTER_NEXT_STEP = SYNCMGR_PRESENTER_NEXT_STEP(0i32);
pub const SYNCMGR_PNS_DEFAULT: SYNCMGR_PRESENTER_NEXT_STEP = SYNCMGR_PRESENTER_NEXT_STEP(1i32);
pub const SYNCMGR_PNS_CANCEL: SYNCMGR_PRESENTER_NEXT_STEP = SYNCMGR_PRESENTER_NEXT_STEP(2i32);
impl ::core::marker::Copy for SYNCMGR_PRESENTER_NEXT_STEP {}
impl ::core::clone::Clone for SYNCMGR_PRESENTER_NEXT_STEP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_PRESENTER_NEXT_STEP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_PRESENTER_NEXT_STEP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_PRESENTER_NEXT_STEP")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_PRESENTER_NEXT_STEP {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_PROGRESS_STATUS(pub i32);
pub const SYNCMGR_PS_UPDATING: SYNCMGR_PROGRESS_STATUS = SYNCMGR_PROGRESS_STATUS(1i32);
pub const SYNCMGR_PS_UPDATING_INDETERMINATE: SYNCMGR_PROGRESS_STATUS =
    SYNCMGR_PROGRESS_STATUS(2i32);
pub const SYNCMGR_PS_SUCCEEDED: SYNCMGR_PROGRESS_STATUS = SYNCMGR_PROGRESS_STATUS(3i32);
pub const SYNCMGR_PS_FAILED: SYNCMGR_PROGRESS_STATUS = SYNCMGR_PROGRESS_STATUS(4i32);
pub const SYNCMGR_PS_CANCELED: SYNCMGR_PROGRESS_STATUS = SYNCMGR_PROGRESS_STATUS(5i32);
pub const SYNCMGR_PS_DISCONNECTED: SYNCMGR_PROGRESS_STATUS = SYNCMGR_PROGRESS_STATUS(6i32);
pub const SYNCMGR_PS_MAX: SYNCMGR_PROGRESS_STATUS = SYNCMGR_PROGRESS_STATUS(6i32);
impl ::core::marker::Copy for SYNCMGR_PROGRESS_STATUS {}
impl ::core::clone::Clone for SYNCMGR_PROGRESS_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_PROGRESS_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_PROGRESS_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_PROGRESS_STATUS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_PROGRESS_STATUS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_RESOLUTION_ABILITIES(pub i32);
pub const SYNCMGR_RA_KEEPOTHER: SYNCMGR_RESOLUTION_ABILITIES = SYNCMGR_RESOLUTION_ABILITIES(1i32);
pub const SYNCMGR_RA_KEEPRECENT: SYNCMGR_RESOLUTION_ABILITIES = SYNCMGR_RESOLUTION_ABILITIES(2i32);
pub const SYNCMGR_RA_REMOVEFROMSYNCSET: SYNCMGR_RESOLUTION_ABILITIES =
    SYNCMGR_RESOLUTION_ABILITIES(4i32);
pub const SYNCMGR_RA_KEEP_SINGLE: SYNCMGR_RESOLUTION_ABILITIES = SYNCMGR_RESOLUTION_ABILITIES(8i32);
pub const SYNCMGR_RA_KEEP_MULTIPLE: SYNCMGR_RESOLUTION_ABILITIES =
    SYNCMGR_RESOLUTION_ABILITIES(16i32);
pub const SYNCMGR_RA_VALID: SYNCMGR_RESOLUTION_ABILITIES = SYNCMGR_RESOLUTION_ABILITIES(31i32);
impl ::core::marker::Copy for SYNCMGR_RESOLUTION_ABILITIES {}
impl ::core::clone::Clone for SYNCMGR_RESOLUTION_ABILITIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_RESOLUTION_ABILITIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_RESOLUTION_ABILITIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_RESOLUTION_ABILITIES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_RESOLUTION_ABILITIES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_RESOLUTION_FEEDBACK(pub i32);
pub const SYNCMGR_RF_CONTINUE: SYNCMGR_RESOLUTION_FEEDBACK = SYNCMGR_RESOLUTION_FEEDBACK(0i32);
pub const SYNCMGR_RF_REFRESH: SYNCMGR_RESOLUTION_FEEDBACK = SYNCMGR_RESOLUTION_FEEDBACK(1i32);
pub const SYNCMGR_RF_CANCEL: SYNCMGR_RESOLUTION_FEEDBACK = SYNCMGR_RESOLUTION_FEEDBACK(2i32);
impl ::core::marker::Copy for SYNCMGR_RESOLUTION_FEEDBACK {}
impl ::core::clone::Clone for SYNCMGR_RESOLUTION_FEEDBACK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_RESOLUTION_FEEDBACK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_RESOLUTION_FEEDBACK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_RESOLUTION_FEEDBACK")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_RESOLUTION_FEEDBACK {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_SYNC_CONTROL_FLAGS(pub i32);
pub const SYNCMGR_SCF_NONE: SYNCMGR_SYNC_CONTROL_FLAGS = SYNCMGR_SYNC_CONTROL_FLAGS(0i32);
pub const SYNCMGR_SCF_IGNORE_IF_ALREADY_SYNCING: SYNCMGR_SYNC_CONTROL_FLAGS =
    SYNCMGR_SYNC_CONTROL_FLAGS(1i32);
pub const SYNCMGR_SCF_VALID: SYNCMGR_SYNC_CONTROL_FLAGS = SYNCMGR_SYNC_CONTROL_FLAGS(1i32);
impl ::core::marker::Copy for SYNCMGR_SYNC_CONTROL_FLAGS {}
impl ::core::clone::Clone for SYNCMGR_SYNC_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_SYNC_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_SYNC_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_SYNC_CONTROL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_SYNC_CONTROL_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SYNCMGR_UPDATE_REASON(pub i32);
pub const SYNCMGR_UR_ADDED: SYNCMGR_UPDATE_REASON = SYNCMGR_UPDATE_REASON(0i32);
pub const SYNCMGR_UR_CHANGED: SYNCMGR_UPDATE_REASON = SYNCMGR_UPDATE_REASON(1i32);
pub const SYNCMGR_UR_REMOVED: SYNCMGR_UPDATE_REASON = SYNCMGR_UPDATE_REASON(2i32);
pub const SYNCMGR_UR_MAX: SYNCMGR_UPDATE_REASON = SYNCMGR_UPDATE_REASON(2i32);
impl ::core::marker::Copy for SYNCMGR_UPDATE_REASON {}
impl ::core::clone::Clone for SYNCMGR_UPDATE_REASON {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SYNCMGR_UPDATE_REASON {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SYNCMGR_UPDATE_REASON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SYNCMGR_UPDATE_REASON")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SYNCMGR_UPDATE_REASON {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SZ_CONTENTTYPE_CDF: &'static str = "application/x-cdf";
pub const SZ_CONTENTTYPE_CDFA: &'static str = "application/x-cdf";
pub const SZ_CONTENTTYPE_CDFW: &'static str = "application/x-cdf";
pub const SZ_CONTENTTYPE_HTML: &'static str = "text/html";
pub const SZ_CONTENTTYPE_HTMLA: &'static str = "text/html";
pub const SZ_CONTENTTYPE_HTMLW: &'static str = "text/html";
pub const S_SYNCMGR_CANCELALL: crate::core::HRESULT = crate::core::HRESULT(262660i32);
pub const S_SYNCMGR_CANCELITEM: crate::core::HRESULT = crate::core::HRESULT(262659i32);
pub const S_SYNCMGR_ENUMITEMS: crate::core::HRESULT = crate::core::HRESULT(262673i32);
pub const S_SYNCMGR_ITEMDELETED: crate::core::HRESULT = crate::core::HRESULT(262672i32);
pub const S_SYNCMGR_MISSINGITEMS: crate::core::HRESULT = crate::core::HRESULT(262657i32);
pub const S_SYNCMGR_RETRYSYNC: crate::core::HRESULT = crate::core::HRESULT(262658i32);
pub const ScheduledTasks: crate::core::GUID =
    crate::core::GUID::from_u128(0xd6277990_4c6a_11cf_8d87_00aa0060f5bf);
pub const SearchFolderItemFactory: crate::core::GUID =
    crate::core::GUID::from_u128(0x14010e02_bbbd_41f0_88e3_eda371216584);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct SecureLockIconConstants(pub i32);
pub const secureLockIconUnsecure: SecureLockIconConstants = SecureLockIconConstants(0i32);
pub const secureLockIconMixed: SecureLockIconConstants = SecureLockIconConstants(1i32);
pub const secureLockIconSecureUnknownBits: SecureLockIconConstants = SecureLockIconConstants(2i32);
pub const secureLockIconSecure40Bit: SecureLockIconConstants = SecureLockIconConstants(3i32);
pub const secureLockIconSecure56Bit: SecureLockIconConstants = SecureLockIconConstants(4i32);
pub const secureLockIconSecureFortezza: SecureLockIconConstants = SecureLockIconConstants(5i32);
pub const secureLockIconSecure128Bit: SecureLockIconConstants = SecureLockIconConstants(6i32);
impl ::core::marker::Copy for SecureLockIconConstants {}
impl ::core::clone::Clone for SecureLockIconConstants {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SecureLockIconConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for SecureLockIconConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SecureLockIconConstants")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for SecureLockIconConstants {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const SelectedItemCount_Property_GUID: crate::core::GUID =
    crate::core::GUID::from_u128(0x8fe316d2_0e52_460a_9c1e_48f273d470a3);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ShFindChangeNotificationHandle(pub PtrDiffRepr);
impl ShFindChangeNotificationHandle {
    pub fn is_invalid(&self) -> bool {
        *self == unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::default::Default for ShFindChangeNotificationHandle {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::clone::Clone for ShFindChangeNotificationHandle {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::marker::Copy for ShFindChangeNotificationHandle {}
impl ::core::hash::Hash for ShFindChangeNotificationHandle {
    fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}
impl ::core::fmt::Debug for ShFindChangeNotificationHandle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ShFindChangeNotificationHandle")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ShFindChangeNotificationHandle {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<PtrDiffRepr as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        std::mem::size_of::<PtrDiffRepr>()
    }
}
pub const SharedBitmap: crate::core::GUID =
    crate::core::GUID::from_u128(0x4db26476_6787_4046_b836_e8412a9e8a27);
pub const SharingConfigurationManager: crate::core::GUID =
    crate::core::GUID::from_u128(0x49f371e1_8c5c_4d9c_9a3b_54a6827f513c);
pub const Shell: crate::core::GUID =
    crate::core::GUID::from_u128(0x13709620_c279_11ce_a49e_444553540000);
pub const ShellBrowserWindow: crate::core::GUID =
    crate::core::GUID::from_u128(0xc08afd90_f2a1_11d1_8455_00a0c91f3880);
pub const ShellDesktop: crate::core::GUID =
    crate::core::GUID::from_u128(0x00021400_0000_0000_c000_000000000046);
pub const ShellDispatchInproc: crate::core::GUID =
    crate::core::GUID::from_u128(0x0a89a860_d7b1_11ce_8350_444553540000);
pub const ShellFSFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0xf3364ba0_65b9_11ce_a9ba_00aa004ae837);
pub const ShellFolderItem: crate::core::GUID =
    crate::core::GUID::from_u128(0x2fe352ea_fd1f_11d2_b1f4_00c04f8eeb3e);
pub const ShellFolderView: crate::core::GUID =
    crate::core::GUID::from_u128(0x62112aa1_ebe4_11cf_a5fb_0020afe7292d);
pub const ShellFolderViewOC: crate::core::GUID =
    crate::core::GUID::from_u128(0x9ba05971_f6a8_11cf_a442_00a0c90a8f39);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ShellFolderViewOptions(pub i32);
pub const SFVVO_SHOWALLOBJECTS: ShellFolderViewOptions = ShellFolderViewOptions(1i32);
pub const SFVVO_SHOWEXTENSIONS: ShellFolderViewOptions = ShellFolderViewOptions(2i32);
pub const SFVVO_SHOWCOMPCOLOR: ShellFolderViewOptions = ShellFolderViewOptions(8i32);
pub const SFVVO_SHOWSYSFILES: ShellFolderViewOptions = ShellFolderViewOptions(32i32);
pub const SFVVO_WIN95CLASSIC: ShellFolderViewOptions = ShellFolderViewOptions(64i32);
pub const SFVVO_DOUBLECLICKINWEBVIEW: ShellFolderViewOptions = ShellFolderViewOptions(128i32);
pub const SFVVO_DESKTOPHTML: ShellFolderViewOptions = ShellFolderViewOptions(512i32);
impl ::core::marker::Copy for ShellFolderViewOptions {}
impl ::core::clone::Clone for ShellFolderViewOptions {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ShellFolderViewOptions {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ShellFolderViewOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ShellFolderViewOptions")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ShellFolderViewOptions {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const ShellImageDataFactory: crate::core::GUID =
    crate::core::GUID::from_u128(0x66e4e4fb_f385_4dd0_8d74_a2efd1bc6178);
pub const ShellItem: crate::core::GUID =
    crate::core::GUID::from_u128(0x9ac9fbe1_e0a2_4ad6_b4ee_e212013ea917);
pub const ShellLibrary: crate::core::GUID =
    crate::core::GUID::from_u128(0xd9b3211d_e57f_4426_aaef_30a806add397);
pub const ShellLink: crate::core::GUID =
    crate::core::GUID::from_u128(0x00021401_0000_0000_c000_000000000046);
pub const ShellLinkObject: crate::core::GUID =
    crate::core::GUID::from_u128(0x11219420_1768_11d1_95be_00609797ea4f);
pub const ShellNameSpace: crate::core::GUID =
    crate::core::GUID::from_u128(0x55136805_b2de_11d1_b9f2_00a0c98bc547);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ShellSpecialFolderConstants(pub i32);
pub const ssfDESKTOP: ShellSpecialFolderConstants = ShellSpecialFolderConstants(0i32);
pub const ssfPROGRAMS: ShellSpecialFolderConstants = ShellSpecialFolderConstants(2i32);
pub const ssfCONTROLS: ShellSpecialFolderConstants = ShellSpecialFolderConstants(3i32);
pub const ssfPRINTERS: ShellSpecialFolderConstants = ShellSpecialFolderConstants(4i32);
pub const ssfPERSONAL: ShellSpecialFolderConstants = ShellSpecialFolderConstants(5i32);
pub const ssfFAVORITES: ShellSpecialFolderConstants = ShellSpecialFolderConstants(6i32);
pub const ssfSTARTUP: ShellSpecialFolderConstants = ShellSpecialFolderConstants(7i32);
pub const ssfRECENT: ShellSpecialFolderConstants = ShellSpecialFolderConstants(8i32);
pub const ssfSENDTO: ShellSpecialFolderConstants = ShellSpecialFolderConstants(9i32);
pub const ssfBITBUCKET: ShellSpecialFolderConstants = ShellSpecialFolderConstants(10i32);
pub const ssfSTARTMENU: ShellSpecialFolderConstants = ShellSpecialFolderConstants(11i32);
pub const ssfDESKTOPDIRECTORY: ShellSpecialFolderConstants = ShellSpecialFolderConstants(16i32);
pub const ssfDRIVES: ShellSpecialFolderConstants = ShellSpecialFolderConstants(17i32);
pub const ssfNETWORK: ShellSpecialFolderConstants = ShellSpecialFolderConstants(18i32);
pub const ssfNETHOOD: ShellSpecialFolderConstants = ShellSpecialFolderConstants(19i32);
pub const ssfFONTS: ShellSpecialFolderConstants = ShellSpecialFolderConstants(20i32);
pub const ssfTEMPLATES: ShellSpecialFolderConstants = ShellSpecialFolderConstants(21i32);
pub const ssfCOMMONSTARTMENU: ShellSpecialFolderConstants = ShellSpecialFolderConstants(22i32);
pub const ssfCOMMONPROGRAMS: ShellSpecialFolderConstants = ShellSpecialFolderConstants(23i32);
pub const ssfCOMMONSTARTUP: ShellSpecialFolderConstants = ShellSpecialFolderConstants(24i32);
pub const ssfCOMMONDESKTOPDIR: ShellSpecialFolderConstants = ShellSpecialFolderConstants(25i32);
pub const ssfAPPDATA: ShellSpecialFolderConstants = ShellSpecialFolderConstants(26i32);
pub const ssfPRINTHOOD: ShellSpecialFolderConstants = ShellSpecialFolderConstants(27i32);
pub const ssfLOCALAPPDATA: ShellSpecialFolderConstants = ShellSpecialFolderConstants(28i32);
pub const ssfALTSTARTUP: ShellSpecialFolderConstants = ShellSpecialFolderConstants(29i32);
pub const ssfCOMMONALTSTARTUP: ShellSpecialFolderConstants = ShellSpecialFolderConstants(30i32);
pub const ssfCOMMONFAVORITES: ShellSpecialFolderConstants = ShellSpecialFolderConstants(31i32);
pub const ssfINTERNETCACHE: ShellSpecialFolderConstants = ShellSpecialFolderConstants(32i32);
pub const ssfCOOKIES: ShellSpecialFolderConstants = ShellSpecialFolderConstants(33i32);
pub const ssfHISTORY: ShellSpecialFolderConstants = ShellSpecialFolderConstants(34i32);
pub const ssfCOMMONAPPDATA: ShellSpecialFolderConstants = ShellSpecialFolderConstants(35i32);
pub const ssfWINDOWS: ShellSpecialFolderConstants = ShellSpecialFolderConstants(36i32);
pub const ssfSYSTEM: ShellSpecialFolderConstants = ShellSpecialFolderConstants(37i32);
pub const ssfPROGRAMFILES: ShellSpecialFolderConstants = ShellSpecialFolderConstants(38i32);
pub const ssfMYPICTURES: ShellSpecialFolderConstants = ShellSpecialFolderConstants(39i32);
pub const ssfPROFILE: ShellSpecialFolderConstants = ShellSpecialFolderConstants(40i32);
pub const ssfSYSTEMx86: ShellSpecialFolderConstants = ShellSpecialFolderConstants(41i32);
pub const ssfPROGRAMFILESx86: ShellSpecialFolderConstants = ShellSpecialFolderConstants(48i32);
impl ::core::marker::Copy for ShellSpecialFolderConstants {}
impl ::core::clone::Clone for ShellSpecialFolderConstants {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ShellSpecialFolderConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ShellSpecialFolderConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ShellSpecialFolderConstants")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ShellSpecialFolderConstants {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const ShellUIHelper: crate::core::GUID =
    crate::core::GUID::from_u128(0x64ab4bb7_111e_11d1_8f79_00c04fc2fbe1);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ShellWindowFindWindowOptions(pub i32);
pub const SWFO_NEEDDISPATCH: ShellWindowFindWindowOptions = ShellWindowFindWindowOptions(1i32);
pub const SWFO_INCLUDEPENDING: ShellWindowFindWindowOptions = ShellWindowFindWindowOptions(2i32);
pub const SWFO_COOKIEPASSED: ShellWindowFindWindowOptions = ShellWindowFindWindowOptions(4i32);
impl ::core::marker::Copy for ShellWindowFindWindowOptions {}
impl ::core::clone::Clone for ShellWindowFindWindowOptions {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ShellWindowFindWindowOptions {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ShellWindowFindWindowOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ShellWindowFindWindowOptions")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ShellWindowFindWindowOptions {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ShellWindowTypeConstants(pub i32);
pub const SWC_EXPLORER: ShellWindowTypeConstants = ShellWindowTypeConstants(0i32);
pub const SWC_BROWSER: ShellWindowTypeConstants = ShellWindowTypeConstants(1i32);
pub const SWC_3RDPARTY: ShellWindowTypeConstants = ShellWindowTypeConstants(2i32);
pub const SWC_CALLBACK: ShellWindowTypeConstants = ShellWindowTypeConstants(4i32);
pub const SWC_DESKTOP: ShellWindowTypeConstants = ShellWindowTypeConstants(8i32);
impl ::core::marker::Copy for ShellWindowTypeConstants {}
impl ::core::clone::Clone for ShellWindowTypeConstants {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ShellWindowTypeConstants {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ShellWindowTypeConstants {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ShellWindowTypeConstants")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ShellWindowTypeConstants {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const ShellWindows: crate::core::GUID =
    crate::core::GUID::from_u128(0x9ba05972_f6a8_11cf_a442_00a0c90a8f39);
pub const ShowInputPaneAnimationCoordinator: crate::core::GUID =
    crate::core::GUID::from_u128(0x1f046abf_3202_4dc1_8cb5_3c67617ce1fa);
pub const SimpleConflictPresenter: crate::core::GUID =
    crate::core::GUID::from_u128(0x7a0f6ab7_ed84_46b6_b47e_02aa159a152b);
pub const SizeCategorizer: crate::core::GUID =
    crate::core::GUID::from_u128(0x55d7b852_f6d1_42f2_aa75_8728a1b2d264);
pub const SmartcardCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x8fd7e19c_3bf7_489b_a72c_846ab3678c96);
pub const SmartcardPinProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x94596c7e_3744_41ce_893e_bbf09122f76a);
pub const SmartcardReaderSelectionProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x1b283861_754f_4022_ad47_a5eaaa618894);
pub const SmartcardWinRTProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x1ee7337f_85ac_45e2_a23c_37c753209769);
pub const StartMenuPin: crate::core::GUID =
    crate::core::GUID::from_u128(0xa2a9545d_a0c2_42b4_9708_a0b2badd77c8);
pub const StorageProviderBanners: crate::core::GUID =
    crate::core::GUID::from_u128(0x7ccdf9f4_e576_455a_8bc7_f6ec68d6f063);
pub const SuspensionDependencyManager: crate::core::GUID =
    crate::core::GUID::from_u128(0x6b273fc5_61fd_4918_95a2_c3b5e9d7f581);
pub const SyncMgr: crate::core::GUID =
    crate::core::GUID::from_u128(0x6295df27_35ee_11d1_8707_00c04fd93327);
pub const SyncMgrClient: crate::core::GUID =
    crate::core::GUID::from_u128(0x1202db60_1dac_42c5_aed5_1abdd432248e);
pub const SyncMgrControl: crate::core::GUID =
    crate::core::GUID::from_u128(0x1a1f4206_0688_4e7f_be03_d82ec69df9a5);
pub const SyncMgrFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x9c73f5e5_7ae7_4e32_a8e8_8d23b85255bf);
pub const SyncMgrScheduleWizard: crate::core::GUID =
    crate::core::GUID::from_u128(0x8d8b8e30_c451_421b_8553_d2976afa648c);
pub const SyncResultsFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x71d99464_3b6b_475c_b241_e15883207529);
pub const SyncSetupFolder: crate::core::GUID =
    crate::core::GUID::from_u128(0x2e9e59c0_b437_4981_a647_9c34b9b90891);
pub const TBIF_APPEND: u32 = 0u32;
pub const TBIF_DEFAULT: u32 = 0u32;
pub const TBIF_INTERNETBAR: u32 = 65536u32;
pub const TBIF_NOTOOLBAR: u32 = 196608u32;
pub const TBIF_PREPEND: u32 = 1u32;
pub const TBIF_REPLACE: u32 = 2u32;
pub const TBIF_STANDARDTOOLBAR: u32 = 131072u32;
pub struct TBINFO {
    pub cbuttons: u32,
    pub uFlags: u32,
}
impl ::core::marker::Copy for TBINFO {}
impl ::core::clone::Clone for TBINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TBINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TBINFO")
            .field("cbuttons", &self.cbuttons)
            .field("uFlags", &self.uFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for TBINFO {
    fn eq(&self, other: &Self) -> bool {
        self.cbuttons == other.cbuttons && self.uFlags == other.uFlags
    }
}
impl ::core::cmp::Eq for TBINFO {}
impl FromIntoMemory for TBINFO {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 8);
        let f_cbuttons = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_uFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        Self {
            cbuttons: f_cbuttons,
            uFlags: f_uFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 8);
        FromIntoMemory::into_bytes(self.cbuttons, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.uFlags, &mut into[4..4 + 4]);
    }
    fn size() -> usize {
        8
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct TBPFLAG(pub i32);
pub const TBPF_NOPROGRESS: TBPFLAG = TBPFLAG(0i32);
pub const TBPF_INDETERMINATE: TBPFLAG = TBPFLAG(1i32);
pub const TBPF_NORMAL: TBPFLAG = TBPFLAG(2i32);
pub const TBPF_ERROR: TBPFLAG = TBPFLAG(4i32);
pub const TBPF_PAUSED: TBPFLAG = TBPFLAG(8i32);
impl ::core::marker::Copy for TBPFLAG {}
impl ::core::clone::Clone for TBPFLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for TBPFLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for TBPFLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TBPFLAG").field(&self.0).finish()
    }
}
impl FromIntoMemory for TBPFLAG {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const THBN_CLICKED: u32 = 6144u32;
pub struct THUMBBUTTON {
    pub dwMask: THUMBBUTTONMASK,
    pub iId: u32,
    pub iBitmap: u32,
    pub hIcon: super::WindowsAndMessaging::HICON,
    pub szTip: [u16; 260],
    pub dwFlags: THUMBBUTTONFLAGS,
}
impl ::core::marker::Copy for THUMBBUTTON {}
impl ::core::clone::Clone for THUMBBUTTON {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for THUMBBUTTON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("THUMBBUTTON")
            .field("dwMask", &self.dwMask)
            .field("iId", &self.iId)
            .field("iBitmap", &self.iBitmap)
            .field("hIcon", &self.hIcon)
            .field("szTip", &self.szTip)
            .field("dwFlags", &self.dwFlags)
            .finish()
    }
}
impl ::core::cmp::PartialEq for THUMBBUTTON {
    fn eq(&self, other: &Self) -> bool {
        self.dwMask == other.dwMask
            && self.iId == other.iId
            && self.iBitmap == other.iBitmap
            && self.hIcon == other.hIcon
            && self.szTip == other.szTip
            && self.dwFlags == other.dwFlags
    }
}
impl ::core::cmp::Eq for THUMBBUTTON {}
impl FromIntoMemory for THUMBBUTTON {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 280);
        let f_dwMask = <THUMBBUTTONMASK as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_iId = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_iBitmap = <u32 as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_hIcon =
            <super::WindowsAndMessaging::HICON as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_szTip = <[u16; 260] as FromIntoMemory>::from_bytes(&from[16..16 + 260]);
        let f_dwFlags = <THUMBBUTTONFLAGS as FromIntoMemory>::from_bytes(&from[276..276 + 4]);
        Self {
            dwMask: f_dwMask,
            iId: f_iId,
            iBitmap: f_iBitmap,
            hIcon: f_hIcon,
            szTip: f_szTip,
            dwFlags: f_dwFlags,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 280);
        FromIntoMemory::into_bytes(self.dwMask, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.iId, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.iBitmap, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.hIcon, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.szTip, &mut into[16..16 + 260]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[276..276 + 4]);
    }
    fn size() -> usize {
        280
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct THUMBBUTTONFLAGS(pub i32);
pub const THBF_ENABLED: THUMBBUTTONFLAGS = THUMBBUTTONFLAGS(0i32);
pub const THBF_DISABLED: THUMBBUTTONFLAGS = THUMBBUTTONFLAGS(1i32);
pub const THBF_DISMISSONCLICK: THUMBBUTTONFLAGS = THUMBBUTTONFLAGS(2i32);
pub const THBF_NOBACKGROUND: THUMBBUTTONFLAGS = THUMBBUTTONFLAGS(4i32);
pub const THBF_HIDDEN: THUMBBUTTONFLAGS = THUMBBUTTONFLAGS(8i32);
pub const THBF_NONINTERACTIVE: THUMBBUTTONFLAGS = THUMBBUTTONFLAGS(16i32);
impl ::core::marker::Copy for THUMBBUTTONFLAGS {}
impl ::core::clone::Clone for THUMBBUTTONFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for THUMBBUTTONFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for THUMBBUTTONFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("THUMBBUTTONFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for THUMBBUTTONFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct THUMBBUTTONMASK(pub i32);
pub const THB_BITMAP: THUMBBUTTONMASK = THUMBBUTTONMASK(1i32);
pub const THB_ICON: THUMBBUTTONMASK = THUMBBUTTONMASK(2i32);
pub const THB_TOOLTIP: THUMBBUTTONMASK = THUMBBUTTONMASK(4i32);
pub const THB_FLAGS: THUMBBUTTONMASK = THUMBBUTTONMASK(8i32);
impl ::core::marker::Copy for THUMBBUTTONMASK {}
impl ::core::clone::Clone for THUMBBUTTONMASK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for THUMBBUTTONMASK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for THUMBBUTTONMASK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("THUMBBUTTONMASK").field(&self.0).finish()
    }
}
impl FromIntoMemory for THUMBBUTTONMASK {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const TITLEBARNAMELEN: u32 = 40u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct TI_FLAGS(pub i32);
pub const TI_BITMAP: TI_FLAGS = TI_FLAGS(1i32);
pub const TI_JPEG: TI_FLAGS = TI_FLAGS(2i32);
impl ::core::marker::Copy for TI_FLAGS {}
impl ::core::clone::Clone for TI_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for TI_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for TI_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TI_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for TI_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct TLENUMF(pub i32);
pub const TLEF_RELATIVE_INCLUDE_CURRENT: TLENUMF = TLENUMF(1i32);
pub const TLEF_RELATIVE_BACK: TLENUMF = TLENUMF(16i32);
pub const TLEF_RELATIVE_FORE: TLENUMF = TLENUMF(32i32);
pub const TLEF_INCLUDE_UNINVOKEABLE: TLENUMF = TLENUMF(64i32);
pub const TLEF_ABSOLUTE: TLENUMF = TLENUMF(49i32);
pub const TLEF_EXCLUDE_SUBFRAME_ENTRIES: TLENUMF = TLENUMF(128i32);
pub const TLEF_EXCLUDE_ABOUT_PAGES: TLENUMF = TLENUMF(256i32);
impl ::core::marker::Copy for TLENUMF {}
impl ::core::clone::Clone for TLENUMF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for TLENUMF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for TLENUMF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TLENUMF").field(&self.0).finish()
    }
}
impl FromIntoMemory for TLENUMF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const TLMENUF_BACK: u32 = 16u32;
pub const TLMENUF_FORE: u32 = 32u32;
pub const TLMENUF_INCLUDECURRENT: u32 = 1u32;
pub const TLOG_BACK: i32 = -1i32;
pub const TLOG_CURRENT: u32 = 0u32;
pub const TLOG_FORE: u32 = 1u32;
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct TOOLBARITEM {
    pub ptbar: IDockingWindow,
    pub rcBorderTool: super::super::Foundation::RECT,
    pub pwszItem: PWSTR,
    pub fShow: super::super::Foundation::BOOL,
    pub hMon: super::super::Graphics::Gdi::HMONITOR,
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for TOOLBARITEM {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for TOOLBARITEM {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for TOOLBARITEM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOOLBARITEM")
            .field("ptbar", &self.ptbar)
            .field("rcBorderTool", &self.rcBorderTool)
            .field("pwszItem", &self.pwszItem)
            .field("fShow", &self.fShow)
            .field("hMon", &self.hMon)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for TOOLBARITEM {
    fn eq(&self, other: &Self) -> bool {
        self.ptbar == other.ptbar
            && self.rcBorderTool == other.rcBorderTool
            && self.pwszItem == other.pwszItem
            && self.fShow == other.fShow
            && self.hMon == other.hMon
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for TOOLBARITEM {}
#[doc = "*Required namespaces: 'Windows.Win32.Foundation', 'Windows.Win32.Graphics.Gdi', 'Windows.Win32.System.Ole'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for TOOLBARITEM {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 32);
        let f_ptbar = <IDockingWindow as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_rcBorderTool =
            <super::super::Foundation::RECT as FromIntoMemory>::from_bytes(&from[4..4 + 16]);
        let f_pwszItem = <PWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        let f_fShow =
            <super::super::Foundation::BOOL as FromIntoMemory>::from_bytes(&from[24..24 + 4]);
        let f_hMon = <super::super::Graphics::Gdi::HMONITOR as FromIntoMemory>::from_bytes(
            &from[28..28 + 4],
        );
        Self {
            ptbar: f_ptbar,
            rcBorderTool: f_rcBorderTool,
            pwszItem: f_pwszItem,
            fShow: f_fShow,
            hMon: f_hMon,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 32);
        FromIntoMemory::into_bytes(self.ptbar, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.rcBorderTool, &mut into[4..4 + 16]);
        FromIntoMemory::into_bytes(self.pwszItem, &mut into[20..20 + 4]);
        FromIntoMemory::into_bytes(self.fShow, &mut into[24..24 + 4]);
        FromIntoMemory::into_bytes(self.hMon, &mut into[28..28 + 4]);
    }
    fn size() -> usize {
        32
    }
}
pub const TaskbarList: crate::core::GUID =
    crate::core::GUID::from_u128(0x56fdf344_fd6d_11d0_958a_006097c9a090);
pub const ThumbnailStreamCache: crate::core::GUID =
    crate::core::GUID::from_u128(0xcbe0fed3_4b91_4e90_8354_8a8c84ec6872);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct ThumbnailStreamCacheOptions(pub i32);
pub const ExtractIfNotCached: ThumbnailStreamCacheOptions = ThumbnailStreamCacheOptions(0i32);
pub const ReturnOnlyIfCached: ThumbnailStreamCacheOptions = ThumbnailStreamCacheOptions(1i32);
pub const ResizeThumbnail: ThumbnailStreamCacheOptions = ThumbnailStreamCacheOptions(2i32);
pub const AllowSmallerSize: ThumbnailStreamCacheOptions = ThumbnailStreamCacheOptions(4i32);
impl ::core::marker::Copy for ThumbnailStreamCacheOptions {}
impl ::core::clone::Clone for ThumbnailStreamCacheOptions {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ThumbnailStreamCacheOptions {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for ThumbnailStreamCacheOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ThumbnailStreamCacheOptions")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for ThumbnailStreamCacheOptions {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const TimeCategorizer: crate::core::GUID =
    crate::core::GUID::from_u128(0x3bb4118f_ddfd_4d30_a348_9fb5d6bf1afe);
pub const TrackShellMenu: crate::core::GUID =
    crate::core::GUID::from_u128(0x8278f931_2a3e_11d2_838f_00c04fd918d0);
pub const TrayBandSiteService: crate::core::GUID =
    crate::core::GUID::from_u128(0xf60ad0a0_e5e1_45cb_b51a_e15b9f8b2934);
pub const TrayDeskBand: crate::core::GUID =
    crate::core::GUID::from_u128(0xe6442437_6c68_4f52_94dd_2cfed267efb9);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct UNDOCK_REASON(pub i32);
pub const UR_RESOLUTION_CHANGE: UNDOCK_REASON = UNDOCK_REASON(0i32);
pub const UR_MONITOR_DISCONNECT: UNDOCK_REASON = UNDOCK_REASON(1i32);
impl ::core::marker::Copy for UNDOCK_REASON {}
impl ::core::clone::Clone for UNDOCK_REASON {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for UNDOCK_REASON {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for UNDOCK_REASON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("UNDOCK_REASON").field(&self.0).finish()
    }
}
impl FromIntoMemory for UNDOCK_REASON {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct URLIS(pub i32);
pub const URLIS_URL: URLIS = URLIS(0i32);
pub const URLIS_OPAQUE: URLIS = URLIS(1i32);
pub const URLIS_NOHISTORY: URLIS = URLIS(2i32);
pub const URLIS_FILEURL: URLIS = URLIS(3i32);
pub const URLIS_APPLIABLE: URLIS = URLIS(4i32);
pub const URLIS_DIRECTORY: URLIS = URLIS(5i32);
pub const URLIS_HASQUERY: URLIS = URLIS(6i32);
impl ::core::marker::Copy for URLIS {}
impl ::core::clone::Clone for URLIS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for URLIS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for URLIS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("URLIS").field(&self.0).finish()
    }
}
impl FromIntoMemory for URLIS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const URL_APPLY_DEFAULT: u32 = 1u32;
pub const URL_APPLY_FORCEAPPLY: u32 = 8u32;
pub const URL_APPLY_GUESSFILE: u32 = 4u32;
pub const URL_APPLY_GUESSSCHEME: u32 = 2u32;
pub const URL_BROWSER_MODE: u32 = 33554432u32;
pub const URL_CONVERT_IF_DOSPATH: u32 = 2097152u32;
pub const URL_DONT_ESCAPE_EXTRA_INFO: u32 = 33554432u32;
pub const URL_DONT_SIMPLIFY: u32 = 134217728u32;
pub const URL_DONT_UNESCAPE: u32 = 131072u32;
pub const URL_DONT_UNESCAPE_EXTRA_INFO: u32 = 33554432u32;
pub const URL_ESCAPE_ASCII_URI_COMPONENT: u32 = 524288u32;
pub const URL_ESCAPE_AS_UTF8: u32 = 262144u32;
pub const URL_ESCAPE_PERCENT: u32 = 4096u32;
pub const URL_ESCAPE_SEGMENT_ONLY: u32 = 8192u32;
pub const URL_ESCAPE_SPACES_ONLY: u32 = 67108864u32;
pub const URL_ESCAPE_UNSAFE: u32 = 536870912u32;
pub const URL_E_INVALID_SYNTAX: crate::core::HRESULT = crate::core::HRESULT(-2147217407i32);
pub const URL_E_UNREGISTERED_PROTOCOL: crate::core::HRESULT = crate::core::HRESULT(-2147217406i32);
pub const URL_FILE_USE_PATHURL: u32 = 65536u32;
pub const URL_INTERNAL_PATH: u32 = 8388608u32;
pub const URL_NO_META: u32 = 134217728u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct URL_PART(pub i32);
pub const URL_PART_NONE: URL_PART = URL_PART(0i32);
pub const URL_PART_SCHEME: URL_PART = URL_PART(1i32);
pub const URL_PART_HOSTNAME: URL_PART = URL_PART(2i32);
pub const URL_PART_USERNAME: URL_PART = URL_PART(3i32);
pub const URL_PART_PASSWORD: URL_PART = URL_PART(4i32);
pub const URL_PART_PORT: URL_PART = URL_PART(5i32);
pub const URL_PART_QUERY: URL_PART = URL_PART(6i32);
impl ::core::marker::Copy for URL_PART {}
impl ::core::clone::Clone for URL_PART {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for URL_PART {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for URL_PART {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("URL_PART").field(&self.0).finish()
    }
}
impl FromIntoMemory for URL_PART {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const URL_PARTFLAG_KEEPSCHEME: u32 = 1u32;
pub const URL_PLUGGABLE_PROTOCOL: u32 = 1073741824u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct URL_SCHEME(pub i32);
pub const URL_SCHEME_INVALID: URL_SCHEME = URL_SCHEME(-1i32);
pub const URL_SCHEME_UNKNOWN: URL_SCHEME = URL_SCHEME(0i32);
pub const URL_SCHEME_FTP: URL_SCHEME = URL_SCHEME(1i32);
pub const URL_SCHEME_HTTP: URL_SCHEME = URL_SCHEME(2i32);
pub const URL_SCHEME_GOPHER: URL_SCHEME = URL_SCHEME(3i32);
pub const URL_SCHEME_MAILTO: URL_SCHEME = URL_SCHEME(4i32);
pub const URL_SCHEME_NEWS: URL_SCHEME = URL_SCHEME(5i32);
pub const URL_SCHEME_NNTP: URL_SCHEME = URL_SCHEME(6i32);
pub const URL_SCHEME_TELNET: URL_SCHEME = URL_SCHEME(7i32);
pub const URL_SCHEME_WAIS: URL_SCHEME = URL_SCHEME(8i32);
pub const URL_SCHEME_FILE: URL_SCHEME = URL_SCHEME(9i32);
pub const URL_SCHEME_MK: URL_SCHEME = URL_SCHEME(10i32);
pub const URL_SCHEME_HTTPS: URL_SCHEME = URL_SCHEME(11i32);
pub const URL_SCHEME_SHELL: URL_SCHEME = URL_SCHEME(12i32);
pub const URL_SCHEME_SNEWS: URL_SCHEME = URL_SCHEME(13i32);
pub const URL_SCHEME_LOCAL: URL_SCHEME = URL_SCHEME(14i32);
pub const URL_SCHEME_JAVASCRIPT: URL_SCHEME = URL_SCHEME(15i32);
pub const URL_SCHEME_VBSCRIPT: URL_SCHEME = URL_SCHEME(16i32);
pub const URL_SCHEME_ABOUT: URL_SCHEME = URL_SCHEME(17i32);
pub const URL_SCHEME_RES: URL_SCHEME = URL_SCHEME(18i32);
pub const URL_SCHEME_MSSHELLROOTED: URL_SCHEME = URL_SCHEME(19i32);
pub const URL_SCHEME_MSSHELLIDLIST: URL_SCHEME = URL_SCHEME(20i32);
pub const URL_SCHEME_MSHELP: URL_SCHEME = URL_SCHEME(21i32);
pub const URL_SCHEME_MSSHELLDEVICE: URL_SCHEME = URL_SCHEME(22i32);
pub const URL_SCHEME_WILDCARD: URL_SCHEME = URL_SCHEME(23i32);
pub const URL_SCHEME_SEARCH_MS: URL_SCHEME = URL_SCHEME(24i32);
pub const URL_SCHEME_SEARCH: URL_SCHEME = URL_SCHEME(25i32);
pub const URL_SCHEME_KNOWNFOLDER: URL_SCHEME = URL_SCHEME(26i32);
pub const URL_SCHEME_MAXVALUE: URL_SCHEME = URL_SCHEME(27i32);
impl ::core::marker::Copy for URL_SCHEME {}
impl ::core::clone::Clone for URL_SCHEME {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for URL_SCHEME {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for URL_SCHEME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("URL_SCHEME").field(&self.0).finish()
    }
}
impl FromIntoMemory for URL_SCHEME {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const URL_UNESCAPE: u32 = 268435456u32;
pub const URL_UNESCAPE_AS_UTF8: u32 = 262144u32;
pub const URL_UNESCAPE_HIGH_ANSI_ONLY: u32 = 4194304u32;
pub const URL_UNESCAPE_INPLACE: u32 = 1048576u32;
pub const URL_UNESCAPE_URI_COMPONENT: u32 = 262144u32;
pub const URL_WININET_COMPATIBILITY: u32 = 2147483648u32;
pub const UserNotification: crate::core::GUID =
    crate::core::GUID::from_u128(0x0010890e_8789_413c_adbc_48f5b511b3af);
pub const V1PasswordCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x6f45dc1e_5384_457a_bc13_2cd81b0d28ed);
pub const V1SmartcardCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x8bf9a910_a8ff_457f_999f_a5ca10b4a885);
pub const V1WinBioCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0xac3ac249_e820_4343_a65b_377ac634dc09);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct VALIDATEUNC_OPTION(pub i32);
pub const VALIDATEUNC_CONNECT: VALIDATEUNC_OPTION = VALIDATEUNC_OPTION(1i32);
pub const VALIDATEUNC_NOUI: VALIDATEUNC_OPTION = VALIDATEUNC_OPTION(2i32);
pub const VALIDATEUNC_PRINT: VALIDATEUNC_OPTION = VALIDATEUNC_OPTION(4i32);
pub const VALIDATEUNC_PERSIST: VALIDATEUNC_OPTION = VALIDATEUNC_OPTION(8i32);
pub const VALIDATEUNC_VALID: VALIDATEUNC_OPTION = VALIDATEUNC_OPTION(15i32);
impl ::core::marker::Copy for VALIDATEUNC_OPTION {}
impl ::core::clone::Clone for VALIDATEUNC_OPTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for VALIDATEUNC_OPTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VALIDATEUNC_OPTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VALIDATEUNC_OPTION").field(&self.0).finish()
    }
}
impl ::core::ops::BitOr for VALIDATEUNC_OPTION {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for VALIDATEUNC_OPTION {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for VALIDATEUNC_OPTION {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for VALIDATEUNC_OPTION {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for VALIDATEUNC_OPTION {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
impl FromIntoMemory for VALIDATEUNC_OPTION {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const VID_Content: crate::core::GUID =
    crate::core::GUID::from_u128(0x30c2c434_0889_4c8d_985d_a9f71830b0a9);
pub const VID_Details: crate::core::GUID =
    crate::core::GUID::from_u128(0x137e7700_3573_11cf_ae69_08002b2e1262);
pub const VID_LargeIcons: crate::core::GUID =
    crate::core::GUID::from_u128(0x0057d0e0_3573_11cf_ae69_08002b2e1262);
pub const VID_List: crate::core::GUID =
    crate::core::GUID::from_u128(0x0e1fa5e0_3573_11cf_ae69_08002b2e1262);
pub const VID_SmallIcons: crate::core::GUID =
    crate::core::GUID::from_u128(0x089000c0_3573_11cf_ae69_08002b2e1262);
pub const VID_ThumbStrip: crate::core::GUID =
    crate::core::GUID::from_u128(0x8eefa624_d1e9_445b_94b7_74fbce2ea11a);
pub const VID_Thumbnails: crate::core::GUID =
    crate::core::GUID::from_u128(0x8bebb290_52d0_11d0_b7f4_00c04fd706ec);
pub const VID_Tile: crate::core::GUID =
    crate::core::GUID::from_u128(0x65f125e5_7be1_4810_ba9d_d271c8432ce3);
pub const VIEW_PRIORITY_CACHEHIT: u32 = 80u32;
pub const VIEW_PRIORITY_CACHEMISS: u32 = 48u32;
pub const VIEW_PRIORITY_DESPERATE: u32 = 16u32;
pub const VIEW_PRIORITY_INHERIT: u32 = 32u32;
pub const VIEW_PRIORITY_NONE: u32 = 0u32;
pub const VIEW_PRIORITY_RESTRICTED: u32 = 112u32;
pub const VIEW_PRIORITY_SHELLEXT: u32 = 64u32;
pub const VIEW_PRIORITY_SHELLEXT_ASBACKUP: u32 = 21u32;
pub const VIEW_PRIORITY_STALECACHEHIT: u32 = 69u32;
pub const VIEW_PRIORITY_USEASDEFAULT: u32 = 67u32;
pub const VOLUME_PREFIX: &'static str = "\\\\?\\Volume";
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct VPCOLORFLAGS(pub i32);
pub const VPCF_TEXT: VPCOLORFLAGS = VPCOLORFLAGS(1i32);
pub const VPCF_BACKGROUND: VPCOLORFLAGS = VPCOLORFLAGS(2i32);
pub const VPCF_SORTCOLUMN: VPCOLORFLAGS = VPCOLORFLAGS(3i32);
pub const VPCF_SUBTEXT: VPCOLORFLAGS = VPCOLORFLAGS(4i32);
pub const VPCF_TEXTBACKGROUND: VPCOLORFLAGS = VPCOLORFLAGS(5i32);
impl ::core::marker::Copy for VPCOLORFLAGS {}
impl ::core::clone::Clone for VPCOLORFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for VPCOLORFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VPCOLORFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VPCOLORFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for VPCOLORFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct VPWATERMARKFLAGS(pub i32);
pub const VPWF_DEFAULT: VPWATERMARKFLAGS = VPWATERMARKFLAGS(0i32);
pub const VPWF_ALPHABLEND: VPWATERMARKFLAGS = VPWATERMARKFLAGS(1i32);
impl ::core::marker::Copy for VPWATERMARKFLAGS {}
impl ::core::clone::Clone for VPWATERMARKFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for VPWATERMARKFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for VPWATERMARKFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VPWATERMARKFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for VPWATERMARKFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const VaultProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0x503739d0_4c5e_4cfd_b3ba_d881334f0df2);
pub const VirtualDesktopManager: crate::core::GUID =
    crate::core::GUID::from_u128(0xaa509086_5ca9_4c25_8f95_589d3c07b48a);
pub const WC_NETADDRESS: &'static str = "msctls_netaddress";
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
pub struct WINDOWDATA {
    pub dwWindowID: u32,
    pub uiCP: u32,
    pub pidl: MutPtr<Common::ITEMIDLIST>,
    pub lpszUrl: PWSTR,
    pub lpszUrlLocation: PWSTR,
    pub lpszTitle: PWSTR,
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::marker::Copy for WINDOWDATA {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::clone::Clone for WINDOWDATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::fmt::Debug for WINDOWDATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WINDOWDATA")
            .field("dwWindowID", &self.dwWindowID)
            .field("uiCP", &self.uiCP)
            .field("pidl", &self.pidl)
            .field("lpszUrl", &self.lpszUrl)
            .field("lpszUrlLocation", &self.lpszUrlLocation)
            .field("lpszTitle", &self.lpszTitle)
            .finish()
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::PartialEq for WINDOWDATA {
    fn eq(&self, other: &Self) -> bool {
        self.dwWindowID == other.dwWindowID
            && self.uiCP == other.uiCP
            && self.pidl == other.pidl
            && self.lpszUrl == other.lpszUrl
            && self.lpszUrlLocation == other.lpszUrlLocation
            && self.lpszTitle == other.lpszTitle
    }
}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl ::core::cmp::Eq for WINDOWDATA {}
#[doc = "*Required namespaces: 'Windows.Win32.UI.Shell.Common'*"]
#[cfg(dummy_option_that_does_not_exist)]
impl FromIntoMemory for WINDOWDATA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 24);
        let f_dwWindowID = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_uiCP = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_pidl = <MutPtr<Common::ITEMIDLIST> as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_lpszUrl = <PWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        let f_lpszUrlLocation = <PWSTR as FromIntoMemory>::from_bytes(&from[16..16 + 4]);
        let f_lpszTitle = <PWSTR as FromIntoMemory>::from_bytes(&from[20..20 + 4]);
        Self {
            dwWindowID: f_dwWindowID,
            uiCP: f_uiCP,
            pidl: f_pidl,
            lpszUrl: f_lpszUrl,
            lpszUrlLocation: f_lpszUrlLocation,
            lpszTitle: f_lpszTitle,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 24);
        FromIntoMemory::into_bytes(self.dwWindowID, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.uiCP, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.pidl, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.lpszUrl, &mut into[12..12 + 4]);
        FromIntoMemory::into_bytes(self.lpszUrlLocation, &mut into[16..16 + 4]);
        FromIntoMemory::into_bytes(self.lpszTitle, &mut into[20..20 + 4]);
    }
    fn size() -> usize {
        24
    }
}
pub const WM_CPL_LAUNCH: u32 = 2024u32;
pub const WM_CPL_LAUNCHED: u32 = 2025u32;
pub const WPSTYLE_CENTER: u32 = 0u32;
pub const WPSTYLE_CROPTOFIT: u32 = 4u32;
pub const WPSTYLE_KEEPASPECT: u32 = 3u32;
pub const WPSTYLE_MAX: u32 = 6u32;
pub const WPSTYLE_SPAN: u32 = 5u32;
pub const WPSTYLE_STRETCH: u32 = 2u32;
pub const WPSTYLE_TILE: u32 = 1u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct WTS_ALPHATYPE(pub i32);
pub const WTSAT_UNKNOWN: WTS_ALPHATYPE = WTS_ALPHATYPE(0i32);
pub const WTSAT_RGB: WTS_ALPHATYPE = WTS_ALPHATYPE(1i32);
pub const WTSAT_ARGB: WTS_ALPHATYPE = WTS_ALPHATYPE(2i32);
impl ::core::marker::Copy for WTS_ALPHATYPE {}
impl ::core::clone::Clone for WTS_ALPHATYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for WTS_ALPHATYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for WTS_ALPHATYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("WTS_ALPHATYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for WTS_ALPHATYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct WTS_CACHEFLAGS(pub i32);
pub const WTS_DEFAULT: WTS_CACHEFLAGS = WTS_CACHEFLAGS(0i32);
pub const WTS_LOWQUALITY: WTS_CACHEFLAGS = WTS_CACHEFLAGS(1i32);
pub const WTS_CACHED: WTS_CACHEFLAGS = WTS_CACHEFLAGS(2i32);
impl ::core::marker::Copy for WTS_CACHEFLAGS {}
impl ::core::clone::Clone for WTS_CACHEFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for WTS_CACHEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for WTS_CACHEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("WTS_CACHEFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for WTS_CACHEFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct WTS_CONTEXTFLAGS(pub i32);
pub const WTSCF_DEFAULT: WTS_CONTEXTFLAGS = WTS_CONTEXTFLAGS(0i32);
pub const WTSCF_APPSTYLE: WTS_CONTEXTFLAGS = WTS_CONTEXTFLAGS(1i32);
pub const WTSCF_SQUARE: WTS_CONTEXTFLAGS = WTS_CONTEXTFLAGS(2i32);
pub const WTSCF_WIDE: WTS_CONTEXTFLAGS = WTS_CONTEXTFLAGS(4i32);
pub const WTSCF_FAST: WTS_CONTEXTFLAGS = WTS_CONTEXTFLAGS(8i32);
impl ::core::marker::Copy for WTS_CONTEXTFLAGS {}
impl ::core::clone::Clone for WTS_CONTEXTFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for WTS_CONTEXTFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for WTS_CONTEXTFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("WTS_CONTEXTFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for WTS_CONTEXTFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const WTS_E_DATAFILEUNAVAILABLE: crate::core::HRESULT = crate::core::HRESULT(-2147175932i32);
pub const WTS_E_EXTRACTIONBLOCKED: crate::core::HRESULT = crate::core::HRESULT(-2147175930i32);
pub const WTS_E_EXTRACTIONPENDING: crate::core::HRESULT = crate::core::HRESULT(-2147175931i32);
pub const WTS_E_EXTRACTIONTIMEDOUT: crate::core::HRESULT = crate::core::HRESULT(-2147175935i32);
pub const WTS_E_FAILEDEXTRACTION: crate::core::HRESULT = crate::core::HRESULT(-2147175936i32);
pub const WTS_E_FASTEXTRACTIONNOTSUPPORTED: crate::core::HRESULT =
    crate::core::HRESULT(-2147175933i32);
pub const WTS_E_NOSTORAGEPROVIDERTHUMBNAILHANDLER: crate::core::HRESULT =
    crate::core::HRESULT(-2147175929i32);
pub const WTS_E_SURROGATEUNAVAILABLE: crate::core::HRESULT = crate::core::HRESULT(-2147175934i32);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct WTS_FLAGS(pub i32);
pub const WTS_NONE: WTS_FLAGS = WTS_FLAGS(0i32);
pub const WTS_EXTRACT: WTS_FLAGS = WTS_FLAGS(0i32);
pub const WTS_INCACHEONLY: WTS_FLAGS = WTS_FLAGS(1i32);
pub const WTS_FASTEXTRACT: WTS_FLAGS = WTS_FLAGS(2i32);
pub const WTS_FORCEEXTRACTION: WTS_FLAGS = WTS_FLAGS(4i32);
pub const WTS_SLOWRECLAIM: WTS_FLAGS = WTS_FLAGS(8i32);
pub const WTS_EXTRACTDONOTCACHE: WTS_FLAGS = WTS_FLAGS(32i32);
pub const WTS_SCALETOREQUESTEDSIZE: WTS_FLAGS = WTS_FLAGS(64i32);
pub const WTS_SKIPFASTEXTRACT: WTS_FLAGS = WTS_FLAGS(128i32);
pub const WTS_EXTRACTINPROC: WTS_FLAGS = WTS_FLAGS(256i32);
pub const WTS_CROPTOSQUARE: WTS_FLAGS = WTS_FLAGS(512i32);
pub const WTS_INSTANCESURROGATE: WTS_FLAGS = WTS_FLAGS(1024i32);
pub const WTS_REQUIRESURROGATE: WTS_FLAGS = WTS_FLAGS(2048i32);
pub const WTS_APPSTYLE: WTS_FLAGS = WTS_FLAGS(8192i32);
pub const WTS_WIDETHUMBNAILS: WTS_FLAGS = WTS_FLAGS(16384i32);
pub const WTS_IDEALCACHESIZEONLY: WTS_FLAGS = WTS_FLAGS(32768i32);
pub const WTS_SCALEUP: WTS_FLAGS = WTS_FLAGS(65536i32);
impl ::core::marker::Copy for WTS_FLAGS {}
impl ::core::clone::Clone for WTS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for WTS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for WTS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("WTS_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for WTS_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct WTS_THUMBNAILID {
    pub rgbKey: [u8; 16],
}
impl ::core::marker::Copy for WTS_THUMBNAILID {}
impl ::core::clone::Clone for WTS_THUMBNAILID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WTS_THUMBNAILID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WTS_THUMBNAILID")
            .field("rgbKey", &self.rgbKey)
            .finish()
    }
}
impl ::core::cmp::PartialEq for WTS_THUMBNAILID {
    fn eq(&self, other: &Self) -> bool {
        self.rgbKey == other.rgbKey
    }
}
impl ::core::cmp::Eq for WTS_THUMBNAILID {}
impl FromIntoMemory for WTS_THUMBNAILID {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_rgbKey = <[u8; 16] as FromIntoMemory>::from_bytes(&from[0..0 + 16]);
        Self { rgbKey: f_rgbKey }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.rgbKey, &mut into[0..0 + 16]);
    }
    fn size() -> usize {
        16
    }
}
pub const WebBrowser: crate::core::GUID =
    crate::core::GUID::from_u128(0x8856f961_340a_11d0_a96b_00c04fd705a2);
pub const WebBrowser_V1: crate::core::GUID =
    crate::core::GUID::from_u128(0xeab22ac3_30c1_11cf_a7eb_0000c05bae0b);
pub const WebWizardHost: crate::core::GUID =
    crate::core::GUID::from_u128(0xc827f149_55c1_4d28_935e_57e47caed973);
pub const WinBioCredentialProvider: crate::core::GUID =
    crate::core::GUID::from_u128(0xbec09223_b018_416d_a0ac_523971b639f5);
pub struct _APPCONSTRAIN_REGISTRATION(pub u8);
pub struct _APPSTATE_REGISTRATION(pub u8);
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _BROWSERFRAMEOPTIONS(pub i32);
pub const BFO_NONE: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(0i32);
pub const BFO_BROWSER_PERSIST_SETTINGS: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(1i32);
pub const BFO_RENAME_FOLDER_OPTIONS_TOINTERNET: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(2i32);
pub const BFO_BOTH_OPTIONS: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(4i32);
pub const BIF_PREFER_INTERNET_SHORTCUT: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(8i32);
pub const BFO_BROWSE_NO_IN_NEW_PROCESS: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(16i32);
pub const BFO_ENABLE_HYPERLINK_TRACKING: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(32i32);
pub const BFO_USE_IE_OFFLINE_SUPPORT: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(64i32);
pub const BFO_SUBSTITUE_INTERNET_START_PAGE: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(128i32);
pub const BFO_USE_IE_LOGOBANDING: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(256i32);
pub const BFO_ADD_IE_TOCAPTIONBAR: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(512i32);
pub const BFO_USE_DIALUP_REF: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(1024i32);
pub const BFO_USE_IE_TOOLBAR: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(2048i32);
pub const BFO_NO_PARENT_FOLDER_SUPPORT: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(4096i32);
pub const BFO_NO_REOPEN_NEXT_RESTART: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(8192i32);
pub const BFO_GO_HOME_PAGE: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(16384i32);
pub const BFO_PREFER_IEPROCESS: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(32768i32);
pub const BFO_SHOW_NAVIGATION_CANCELLED: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(65536i32);
pub const BFO_USE_IE_STATUSBAR: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(131072i32);
pub const BFO_QUERY_ALL: _BROWSERFRAMEOPTIONS = _BROWSERFRAMEOPTIONS(-1i32);
impl ::core::marker::Copy for _BROWSERFRAMEOPTIONS {}
impl ::core::clone::Clone for _BROWSERFRAMEOPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _BROWSERFRAMEOPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _BROWSERFRAMEOPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_BROWSERFRAMEOPTIONS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for _BROWSERFRAMEOPTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _CDBE_ACTIONS(pub i32);
pub const CDBE_TYPE_MUSIC: _CDBE_ACTIONS = _CDBE_ACTIONS(1i32);
pub const CDBE_TYPE_DATA: _CDBE_ACTIONS = _CDBE_ACTIONS(2i32);
pub const CDBE_TYPE_ALL: _CDBE_ACTIONS = _CDBE_ACTIONS(-1i32);
impl ::core::marker::Copy for _CDBE_ACTIONS {}
impl ::core::clone::Clone for _CDBE_ACTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _CDBE_ACTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _CDBE_ACTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_CDBE_ACTIONS").field(&self.0).finish()
    }
}
impl FromIntoMemory for _CDBE_ACTIONS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _EXPCMDFLAGS(pub i32);
pub const ECF_DEFAULT: _EXPCMDFLAGS = _EXPCMDFLAGS(0i32);
pub const ECF_HASSUBCOMMANDS: _EXPCMDFLAGS = _EXPCMDFLAGS(1i32);
pub const ECF_HASSPLITBUTTON: _EXPCMDFLAGS = _EXPCMDFLAGS(2i32);
pub const ECF_HIDELABEL: _EXPCMDFLAGS = _EXPCMDFLAGS(4i32);
pub const ECF_ISSEPARATOR: _EXPCMDFLAGS = _EXPCMDFLAGS(8i32);
pub const ECF_HASLUASHIELD: _EXPCMDFLAGS = _EXPCMDFLAGS(16i32);
pub const ECF_SEPARATORBEFORE: _EXPCMDFLAGS = _EXPCMDFLAGS(32i32);
pub const ECF_SEPARATORAFTER: _EXPCMDFLAGS = _EXPCMDFLAGS(64i32);
pub const ECF_ISDROPDOWN: _EXPCMDFLAGS = _EXPCMDFLAGS(128i32);
pub const ECF_TOGGLEABLE: _EXPCMDFLAGS = _EXPCMDFLAGS(256i32);
pub const ECF_AUTOMENUICONS: _EXPCMDFLAGS = _EXPCMDFLAGS(512i32);
impl ::core::marker::Copy for _EXPCMDFLAGS {}
impl ::core::clone::Clone for _EXPCMDFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _EXPCMDFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _EXPCMDFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_EXPCMDFLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for _EXPCMDFLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _EXPCMDSTATE(pub i32);
pub const ECS_ENABLED: _EXPCMDSTATE = _EXPCMDSTATE(0i32);
pub const ECS_DISABLED: _EXPCMDSTATE = _EXPCMDSTATE(1i32);
pub const ECS_HIDDEN: _EXPCMDSTATE = _EXPCMDSTATE(2i32);
pub const ECS_CHECKBOX: _EXPCMDSTATE = _EXPCMDSTATE(4i32);
pub const ECS_CHECKED: _EXPCMDSTATE = _EXPCMDSTATE(8i32);
pub const ECS_RADIOCHECK: _EXPCMDSTATE = _EXPCMDSTATE(16i32);
impl ::core::marker::Copy for _EXPCMDSTATE {}
impl ::core::clone::Clone for _EXPCMDSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _EXPCMDSTATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _EXPCMDSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_EXPCMDSTATE").field(&self.0).finish()
    }
}
impl FromIntoMemory for _EXPCMDSTATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _EXPLORERPANESTATE(pub i32);
pub const EPS_DONTCARE: _EXPLORERPANESTATE = _EXPLORERPANESTATE(0i32);
pub const EPS_DEFAULT_ON: _EXPLORERPANESTATE = _EXPLORERPANESTATE(1i32);
pub const EPS_DEFAULT_OFF: _EXPLORERPANESTATE = _EXPLORERPANESTATE(2i32);
pub const EPS_STATEMASK: _EXPLORERPANESTATE = _EXPLORERPANESTATE(65535i32);
pub const EPS_INITIALSTATE: _EXPLORERPANESTATE = _EXPLORERPANESTATE(65536i32);
pub const EPS_FORCE: _EXPLORERPANESTATE = _EXPLORERPANESTATE(131072i32);
impl ::core::marker::Copy for _EXPLORERPANESTATE {}
impl ::core::clone::Clone for _EXPLORERPANESTATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _EXPLORERPANESTATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _EXPLORERPANESTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_EXPLORERPANESTATE").field(&self.0).finish()
    }
}
impl FromIntoMemory for _EXPLORERPANESTATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _EXPPS(pub i32);
pub const EXPPS_FILETYPES: _EXPPS = _EXPPS(1i32);
impl ::core::marker::Copy for _EXPPS {}
impl ::core::clone::Clone for _EXPPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _EXPPS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _EXPPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_EXPPS").field(&self.0).finish()
    }
}
impl FromIntoMemory for _EXPPS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _HLSHORTCUTF__NOREDEF10(pub i32);
pub const HLSHORTCUTF_DEFAULT: _HLSHORTCUTF__NOREDEF10 = _HLSHORTCUTF__NOREDEF10(0i32);
pub const HLSHORTCUTF_DONTACTUALLYCREATE: _HLSHORTCUTF__NOREDEF10 = _HLSHORTCUTF__NOREDEF10(1i32);
pub const HLSHORTCUTF_USEFILENAMEFROMFRIENDLYNAME: _HLSHORTCUTF__NOREDEF10 =
    _HLSHORTCUTF__NOREDEF10(2i32);
pub const HLSHORTCUTF_USEUNIQUEFILENAME: _HLSHORTCUTF__NOREDEF10 = _HLSHORTCUTF__NOREDEF10(4i32);
pub const HLSHORTCUTF_MAYUSEEXISTINGSHORTCUT: _HLSHORTCUTF__NOREDEF10 =
    _HLSHORTCUTF__NOREDEF10(8i32);
impl ::core::marker::Copy for _HLSHORTCUTF__NOREDEF10 {}
impl ::core::clone::Clone for _HLSHORTCUTF__NOREDEF10 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _HLSHORTCUTF__NOREDEF10 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _HLSHORTCUTF__NOREDEF10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_HLSHORTCUTF__NOREDEF10")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for _HLSHORTCUTF__NOREDEF10 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _HLSR_NOREDEF10(pub i32);
pub const HLSR_HOME: _HLSR_NOREDEF10 = _HLSR_NOREDEF10(0i32);
pub const HLSR_SEARCHPAGE: _HLSR_NOREDEF10 = _HLSR_NOREDEF10(1i32);
pub const HLSR_HISTORYFOLDER: _HLSR_NOREDEF10 = _HLSR_NOREDEF10(2i32);
impl ::core::marker::Copy for _HLSR_NOREDEF10 {}
impl ::core::clone::Clone for _HLSR_NOREDEF10 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _HLSR_NOREDEF10 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _HLSR_NOREDEF10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_HLSR_NOREDEF10").field(&self.0).finish()
    }
}
impl FromIntoMemory for _HLSR_NOREDEF10 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _HLTRANSLATEF_NOREDEF10(pub i32);
pub const HLTRANSLATEF_DEFAULT: _HLTRANSLATEF_NOREDEF10 = _HLTRANSLATEF_NOREDEF10(0i32);
pub const HLTRANSLATEF_DONTAPPLYDEFAULTPREFIX: _HLTRANSLATEF_NOREDEF10 =
    _HLTRANSLATEF_NOREDEF10(1i32);
impl ::core::marker::Copy for _HLTRANSLATEF_NOREDEF10 {}
impl ::core::clone::Clone for _HLTRANSLATEF_NOREDEF10 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _HLTRANSLATEF_NOREDEF10 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _HLTRANSLATEF_NOREDEF10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_HLTRANSLATEF_NOREDEF10")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for _HLTRANSLATEF_NOREDEF10 {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _KF_DEFINITION_FLAGS(pub i32);
pub const KFDF_LOCAL_REDIRECT_ONLY: _KF_DEFINITION_FLAGS = _KF_DEFINITION_FLAGS(2i32);
pub const KFDF_ROAMABLE: _KF_DEFINITION_FLAGS = _KF_DEFINITION_FLAGS(4i32);
pub const KFDF_PRECREATE: _KF_DEFINITION_FLAGS = _KF_DEFINITION_FLAGS(8i32);
pub const KFDF_STREAM: _KF_DEFINITION_FLAGS = _KF_DEFINITION_FLAGS(16i32);
pub const KFDF_PUBLISHEXPANDEDPATH: _KF_DEFINITION_FLAGS = _KF_DEFINITION_FLAGS(32i32);
pub const KFDF_NO_REDIRECT_UI: _KF_DEFINITION_FLAGS = _KF_DEFINITION_FLAGS(64i32);
impl ::core::marker::Copy for _KF_DEFINITION_FLAGS {}
impl ::core::clone::Clone for _KF_DEFINITION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _KF_DEFINITION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _KF_DEFINITION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_KF_DEFINITION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for _KF_DEFINITION_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _KF_REDIRECTION_CAPABILITIES(pub i32);
pub const KF_REDIRECTION_CAPABILITIES_ALLOW_ALL: _KF_REDIRECTION_CAPABILITIES =
    _KF_REDIRECTION_CAPABILITIES(255i32);
pub const KF_REDIRECTION_CAPABILITIES_REDIRECTABLE: _KF_REDIRECTION_CAPABILITIES =
    _KF_REDIRECTION_CAPABILITIES(1i32);
pub const KF_REDIRECTION_CAPABILITIES_DENY_ALL: _KF_REDIRECTION_CAPABILITIES =
    _KF_REDIRECTION_CAPABILITIES(1048320i32);
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY_REDIRECTED: _KF_REDIRECTION_CAPABILITIES =
    _KF_REDIRECTION_CAPABILITIES(256i32);
pub const KF_REDIRECTION_CAPABILITIES_DENY_POLICY: _KF_REDIRECTION_CAPABILITIES =
    _KF_REDIRECTION_CAPABILITIES(512i32);
pub const KF_REDIRECTION_CAPABILITIES_DENY_PERMISSIONS: _KF_REDIRECTION_CAPABILITIES =
    _KF_REDIRECTION_CAPABILITIES(1024i32);
impl ::core::marker::Copy for _KF_REDIRECTION_CAPABILITIES {}
impl ::core::clone::Clone for _KF_REDIRECTION_CAPABILITIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _KF_REDIRECTION_CAPABILITIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _KF_REDIRECTION_CAPABILITIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_KF_REDIRECTION_CAPABILITIES")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for _KF_REDIRECTION_CAPABILITIES {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _KF_REDIRECT_FLAGS(pub i32);
pub const KF_REDIRECT_USER_EXCLUSIVE: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(1i32);
pub const KF_REDIRECT_COPY_SOURCE_DACL: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(2i32);
pub const KF_REDIRECT_OWNER_USER: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(4i32);
pub const KF_REDIRECT_SET_OWNER_EXPLICIT: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(8i32);
pub const KF_REDIRECT_CHECK_ONLY: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(16i32);
pub const KF_REDIRECT_WITH_UI: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(32i32);
pub const KF_REDIRECT_UNPIN: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(64i32);
pub const KF_REDIRECT_PIN: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(128i32);
pub const KF_REDIRECT_COPY_CONTENTS: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(512i32);
pub const KF_REDIRECT_DEL_SOURCE_CONTENTS: _KF_REDIRECT_FLAGS = _KF_REDIRECT_FLAGS(1024i32);
pub const KF_REDIRECT_EXCLUDE_ALL_KNOWN_SUBFOLDERS: _KF_REDIRECT_FLAGS =
    _KF_REDIRECT_FLAGS(2048i32);
impl ::core::marker::Copy for _KF_REDIRECT_FLAGS {}
impl ::core::clone::Clone for _KF_REDIRECT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _KF_REDIRECT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _KF_REDIRECT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_KF_REDIRECT_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for _KF_REDIRECT_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _NMCII_FLAGS(pub i32);
pub const NMCII_NONE: _NMCII_FLAGS = _NMCII_FLAGS(0i32);
pub const NMCII_ITEMS: _NMCII_FLAGS = _NMCII_FLAGS(1i32);
pub const NMCII_FOLDERS: _NMCII_FLAGS = _NMCII_FLAGS(2i32);
impl ::core::marker::Copy for _NMCII_FLAGS {}
impl ::core::clone::Clone for _NMCII_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _NMCII_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _NMCII_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_NMCII_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for _NMCII_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _NMCSAEI_FLAGS(pub i32);
pub const NMCSAEI_SELECT: _NMCSAEI_FLAGS = _NMCSAEI_FLAGS(0i32);
pub const NMCSAEI_EDIT: _NMCSAEI_FLAGS = _NMCSAEI_FLAGS(1i32);
impl ::core::marker::Copy for _NMCSAEI_FLAGS {}
impl ::core::clone::Clone for _NMCSAEI_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _NMCSAEI_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _NMCSAEI_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_NMCSAEI_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for _NMCSAEI_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _NSTCECLICKTYPE(pub i32);
pub const NSTCECT_LBUTTON: _NSTCECLICKTYPE = _NSTCECLICKTYPE(1i32);
pub const NSTCECT_MBUTTON: _NSTCECLICKTYPE = _NSTCECLICKTYPE(2i32);
pub const NSTCECT_RBUTTON: _NSTCECLICKTYPE = _NSTCECLICKTYPE(3i32);
pub const NSTCECT_BUTTON: _NSTCECLICKTYPE = _NSTCECLICKTYPE(3i32);
pub const NSTCECT_DBLCLICK: _NSTCECLICKTYPE = _NSTCECLICKTYPE(4i32);
impl ::core::marker::Copy for _NSTCECLICKTYPE {}
impl ::core::clone::Clone for _NSTCECLICKTYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _NSTCECLICKTYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _NSTCECLICKTYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_NSTCECLICKTYPE").field(&self.0).finish()
    }
}
impl FromIntoMemory for _NSTCECLICKTYPE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _NSTCEHITTEST(pub i32);
pub const NSTCEHT_NOWHERE: _NSTCEHITTEST = _NSTCEHITTEST(1i32);
pub const NSTCEHT_ONITEMICON: _NSTCEHITTEST = _NSTCEHITTEST(2i32);
pub const NSTCEHT_ONITEMLABEL: _NSTCEHITTEST = _NSTCEHITTEST(4i32);
pub const NSTCEHT_ONITEMINDENT: _NSTCEHITTEST = _NSTCEHITTEST(8i32);
pub const NSTCEHT_ONITEMBUTTON: _NSTCEHITTEST = _NSTCEHITTEST(16i32);
pub const NSTCEHT_ONITEMRIGHT: _NSTCEHITTEST = _NSTCEHITTEST(32i32);
pub const NSTCEHT_ONITEMSTATEICON: _NSTCEHITTEST = _NSTCEHITTEST(64i32);
pub const NSTCEHT_ONITEM: _NSTCEHITTEST = _NSTCEHITTEST(70i32);
pub const NSTCEHT_ONITEMTABBUTTON: _NSTCEHITTEST = _NSTCEHITTEST(4096i32);
impl ::core::marker::Copy for _NSTCEHITTEST {}
impl ::core::clone::Clone for _NSTCEHITTEST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _NSTCEHITTEST {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _NSTCEHITTEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_NSTCEHITTEST").field(&self.0).finish()
    }
}
impl FromIntoMemory for _NSTCEHITTEST {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _NSTCITEMSTATE(pub i32);
pub const NSTCIS_NONE: _NSTCITEMSTATE = _NSTCITEMSTATE(0i32);
pub const NSTCIS_SELECTED: _NSTCITEMSTATE = _NSTCITEMSTATE(1i32);
pub const NSTCIS_EXPANDED: _NSTCITEMSTATE = _NSTCITEMSTATE(2i32);
pub const NSTCIS_BOLD: _NSTCITEMSTATE = _NSTCITEMSTATE(4i32);
pub const NSTCIS_DISABLED: _NSTCITEMSTATE = _NSTCITEMSTATE(8i32);
pub const NSTCIS_SELECTEDNOEXPAND: _NSTCITEMSTATE = _NSTCITEMSTATE(16i32);
impl ::core::marker::Copy for _NSTCITEMSTATE {}
impl ::core::clone::Clone for _NSTCITEMSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _NSTCITEMSTATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _NSTCITEMSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_NSTCITEMSTATE").field(&self.0).finish()
    }
}
impl FromIntoMemory for _NSTCITEMSTATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _NSTCROOTSTYLE(pub i32);
pub const NSTCRS_VISIBLE: _NSTCROOTSTYLE = _NSTCROOTSTYLE(0i32);
pub const NSTCRS_HIDDEN: _NSTCROOTSTYLE = _NSTCROOTSTYLE(1i32);
pub const NSTCRS_EXPANDED: _NSTCROOTSTYLE = _NSTCROOTSTYLE(2i32);
impl ::core::marker::Copy for _NSTCROOTSTYLE {}
impl ::core::clone::Clone for _NSTCROOTSTYLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _NSTCROOTSTYLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _NSTCROOTSTYLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_NSTCROOTSTYLE").field(&self.0).finish()
    }
}
impl FromIntoMemory for _NSTCROOTSTYLE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _NSTCSTYLE(pub i32);
pub const NSTCS_HASEXPANDOS: _NSTCSTYLE = _NSTCSTYLE(1i32);
pub const NSTCS_HASLINES: _NSTCSTYLE = _NSTCSTYLE(2i32);
pub const NSTCS_SINGLECLICKEXPAND: _NSTCSTYLE = _NSTCSTYLE(4i32);
pub const NSTCS_FULLROWSELECT: _NSTCSTYLE = _NSTCSTYLE(8i32);
pub const NSTCS_SPRINGEXPAND: _NSTCSTYLE = _NSTCSTYLE(16i32);
pub const NSTCS_HORIZONTALSCROLL: _NSTCSTYLE = _NSTCSTYLE(32i32);
pub const NSTCS_ROOTHASEXPANDO: _NSTCSTYLE = _NSTCSTYLE(64i32);
pub const NSTCS_SHOWSELECTIONALWAYS: _NSTCSTYLE = _NSTCSTYLE(128i32);
pub const NSTCS_NOINFOTIP: _NSTCSTYLE = _NSTCSTYLE(512i32);
pub const NSTCS_EVENHEIGHT: _NSTCSTYLE = _NSTCSTYLE(1024i32);
pub const NSTCS_NOREPLACEOPEN: _NSTCSTYLE = _NSTCSTYLE(2048i32);
pub const NSTCS_DISABLEDRAGDROP: _NSTCSTYLE = _NSTCSTYLE(4096i32);
pub const NSTCS_NOORDERSTREAM: _NSTCSTYLE = _NSTCSTYLE(8192i32);
pub const NSTCS_RICHTOOLTIP: _NSTCSTYLE = _NSTCSTYLE(16384i32);
pub const NSTCS_BORDER: _NSTCSTYLE = _NSTCSTYLE(32768i32);
pub const NSTCS_NOEDITLABELS: _NSTCSTYLE = _NSTCSTYLE(65536i32);
pub const NSTCS_TABSTOP: _NSTCSTYLE = _NSTCSTYLE(131072i32);
pub const NSTCS_FAVORITESMODE: _NSTCSTYLE = _NSTCSTYLE(524288i32);
pub const NSTCS_AUTOHSCROLL: _NSTCSTYLE = _NSTCSTYLE(1048576i32);
pub const NSTCS_FADEINOUTEXPANDOS: _NSTCSTYLE = _NSTCSTYLE(2097152i32);
pub const NSTCS_EMPTYTEXT: _NSTCSTYLE = _NSTCSTYLE(4194304i32);
pub const NSTCS_CHECKBOXES: _NSTCSTYLE = _NSTCSTYLE(8388608i32);
pub const NSTCS_PARTIALCHECKBOXES: _NSTCSTYLE = _NSTCSTYLE(16777216i32);
pub const NSTCS_EXCLUSIONCHECKBOXES: _NSTCSTYLE = _NSTCSTYLE(33554432i32);
pub const NSTCS_DIMMEDCHECKBOXES: _NSTCSTYLE = _NSTCSTYLE(67108864i32);
pub const NSTCS_NOINDENTCHECKS: _NSTCSTYLE = _NSTCSTYLE(134217728i32);
pub const NSTCS_ALLOWJUNCTIONS: _NSTCSTYLE = _NSTCSTYLE(268435456i32);
pub const NSTCS_SHOWTABSBUTTON: _NSTCSTYLE = _NSTCSTYLE(536870912i32);
pub const NSTCS_SHOWDELETEBUTTON: _NSTCSTYLE = _NSTCSTYLE(1073741824i32);
pub const NSTCS_SHOWREFRESHBUTTON: _NSTCSTYLE = _NSTCSTYLE(-2147483648i32);
impl ::core::marker::Copy for _NSTCSTYLE {}
impl ::core::clone::Clone for _NSTCSTYLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _NSTCSTYLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _NSTCSTYLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_NSTCSTYLE").field(&self.0).finish()
    }
}
impl FromIntoMemory for _NSTCSTYLE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _OPPROGDLGF(pub i32);
pub const OPPROGDLG_DEFAULT: _OPPROGDLGF = _OPPROGDLGF(0i32);
pub const OPPROGDLG_ENABLEPAUSE: _OPPROGDLGF = _OPPROGDLGF(128i32);
pub const OPPROGDLG_ALLOWUNDO: _OPPROGDLGF = _OPPROGDLGF(256i32);
pub const OPPROGDLG_DONTDISPLAYSOURCEPATH: _OPPROGDLGF = _OPPROGDLGF(512i32);
pub const OPPROGDLG_DONTDISPLAYDESTPATH: _OPPROGDLGF = _OPPROGDLGF(1024i32);
pub const OPPROGDLG_NOMULTIDAYESTIMATES: _OPPROGDLGF = _OPPROGDLGF(2048i32);
pub const OPPROGDLG_DONTDISPLAYLOCATIONS: _OPPROGDLGF = _OPPROGDLGF(4096i32);
impl ::core::marker::Copy for _OPPROGDLGF {}
impl ::core::clone::Clone for _OPPROGDLGF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _OPPROGDLGF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _OPPROGDLGF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_OPPROGDLGF").field(&self.0).finish()
    }
}
impl FromIntoMemory for _OPPROGDLGF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _PDMODE(pub i32);
pub const PDM_DEFAULT: _PDMODE = _PDMODE(0i32);
pub const PDM_RUN: _PDMODE = _PDMODE(1i32);
pub const PDM_PREFLIGHT: _PDMODE = _PDMODE(2i32);
pub const PDM_UNDOING: _PDMODE = _PDMODE(4i32);
pub const PDM_ERRORSBLOCKING: _PDMODE = _PDMODE(8i32);
pub const PDM_INDETERMINATE: _PDMODE = _PDMODE(16i32);
impl ::core::marker::Copy for _PDMODE {}
impl ::core::clone::Clone for _PDMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _PDMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _PDMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_PDMODE").field(&self.0).finish()
    }
}
impl FromIntoMemory for _PDMODE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SHCONTF(pub i32);
pub const SHCONTF_CHECKING_FOR_CHILDREN: _SHCONTF = _SHCONTF(16i32);
pub const SHCONTF_FOLDERS: _SHCONTF = _SHCONTF(32i32);
pub const SHCONTF_NONFOLDERS: _SHCONTF = _SHCONTF(64i32);
pub const SHCONTF_INCLUDEHIDDEN: _SHCONTF = _SHCONTF(128i32);
pub const SHCONTF_INIT_ON_FIRST_NEXT: _SHCONTF = _SHCONTF(256i32);
pub const SHCONTF_NETPRINTERSRCH: _SHCONTF = _SHCONTF(512i32);
pub const SHCONTF_SHAREABLE: _SHCONTF = _SHCONTF(1024i32);
pub const SHCONTF_STORAGE: _SHCONTF = _SHCONTF(2048i32);
pub const SHCONTF_NAVIGATION_ENUM: _SHCONTF = _SHCONTF(4096i32);
pub const SHCONTF_FASTITEMS: _SHCONTF = _SHCONTF(8192i32);
pub const SHCONTF_FLATLIST: _SHCONTF = _SHCONTF(16384i32);
pub const SHCONTF_ENABLE_ASYNC: _SHCONTF = _SHCONTF(32768i32);
pub const SHCONTF_INCLUDESUPERHIDDEN: _SHCONTF = _SHCONTF(65536i32);
impl ::core::marker::Copy for _SHCONTF {}
impl ::core::clone::Clone for _SHCONTF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SHCONTF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SHCONTF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SHCONTF").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SHCONTF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SHGDNF(pub i32);
pub const SHGDN_NORMAL: _SHGDNF = _SHGDNF(0i32);
pub const SHGDN_INFOLDER: _SHGDNF = _SHGDNF(1i32);
pub const SHGDN_FOREDITING: _SHGDNF = _SHGDNF(4096i32);
pub const SHGDN_FORADDRESSBAR: _SHGDNF = _SHGDNF(16384i32);
pub const SHGDN_FORPARSING: _SHGDNF = _SHGDNF(32768i32);
impl ::core::marker::Copy for _SHGDNF {}
impl ::core::clone::Clone for _SHGDNF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SHGDNF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SHGDNF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SHGDNF").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SHGDNF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SICHINTF(pub i32);
pub const SICHINT_DISPLAY: _SICHINTF = _SICHINTF(0i32);
pub const SICHINT_ALLFIELDS: _SICHINTF = _SICHINTF(-2147483648i32);
pub const SICHINT_CANONICAL: _SICHINTF = _SICHINTF(268435456i32);
pub const SICHINT_TEST_FILESYSPATH_IF_NOT_EQUAL: _SICHINTF = _SICHINTF(536870912i32);
impl ::core::marker::Copy for _SICHINTF {}
impl ::core::clone::Clone for _SICHINTF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SICHINTF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SICHINTF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SICHINTF").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SICHINTF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SPBEGINF(pub i32);
pub const SPBEGINF_NORMAL: _SPBEGINF = _SPBEGINF(0i32);
pub const SPBEGINF_AUTOTIME: _SPBEGINF = _SPBEGINF(2i32);
pub const SPBEGINF_NOPROGRESSBAR: _SPBEGINF = _SPBEGINF(16i32);
pub const SPBEGINF_MARQUEEPROGRESS: _SPBEGINF = _SPBEGINF(32i32);
pub const SPBEGINF_NOCANCELBUTTON: _SPBEGINF = _SPBEGINF(64i32);
impl ::core::marker::Copy for _SPBEGINF {}
impl ::core::clone::Clone for _SPBEGINF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SPBEGINF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SPBEGINF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SPBEGINF").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SPBEGINF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SPINITF(pub i32);
pub const SPINITF_NORMAL: _SPINITF = _SPINITF(0i32);
pub const SPINITF_MODAL: _SPINITF = _SPINITF(1i32);
pub const SPINITF_NOMINIMIZE: _SPINITF = _SPINITF(8i32);
impl ::core::marker::Copy for _SPINITF {}
impl ::core::clone::Clone for _SPINITF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SPINITF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SPINITF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SPINITF").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SPINITF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SV3CVW3_FLAGS(pub i32);
pub const SV3CVW3_DEFAULT: _SV3CVW3_FLAGS = _SV3CVW3_FLAGS(0i32);
pub const SV3CVW3_NONINTERACTIVE: _SV3CVW3_FLAGS = _SV3CVW3_FLAGS(1i32);
pub const SV3CVW3_FORCEVIEWMODE: _SV3CVW3_FLAGS = _SV3CVW3_FLAGS(2i32);
pub const SV3CVW3_FORCEFOLDERFLAGS: _SV3CVW3_FLAGS = _SV3CVW3_FLAGS(4i32);
impl ::core::marker::Copy for _SV3CVW3_FLAGS {}
impl ::core::clone::Clone for _SV3CVW3_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SV3CVW3_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SV3CVW3_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SV3CVW3_FLAGS").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SV3CVW3_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SVGIO(pub i32);
pub const SVGIO_BACKGROUND: _SVGIO = _SVGIO(0i32);
pub const SVGIO_SELECTION: _SVGIO = _SVGIO(1i32);
pub const SVGIO_ALLVIEW: _SVGIO = _SVGIO(2i32);
pub const SVGIO_CHECKED: _SVGIO = _SVGIO(3i32);
pub const SVGIO_TYPE_MASK: _SVGIO = _SVGIO(15i32);
pub const SVGIO_FLAG_VIEWORDER: _SVGIO = _SVGIO(-2147483648i32);
impl ::core::marker::Copy for _SVGIO {}
impl ::core::clone::Clone for _SVGIO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SVGIO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SVGIO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SVGIO").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SVGIO {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _SVSIF(pub i32);
pub const SVSI_DESELECT: _SVSIF = _SVSIF(0i32);
pub const SVSI_SELECT: _SVSIF = _SVSIF(1i32);
pub const SVSI_EDIT: _SVSIF = _SVSIF(3i32);
pub const SVSI_DESELECTOTHERS: _SVSIF = _SVSIF(4i32);
pub const SVSI_ENSUREVISIBLE: _SVSIF = _SVSIF(8i32);
pub const SVSI_FOCUSED: _SVSIF = _SVSIF(16i32);
pub const SVSI_TRANSLATEPT: _SVSIF = _SVSIF(32i32);
pub const SVSI_SELECTIONMARK: _SVSIF = _SVSIF(64i32);
pub const SVSI_POSITIONITEM: _SVSIF = _SVSIF(128i32);
pub const SVSI_CHECK: _SVSIF = _SVSIF(256i32);
pub const SVSI_CHECK2: _SVSIF = _SVSIF(512i32);
pub const SVSI_KEYBOARDSELECT: _SVSIF = _SVSIF(1025i32);
pub const SVSI_NOTAKEFOCUS: _SVSIF = _SVSIF(1073741824i32);
impl ::core::marker::Copy for _SVSIF {}
impl ::core::clone::Clone for _SVSIF {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _SVSIF {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _SVSIF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_SVSIF").field(&self.0).finish()
    }
}
impl FromIntoMemory for _SVSIF {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _TRANSFER_ADVISE_STATE(pub i32);
pub const TS_NONE: _TRANSFER_ADVISE_STATE = _TRANSFER_ADVISE_STATE(0i32);
pub const TS_PERFORMING: _TRANSFER_ADVISE_STATE = _TRANSFER_ADVISE_STATE(1i32);
pub const TS_PREPARING: _TRANSFER_ADVISE_STATE = _TRANSFER_ADVISE_STATE(2i32);
pub const TS_INDETERMINATE: _TRANSFER_ADVISE_STATE = _TRANSFER_ADVISE_STATE(4i32);
impl ::core::marker::Copy for _TRANSFER_ADVISE_STATE {}
impl ::core::clone::Clone for _TRANSFER_ADVISE_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _TRANSFER_ADVISE_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _TRANSFER_ADVISE_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_TRANSFER_ADVISE_STATE")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for _TRANSFER_ADVISE_STATE {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct _TRANSFER_SOURCE_FLAGS(pub i32);
pub const TSF_NORMAL: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(0i32);
pub const TSF_FAIL_EXIST: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(0i32);
pub const TSF_RENAME_EXIST: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(1i32);
pub const TSF_OVERWRITE_EXIST: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(2i32);
pub const TSF_ALLOW_DECRYPTION: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(4i32);
pub const TSF_NO_SECURITY: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(8i32);
pub const TSF_COPY_CREATION_TIME: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(16i32);
pub const TSF_COPY_WRITE_TIME: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(32i32);
pub const TSF_USE_FULL_ACCESS: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(64i32);
pub const TSF_DELETE_RECYCLE_IF_POSSIBLE: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(128i32);
pub const TSF_COPY_HARD_LINK: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(256i32);
pub const TSF_COPY_LOCALIZED_NAME: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(512i32);
pub const TSF_MOVE_AS_COPY_DELETE: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(1024i32);
pub const TSF_SUSPEND_SHELLEVENTS: _TRANSFER_SOURCE_FLAGS = _TRANSFER_SOURCE_FLAGS(2048i32);
impl ::core::marker::Copy for _TRANSFER_SOURCE_FLAGS {}
impl ::core::clone::Clone for _TRANSFER_SOURCE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _TRANSFER_SOURCE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for _TRANSFER_SOURCE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_TRANSFER_SOURCE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for _TRANSFER_SOURCE_FLAGS {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub const idsAppName: u32 = 1007u32;
pub const idsBadOldPW: u32 = 1006u32;
pub const idsChangePW: u32 = 1005u32;
pub const idsDefKeyword: u32 = 1010u32;
pub const idsDifferentPW: u32 = 1004u32;
pub const idsHelpFile: u32 = 1009u32;
pub const idsIniFile: u32 = 1001u32;
pub const idsIsPassword: u32 = 1000u32;
pub const idsNoHelpMemory: u32 = 1008u32;
pub const idsPassword: u32 = 1003u32;
pub const idsScreenSaver: u32 = 1002u32;
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct iurl_invokecommand_flags(pub i32);
pub const IURL_INVOKECOMMAND_FL_ALLOW_UI: iurl_invokecommand_flags = iurl_invokecommand_flags(1i32);
pub const IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB: iurl_invokecommand_flags =
    iurl_invokecommand_flags(2i32);
pub const IURL_INVOKECOMMAND_FL_DDEWAIT: iurl_invokecommand_flags = iurl_invokecommand_flags(4i32);
pub const IURL_INVOKECOMMAND_FL_ASYNCOK: iurl_invokecommand_flags = iurl_invokecommand_flags(8i32);
pub const IURL_INVOKECOMMAND_FL_LOG_USAGE: iurl_invokecommand_flags =
    iurl_invokecommand_flags(16i32);
impl ::core::marker::Copy for iurl_invokecommand_flags {}
impl ::core::clone::Clone for iurl_invokecommand_flags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for iurl_invokecommand_flags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for iurl_invokecommand_flags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("iurl_invokecommand_flags")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for iurl_invokecommand_flags {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct iurl_seturl_flags(pub i32);
pub const IURL_SETURL_FL_GUESS_PROTOCOL: iurl_seturl_flags = iurl_seturl_flags(1i32);
pub const IURL_SETURL_FL_USE_DEFAULT_PROTOCOL: iurl_seturl_flags = iurl_seturl_flags(2i32);
impl ::core::marker::Copy for iurl_seturl_flags {}
impl ::core::clone::Clone for iurl_seturl_flags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for iurl_seturl_flags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for iurl_seturl_flags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("iurl_seturl_flags").field(&self.0).finish()
    }
}
impl FromIntoMemory for iurl_seturl_flags {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct mimeassociationdialog_in_flags(pub i32);
pub const MIMEASSOCDLG_FL_REGISTER_ASSOC: mimeassociationdialog_in_flags =
    mimeassociationdialog_in_flags(1i32);
impl ::core::marker::Copy for mimeassociationdialog_in_flags {}
impl ::core::clone::Clone for mimeassociationdialog_in_flags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for mimeassociationdialog_in_flags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for mimeassociationdialog_in_flags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("mimeassociationdialog_in_flags")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for mimeassociationdialog_in_flags {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct translateurl_in_flags(pub i32);
pub const TRANSLATEURL_FL_GUESS_PROTOCOL: translateurl_in_flags = translateurl_in_flags(1i32);
pub const TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL: translateurl_in_flags = translateurl_in_flags(2i32);
impl ::core::marker::Copy for translateurl_in_flags {}
impl ::core::clone::Clone for translateurl_in_flags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for translateurl_in_flags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for translateurl_in_flags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("translateurl_in_flags")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for translateurl_in_flags {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
#[derive(:: core :: cmp :: PartialEq, :: core :: cmp :: Eq)]
pub struct urlassociationdialog_in_flags(pub i32);
pub const URLASSOCDLG_FL_USE_DEFAULT_NAME: urlassociationdialog_in_flags =
    urlassociationdialog_in_flags(1i32);
pub const URLASSOCDLG_FL_REGISTER_ASSOC: urlassociationdialog_in_flags =
    urlassociationdialog_in_flags(2i32);
impl ::core::marker::Copy for urlassociationdialog_in_flags {}
impl ::core::clone::Clone for urlassociationdialog_in_flags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for urlassociationdialog_in_flags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::core::fmt::Debug for urlassociationdialog_in_flags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("urlassociationdialog_in_flags")
            .field(&self.0)
            .finish()
    }
}
impl FromIntoMemory for urlassociationdialog_in_flags {
    fn from_bytes(from: &[u8]) -> Self {
        Self(<i32 as FromIntoMemory>::from_bytes(from))
    }
    fn into_bytes(self, into: &mut [u8]) {
        FromIntoMemory::into_bytes(self.0, into)
    }
    fn size() -> usize {
        4
    }
}
pub struct urlinvokecommandinfoA {
    pub dwcbSize: u32,
    pub dwFlags: u32,
    pub hwndParent: super::super::Foundation::HWND,
    pub pcszVerb: PCSTR,
}
impl ::core::marker::Copy for urlinvokecommandinfoA {}
impl ::core::clone::Clone for urlinvokecommandinfoA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for urlinvokecommandinfoA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("urlinvokecommandinfoA")
            .field("dwcbSize", &self.dwcbSize)
            .field("dwFlags", &self.dwFlags)
            .field("hwndParent", &self.hwndParent)
            .field("pcszVerb", &self.pcszVerb)
            .finish()
    }
}
impl ::core::cmp::PartialEq for urlinvokecommandinfoA {
    fn eq(&self, other: &Self) -> bool {
        self.dwcbSize == other.dwcbSize
            && self.dwFlags == other.dwFlags
            && self.hwndParent == other.hwndParent
            && self.pcszVerb == other.pcszVerb
    }
}
impl ::core::cmp::Eq for urlinvokecommandinfoA {}
impl FromIntoMemory for urlinvokecommandinfoA {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwcbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwndParent =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pcszVerb = <PCSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwcbSize: f_dwcbSize,
            dwFlags: f_dwFlags,
            hwndParent: f_hwndParent,
            pcszVerb: f_pcszVerb,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwcbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwndParent, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pcszVerb, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub struct urlinvokecommandinfoW {
    pub dwcbSize: u32,
    pub dwFlags: u32,
    pub hwndParent: super::super::Foundation::HWND,
    pub pcszVerb: PCWSTR,
}
impl ::core::marker::Copy for urlinvokecommandinfoW {}
impl ::core::clone::Clone for urlinvokecommandinfoW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for urlinvokecommandinfoW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("urlinvokecommandinfoW")
            .field("dwcbSize", &self.dwcbSize)
            .field("dwFlags", &self.dwFlags)
            .field("hwndParent", &self.hwndParent)
            .field("pcszVerb", &self.pcszVerb)
            .finish()
    }
}
impl ::core::cmp::PartialEq for urlinvokecommandinfoW {
    fn eq(&self, other: &Self) -> bool {
        self.dwcbSize == other.dwcbSize
            && self.dwFlags == other.dwFlags
            && self.hwndParent == other.hwndParent
            && self.pcszVerb == other.pcszVerb
    }
}
impl ::core::cmp::Eq for urlinvokecommandinfoW {}
impl FromIntoMemory for urlinvokecommandinfoW {
    fn from_bytes(from: &[u8]) -> Self {
        assert_eq!(from.len(), 16);
        let f_dwcbSize = <u32 as FromIntoMemory>::from_bytes(&from[0..0 + 4]);
        let f_dwFlags = <u32 as FromIntoMemory>::from_bytes(&from[4..4 + 4]);
        let f_hwndParent =
            <super::super::Foundation::HWND as FromIntoMemory>::from_bytes(&from[8..8 + 4]);
        let f_pcszVerb = <PCWSTR as FromIntoMemory>::from_bytes(&from[12..12 + 4]);
        Self {
            dwcbSize: f_dwcbSize,
            dwFlags: f_dwFlags,
            hwndParent: f_hwndParent,
            pcszVerb: f_pcszVerb,
        }
    }
    fn into_bytes(self, into: &mut [u8]) {
        assert_eq!(into.len(), 16);
        FromIntoMemory::into_bytes(self.dwcbSize, &mut into[0..0 + 4]);
        FromIntoMemory::into_bytes(self.dwFlags, &mut into[4..4 + 4]);
        FromIntoMemory::into_bytes(self.hwndParent, &mut into[8..8 + 4]);
        FromIntoMemory::into_bytes(self.pcszVerb, &mut into[12..12 + 4]);
    }
    fn size() -> usize {
        16
    }
}
pub trait Api {
    #[doc = "CommandLineToArgvW from SHELL32"]
    fn CommandLineToArgvW(&self, lp_cmd_line: PCWSTR, p_num_args: MutPtr<i32>) -> MutPtr<PWSTR> {
        todo!("CommandLineToArgvW")
    }
    #[doc = "DAD_AutoScroll from SHELL32"]
    fn DAD_AutoScroll(
        &self,
        hwnd: super::super::Foundation::HWND,
        pad: MutPtr<AUTO_SCROLL_DATA>,
        ppt_now: ConstPtr<super::super::Foundation::POINT>,
    ) -> super::super::Foundation::BOOL {
        todo!("DAD_AutoScroll")
    }
    #[doc = "DAD_DragEnterEx from SHELL32"]
    fn DAD_DragEnterEx(
        &self,
        hwnd_target: super::super::Foundation::HWND,
        pt_start: super::super::Foundation::POINT,
    ) -> super::super::Foundation::BOOL {
        todo!("DAD_DragEnterEx")
    }
    #[doc = "DAD_DragLeave from SHELL32"]
    fn DAD_DragLeave(&self) -> super::super::Foundation::BOOL {
        todo!("DAD_DragLeave")
    }
    #[doc = "DAD_DragMove from SHELL32"]
    fn DAD_DragMove(&self, pt: super::super::Foundation::POINT) -> super::super::Foundation::BOOL {
        todo!("DAD_DragMove")
    }
    #[doc = "DAD_ShowDragImage from SHELL32"]
    fn DAD_ShowDragImage(
        &self,
        f_show: super::super::Foundation::BOOL,
    ) -> super::super::Foundation::BOOL {
        todo!("DAD_ShowDragImage")
    }
    #[doc = "DoEnvironmentSubstA from SHELL32"]
    fn DoEnvironmentSubstA(&self, psz_src: PSTR, cch_src: u32) -> u32 {
        todo!("DoEnvironmentSubstA")
    }
    #[doc = "DoEnvironmentSubstW from SHELL32"]
    fn DoEnvironmentSubstW(&self, psz_src: PWSTR, cch_src: u32) -> u32 {
        todo!("DoEnvironmentSubstW")
    }
    #[doc = "DragAcceptFiles from SHELL32"]
    fn DragAcceptFiles(
        &self,
        h_wnd: super::super::Foundation::HWND,
        f_accept: super::super::Foundation::BOOL,
    ) {
        todo!("DragAcceptFiles")
    }
    #[doc = "DragFinish from SHELL32"]
    fn DragFinish(&self, h_drop: HDROP) {
        todo!("DragFinish")
    }
    #[doc = "DragQueryFileA from SHELL32"]
    fn DragQueryFileA(&self, h_drop: HDROP, i_file: u32, lpsz_file: PSTR, cch: u32) -> u32 {
        todo!("DragQueryFileA")
    }
    #[doc = "DragQueryFileW from SHELL32"]
    fn DragQueryFileW(&self, h_drop: HDROP, i_file: u32, lpsz_file: PWSTR, cch: u32) -> u32 {
        todo!("DragQueryFileW")
    }
    #[doc = "DragQueryPoint from SHELL32"]
    fn DragQueryPoint(
        &self,
        h_drop: HDROP,
        ppt: MutPtr<super::super::Foundation::POINT>,
    ) -> super::super::Foundation::BOOL {
        todo!("DragQueryPoint")
    }
    #[doc = "DriveType from SHELL32"]
    fn DriveType(&self, i_drive: i32) -> i32 {
        todo!("DriveType")
    }
    #[doc = "DuplicateIcon from SHELL32"]
    fn DuplicateIcon(
        &self,
        h_inst: super::super::Foundation::HINSTANCE,
        h_icon: super::WindowsAndMessaging::HICON,
    ) -> super::WindowsAndMessaging::HICON {
        todo!("DuplicateIcon")
    }
    #[doc = "ExtractAssociatedIconA from SHELL32"]
    fn ExtractAssociatedIconA(
        &self,
        h_inst: super::super::Foundation::HINSTANCE,
        psz_icon_path: PSTR,
        pi_icon: MutPtr<u16>,
    ) -> super::WindowsAndMessaging::HICON {
        todo!("ExtractAssociatedIconA")
    }
    #[doc = "ExtractAssociatedIconExA from SHELL32"]
    fn ExtractAssociatedIconExA(
        &self,
        h_inst: super::super::Foundation::HINSTANCE,
        psz_icon_path: PSTR,
        pi_icon_index: MutPtr<u16>,
        pi_icon_id: MutPtr<u16>,
    ) -> super::WindowsAndMessaging::HICON {
        todo!("ExtractAssociatedIconExA")
    }
    #[doc = "ExtractAssociatedIconExW from SHELL32"]
    fn ExtractAssociatedIconExW(
        &self,
        h_inst: super::super::Foundation::HINSTANCE,
        psz_icon_path: PWSTR,
        pi_icon_index: MutPtr<u16>,
        pi_icon_id: MutPtr<u16>,
    ) -> super::WindowsAndMessaging::HICON {
        todo!("ExtractAssociatedIconExW")
    }
    #[doc = "ExtractAssociatedIconW from SHELL32"]
    fn ExtractAssociatedIconW(
        &self,
        h_inst: super::super::Foundation::HINSTANCE,
        psz_icon_path: PWSTR,
        pi_icon: MutPtr<u16>,
    ) -> super::WindowsAndMessaging::HICON {
        todo!("ExtractAssociatedIconW")
    }
    #[doc = "ExtractIconA from SHELL32"]
    fn ExtractIconA(
        &self,
        h_inst: super::super::Foundation::HINSTANCE,
        psz_exe_file_name: PCSTR,
        n_icon_index: u32,
    ) -> super::WindowsAndMessaging::HICON {
        todo!("ExtractIconA")
    }
    #[doc = "ExtractIconExA from SHELL32"]
    fn ExtractIconExA(
        &self,
        lpsz_file: PCSTR,
        n_icon_index: i32,
        phicon_large: MutPtr<super::WindowsAndMessaging::HICON>,
        phicon_small: MutPtr<super::WindowsAndMessaging::HICON>,
        n_icons: u32,
    ) -> u32 {
        todo!("ExtractIconExA")
    }
    #[doc = "ExtractIconExW from SHELL32"]
    fn ExtractIconExW(
        &self,
        lpsz_file: PCWSTR,
        n_icon_index: i32,
        phicon_large: MutPtr<super::WindowsAndMessaging::HICON>,
        phicon_small: MutPtr<super::WindowsAndMessaging::HICON>,
        n_icons: u32,
    ) -> u32 {
        todo!("ExtractIconExW")
    }
    #[doc = "ExtractIconW from SHELL32"]
    fn ExtractIconW(
        &self,
        h_inst: super::super::Foundation::HINSTANCE,
        psz_exe_file_name: PCWSTR,
        n_icon_index: u32,
    ) -> super::WindowsAndMessaging::HICON {
        todo!("ExtractIconW")
    }
    #[doc = "FindExecutableA from SHELL32"]
    fn FindExecutableA(
        &self,
        lp_file: PCSTR,
        lp_directory: PCSTR,
        lp_result: PSTR,
    ) -> super::super::Foundation::HINSTANCE {
        todo!("FindExecutableA")
    }
    #[doc = "FindExecutableW from SHELL32"]
    fn FindExecutableW(
        &self,
        lp_file: PCWSTR,
        lp_directory: PCWSTR,
        lp_result: PWSTR,
    ) -> super::super::Foundation::HINSTANCE {
        todo!("FindExecutableW")
    }
    #[doc = "GetFileNameFromBrowse from SHELL32"]
    fn GetFileNameFromBrowse(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_file_path: PWSTR,
        cch_file_path: u32,
        psz_working_dir: PCWSTR,
        psz_def_ext: PCWSTR,
        psz_filters: PCWSTR,
        psz_title: PCWSTR,
    ) -> super::super::Foundation::BOOL {
        todo!("GetFileNameFromBrowse")
    }
    #[doc = "GetMenuContextHelpId from USER32"]
    fn GetMenuContextHelpId(&self, param_0: super::WindowsAndMessaging::HMENU) -> u32 {
        todo!("GetMenuContextHelpId")
    }
    #[doc = "GetWindowContextHelpId from USER32"]
    fn GetWindowContextHelpId(&self, param_0: super::super::Foundation::HWND) -> u32 {
        todo!("GetWindowContextHelpId")
    }
    #[doc = "HMONITOR_UserFree from OLE32"]
    fn HMONITOR_UserFree(
        &self,
        param_0: ConstPtr<u32>,
        param_1: ConstPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) {
        todo!("HMONITOR_UserFree")
    }
    #[doc = "HMONITOR_UserFree64 from OLE32"]
    fn HMONITOR_UserFree64(
        &self,
        param_0: ConstPtr<u32>,
        param_1: ConstPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) {
        todo!("HMONITOR_UserFree64")
    }
    #[doc = "HMONITOR_UserMarshal from OLE32"]
    fn HMONITOR_UserMarshal(
        &self,
        param_0: ConstPtr<u32>,
        param_1: MutPtr<u8>,
        param_2: ConstPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> MutPtr<u8> {
        todo!("HMONITOR_UserMarshal")
    }
    #[doc = "HMONITOR_UserMarshal64 from OLE32"]
    fn HMONITOR_UserMarshal64(
        &self,
        param_0: ConstPtr<u32>,
        param_1: MutPtr<u8>,
        param_2: ConstPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> MutPtr<u8> {
        todo!("HMONITOR_UserMarshal64")
    }
    #[doc = "HMONITOR_UserSize from OLE32"]
    fn HMONITOR_UserSize(
        &self,
        param_0: ConstPtr<u32>,
        param_1: u32,
        param_2: ConstPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> u32 {
        todo!("HMONITOR_UserSize")
    }
    #[doc = "HMONITOR_UserSize64 from OLE32"]
    fn HMONITOR_UserSize64(
        &self,
        param_0: ConstPtr<u32>,
        param_1: u32,
        param_2: ConstPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> u32 {
        todo!("HMONITOR_UserSize64")
    }
    #[doc = "HMONITOR_UserUnmarshal from OLE32"]
    fn HMONITOR_UserUnmarshal(
        &self,
        param_0: ConstPtr<u32>,
        param_1: ConstPtr<u8>,
        param_2: MutPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> MutPtr<u8> {
        todo!("HMONITOR_UserUnmarshal")
    }
    #[doc = "HMONITOR_UserUnmarshal64 from OLE32"]
    fn HMONITOR_UserUnmarshal64(
        &self,
        param_0: ConstPtr<u32>,
        param_1: ConstPtr<u8>,
        param_2: MutPtr<super::super::Graphics::Gdi::HMONITOR>,
    ) -> MutPtr<u8> {
        todo!("HMONITOR_UserUnmarshal64")
    }
    #[doc = "IsLFNDriveA from SHELL32"]
    fn IsLFNDriveA(&self, psz_path: PCSTR) -> super::super::Foundation::BOOL {
        todo!("IsLFNDriveA")
    }
    #[doc = "IsLFNDriveW from SHELL32"]
    fn IsLFNDriveW(&self, psz_path: PCWSTR) -> super::super::Foundation::BOOL {
        todo!("IsLFNDriveW")
    }
    #[doc = "IsNetDrive from SHELL32"]
    fn IsNetDrive(&self, i_drive: i32) -> i32 {
        todo!("IsNetDrive")
    }
    #[doc = "IsUserAnAdmin from SHELL32"]
    fn IsUserAnAdmin(&self) -> super::super::Foundation::BOOL {
        todo!("IsUserAnAdmin")
    }
    #[doc = "PathCleanupSpec from SHELL32"]
    fn PathCleanupSpec(&self, psz_dir: PCWSTR, psz_spec: PWSTR) -> PCS_RET {
        todo!("PathCleanupSpec")
    }
    #[doc = "PathGetShortPath from SHELL32"]
    fn PathGetShortPath(&self, psz_long_path: PWSTR) {
        todo!("PathGetShortPath")
    }
    #[doc = "PathIsExe from SHELL32"]
    fn PathIsExe(&self, psz_path: PCWSTR) -> super::super::Foundation::BOOL {
        todo!("PathIsExe")
    }
    #[doc = "PathIsSlowA from SHELL32"]
    fn PathIsSlowA(&self, psz_file: PCSTR, dw_attr: u32) -> super::super::Foundation::BOOL {
        todo!("PathIsSlowA")
    }
    #[doc = "PathIsSlowW from SHELL32"]
    fn PathIsSlowW(&self, psz_file: PCWSTR, dw_attr: u32) -> super::super::Foundation::BOOL {
        todo!("PathIsSlowW")
    }
    #[doc = "PathMakeUniqueName from SHELL32"]
    fn PathMakeUniqueName(
        &self,
        psz_unique_name: PWSTR,
        cch_max: u32,
        psz_template: PCWSTR,
        psz_long_plate: PCWSTR,
        psz_dir: PCWSTR,
    ) -> super::super::Foundation::BOOL {
        todo!("PathMakeUniqueName")
    }
    #[doc = "PathQualify from SHELL32"]
    fn PathQualify(&self, psz: PWSTR) {
        todo!("PathQualify")
    }
    #[doc = "PathResolve from SHELL32"]
    fn PathResolve(
        &self,
        psz_path: PWSTR,
        dirs: ConstPtr<ConstPtr<u16>>,
        f_flags: PRF_FLAGS,
    ) -> i32 {
        todo!("PathResolve")
    }
    #[doc = "PathYetAnotherMakeUniqueName from SHELL32"]
    fn PathYetAnotherMakeUniqueName(
        &self,
        psz_unique_name: PWSTR,
        psz_path: PCWSTR,
        psz_short: PCWSTR,
        psz_file_spec: PCWSTR,
    ) -> super::super::Foundation::BOOL {
        todo!("PathYetAnotherMakeUniqueName")
    }
    #[doc = "PickIconDlg from SHELL32"]
    fn PickIconDlg(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_icon_path: PWSTR,
        cch_icon_path: u32,
        pi_icon_index: MutPtr<i32>,
    ) -> i32 {
        todo!("PickIconDlg")
    }
    #[doc = "ReadCabinetState from SHELL32"]
    fn ReadCabinetState(
        &self,
        pcs: MutPtr<CABINETSTATE>,
        c_length: i32,
    ) -> super::super::Foundation::BOOL {
        todo!("ReadCabinetState")
    }
    #[doc = "RealDriveType from SHELL32"]
    fn RealDriveType(&self, i_drive: i32, f_ok_to_hit_net: super::super::Foundation::BOOL) -> i32 {
        todo!("RealDriveType")
    }
    #[doc = "RestartDialog from SHELL32"]
    fn RestartDialog(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_prompt: PCWSTR,
        dw_return: u32,
    ) -> i32 {
        todo!("RestartDialog")
    }
    #[doc = "RestartDialogEx from SHELL32"]
    fn RestartDialogEx(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_prompt: PCWSTR,
        dw_return: u32,
        dw_reason_code: u32,
    ) -> i32 {
        todo!("RestartDialogEx")
    }
    #[doc = "SHAddToRecentDocs from SHELL32"]
    fn SHAddToRecentDocs(&self, u_flags: u32, pv: ConstPtr<::core::ffi::c_void>) {
        todo!("SHAddToRecentDocs")
    }
    #[doc = "SHAlloc from SHELL32"]
    fn SHAlloc(&self, cb: PtrRepr) -> MutPtr<::core::ffi::c_void> {
        todo!("SHAlloc")
    }
    #[doc = "SHAppBarMessage from SHELL32"]
    fn SHAppBarMessage(&self, dw_message: u32, p_data: MutPtr<APPBARDATA>) -> PtrRepr {
        todo!("SHAppBarMessage")
    }
    #[doc = "SHCLSIDFromString from SHELL32"]
    fn SHCLSIDFromString(
        &self,
        psz: PCWSTR,
        pclsid: MutPtr<crate::core::GUID>,
    ) -> crate::core::HRESULT {
        todo!("SHCLSIDFromString")
    }
    #[doc = "SHChangeNotification_Unlock from SHELL32"]
    fn SHChangeNotification_Unlock(
        &self,
        h_lock: super::super::Foundation::HANDLE,
    ) -> super::super::Foundation::BOOL {
        todo!("SHChangeNotification_Unlock")
    }
    #[doc = "SHChangeNotify from SHELL32"]
    fn SHChangeNotify(
        &self,
        w_event_id: SHCNE_ID,
        u_flags: SHCNF_FLAGS,
        dw_item_1: ConstPtr<::core::ffi::c_void>,
        dw_item_2: ConstPtr<::core::ffi::c_void>,
    ) {
        todo!("SHChangeNotify")
    }
    #[doc = "SHChangeNotifyDeregister from SHELL32"]
    fn SHChangeNotifyDeregister(&self, ul_id: u32) -> super::super::Foundation::BOOL {
        todo!("SHChangeNotifyDeregister")
    }
    #[doc = "SHCoCreateInstance from SHELL32"]
    fn SHCoCreateInstance(
        &self,
        psz_clsid: PCWSTR,
        pclsid: ConstPtr<crate::core::GUID>,
        p_unk_outer: crate::core::IUnknown,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("SHCoCreateInstance")
    }
    #[doc = "SHCreateDirectory from SHELL32"]
    fn SHCreateDirectory(&self, hwnd: super::super::Foundation::HWND, psz_path: PCWSTR) -> i32 {
        todo!("SHCreateDirectory")
    }
    #[doc = "SHCreateDirectoryExA from SHELL32"]
    fn SHCreateDirectoryExA(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_path: PCSTR,
        psa: ConstPtr<super::super::Security::SECURITY_ATTRIBUTES>,
    ) -> i32 {
        todo!("SHCreateDirectoryExA")
    }
    #[doc = "SHCreateDirectoryExW from SHELL32"]
    fn SHCreateDirectoryExW(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_path: PCWSTR,
        psa: ConstPtr<super::super::Security::SECURITY_ATTRIBUTES>,
    ) -> i32 {
        todo!("SHCreateDirectoryExW")
    }
    #[doc = "SHCreateFileExtractIconW from SHELL32"]
    fn SHCreateFileExtractIconW(
        &self,
        psz_file: PCWSTR,
        dw_file_attributes: u32,
        riid: ConstPtr<crate::core::GUID>,
        ppv: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("SHCreateFileExtractIconW")
    }
    #[doc = "SHCreateProcessAsUserW from SHELL32"]
    fn SHCreateProcessAsUserW(
        &self,
        pscpi: MutPtr<SHCREATEPROCESSINFOW>,
    ) -> super::super::Foundation::BOOL {
        todo!("SHCreateProcessAsUserW")
    }
    #[doc = "SHCreatePropSheetExtArray from SHELL32"]
    fn SHCreatePropSheetExtArray(
        &self,
        h_key: super::super::System::Registry::HKEY,
        psz_sub_key: PCWSTR,
        max_iface: u32,
    ) -> HPSXA {
        todo!("SHCreatePropSheetExtArray")
    }
    #[doc = "SHCreateStdEnumFmtEtc from SHELL32"]
    fn SHCreateStdEnumFmtEtc(
        &self,
        cfmt: u32,
        afmt: ConstPtr<super::super::System::Com::FORMATETC>,
        ppenum_format_etc: MutPtr<super::super::System::Com::IEnumFORMATETC>,
    ) -> crate::core::HRESULT {
        todo!("SHCreateStdEnumFmtEtc")
    }
    #[doc = "SHDefExtractIconA from SHELL32"]
    fn SHDefExtractIconA(
        &self,
        psz_icon_file: PCSTR,
        i_index: i32,
        u_flags: u32,
        phicon_large: MutPtr<super::WindowsAndMessaging::HICON>,
        phicon_small: MutPtr<super::WindowsAndMessaging::HICON>,
        n_icon_size: u32,
    ) -> crate::core::HRESULT {
        todo!("SHDefExtractIconA")
    }
    #[doc = "SHDefExtractIconW from SHELL32"]
    fn SHDefExtractIconW(
        &self,
        psz_icon_file: PCWSTR,
        i_index: i32,
        u_flags: u32,
        phicon_large: MutPtr<super::WindowsAndMessaging::HICON>,
        phicon_small: MutPtr<super::WindowsAndMessaging::HICON>,
        n_icon_size: u32,
    ) -> crate::core::HRESULT {
        todo!("SHDefExtractIconW")
    }
    #[doc = "SHDestroyPropSheetExtArray from SHELL32"]
    fn SHDestroyPropSheetExtArray(&self, hpsxa: HPSXA) {
        todo!("SHDestroyPropSheetExtArray")
    }
    #[doc = "SHEmptyRecycleBinA from SHELL32"]
    fn SHEmptyRecycleBinA(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_root_path: PCSTR,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SHEmptyRecycleBinA")
    }
    #[doc = "SHEmptyRecycleBinW from SHELL32"]
    fn SHEmptyRecycleBinW(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_root_path: PCWSTR,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SHEmptyRecycleBinW")
    }
    #[doc = "SHEnumerateUnreadMailAccountsW from SHELL32"]
    fn SHEnumerateUnreadMailAccountsW(
        &self,
        h_key_user: super::super::System::Registry::HKEY,
        dw_index: u32,
        psz_mail_address: PWSTR,
        cch_mail_address: i32,
    ) -> crate::core::HRESULT {
        todo!("SHEnumerateUnreadMailAccountsW")
    }
    #[doc = "SHFileOperationA from SHELL32"]
    fn SHFileOperationA(&self, lp_file_op: MutPtr<SHFILEOPSTRUCTA>) -> i32 {
        todo!("SHFileOperationA")
    }
    #[doc = "SHFileOperationW from SHELL32"]
    fn SHFileOperationW(&self, lp_file_op: MutPtr<SHFILEOPSTRUCTW>) -> i32 {
        todo!("SHFileOperationW")
    }
    #[doc = "SHFind_InitMenuPopup from SHELL32"]
    fn SHFind_InitMenuPopup(
        &self,
        hmenu: super::WindowsAndMessaging::HMENU,
        hwnd_owner: super::super::Foundation::HWND,
        id_cmd_first: u32,
        id_cmd_last: u32,
    ) -> IContextMenu {
        todo!("SHFind_InitMenuPopup")
    }
    #[doc = "SHFlushSFCache from SHELL32"]
    fn SHFlushSFCache(&self) {
        todo!("SHFlushSFCache")
    }
    #[doc = "SHFormatDrive from SHELL32"]
    fn SHFormatDrive(
        &self,
        hwnd: super::super::Foundation::HWND,
        drive: u32,
        fmt_id: SHFMT_ID,
        options: SHFMT_OPT,
    ) -> u32 {
        todo!("SHFormatDrive")
    }
    #[doc = "SHFree from SHELL32"]
    fn SHFree(&self, pv: ConstPtr<::core::ffi::c_void>) {
        todo!("SHFree")
    }
    #[doc = "SHFreeNameMappings from SHELL32"]
    fn SHFreeNameMappings(&self, h_name_mappings: super::super::Foundation::HANDLE) {
        todo!("SHFreeNameMappings")
    }
    #[doc = "SHGetDiskFreeSpaceExA from SHELL32"]
    fn SHGetDiskFreeSpaceExA(
        &self,
        psz_directory_name: PCSTR,
        pul_free_bytes_available_to_caller: MutPtr<u64>,
        pul_total_number_of_bytes: MutPtr<u64>,
        pul_total_number_of_free_bytes: MutPtr<u64>,
    ) -> super::super::Foundation::BOOL {
        todo!("SHGetDiskFreeSpaceExA")
    }
    #[doc = "SHGetDiskFreeSpaceExW from SHELL32"]
    fn SHGetDiskFreeSpaceExW(
        &self,
        psz_directory_name: PCWSTR,
        pul_free_bytes_available_to_caller: MutPtr<u64>,
        pul_total_number_of_bytes: MutPtr<u64>,
        pul_total_number_of_free_bytes: MutPtr<u64>,
    ) -> super::super::Foundation::BOOL {
        todo!("SHGetDiskFreeSpaceExW")
    }
    #[doc = "SHGetFileInfoA from SHELL32"]
    fn SHGetFileInfoA(
        &self,
        psz_path: PCSTR,
        dw_file_attributes: super::super::Storage::FileSystem::FILE_FLAGS_AND_ATTRIBUTES,
        psfi: MutPtr<SHFILEINFOA>,
        cb_file_info: u32,
        u_flags: SHGFI_FLAGS,
    ) -> PtrRepr {
        todo!("SHGetFileInfoA")
    }
    #[doc = "SHGetFileInfoW from SHELL32"]
    fn SHGetFileInfoW(
        &self,
        psz_path: PCWSTR,
        dw_file_attributes: super::super::Storage::FileSystem::FILE_FLAGS_AND_ATTRIBUTES,
        psfi: MutPtr<SHFILEINFOW>,
        cb_file_info: u32,
        u_flags: SHGFI_FLAGS,
    ) -> PtrRepr {
        todo!("SHGetFileInfoW")
    }
    #[doc = "SHGetFolderPathA from SHELL32"]
    fn SHGetFolderPathA(
        &self,
        hwnd: super::super::Foundation::HWND,
        csidl: i32,
        h_token: super::super::Foundation::HANDLE,
        dw_flags: u32,
        psz_path: PSTR,
    ) -> crate::core::HRESULT {
        todo!("SHGetFolderPathA")
    }
    #[doc = "SHGetFolderPathAndSubDirA from SHELL32"]
    fn SHGetFolderPathAndSubDirA(
        &self,
        hwnd: super::super::Foundation::HWND,
        csidl: i32,
        h_token: super::super::Foundation::HANDLE,
        dw_flags: u32,
        psz_sub_dir: PCSTR,
        psz_path: PSTR,
    ) -> crate::core::HRESULT {
        todo!("SHGetFolderPathAndSubDirA")
    }
    #[doc = "SHGetFolderPathAndSubDirW from SHELL32"]
    fn SHGetFolderPathAndSubDirW(
        &self,
        hwnd: super::super::Foundation::HWND,
        csidl: i32,
        h_token: super::super::Foundation::HANDLE,
        dw_flags: u32,
        psz_sub_dir: PCWSTR,
        psz_path: PWSTR,
    ) -> crate::core::HRESULT {
        todo!("SHGetFolderPathAndSubDirW")
    }
    #[doc = "SHGetFolderPathW from SHELL32"]
    fn SHGetFolderPathW(
        &self,
        hwnd: super::super::Foundation::HWND,
        csidl: i32,
        h_token: super::super::Foundation::HANDLE,
        dw_flags: u32,
        psz_path: PWSTR,
    ) -> crate::core::HRESULT {
        todo!("SHGetFolderPathW")
    }
    #[doc = "SHGetIconOverlayIndexA from SHELL32"]
    fn SHGetIconOverlayIndexA(&self, psz_icon_path: PCSTR, i_icon_index: i32) -> i32 {
        todo!("SHGetIconOverlayIndexA")
    }
    #[doc = "SHGetIconOverlayIndexW from SHELL32"]
    fn SHGetIconOverlayIndexW(&self, psz_icon_path: PCWSTR, i_icon_index: i32) -> i32 {
        todo!("SHGetIconOverlayIndexW")
    }
    #[doc = "SHGetImageList from SHELL32"]
    fn SHGetImageList(
        &self,
        i_image_list: i32,
        riid: ConstPtr<crate::core::GUID>,
        ppv_obj: MutPtr<ConstPtr<::core::ffi::c_void>>,
    ) -> crate::core::HRESULT {
        todo!("SHGetImageList")
    }
    #[doc = "SHGetInstanceExplorer from SHELL32"]
    fn SHGetInstanceExplorer(&self, ppunk: MutPtr<crate::core::IUnknown>) -> crate::core::HRESULT {
        todo!("SHGetInstanceExplorer")
    }
    #[doc = "SHGetMalloc from SHELL32"]
    fn SHGetMalloc(
        &self,
        pp_malloc: MutPtr<super::super::System::Com::IMalloc>,
    ) -> crate::core::HRESULT {
        todo!("SHGetMalloc")
    }
    #[doc = "SHGetNewLinkInfoA from SHELL32"]
    fn SHGetNewLinkInfoA(
        &self,
        psz_link_to: PCSTR,
        psz_dir: PCSTR,
        psz_name: PSTR,
        pf_must_copy: MutPtr<super::super::Foundation::BOOL>,
        u_flags: u32,
    ) -> super::super::Foundation::BOOL {
        todo!("SHGetNewLinkInfoA")
    }
    #[doc = "SHGetNewLinkInfoW from SHELL32"]
    fn SHGetNewLinkInfoW(
        &self,
        psz_link_to: PCWSTR,
        psz_dir: PCWSTR,
        psz_name: PWSTR,
        pf_must_copy: MutPtr<super::super::Foundation::BOOL>,
        u_flags: u32,
    ) -> super::super::Foundation::BOOL {
        todo!("SHGetNewLinkInfoW")
    }
    #[doc = "SHGetSetFolderCustomSettings from SHELL32"]
    fn SHGetSetFolderCustomSettings(
        &self,
        pfcs: MutPtr<SHFOLDERCUSTOMSETTINGS>,
        psz_path: PCWSTR,
        dw_read_write: u32,
    ) -> crate::core::HRESULT {
        todo!("SHGetSetFolderCustomSettings")
    }
    #[doc = "SHGetSetSettings from SHELL32"]
    fn SHGetSetSettings(
        &self,
        lpss: MutPtr<SHELLSTATEA>,
        dw_mask: SSF_MASK,
        b_set: super::super::Foundation::BOOL,
    ) {
        todo!("SHGetSetSettings")
    }
    #[doc = "SHGetSettings from SHELL32"]
    fn SHGetSettings(&self, psfs: MutPtr<SHELLFLAGSTATE>, dw_mask: u32) {
        todo!("SHGetSettings")
    }
    #[doc = "SHGetSpecialFolderPathA from SHELL32"]
    fn SHGetSpecialFolderPathA(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_path: PSTR,
        csidl: i32,
        f_create: super::super::Foundation::BOOL,
    ) -> super::super::Foundation::BOOL {
        todo!("SHGetSpecialFolderPathA")
    }
    #[doc = "SHGetSpecialFolderPathW from SHELL32"]
    fn SHGetSpecialFolderPathW(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_path: PWSTR,
        csidl: i32,
        f_create: super::super::Foundation::BOOL,
    ) -> super::super::Foundation::BOOL {
        todo!("SHGetSpecialFolderPathW")
    }
    #[doc = "SHGetUnreadMailCountW from SHELL32"]
    fn SHGetUnreadMailCountW(
        &self,
        h_key_user: super::super::System::Registry::HKEY,
        psz_mail_address: PCWSTR,
        pdw_count: MutPtr<u32>,
        p_file_time: MutPtr<super::super::Foundation::FILETIME>,
        psz_shell_execute_command: PWSTR,
        cch_shell_execute_command: i32,
    ) -> crate::core::HRESULT {
        todo!("SHGetUnreadMailCountW")
    }
    #[doc = "SHInvokePrinterCommandA from SHELL32"]
    fn SHInvokePrinterCommandA(
        &self,
        hwnd: super::super::Foundation::HWND,
        u_action: u32,
        lp_buf_1: PCSTR,
        lp_buf_2: PCSTR,
        f_modal: super::super::Foundation::BOOL,
    ) -> super::super::Foundation::BOOL {
        todo!("SHInvokePrinterCommandA")
    }
    #[doc = "SHInvokePrinterCommandW from SHELL32"]
    fn SHInvokePrinterCommandW(
        &self,
        hwnd: super::super::Foundation::HWND,
        u_action: u32,
        lp_buf_1: PCWSTR,
        lp_buf_2: PCWSTR,
        f_modal: super::super::Foundation::BOOL,
    ) -> super::super::Foundation::BOOL {
        todo!("SHInvokePrinterCommandW")
    }
    #[doc = "SHIsFileAvailableOffline from SHELL32"]
    fn SHIsFileAvailableOffline(
        &self,
        pwsz_path: PCWSTR,
        pdw_status: MutPtr<u32>,
    ) -> crate::core::HRESULT {
        todo!("SHIsFileAvailableOffline")
    }
    #[doc = "SHLoadInProc from SHELL32"]
    fn SHLoadInProc(&self, rclsid: ConstPtr<crate::core::GUID>) -> crate::core::HRESULT {
        todo!("SHLoadInProc")
    }
    #[doc = "SHLoadNonloadedIconOverlayIdentifiers from SHELL32"]
    fn SHLoadNonloadedIconOverlayIdentifiers(&self) -> crate::core::HRESULT {
        todo!("SHLoadNonloadedIconOverlayIdentifiers")
    }
    #[doc = "SHObjectProperties from SHELL32"]
    fn SHObjectProperties(
        &self,
        hwnd: super::super::Foundation::HWND,
        shop_object_type: SHOP_TYPE,
        psz_object_name: PCWSTR,
        psz_property_page: PCWSTR,
    ) -> super::super::Foundation::BOOL {
        todo!("SHObjectProperties")
    }
    #[doc = "SHPathPrepareForWriteA from SHELL32"]
    fn SHPathPrepareForWriteA(
        &self,
        hwnd: super::super::Foundation::HWND,
        punk_enable_modless: crate::core::IUnknown,
        psz_path: PCSTR,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SHPathPrepareForWriteA")
    }
    #[doc = "SHPathPrepareForWriteW from SHELL32"]
    fn SHPathPrepareForWriteW(
        &self,
        hwnd: super::super::Foundation::HWND,
        punk_enable_modless: crate::core::IUnknown,
        psz_path: PCWSTR,
        dw_flags: u32,
    ) -> crate::core::HRESULT {
        todo!("SHPathPrepareForWriteW")
    }
    #[doc = "SHQueryRecycleBinA from SHELL32"]
    fn SHQueryRecycleBinA(
        &self,
        psz_root_path: PCSTR,
        p_sh_query_rb_info: MutPtr<SHQUERYRBINFO>,
    ) -> crate::core::HRESULT {
        todo!("SHQueryRecycleBinA")
    }
    #[doc = "SHQueryRecycleBinW from SHELL32"]
    fn SHQueryRecycleBinW(
        &self,
        psz_root_path: PCWSTR,
        p_sh_query_rb_info: MutPtr<SHQUERYRBINFO>,
    ) -> crate::core::HRESULT {
        todo!("SHQueryRecycleBinW")
    }
    #[doc = "SHRestricted from SHELL32"]
    fn SHRestricted(&self, rest: RESTRICTIONS) -> u32 {
        todo!("SHRestricted")
    }
    #[doc = "SHSetFolderPathA from SHELL32"]
    fn SHSetFolderPathA(
        &self,
        csidl: i32,
        h_token: super::super::Foundation::HANDLE,
        dw_flags: u32,
        psz_path: PCSTR,
    ) -> crate::core::HRESULT {
        todo!("SHSetFolderPathA")
    }
    #[doc = "SHSetFolderPathW from SHELL32"]
    fn SHSetFolderPathW(
        &self,
        csidl: i32,
        h_token: super::super::Foundation::HANDLE,
        dw_flags: u32,
        psz_path: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SHSetFolderPathW")
    }
    #[doc = "SHSetInstanceExplorer from SHELL32"]
    fn SHSetInstanceExplorer(&self, punk: crate::core::IUnknown) {
        todo!("SHSetInstanceExplorer")
    }
    #[doc = "SHSetLocalizedName from SHELL32"]
    fn SHSetLocalizedName(
        &self,
        psz_path: PCWSTR,
        psz_res_module: PCWSTR,
        ids_res: i32,
    ) -> crate::core::HRESULT {
        todo!("SHSetLocalizedName")
    }
    #[doc = "SHSetUnreadMailCountW from SHELL32"]
    fn SHSetUnreadMailCountW(
        &self,
        psz_mail_address: PCWSTR,
        dw_count: u32,
        psz_shell_execute_command: PCWSTR,
    ) -> crate::core::HRESULT {
        todo!("SHSetUnreadMailCountW")
    }
    #[doc = "SHShellFolderView_Message from SHELL32"]
    fn SHShellFolderView_Message(
        &self,
        hwnd_main: super::super::Foundation::HWND,
        u_msg: u32,
        l_param: super::super::Foundation::LPARAM,
    ) -> super::super::Foundation::LRESULT {
        todo!("SHShellFolderView_Message")
    }
    #[doc = "SHStartNetConnectionDialogW from SHELL32"]
    fn SHStartNetConnectionDialogW(
        &self,
        hwnd: super::super::Foundation::HWND,
        psz_remote_name: PCWSTR,
        dw_type: u32,
    ) -> crate::core::HRESULT {
        todo!("SHStartNetConnectionDialogW")
    }
    #[doc = "SHTestTokenMembership from SHELL32"]
    fn SHTestTokenMembership(
        &self,
        h_token: super::super::Foundation::HANDLE,
        ul_rid: u32,
    ) -> super::super::Foundation::BOOL {
        todo!("SHTestTokenMembership")
    }
    #[doc = "SHUpdateImageA from SHELL32"]
    fn SHUpdateImageA(&self, psz_hash_item: PCSTR, i_index: i32, u_flags: u32, i_image_index: i32) {
        todo!("SHUpdateImageA")
    }
    #[doc = "SHUpdateImageW from SHELL32"]
    fn SHUpdateImageW(
        &self,
        psz_hash_item: PCWSTR,
        i_index: i32,
        u_flags: u32,
        i_image_index: i32,
    ) {
        todo!("SHUpdateImageW")
    }
    #[doc = "SHValidateUNC from SHELL32"]
    fn SHValidateUNC(
        &self,
        hwnd_owner: super::super::Foundation::HWND,
        psz_file: PWSTR,
        f_connect: VALIDATEUNC_OPTION,
    ) -> super::super::Foundation::BOOL {
        todo!("SHValidateUNC")
    }
    #[doc = "SetMenuContextHelpId from USER32"]
    fn SetMenuContextHelpId(
        &self,
        param_0: super::WindowsAndMessaging::HMENU,
        param_1: u32,
    ) -> super::super::Foundation::BOOL {
        todo!("SetMenuContextHelpId")
    }
    #[doc = "SetWindowContextHelpId from USER32"]
    fn SetWindowContextHelpId(
        &self,
        param_0: super::super::Foundation::HWND,
        param_1: u32,
    ) -> super::super::Foundation::BOOL {
        todo!("SetWindowContextHelpId")
    }
    #[doc = "ShellAboutA from SHELL32"]
    fn ShellAboutA(
        &self,
        h_wnd: super::super::Foundation::HWND,
        sz_app: PCSTR,
        sz_other_stuff: PCSTR,
        h_icon: super::WindowsAndMessaging::HICON,
    ) -> i32 {
        todo!("ShellAboutA")
    }
    #[doc = "ShellAboutW from SHELL32"]
    fn ShellAboutW(
        &self,
        h_wnd: super::super::Foundation::HWND,
        sz_app: PCWSTR,
        sz_other_stuff: PCWSTR,
        h_icon: super::WindowsAndMessaging::HICON,
    ) -> i32 {
        todo!("ShellAboutW")
    }
    #[doc = "ShellExecuteA from SHELL32"]
    fn ShellExecuteA(
        &self,
        hwnd: super::super::Foundation::HWND,
        lp_operation: PCSTR,
        lp_file: PCSTR,
        lp_parameters: PCSTR,
        lp_directory: PCSTR,
        n_show_cmd: i32,
    ) -> super::super::Foundation::HINSTANCE {
        todo!("ShellExecuteA")
    }
    #[doc = "ShellExecuteExA from SHELL32"]
    fn ShellExecuteExA(
        &self,
        p_exec_info: MutPtr<SHELLEXECUTEINFOA>,
    ) -> super::super::Foundation::BOOL {
        todo!("ShellExecuteExA")
    }
    #[doc = "ShellExecuteExW from SHELL32"]
    fn ShellExecuteExW(
        &self,
        p_exec_info: MutPtr<SHELLEXECUTEINFOW>,
    ) -> super::super::Foundation::BOOL {
        todo!("ShellExecuteExW")
    }
    #[doc = "ShellExecuteW from SHELL32"]
    fn ShellExecuteW(
        &self,
        hwnd: super::super::Foundation::HWND,
        lp_operation: PCWSTR,
        lp_file: PCWSTR,
        lp_parameters: PCWSTR,
        lp_directory: PCWSTR,
        n_show_cmd: i32,
    ) -> super::super::Foundation::HINSTANCE {
        todo!("ShellExecuteW")
    }
    #[doc = "Shell_GetCachedImageIndex from SHELL32"]
    fn Shell_GetCachedImageIndex(
        &self,
        pwsz_icon_path: PCWSTR,
        i_icon_index: i32,
        u_icon_flags: u32,
    ) -> i32 {
        todo!("Shell_GetCachedImageIndex")
    }
    #[doc = "Shell_GetCachedImageIndexA from SHELL32"]
    fn Shell_GetCachedImageIndexA(
        &self,
        psz_icon_path: PCSTR,
        i_icon_index: i32,
        u_icon_flags: u32,
    ) -> i32 {
        todo!("Shell_GetCachedImageIndexA")
    }
    #[doc = "Shell_GetCachedImageIndexW from SHELL32"]
    fn Shell_GetCachedImageIndexW(
        &self,
        psz_icon_path: PCWSTR,
        i_icon_index: i32,
        u_icon_flags: u32,
    ) -> i32 {
        todo!("Shell_GetCachedImageIndexW")
    }
    #[doc = "Shell_MergeMenus from SHELL32"]
    fn Shell_MergeMenus(
        &self,
        hm_dst: super::WindowsAndMessaging::HMENU,
        hm_src: super::WindowsAndMessaging::HMENU,
        u_insert: u32,
        u_id_adjust: u32,
        u_id_adjust_max: u32,
        u_flags: MM_FLAGS,
    ) -> u32 {
        todo!("Shell_MergeMenus")
    }
    #[doc = "Shell_NotifyIconA from SHELL32"]
    fn Shell_NotifyIconA(
        &self,
        dw_message: NOTIFY_ICON_MESSAGE,
        lp_data: ConstPtr<NOTIFYICONDATAA>,
    ) -> super::super::Foundation::BOOL {
        todo!("Shell_NotifyIconA")
    }
    #[doc = "Shell_NotifyIconW from SHELL32"]
    fn Shell_NotifyIconW(
        &self,
        dw_message: NOTIFY_ICON_MESSAGE,
        lp_data: ConstPtr<NOTIFYICONDATAW>,
    ) -> super::super::Foundation::BOOL {
        todo!("Shell_NotifyIconW")
    }
    #[doc = "Win32DeleteFile from SHELL32"]
    fn Win32DeleteFile(&self, psz_path: PCWSTR) -> super::super::Foundation::BOOL {
        todo!("Win32DeleteFile")
    }
    #[doc = "WinHelpA from USER32"]
    fn WinHelpA(
        &self,
        h_wnd_main: super::super::Foundation::HWND,
        lpsz_help: PCSTR,
        u_command: u32,
        dw_data: PtrRepr,
    ) -> super::super::Foundation::BOOL {
        todo!("WinHelpA")
    }
    #[doc = "WinHelpW from USER32"]
    fn WinHelpW(
        &self,
        h_wnd_main: super::super::Foundation::HWND,
        lpsz_help: PCWSTR,
        u_command: u32,
        dw_data: PtrRepr,
    ) -> super::super::Foundation::BOOL {
        todo!("WinHelpW")
    }
    #[doc = "WriteCabinetState from SHELL32"]
    fn WriteCabinetState(&self, pcs: ConstPtr<CABINETSTATE>) -> super::super::Foundation::BOOL {
        todo!("WriteCabinetState")
    }
}
pub fn get_api(ctx: &crate::core::Win32Context) -> std::sync::Arc<dyn Api> {
    ctx.get::<dyn Api>()
}
