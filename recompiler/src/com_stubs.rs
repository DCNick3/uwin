use crate::error::Result;
use crate::loader::PAGE_ALIGNMENT;
use crate::pe_file::PeSymbol;
use crate::thunk_id_allocator::ThunkIdAllocator;
use crate::{PeFile, Thunk};
use object::pe;
use object::pe::IMAGE_REL_BASED_HIGHLOW;
use object::write::pe::{NtHeaders, Writer};
use std::collections::BTreeMap;

// ===
// Those are inputs to the com generation process
// they are code generated by bindgen

pub(crate) struct ComStubParams {
    pub classes: Vec<ComStubClassParams>,
}

pub(crate) struct ComStubClassParams {
    pub namespace: String,
    pub name: String,
    pub vtables: Vec<ComStubVtableParams>,
}

pub(crate) struct ComStubVtableParams {
    pub function_names: Vec<(String, String)>,
}

// ===
// Those are the results of the com generation process
// they are embedded as metadata as part of LoadedProcessImage structure

pub type ComThunksInfo = BTreeMap<String, Vec<u32>>;

pub(crate) fn offset_thunks(self_: &mut ComThunksInfo, offset: u32) {
    for (_, class) in self_.iter_mut() {
        for vtable in class.iter_mut() {
            *vtable += offset;
        }
    }
}

fn gen_text_section(
    thunk_id_allocator: &mut ThunkIdAllocator,
    params: &ComStubParams,
) -> (Vec<u8>, BTreeMap<String, Vec<Vec<u32>>>) {
    let mut output = Vec::new();
    let mut classes_info = BTreeMap::new();

    for class in params.classes.iter() {
        let class_info = classes_info
            .entry(format!("{}.{}", class.namespace, class.name))
            .or_insert_with(Vec::new);
        for vtable in class.vtables.iter() {
            class_info.push(Vec::new());
            let vtable_contents = class_info.last_mut().unwrap();
            for (interface, method) in vtable.function_names.iter() {
                let thunk = Thunk::ComMethod {
                    class: &class.name,
                    interface: &interface,
                    method: &method,
                };
                let index = thunk_id_allocator.get_thunk(thunk);

                vtable_contents.push(output.len().try_into().unwrap());

                // FAR JUMP opcode
                output.push(0xea);

                // far call offset
                output.extend(index.to_le_bytes());
                // far call segment (magic number for UW)
                output.extend(0x7775u16.to_le_bytes());
            }
        }
    }

    (output, classes_info)
}

fn gen_rodata_section(
    vtable_contents: &BTreeMap<String, Vec<Vec<u32>>>,
) -> (Vec<u8>, ComThunksInfo, Vec<(u16, u32)>) {
    let mut output = Vec::new();
    let mut relocations = Vec::new();
    let mut thunks_info = BTreeMap::new();

    for (name, class) in vtable_contents.iter() {
        let class_info = thunks_info.entry(name.clone()).or_insert(Vec::new());
        for vtable in class.iter() {
            let offset = output.len().try_into().unwrap();
            class_info.push(offset);

            for function in vtable.iter() {
                let offset = output.len().try_into().unwrap();

                relocations.push((IMAGE_REL_BASED_HIGHLOW, offset));
                output.extend_from_slice(&function.to_le_bytes());
            }
        }
    }

    (output, thunks_info, relocations)
}

fn make_com_stub_dll_impl(
    thunk_id_allocator: &mut ThunkIdAllocator,
    params: &ComStubParams,
) -> Result<(Vec<u8>, ComThunksInfo, BTreeMap<u32, PeSymbol>)> {
    const FILE_ALIGNMENT: u32 = 0x200;

    let mut out_data = Vec::new();
    let mut writer = Writer::new(false, PAGE_ALIGNMENT, FILE_ALIGNMENT, &mut out_data);

    writer.reserve_dos_header();
    writer.reserve_nt_headers(16);
    // writer.reserve_section_headers()
    writer.reserve_section_headers(3); // only .text, .rodata and .reloc needed

    // .text contains the thunks code
    let (text_data, mut vtable_contents) = gen_text_section(thunk_id_allocator, params);

    let text_range = writer.reserve_text_section(text_data.len() as u32);

    for (_, class) in vtable_contents.iter_mut() {
        for vtable in class.iter_mut() {
            for entry in vtable.iter_mut() {
                *entry += text_range.virtual_address;
            }
        }
    }

    // .rodata contains the vtables themselves
    let (rodata_data, mut com_thunks_info, rodata_relocations) =
        gen_rodata_section(&vtable_contents);

    let rodata_range = writer.reserve_rdata_section(text_data.len() as u32);

    for (reloc_type, offset) in rodata_relocations {
        let address = rodata_range.virtual_address + offset;
        writer.add_reloc(address, reloc_type);
    }

    writer.reserve_reloc_section();

    // gen_text_section generates offsets from the start of the text section
    // now translate these offsets to RVAs
    offset_thunks(&mut com_thunks_info, rodata_range.virtual_address);

    writer.write_empty_dos_header()?;
    writer.write_nt_headers(NtHeaders {
        machine: pe::IMAGE_FILE_MACHINE_I386,
        time_date_stamp: 0,
        characteristics: pe::IMAGE_FILE_EXECUTABLE_IMAGE
            | pe::IMAGE_FILE_LINE_NUMS_STRIPPED
            | pe::IMAGE_FILE_LOCAL_SYMS_STRIPPED
            | pe::IMAGE_FILE_32BIT_MACHINE,
        major_linker_version: 0,
        minor_linker_version: 0,
        address_of_entry_point: 0,
        image_base: 0,
        major_operating_system_version: 0,
        minor_operating_system_version: 0,
        major_image_version: 0,
        minor_image_version: 0,
        major_subsystem_version: 0,
        minor_subsystem_version: 0,
        subsystem: pe::IMAGE_SUBSYSTEM_WINDOWS_GUI,
        dll_characteristics: 0,
        size_of_stack_reserve: 0,
        size_of_stack_commit: 0,
        size_of_heap_reserve: 0,
        size_of_heap_commit: 0,
    });
    writer.write_section_headers();
    writer.write_section(text_range.file_offset, &text_data);
    writer.write_section(rodata_range.file_offset, &rodata_data);
    writer.write_reloc_section();

    // TODO: generate symbols
    let symbols = BTreeMap::new();

    while out_data.len() % FILE_ALIGNMENT as usize != 0 {
        out_data.push(0)
    }

    Ok((out_data, com_thunks_info, symbols))
}

pub const COM_STUB_DLL_NAME: &str = "uwin_com.dll";

pub(crate) fn make_com_stub_dll(
    thunk_id_allocator: &mut ThunkIdAllocator,
    params: &ComStubParams,
) -> Result<(PeFile, ComThunksInfo)> {
    let (bytes, com_thunks_info, symbols) = make_com_stub_dll_impl(thunk_id_allocator, params)?;

    let pe = PeFile::parse_from_memory(COM_STUB_DLL_NAME.to_string(), bytes)?.with_symbols(symbols);

    Ok((pe, com_thunks_info))
}
