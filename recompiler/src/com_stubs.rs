use crate::error::Result;
use crate::loader::PAGE_ALIGNMENT;
use crate::pe_file::PeSymbol;
use crate::thunk_id_allocator::ThunkIdAllocator;
use crate::{PeFile, Thunk};
use object::pe;
use object::write::pe::{NtHeaders, Writer};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

// ===
// Those are inputs to the com generation process
// they are code generated by bindgen

pub(crate) struct ComStubParams {
    pub classes: Vec<ComStubClassParams>,
}

pub(crate) struct ComStubClassParams {
    pub name: String,
    pub vtables: Vec<ComStubVtableParams>,
}

pub(crate) struct ComStubVtableParams {
    pub function_names: Vec<(String, String)>,
}

// ===
// Those are the results of the com generation process
// they are embedded as metadata as part of LoadedProcessImage structure

#[derive(Serialize, Deserialize)]
pub struct ComThunksInfo {
    pub classes: BTreeMap<String, ComThunksClassInfo>,
}

#[derive(Serialize, Deserialize)]
pub struct ComThunksClassInfo {
    pub vtables: Vec<ComThunksVtableInfo>,
}

#[derive(Serialize, Deserialize)]
pub struct ComThunksVtableInfo {
    pub function_addresses: Vec<u32>,
}

impl ComThunksInfo {
    pub fn offset(&mut self, offset: u32) {
        for (_, class) in self.classes.iter_mut() {
            for vtable in class.vtables.iter_mut() {
                for address in vtable.function_addresses.iter_mut() {
                    *address += offset;
                }
            }
        }
    }
}

fn gen_text_section(
    thunk_id_allocator: &mut ThunkIdAllocator,
    params: &ComStubParams,
) -> (Vec<u8>, ComThunksInfo) {
    let mut output = Vec::new();
    let mut thunks_info = ComThunksInfo {
        classes: BTreeMap::new(),
    };

    for class in params.classes.iter() {
        let class_info =
            thunks_info
                .classes
                .entry(class.name.clone())
                .or_insert(ComThunksClassInfo {
                    vtables: Vec::new(),
                });
        for vtable in class.vtables.iter() {
            class_info.vtables.push(ComThunksVtableInfo {
                function_addresses: Vec::new(),
            });
            let vtable_info = class_info.vtables.last_mut().unwrap();
            for (interface, method) in vtable.function_names.iter() {
                let thunk = Thunk::ComMethod {
                    class: &class.name,
                    interface: &interface,
                    method: &method,
                };
                let index = thunk_id_allocator.get_thunk(thunk);

                vtable_info
                    .function_addresses
                    .push(output.len().try_into().unwrap());

                // FAR JUMP opcode
                output.push(0xea);

                // far call offset
                output.extend(index.to_le_bytes());
                // far call segment (magic number for UW)
                output.extend(0x7775u16.to_le_bytes());
            }
        }
    }

    (output, thunks_info)
}

fn make_com_stub_dll_impl(
    thunk_id_allocator: &mut ThunkIdAllocator,
    params: &ComStubParams,
) -> Result<(Vec<u8>, ComThunksInfo, BTreeMap<u32, PeSymbol>)> {
    const FILE_ALIGNMENT: u32 = 0x200;

    let mut out_data = Vec::new();
    let mut writer = Writer::new(false, PAGE_ALIGNMENT, FILE_ALIGNMENT, &mut out_data);

    writer.reserve_dos_header();
    writer.reserve_nt_headers(0);
    // writer.reserve_section_headers()
    writer.reserve_section_headers(1); // only .text needed

    let (text_data, mut com_thunks_info) = gen_text_section(thunk_id_allocator, params);

    let text_range = writer.reserve_text_section(text_data.len() as u32);

    // gen_text_section generates offsets from the start of the text section
    // now translate these offsets to RVAs
    com_thunks_info.offset(text_range.virtual_address);

    writer.write_empty_dos_header()?;
    writer.write_nt_headers(NtHeaders {
        machine: pe::IMAGE_FILE_MACHINE_I386,
        time_date_stamp: 0,
        characteristics: pe::IMAGE_FILE_EXECUTABLE_IMAGE
            | pe::IMAGE_FILE_LINE_NUMS_STRIPPED
            | pe::IMAGE_FILE_LOCAL_SYMS_STRIPPED
            | pe::IMAGE_FILE_32BIT_MACHINE,
        major_linker_version: 0,
        minor_linker_version: 0,
        address_of_entry_point: 0,
        image_base: 0,
        major_operating_system_version: 0,
        minor_operating_system_version: 0,
        major_image_version: 0,
        minor_image_version: 0,
        major_subsystem_version: 0,
        minor_subsystem_version: 0,
        subsystem: pe::IMAGE_SUBSYSTEM_WINDOWS_GUI,
        dll_characteristics: 0,
        size_of_stack_reserve: 0,
        size_of_stack_commit: 0,
        size_of_heap_reserve: 0,
        size_of_heap_commit: 0,
    });
    writer.write_section_headers();
    writer.write_section(text_range.file_offset, &text_data);

    // TODO: generate symbols
    let symbols = BTreeMap::new();

    while out_data.len() % FILE_ALIGNMENT as usize != 0 {
        out_data.push(0)
    }

    Ok((out_data, com_thunks_info, symbols))
}

pub const COM_STUB_DLL_NAME: &str = "uwin_com.dll";

pub(crate) fn make_com_stub_dll(
    thunk_id_allocator: &mut ThunkIdAllocator,
    params: &ComStubParams,
) -> Result<(PeFile, ComThunksInfo)> {
    let (bytes, com_thunks_info, symbols) = make_com_stub_dll_impl(thunk_id_allocator, params)?;

    let pe = PeFile::parse_from_memory(COM_STUB_DLL_NAME.to_string(), bytes)?.with_symbols(symbols);

    Ok((pe, com_thunks_info))
}
